


(() => {
    window.addEventListener('scroll', () => {
        const section1 = document.querySelector('.c-site-head--normal')
        let section2 = document.querySelector('.c-site-head-menu__link');

        const verticalScrollPx = window.scrollY || window.pageYOffset;

        if (verticalScrollPx < 800) {
            section2.style.color = '#fff';
            section1.style.backgroundColor = 'transparent';

        } else if (verticalScrollPx > 200) {
            section1.style.backgroundColor = 'rgba(0,0,0,0.68)';
        }
    });
    var __webpack_modules__ = {
        973: function (t, e) {
            !function (t) {
                "use strict";
                var e = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;

                function i(t) {
                    var e = t.nodeType, n = "";
                    if (1 === e || 9 === e || 11 === e) {
                        if ("string" == typeof t.textContent) return t.textContent;
                        for (t = t.firstChild; t; t = t.nextSibling) n += i(t)
                    } else if (3 === e || 4 === e) return t.nodeValue;
                    return n
                }

                var n, r, s, a = /(?:\r|\n|\t\t)/g, o = /(?:\s\s+)/g, h = function () {
                    n = document, r = window, s = 1
                }, l = function (t) {
                    return r.getComputedStyle(t)
                }, c = Array.isArray, u = [].slice, p = function (t, e) {
                    var i;
                    return c(t) ? t : "string" == (i = typeof t) && !e && t ? u.call(n.querySelectorAll(t), 0) : t && "object" === i && "length" in t ? u.call(t, 0) : t ? [t] : []
                }, d = function (t) {
                    return "absolute" === t.position || !0 === t.absolute
                }, f = function (t, e) {
                    for (var i, n = e.length; --n > -1;) if (i = e[n], t.substr(0, i.length) === i) return i.length
                }, m = " style='position:relative;display:inline-block;'", g = function (t, e) {
                    void 0 === t && (t = "");
                    var i = ~t.indexOf("++"), n = 1;
                    return i && (t = t.split("++").join("")), function () {
                        return "<" + e + m + (t ? " class='" + t + (i ? n++ : "") + "'>" : ">")
                    }
                }, v = function t(e, i, n) {
                    var r = e.nodeType;
                    if (1 === r || 9 === r || 11 === r) for (e = e.firstChild; e; e = e.nextSibling) t(e, i, n); else 3 !== r && 4 !== r || (e.nodeValue = e.nodeValue.split(i).join(n))
                }, y = function (t, e) {
                    for (var i = e.length; --i > -1;) t.push(e[i])
                }, b = function (t, e, i) {
                    for (var n; t && t !== e;) {
                        if (n = t._next || t.nextSibling) return n.textContent.charAt(0) === i;
                        t = t.parentNode || t._parent
                    }
                }, x = function t(e) {
                    var i, n, r = p(e.childNodes), s = r.length;
                    for (i = 0; i < s; i++) (n = r[i])._isSplit ? t(n) : (i && 3 === n.previousSibling.nodeType ? n.previousSibling.nodeValue += 3 === n.nodeType ? n.nodeValue : n.firstChild.nodeValue : 3 !== n.nodeType && e.insertBefore(n.firstChild, n), e.removeChild(n))
                }, w = function (t, e) {
                    return parseFloat(e[t]) || 0
                }, _ = function (t, e, i, r, s, a, o) {
                    var h, c, u, p, f, m, g, _, E, M, A, S, T = l(t), D = w("paddingLeft", T), C = -999,
                        P = w("borderBottomWidth", T) + w("borderTopWidth", T),
                        I = w("borderLeftWidth", T) + w("borderRightWidth", T),
                        L = w("paddingTop", T) + w("paddingBottom", T), R = w("paddingLeft", T) + w("paddingRight", T),
                        F = .2 * w("fontSize", T), k = T.textAlign, O = [], z = [], B = [], N = e.wordDelimiter || " ",
                        j = e.tag ? e.tag : e.span ? "span" : "div", V = e.type || e.split || "chars,words,lines",
                        G = s && ~V.indexOf("lines") ? [] : null, U = ~V.indexOf("words"), H = ~V.indexOf("chars"),
                        W = d(e), q = e.linesClass, X = ~(q || "").indexOf("++"), Y = [];
                    for (X && (q = q.split("++").join("")), u = (c = t.getElementsByTagName("*")).length, f = [], h = 0; h < u; h++) f[h] = c[h];
                    if (G || W) for (h = 0; h < u; h++) ((m = (p = f[h]).parentNode === t) || W || H && !U) && (S = p.offsetTop, G && m && Math.abs(S - C) > F && ("BR" !== p.nodeName || 0 === h) && (g = [], G.push(g), C = S), W && (p._x = p.offsetLeft, p._y = S, p._w = p.offsetWidth, p._h = p.offsetHeight), G && ((p._isSplit && m || !H && m || U && m || !U && p.parentNode.parentNode === t && !p.parentNode._isSplit) && (g.push(p), p._x -= D, b(p, t, N) && (p._wordEnd = !0)), "BR" === p.nodeName && (p.nextSibling && "BR" === p.nextSibling.nodeName || 0 === h) && G.push([])));
                    for (h = 0; h < u; h++) m = (p = f[h]).parentNode === t, "BR" !== p.nodeName ? (W && (E = p.style, U || m || (p._x += p.parentNode._x, p._y += p.parentNode._y), E.left = p._x + "px", E.top = p._y + "px", E.position = "absolute", E.display = "block", E.width = p._w + 1 + "px", E.height = p._h + "px"), !U && H ? p._isSplit ? (p._next = p.nextSibling, p.parentNode.appendChild(p)) : p.parentNode._isSplit ? (p._parent = p.parentNode, !p.previousSibling && p.firstChild && (p.firstChild._isFirst = !0), p.nextSibling && " " === p.nextSibling.textContent && !p.nextSibling.nextSibling && Y.push(p.nextSibling), p._next = p.nextSibling && p.nextSibling._isFirst ? null : p.nextSibling, p.parentNode.removeChild(p), f.splice(h--, 1), u--) : m || (S = !p.nextSibling && b(p.parentNode, t, N), p.parentNode._parent && p.parentNode._parent.appendChild(p), S && p.parentNode.appendChild(n.createTextNode(" ")), "span" === j && (p.style.display = "inline"), O.push(p)) : p.parentNode._isSplit && !p._isSplit && "" !== p.innerHTML ? z.push(p) : H && !p._isSplit && ("span" === j && (p.style.display = "inline"), O.push(p))) : G || W ? (p.parentNode && p.parentNode.removeChild(p), f.splice(h--, 1), u--) : U || t.appendChild(p);
                    for (h = Y.length; --h > -1;) Y[h].parentNode.removeChild(Y[h]);
                    if (G) {
                        for (W && (M = n.createElement(j), t.appendChild(M), A = M.offsetWidth + "px", S = M.offsetParent === t ? 0 : t.offsetLeft, t.removeChild(M)), E = t.style.cssText, t.style.cssText = "display:none;"; t.firstChild;) t.removeChild(t.firstChild);
                        for (_ = " " === N && (!W || !U && !H), h = 0; h < G.length; h++) {
                            for (g = G[h], (M = n.createElement(j)).style.cssText = "display:block;text-align:" + k + ";position:" + (W ? "absolute;" : "relative;"), q && (M.className = q + (X ? h + 1 : "")), B.push(M), u = g.length, c = 0; c < u; c++) "BR" !== g[c].nodeName && (p = g[c], M.appendChild(p), _ && p._wordEnd && M.appendChild(n.createTextNode(" ")), W && (0 === c && (M.style.top = p._y + "px", M.style.left = D + S + "px"), p.style.top = "0px", S && (p.style.left = p._x - S + "px")));
                            0 === u ? M.innerHTML = "&nbsp;" : U || H || (x(M), v(M, String.fromCharCode(160), " ")), W && (M.style.width = A, M.style.height = p._h + "px"), t.appendChild(M)
                        }
                        t.style.cssText = E
                    }
                    W && (o > t.clientHeight && (t.style.height = o - L + "px", t.clientHeight < o && (t.style.height = o + P + "px")), a > t.clientWidth && (t.style.width = a - R + "px", t.clientWidth < a && (t.style.width = a + I + "px"))), y(i, O), U && y(r, z), y(s, B)
                }, E = function (t, r, s, h) {
                    var l, c, u, p, m, g, y, b, x = r.tag ? r.tag : r.span ? "span" : "div",
                        w = ~(r.type || r.split || "chars,words,lines").indexOf("chars"), _ = d(r),
                        E = r.wordDelimiter || " ", M = " " !== E ? "" : _ ? "&#173; " : " ", A = "</" + x + ">", S = 1,
                        T = r.specialChars ? "function" == typeof r.specialChars ? r.specialChars : f : null,
                        D = n.createElement("div"), C = t.parentNode;
                    for (C.insertBefore(D, t), D.textContent = t.nodeValue, C.removeChild(t), y = -1 !== (l = i(t = D)).indexOf("<"), !1 !== r.reduceWhiteSpace && (l = l.replace(o, " ").replace(a, "")), y && (l = l.split("<").join("{{LT}}")), m = l.length, c = (" " === l.charAt(0) ? M : "") + s(), u = 0; u < m; u++) if (g = l.charAt(u), T && (b = T(l.substr(u), r.specialChars))) g = l.substr(u, b || 1), c += w && " " !== g ? h() + g + "</" + x + ">" : g, u += b - 1; else if (g === E && l.charAt(u - 1) !== E && u) {
                        for (c += S ? A : "", S = 0; l.charAt(u + 1) === E;) c += M, u++;
                        u === m - 1 ? c += M : ")" !== l.charAt(u + 1) && (c += M + s(), S = 1)
                    } else "{" === g && "{{LT}}" === l.substr(u, 6) ? (c += w ? h() + "{{LT}}</" + x + ">" : "{{LT}}", u += 5) : g.charCodeAt(0) >= 55296 && g.charCodeAt(0) <= 56319 || l.charCodeAt(u + 1) >= 65024 && l.charCodeAt(u + 1) <= 65039 ? (p = ((l.substr(u, 12).split(e) || [])[1] || "").length || 2, c += w && " " !== g ? h() + l.substr(u, p) + "</" + x + ">" : l.substr(u, p), u += p - 1) : c += w && " " !== g ? h() + g + "</" + x + ">" : g;
                    t.outerHTML = c + (S ? A : ""), y && v(C, "{{LT}}", "<")
                }, M = function t(e, i, n, r) {
                    var s, a, o = p(e.childNodes), h = o.length, c = d(i);
                    if (3 !== e.nodeType || h > 1) {
                        for (i.absolute = !1, s = 0; s < h; s++) (3 !== (a = o[s]).nodeType || /\S+/.test(a.nodeValue)) && (c && 3 !== a.nodeType && "inline" === l(a).display && (a.style.display = "inline-block", a.style.position = "relative"), a._isSplit = !0, t(a, i, n, r));
                        return i.absolute = c, void (e._isSplit = !0)
                    }
                    E(e, i, n, r)
                }, A = function () {
                    function t(t, e) {
                        s || h(), this.elements = p(t), this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = e || {}, this.split(e)
                    }

                    var e = t.prototype;
                    return e.split = function (t) {
                        this.isSplit && this.revert(), this.vars = t = t || this.vars, this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
                        for (var e, i, n, r = this.elements.length, s = t.tag ? t.tag : t.span ? "span" : "div", a = g(t.wordsClass, s), o = g(t.charsClass, s); --r > -1;) n = this.elements[r], this._originals[r] = n.innerHTML, e = n.clientHeight, i = n.clientWidth, M(n, t, a, o), _(n, t, this.chars, this.words, this.lines, i, e);
                        return this.chars.reverse(), this.words.reverse(), this.lines.reverse(), this.isSplit = !0, this
                    }, e.revert = function () {
                        var t = this._originals;
                        if (!t) throw"revert() call wasn't scoped properly.";
                        return this.elements.forEach((function (e, i) {
                            return e.innerHTML = t[i]
                        })), this.chars = [], this.words = [], this.lines = [], this.isSplit = !1, this
                    }, t.create = function (e, i) {
                        return new t(e, i)
                    }, t
                }();
                A.version = "3.0.0", t.SplitText = A, t.default = A, Object.defineProperty(t, "__esModule", {value: !0})
            }(e)
        }, 763: t => {
            "use strict";
            t.exports = function (t) {
                if ("string" != typeof t) throw new TypeError("expected a string");
                return (t = (t = (t = t.replace(/([a-z])([A-Z])/g, "$1-$2")).replace(/[ \t\W]/g, "-")).replace(/^-+|-+$/g, "")).toLowerCase()
            }
        }, 306: t => {
            "use strict";

            function e(t, e, i) {
                var n, r;
                if (!Array.isArray(e)) throw new Error("Get closest expects an array as second argument");
                return e.forEach((function (e, s) {
                    var a = i(e, t);
                    a >= 0 && (void 0 === r || a < r) && (r = a, n = s)
                })), n
            }

            t.exports = {
                number: function (t, i) {
                    return e(t, i, (function (t, e) {
                        return Math.abs(t - e)
                    }))
                }, greaterNumber: function (t, i) {
                    return e(t, i, (function (t, e) {
                        return t - e
                    }))
                }, lowerNumber: function (t, i) {
                    return e(t, i, (function (t, e) {
                        return e - t
                    }))
                }, custom: function (t, i, n) {
                    return e(t, i, n)
                }
            }
        }, 827: () => {
            !function () {
                "use strict";
                if ("object" == typeof window) if ("IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype) "isIntersecting" in window.IntersectionObserverEntry.prototype || Object.defineProperty(window.IntersectionObserverEntry.prototype, "isIntersecting", {
                    get: function () {
                        return this.intersectionRatio > 0
                    }
                }); else {
                    var t = function (t) {
                        for (var e = window.document, i = r(e); i;) i = r(e = i.ownerDocument);
                        return e
                    }(), e = [], i = null, n = null;
                    a.prototype.THROTTLE_TIMEOUT = 100, a.prototype.POLL_INTERVAL = null, a.prototype.USE_MUTATION_OBSERVER = !0, a._setupCrossOriginUpdater = function () {
                        return i || (i = function (t, i) {
                            n = t && i ? u(t, i) : {
                                top: 0,
                                bottom: 0,
                                left: 0,
                                right: 0,
                                width: 0,
                                height: 0
                            }, e.forEach((function (t) {
                                t._checkForIntersections()
                            }))
                        }), i
                    }, a._resetCrossOriginUpdater = function () {
                        i = null, n = null
                    }, a.prototype.observe = function (t) {
                        if (!this._observationTargets.some((function (e) {
                            return e.element == t
                        }))) {
                            if (!t || 1 != t.nodeType) throw new Error("target must be an Element");
                            this._registerInstance(), this._observationTargets.push({
                                element: t,
                                entry: null
                            }), this._monitorIntersections(t.ownerDocument), this._checkForIntersections()
                        }
                    }, a.prototype.unobserve = function (t) {
                        this._observationTargets = this._observationTargets.filter((function (e) {
                            return e.element != t
                        })), this._unmonitorIntersections(t.ownerDocument), 0 == this._observationTargets.length && this._unregisterInstance()
                    }, a.prototype.disconnect = function () {
                        this._observationTargets = [], this._unmonitorAllIntersections(), this._unregisterInstance()
                    }, a.prototype.takeRecords = function () {
                        var t = this._queuedEntries.slice();
                        return this._queuedEntries = [], t
                    }, a.prototype._initThresholds = function (t) {
                        var e = t || [0];
                        return Array.isArray(e) || (e = [e]), e.sort().filter((function (t, e, i) {
                            if ("number" != typeof t || isNaN(t) || t < 0 || t > 1) throw new Error("threshold must be a number between 0 and 1 inclusively");
                            return t !== i[e - 1]
                        }))
                    }, a.prototype._parseRootMargin = function (t) {
                        var e = (t || "0px").split(/\s+/).map((function (t) {
                            var e = /^(-?\d*\.?\d+)(px|%)$/.exec(t);
                            if (!e) throw new Error("rootMargin must be specified in pixels or percent");
                            return {value: parseFloat(e[1]), unit: e[2]}
                        }));
                        return e[1] = e[1] || e[0], e[2] = e[2] || e[0], e[3] = e[3] || e[1], e
                    }, a.prototype._monitorIntersections = function (e) {
                        var i = e.defaultView;
                        if (i && -1 == this._monitoringDocuments.indexOf(e)) {
                            var n = this._checkForIntersections, s = null, a = null;
                            this.POLL_INTERVAL ? s = i.setInterval(n, this.POLL_INTERVAL) : (o(i, "resize", n, !0), o(e, "scroll", n, !0), this.USE_MUTATION_OBSERVER && "MutationObserver" in i && (a = new i.MutationObserver(n)).observe(e, {
                                attributes: !0,
                                childList: !0,
                                characterData: !0,
                                subtree: !0
                            })), this._monitoringDocuments.push(e), this._monitoringUnsubscribes.push((function () {
                                var t = e.defaultView;
                                t && (s && t.clearInterval(s), h(t, "resize", n, !0)), h(e, "scroll", n, !0), a && a.disconnect()
                            }));
                            var l = this.root && (this.root.ownerDocument || this.root) || t;
                            if (e != l) {
                                var c = r(e);
                                c && this._monitorIntersections(c.ownerDocument)
                            }
                        }
                    }, a.prototype._unmonitorIntersections = function (e) {
                        var i = this._monitoringDocuments.indexOf(e);
                        if (-1 != i) {
                            var n = this.root && (this.root.ownerDocument || this.root) || t,
                                s = this._observationTargets.some((function (t) {
                                    var i = t.element.ownerDocument;
                                    if (i == e) return !0;
                                    for (; i && i != n;) {
                                        var s = r(i);
                                        if ((i = s && s.ownerDocument) == e) return !0
                                    }
                                    return !1
                                }));
                            if (!s) {
                                var a = this._monitoringUnsubscribes[i];
                                if (this._monitoringDocuments.splice(i, 1), this._monitoringUnsubscribes.splice(i, 1), a(), e != n) {
                                    var o = r(e);
                                    o && this._unmonitorIntersections(o.ownerDocument)
                                }
                            }
                        }
                    }, a.prototype._unmonitorAllIntersections = function () {
                        var t = this._monitoringUnsubscribes.slice(0);
                        this._monitoringDocuments.length = 0, this._monitoringUnsubscribes.length = 0;
                        for (var e = 0; e < t.length; e++) t[e]()
                    }, a.prototype._checkForIntersections = function () {
                        if (this.root || !i || n) {
                            var t = this._rootIsInDom(), e = t ? this._getRootRect() : {
                                top: 0,
                                bottom: 0,
                                left: 0,
                                right: 0,
                                width: 0,
                                height: 0
                            };
                            this._observationTargets.forEach((function (n) {
                                var r = n.element, a = l(r), o = this._rootContainsTarget(r), h = n.entry,
                                    c = t && o && this._computeTargetAndRootIntersection(r, a, e), u = null;
                                this._rootContainsTarget(r) ? i && !this.root || (u = e) : u = {
                                    top: 0,
                                    bottom: 0,
                                    left: 0,
                                    right: 0,
                                    width: 0,
                                    height: 0
                                };
                                var p = n.entry = new s({
                                    time: window.performance && performance.now && performance.now(),
                                    target: r,
                                    boundingClientRect: a,
                                    rootBounds: u,
                                    intersectionRect: c
                                });
                                h ? t && o ? this._hasCrossedThreshold(h, p) && this._queuedEntries.push(p) : h && h.isIntersecting && this._queuedEntries.push(p) : this._queuedEntries.push(p)
                            }), this), this._queuedEntries.length && this._callback(this.takeRecords(), this)
                        }
                    }, a.prototype._computeTargetAndRootIntersection = function (e, r, s) {
                        if ("none" != window.getComputedStyle(e).display) {
                            for (var a, o, h, c, p, f, m, g, v = r, y = d(e), b = !1; !b && y;) {
                                var x = null, w = 1 == y.nodeType ? window.getComputedStyle(y) : {};
                                if ("none" == w.display) return null;
                                if (y == this.root || 9 == y.nodeType) if (b = !0, y == this.root || y == t) i && !this.root ? !n || 0 == n.width && 0 == n.height ? (y = null, x = null, v = null) : x = n : x = s; else {
                                    var _ = d(y), E = _ && l(_),
                                        M = _ && this._computeTargetAndRootIntersection(_, E, s);
                                    E && M ? (y = _, x = u(E, M)) : (y = null, v = null)
                                } else {
                                    var A = y.ownerDocument;
                                    y != A.body && y != A.documentElement && "visible" != w.overflow && (x = l(y))
                                }
                                if (x && (a = x, o = v, h = void 0, c = void 0, p = void 0, f = void 0, m = void 0, g = void 0, h = Math.max(a.top, o.top), c = Math.min(a.bottom, o.bottom), p = Math.max(a.left, o.left), f = Math.min(a.right, o.right), g = c - h, v = (m = f - p) >= 0 && g >= 0 && {
                                    top: h,
                                    bottom: c,
                                    left: p,
                                    right: f,
                                    width: m,
                                    height: g
                                } || null), !v) break;
                                y = y && d(y)
                            }
                            return v
                        }
                    }, a.prototype._getRootRect = function () {
                        var e;
                        if (this.root && !f(this.root)) e = l(this.root); else {
                            var i = f(this.root) ? this.root : t, n = i.documentElement, r = i.body;
                            e = {
                                top: 0,
                                left: 0,
                                right: n.clientWidth || r.clientWidth,
                                width: n.clientWidth || r.clientWidth,
                                bottom: n.clientHeight || r.clientHeight,
                                height: n.clientHeight || r.clientHeight
                            }
                        }
                        return this._expandRectByRootMargin(e)
                    }, a.prototype._expandRectByRootMargin = function (t) {
                        var e = this._rootMarginValues.map((function (e, i) {
                            return "px" == e.unit ? e.value : e.value * (i % 2 ? t.width : t.height) / 100
                        })), i = {
                            top: t.top - e[0],
                            right: t.right + e[1],
                            bottom: t.bottom + e[2],
                            left: t.left - e[3]
                        };
                        return i.width = i.right - i.left, i.height = i.bottom - i.top, i
                    }, a.prototype._hasCrossedThreshold = function (t, e) {
                        var i = t && t.isIntersecting ? t.intersectionRatio || 0 : -1,
                            n = e.isIntersecting ? e.intersectionRatio || 0 : -1;
                        if (i !== n) for (var r = 0; r < this.thresholds.length; r++) {
                            var s = this.thresholds[r];
                            if (s == i || s == n || s < i != s < n) return !0
                        }
                    }, a.prototype._rootIsInDom = function () {
                        return !this.root || p(t, this.root)
                    }, a.prototype._rootContainsTarget = function (e) {
                        var i = this.root && (this.root.ownerDocument || this.root) || t;
                        return p(i, e) && (!this.root || i == e.ownerDocument)
                    }, a.prototype._registerInstance = function () {
                        e.indexOf(this) < 0 && e.push(this)
                    }, a.prototype._unregisterInstance = function () {
                        var t = e.indexOf(this);
                        -1 != t && e.splice(t, 1)
                    }, window.IntersectionObserver = a, window.IntersectionObserverEntry = s
                }

                function r(t) {
                    try {
                        return t.defaultView && t.defaultView.frameElement || null
                    } catch (t) {
                        return null
                    }
                }

                function s(t) {
                    this.time = t.time, this.target = t.target, this.rootBounds = c(t.rootBounds), this.boundingClientRect = c(t.boundingClientRect), this.intersectionRect = c(t.intersectionRect || {
                        top: 0,
                        bottom: 0,
                        left: 0,
                        right: 0,
                        width: 0,
                        height: 0
                    }), this.isIntersecting = !!t.intersectionRect;
                    var e = this.boundingClientRect, i = e.width * e.height, n = this.intersectionRect,
                        r = n.width * n.height;
                    this.intersectionRatio = i ? Number((r / i).toFixed(4)) : this.isIntersecting ? 1 : 0
                }

                function a(t, e) {
                    var i, n, r, s = e || {};
                    if ("function" != typeof t) throw new Error("callback must be a function");
                    if (s.root && 1 != s.root.nodeType && 9 != s.root.nodeType) throw new Error("root must be a Document or Element");
                    this._checkForIntersections = (i = this._checkForIntersections.bind(this), n = this.THROTTLE_TIMEOUT, r = null, function () {
                        r || (r = setTimeout((function () {
                            i(), r = null
                        }), n))
                    }), this._callback = t, this._observationTargets = [], this._queuedEntries = [], this._rootMarginValues = this._parseRootMargin(s.rootMargin), this.thresholds = this._initThresholds(s.threshold), this.root = s.root || null, this.rootMargin = this._rootMarginValues.map((function (t) {
                        return t.value + t.unit
                    })).join(" "), this._monitoringDocuments = [], this._monitoringUnsubscribes = []
                }

                function o(t, e, i, n) {
                    "function" == typeof t.addEventListener ? t.addEventListener(e, i, n || !1) : "function" == typeof t.attachEvent && t.attachEvent("on" + e, i)
                }

                function h(t, e, i, n) {
                    "function" == typeof t.removeEventListener ? t.removeEventListener(e, i, n || !1) : "function" == typeof t.detatchEvent && t.detatchEvent("on" + e, i)
                }

                function l(t) {
                    var e;
                    try {
                        e = t.getBoundingClientRect()
                    } catch (t) {
                    }
                    return e ? (e.width && e.height || (e = {
                        top: e.top,
                        right: e.right,
                        bottom: e.bottom,
                        left: e.left,
                        width: e.right - e.left,
                        height: e.bottom - e.top
                    }), e) : {top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0}
                }

                function c(t) {
                    return !t || "x" in t ? t : {
                        top: t.top,
                        y: t.top,
                        bottom: t.bottom,
                        left: t.left,
                        x: t.left,
                        right: t.right,
                        width: t.width,
                        height: t.height
                    }
                }

                function u(t, e) {
                    var i = e.top - t.top, n = e.left - t.left;
                    return {top: i, left: n, height: e.height, width: e.width, bottom: i + e.height, right: n + e.width}
                }

                function p(t, e) {
                    for (var i = e; i;) {
                        if (i == t) return !0;
                        i = d(i)
                    }
                    return !1
                }

                function d(e) {
                    var i = e.parentNode;
                    return 9 == e.nodeType && e != t ? r(e) : (i && i.assignedSlot && (i = i.assignedSlot.parentNode), i && 11 == i.nodeType && i.host ? i.host : i)
                }

                function f(t) {
                    return t && 9 === t.nodeType
                }
            }()
        }, 198: (t, e, i) => {
            var n = /^\s+|\s+$/g, r = /^[-+]0x[0-9a-f]+$/i, s = /^0b[01]+$/i, a = /^0o[0-7]+$/i, o = parseInt,
                h = "object" == typeof i.g && i.g && i.g.Object === Object && i.g,
                l = "object" == typeof self && self && self.Object === Object && self,
                c = h || l || Function("return this")(), u = Object.prototype.toString, p = Math.max, d = Math.min,
                f = function () {
                    return c.Date.now()
                };

            function m(t) {
                var e = typeof t;
                return !!t && ("object" == e || "function" == e)
            }

            function g(t) {
                if ("number" == typeof t) return t;
                if (function (t) {
                    return "symbol" == typeof t || function (t) {
                        return !!t && "object" == typeof t
                    }(t) && "[object Symbol]" == u.call(t)
                }(t)) return NaN;
                if (m(t)) {
                    var e = "function" == typeof t.valueOf ? t.valueOf() : t;
                    t = m(e) ? e + "" : e
                }
                if ("string" != typeof t) return 0 === t ? t : +t;
                t = t.replace(n, "");
                var i = s.test(t);
                return i || a.test(t) ? o(t.slice(2), i ? 2 : 8) : r.test(t) ? NaN : +t
            }

            t.exports = function (t, e, i) {
                var n, r, s, a, o, h, l = 0, c = !1, u = !1, v = !0;
                if ("function" != typeof t) throw new TypeError("Expected a function");

                function y(e) {
                    var i = n, s = r;
                    return n = r = void 0, l = e, a = t.apply(s, i)
                }

                function b(t) {
                    return l = t, o = setTimeout(w, e), c ? y(t) : a
                }

                function x(t) {
                    var i = t - h;
                    return void 0 === h || i >= e || i < 0 || u && t - l >= s
                }

                function w() {
                    var t = f();
                    if (x(t)) return _(t);
                    o = setTimeout(w, function (t) {
                        var i = e - (t - h);
                        return u ? d(i, s - (t - l)) : i
                    }(t))
                }

                function _(t) {
                    return o = void 0, v && n ? y(t) : (n = r = void 0, a)
                }

                function E() {
                    var t = f(), i = x(t);
                    if (n = arguments, r = this, h = t, i) {
                        if (void 0 === o) return b(h);
                        if (u) return o = setTimeout(w, e), y(h)
                    }
                    return void 0 === o && (o = setTimeout(w, e)), a
                }

                return e = g(e) || 0, m(i) && (c = !!i.leading, s = (u = "maxWait" in i) ? p(g(i.maxWait) || 0, e) : s, v = "trailing" in i ? !!i.trailing : v), E.cancel = function () {
                    void 0 !== o && clearTimeout(o), l = 0, n = h = r = o = void 0
                }, E.flush = function () {
                    return void 0 === o ? a : _(f())
                }, E
            }
        }, 809: (module, exports, __webpack_require__) => {
            var __WEBPACK_AMD_DEFINE_RESULT__, root, factory;
            "undefined" != typeof navigator && (root = window || {}, factory = function (window) {
                "use strict";
                var svgNS = "http://www.w3.org/2000/svg", locationHref = "", initialDefaultFrame = -999999,
                    _useWebWorker = !1, subframeEnabled = !0, idPrefix = "", expressionsPlugin,
                    isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), cachedColors = {}, bmRnd,
                    bmPow = Math.pow, bmSqrt = Math.sqrt, bmFloor = Math.floor, bmMax = Math.max, bmMin = Math.min,
                    BMMath = {};

                function ProjectInterface() {
                    return {}
                }

                !function () {
                    var t,
                        e = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"],
                        i = e.length;
                    for (t = 0; t < i; t += 1) BMMath[e[t]] = Math[e[t]]
                }(), BMMath.random = Math.random, BMMath.abs = function (t) {
                    if ("object" == typeof t && t.length) {
                        var e, i = createSizedArray(t.length), n = t.length;
                        for (e = 0; e < n; e += 1) i[e] = Math.abs(t[e]);
                        return i
                    }
                    return Math.abs(t)
                };
                var defaultCurveSegments = 150, degToRads = Math.PI / 180, roundCorner = .5519;

                function roundValues(t) {
                    bmRnd = t ? Math.round : function (t) {
                        return t
                    }
                }

                function styleDiv(t) {
                    t.style.position = "absolute", t.style.top = 0, t.style.left = 0, t.style.display = "block", t.style.transformOrigin = "0 0", t.style.webkitTransformOrigin = "0 0", t.style.backfaceVisibility = "visible", t.style.webkitBackfaceVisibility = "visible", t.style.transformStyle = "preserve-3d", t.style.webkitTransformStyle = "preserve-3d", t.style.mozTransformStyle = "preserve-3d"
                }

                function BMEnterFrameEvent(t, e, i, n) {
                    this.type = t, this.currentTime = e, this.totalTime = i, this.direction = n < 0 ? -1 : 1
                }

                function BMCompleteEvent(t, e) {
                    this.type = t, this.direction = e < 0 ? -1 : 1
                }

                function BMCompleteLoopEvent(t, e, i, n) {
                    this.type = t, this.currentLoop = i, this.totalLoops = e, this.direction = n < 0 ? -1 : 1
                }

                function BMSegmentStartEvent(t, e, i) {
                    this.type = t, this.firstFrame = e, this.totalFrames = i
                }

                function BMDestroyEvent(t, e) {
                    this.type = t, this.target = e
                }

                function BMRenderFrameErrorEvent(t, e) {
                    this.type = "renderFrameError", this.nativeError = t, this.currentTime = e
                }

                function BMConfigErrorEvent(t) {
                    this.type = "configError", this.nativeError = t
                }

                function BMAnimationConfigErrorEvent(t, e) {
                    this.type = t, this.nativeError = e
                }

                roundValues(!1);
                var createElementID = (_count = 0, function () {
                    return idPrefix + "__lottie_element_" + (_count += 1)
                }), _count;

                function HSVtoRGB(t, e, i) {
                    var n, r, s, a, o, h, l, c;
                    switch (h = i * (1 - e), l = i * (1 - (o = 6 * t - (a = Math.floor(6 * t))) * e), c = i * (1 - (1 - o) * e), a % 6) {
                        case 0:
                            n = i, r = c, s = h;
                            break;
                        case 1:
                            n = l, r = i, s = h;
                            break;
                        case 2:
                            n = h, r = i, s = c;
                            break;
                        case 3:
                            n = h, r = l, s = i;
                            break;
                        case 4:
                            n = c, r = h, s = i;
                            break;
                        case 5:
                            n = i, r = h, s = l
                    }
                    return [n, r, s]
                }

                function RGBtoHSV(t, e, i) {
                    var n, r = Math.max(t, e, i), s = Math.min(t, e, i), a = r - s, o = 0 === r ? 0 : a / r,
                        h = r / 255;
                    switch (r) {
                        case s:
                            n = 0;
                            break;
                        case t:
                            n = e - i + a * (e < i ? 6 : 0), n /= 6 * a;
                            break;
                        case e:
                            n = i - t + 2 * a, n /= 6 * a;
                            break;
                        case i:
                            n = t - e + 4 * a, n /= 6 * a
                    }
                    return [n, o, h]
                }

                function addSaturationToRGB(t, e) {
                    var i = RGBtoHSV(255 * t[0], 255 * t[1], 255 * t[2]);
                    return i[1] += e, i[1] > 1 ? i[1] = 1 : i[1] <= 0 && (i[1] = 0), HSVtoRGB(i[0], i[1], i[2])
                }

                function addBrightnessToRGB(t, e) {
                    var i = RGBtoHSV(255 * t[0], 255 * t[1], 255 * t[2]);
                    return i[2] += e, i[2] > 1 ? i[2] = 1 : i[2] < 0 && (i[2] = 0), HSVtoRGB(i[0], i[1], i[2])
                }

                function addHueToRGB(t, e) {
                    var i = RGBtoHSV(255 * t[0], 255 * t[1], 255 * t[2]);
                    return i[0] += e / 360, i[0] > 1 ? i[0] -= 1 : i[0] < 0 && (i[0] += 1), HSVtoRGB(i[0], i[1], i[2])
                }

                var rgbToHex = function () {
                    var t, e, i = [];
                    for (t = 0; t < 256; t += 1) e = t.toString(16), i[t] = 1 === e.length ? "0" + e : e;
                    return function (t, e, n) {
                        return t < 0 && (t = 0), e < 0 && (e = 0), n < 0 && (n = 0), "#" + i[t] + i[e] + i[n]
                    }
                }();

                function BaseEvent() {
                }

                BaseEvent.prototype = {
                    triggerEvent: function (t, e) {
                        if (this._cbs[t]) for (var i = this._cbs[t], n = 0; n < i.length; n += 1) i[n](e)
                    }, addEventListener: function (t, e) {
                        return this._cbs[t] || (this._cbs[t] = []), this._cbs[t].push(e), function () {
                            this.removeEventListener(t, e)
                        }.bind(this)
                    }, removeEventListener: function (t, e) {
                        if (e) {
                            if (this._cbs[t]) {
                                for (var i = 0, n = this._cbs[t].length; i < n;) this._cbs[t][i] === e && (this._cbs[t].splice(i, 1), i -= 1, n -= 1), i += 1;
                                this._cbs[t].length || (this._cbs[t] = null)
                            }
                        } else this._cbs[t] = null
                    }
                };
                var createTypedArray = function () {
                    function t(t, e) {
                        var i, n = 0, r = [];
                        switch (t) {
                            case"int16":
                            case"uint8c":
                                i = 1;
                                break;
                            default:
                                i = 1.1
                        }
                        for (n = 0; n < e; n += 1) r.push(i);
                        return r
                    }

                    return "function" == typeof Uint8ClampedArray && "function" == typeof Float32Array ? function (e, i) {
                        return "float32" === e ? new Float32Array(i) : "int16" === e ? new Int16Array(i) : "uint8c" === e ? new Uint8ClampedArray(i) : t(e, i)
                    } : t
                }();

                function createSizedArray(t) {
                    return Array.apply(null, {length: t})
                }

                function createNS(t) {
                    return document.createElementNS(svgNS, t)
                }

                function createTag(t) {
                    return document.createElement(t)
                }

                function DynamicPropertyContainer() {
                }

                DynamicPropertyContainer.prototype = {
                    addDynamicProperty: function (t) {
                        -1 === this.dynamicProperties.indexOf(t) && (this.dynamicProperties.push(t), this.container.addDynamicProperty(this), this._isAnimated = !0)
                    }, iterateDynamicProperties: function () {
                        var t;
                        this._mdf = !1;
                        var e = this.dynamicProperties.length;
                        for (t = 0; t < e; t += 1) this.dynamicProperties[t].getValue(), this.dynamicProperties[t]._mdf && (this._mdf = !0)
                    }, initDynamicPropertyContainer: function (t) {
                        this.container = t, this.dynamicProperties = [], this._mdf = !1, this._isAnimated = !1
                    }
                };
                var getBlendMode = (blendModeEnums = {
                        0: "source-over",
                        1: "multiply",
                        2: "screen",
                        3: "overlay",
                        4: "darken",
                        5: "lighten",
                        6: "color-dodge",
                        7: "color-burn",
                        8: "hard-light",
                        9: "soft-light",
                        10: "difference",
                        11: "exclusion",
                        12: "hue",
                        13: "saturation",
                        14: "color",
                        15: "luminosity"
                    }, function (t) {
                        return blendModeEnums[t] || ""
                    }), blendModeEnums, lineCapEnum = {1: "butt", 2: "round", 3: "square"},
                    lineJoinEnum = {1: "miter", 2: "round", 3: "bevel"}, Matrix = function () {
                        var t = Math.cos, e = Math.sin, i = Math.tan, n = Math.round;

                        function r() {
                            return this.props[0] = 1, this.props[1] = 0, this.props[2] = 0, this.props[3] = 0, this.props[4] = 0, this.props[5] = 1, this.props[6] = 0, this.props[7] = 0, this.props[8] = 0, this.props[9] = 0, this.props[10] = 1, this.props[11] = 0, this.props[12] = 0, this.props[13] = 0, this.props[14] = 0, this.props[15] = 1, this
                        }

                        function s(i) {
                            if (0 === i) return this;
                            var n = t(i), r = e(i);
                            return this._t(n, -r, 0, 0, r, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
                        }

                        function a(i) {
                            if (0 === i) return this;
                            var n = t(i), r = e(i);
                            return this._t(1, 0, 0, 0, 0, n, -r, 0, 0, r, n, 0, 0, 0, 0, 1)
                        }

                        function o(i) {
                            if (0 === i) return this;
                            var n = t(i), r = e(i);
                            return this._t(n, 0, r, 0, 0, 1, 0, 0, -r, 0, n, 0, 0, 0, 0, 1)
                        }

                        function h(i) {
                            if (0 === i) return this;
                            var n = t(i), r = e(i);
                            return this._t(n, -r, 0, 0, r, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
                        }

                        function l(t, e) {
                            return this._t(1, e, t, 1, 0, 0)
                        }

                        function c(t, e) {
                            return this.shear(i(t), i(e))
                        }

                        function u(n, r) {
                            var s = t(r), a = e(r);
                            return this._t(s, a, 0, 0, -a, s, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, i(n), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(s, -a, 0, 0, a, s, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
                        }

                        function p(t, e, i) {
                            return i || 0 === i || (i = 1), 1 === t && 1 === e && 1 === i ? this : this._t(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1)
                        }

                        function d(t, e, i, n, r, s, a, o, h, l, c, u, p, d, f, m) {
                            return this.props[0] = t, this.props[1] = e, this.props[2] = i, this.props[3] = n, this.props[4] = r, this.props[5] = s, this.props[6] = a, this.props[7] = o, this.props[8] = h, this.props[9] = l, this.props[10] = c, this.props[11] = u, this.props[12] = p, this.props[13] = d, this.props[14] = f, this.props[15] = m, this
                        }

                        function f(t, e, i) {
                            return i = i || 0, 0 !== t || 0 !== e || 0 !== i ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, t, e, i, 1) : this
                        }

                        function m(t, e, i, n, r, s, a, o, h, l, c, u, p, d, f, m) {
                            var g = this.props;
                            if (1 === t && 0 === e && 0 === i && 0 === n && 0 === r && 1 === s && 0 === a && 0 === o && 0 === h && 0 === l && 1 === c && 0 === u) return g[12] = g[12] * t + g[15] * p, g[13] = g[13] * s + g[15] * d, g[14] = g[14] * c + g[15] * f, g[15] *= m, this._identityCalculated = !1, this;
                            var v = g[0], y = g[1], b = g[2], x = g[3], w = g[4], _ = g[5], E = g[6], M = g[7], A = g[8],
                                S = g[9], T = g[10], D = g[11], C = g[12], P = g[13], I = g[14], L = g[15];
                            return g[0] = v * t + y * r + b * h + x * p, g[1] = v * e + y * s + b * l + x * d, g[2] = v * i + y * a + b * c + x * f, g[3] = v * n + y * o + b * u + x * m, g[4] = w * t + _ * r + E * h + M * p, g[5] = w * e + _ * s + E * l + M * d, g[6] = w * i + _ * a + E * c + M * f, g[7] = w * n + _ * o + E * u + M * m, g[8] = A * t + S * r + T * h + D * p, g[9] = A * e + S * s + T * l + D * d, g[10] = A * i + S * a + T * c + D * f, g[11] = A * n + S * o + T * u + D * m, g[12] = C * t + P * r + I * h + L * p, g[13] = C * e + P * s + I * l + L * d, g[14] = C * i + P * a + I * c + L * f, g[15] = C * n + P * o + I * u + L * m, this._identityCalculated = !1, this
                        }

                        function g() {
                            return this._identityCalculated || (this._identity = !(1 !== this.props[0] || 0 !== this.props[1] || 0 !== this.props[2] || 0 !== this.props[3] || 0 !== this.props[4] || 1 !== this.props[5] || 0 !== this.props[6] || 0 !== this.props[7] || 0 !== this.props[8] || 0 !== this.props[9] || 1 !== this.props[10] || 0 !== this.props[11] || 0 !== this.props[12] || 0 !== this.props[13] || 0 !== this.props[14] || 1 !== this.props[15]), this._identityCalculated = !0), this._identity
                        }

                        function v(t) {
                            for (var e = 0; e < 16;) {
                                if (t.props[e] !== this.props[e]) return !1;
                                e += 1
                            }
                            return !0
                        }

                        function y(t) {
                            var e;
                            for (e = 0; e < 16; e += 1) t.props[e] = this.props[e];
                            return t
                        }

                        function b(t) {
                            var e;
                            for (e = 0; e < 16; e += 1) this.props[e] = t[e]
                        }

                        function x(t, e, i) {
                            return {
                                x: t * this.props[0] + e * this.props[4] + i * this.props[8] + this.props[12],
                                y: t * this.props[1] + e * this.props[5] + i * this.props[9] + this.props[13],
                                z: t * this.props[2] + e * this.props[6] + i * this.props[10] + this.props[14]
                            }
                        }

                        function w(t, e, i) {
                            return t * this.props[0] + e * this.props[4] + i * this.props[8] + this.props[12]
                        }

                        function _(t, e, i) {
                            return t * this.props[1] + e * this.props[5] + i * this.props[9] + this.props[13]
                        }

                        function E(t, e, i) {
                            return t * this.props[2] + e * this.props[6] + i * this.props[10] + this.props[14]
                        }

                        function M() {
                            var t = this.props[0] * this.props[5] - this.props[1] * this.props[4], e = this.props[5] / t,
                                i = -this.props[1] / t, n = -this.props[4] / t, r = this.props[0] / t,
                                s = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / t,
                                a = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / t, o = new Matrix;
                            return o.props[0] = e, o.props[1] = i, o.props[4] = n, o.props[5] = r, o.props[12] = s, o.props[13] = a, o
                        }

                        function A(t) {
                            return this.getInverseMatrix().applyToPointArray(t[0], t[1], t[2] || 0)
                        }

                        function S(t) {
                            var e, i = t.length, n = [];
                            for (e = 0; e < i; e += 1) n[e] = A(t[e]);
                            return n
                        }

                        function T(t, e, i) {
                            var n = createTypedArray("float32", 6);
                            if (this.isIdentity()) n[0] = t[0], n[1] = t[1], n[2] = e[0], n[3] = e[1], n[4] = i[0], n[5] = i[1]; else {
                                var r = this.props[0], s = this.props[1], a = this.props[4], o = this.props[5],
                                    h = this.props[12], l = this.props[13];
                                n[0] = t[0] * r + t[1] * a + h, n[1] = t[0] * s + t[1] * o + l, n[2] = e[0] * r + e[1] * a + h, n[3] = e[0] * s + e[1] * o + l, n[4] = i[0] * r + i[1] * a + h, n[5] = i[0] * s + i[1] * o + l
                            }
                            return n
                        }

                        function D(t, e, i) {
                            return this.isIdentity() ? [t, e, i] : [t * this.props[0] + e * this.props[4] + i * this.props[8] + this.props[12], t * this.props[1] + e * this.props[5] + i * this.props[9] + this.props[13], t * this.props[2] + e * this.props[6] + i * this.props[10] + this.props[14]]
                        }

                        function C(t, e) {
                            if (this.isIdentity()) return t + "," + e;
                            var i = this.props;
                            return Math.round(100 * (t * i[0] + e * i[4] + i[12])) / 100 + "," + Math.round(100 * (t * i[1] + e * i[5] + i[13])) / 100
                        }

                        function P() {
                            for (var t = 0, e = this.props, i = "matrix3d("; t < 16;) i += n(1e4 * e[t]) / 1e4, i += 15 === t ? ")" : ",", t += 1;
                            return i
                        }

                        function I(t) {
                            return t < 1e-6 && t > 0 || t > -1e-6 && t < 0 ? n(1e4 * t) / 1e4 : t
                        }

                        function L() {
                            var t = this.props;
                            return "matrix(" + I(t[0]) + "," + I(t[1]) + "," + I(t[4]) + "," + I(t[5]) + "," + I(t[12]) + "," + I(t[13]) + ")"
                        }

                        return function () {
                            this.reset = r, this.rotate = s, this.rotateX = a, this.rotateY = o, this.rotateZ = h, this.skew = c, this.skewFromAxis = u, this.shear = l, this.scale = p, this.setTransform = d, this.translate = f, this.transform = m, this.applyToPoint = x, this.applyToX = w, this.applyToY = _, this.applyToZ = E, this.applyToPointArray = D, this.applyToTriplePoints = T, this.applyToPointStringified = C, this.toCSS = P, this.to2dCSS = L, this.clone = y, this.cloneFromProps = b, this.equals = v, this.inversePoints = S, this.inversePoint = A, this.getInverseMatrix = M, this._t = this.transform, this.isIdentity = g, this._identity = !0, this._identityCalculated = !1, this.props = createTypedArray("float32", 16), this.reset()
                        }
                    }();
                !function (t, e) {
                    var i = this, n = 256, r = e.pow(n, 6), s = e.pow(2, 52), a = 2 * s, o = 255;

                    function h(t) {
                        var e, i = t.length, r = this, s = 0, a = r.i = r.j = 0, h = r.S = [];
                        for (i || (t = [i++]); s < n;) h[s] = s++;
                        for (s = 0; s < n; s++) h[s] = h[a = o & a + t[s % i] + (e = h[s])], h[a] = e;
                        r.g = function (t) {
                            for (var e, i = 0, s = r.i, a = r.j, h = r.S; t--;) e = h[s = o & s + 1], i = i * n + h[o & (h[s] = h[a = o & a + e]) + (h[a] = e)];
                            return r.i = s, r.j = a, i
                        }
                    }

                    function l(t, e) {
                        return e.i = t.i, e.j = t.j, e.S = t.S.slice(), e
                    }

                    function c(t, e) {
                        var i, n = [], r = typeof t;
                        if (e && "object" == r) for (i in t) try {
                            n.push(c(t[i], e - 1))
                        } catch (t) {
                        }
                        return n.length ? n : "string" == r ? t : t + "\0"
                    }

                    function u(t, e) {
                        for (var i, n = t + "", r = 0; r < n.length;) e[o & r] = o & (i ^= 19 * e[o & r]) + n.charCodeAt(r++);
                        return p(e)
                    }

                    function p(t) {
                        return String.fromCharCode.apply(0, t)
                    }

                    e.seedrandom = function (o, d, f) {
                        var m = [],
                            g = u(c((d = !0 === d ? {entropy: !0} : d || {}).entropy ? [o, p(t)] : null === o ? function () {
                                try {
                                    var e = new Uint8Array(n);
                                    return (i.crypto || i.msCrypto).getRandomValues(e), p(e)
                                } catch (e) {
                                    var r = i.navigator, s = r && r.plugins;
                                    return [+new Date, i, s, i.screen, p(t)]
                                }
                            }() : o, 3), m), v = new h(m), y = function () {
                                for (var t = v.g(6), e = r, i = 0; t < s;) t = (t + i) * n, e *= n, i = v.g(1);
                                for (; t >= a;) t /= 2, e /= 2, i >>>= 1;
                                return (t + i) / e
                            };
                        return y.int32 = function () {
                            return 0 | v.g(4)
                        }, y.quick = function () {
                            return v.g(4) / 4294967296
                        }, y.double = y, u(p(v.S), t), (d.pass || f || function (t, i, n, r) {
                            return r && (r.S && l(r, v), t.state = function () {
                                return l(v, {})
                            }), n ? (e.random = t, i) : t
                        })(y, g, "global" in d ? d.global : this == e, d.state)
                    }, u(e.random(), t)
                }([], BMMath);
                var BezierFactory = function () {
                    var t = {
                        getBezierEasing: function (t, i, n, r, s) {
                            var a = s || ("bez_" + t + "_" + i + "_" + n + "_" + r).replace(/\./g, "p");
                            if (e[a]) return e[a];
                            var o = new l([t, i, n, r]);
                            return e[a] = o, o
                        }
                    }, e = {}, i = .1, n = "function" == typeof Float32Array;

                    function r(t, e) {
                        return 1 - 3 * e + 3 * t
                    }

                    function s(t, e) {
                        return 3 * e - 6 * t
                    }

                    function a(t) {
                        return 3 * t
                    }

                    function o(t, e, i) {
                        return ((r(e, i) * t + s(e, i)) * t + a(e)) * t
                    }

                    function h(t, e, i) {
                        return 3 * r(e, i) * t * t + 2 * s(e, i) * t + a(e)
                    }

                    function l(t) {
                        this._p = t, this._mSampleValues = n ? new Float32Array(11) : new Array(11), this._precomputed = !1, this.get = this.get.bind(this)
                    }

                    return l.prototype = {
                        get: function (t) {
                            var e = this._p[0], i = this._p[1], n = this._p[2], r = this._p[3];
                            return this._precomputed || this._precompute(), e === i && n === r ? t : 0 === t ? 0 : 1 === t ? 1 : o(this._getTForX(t), i, r)
                        }, _precompute: function () {
                            var t = this._p[0], e = this._p[1], i = this._p[2], n = this._p[3];
                            this._precomputed = !0, t === e && i === n || this._calcSampleValues()
                        }, _calcSampleValues: function () {
                            for (var t = this._p[0], e = this._p[2], n = 0; n < 11; ++n) this._mSampleValues[n] = o(n * i, t, e)
                        }, _getTForX: function (t) {
                            for (var e = this._p[0], n = this._p[2], r = this._mSampleValues, s = 0, a = 1; 10 !== a && r[a] <= t; ++a) s += i;
                            var l = s + (t - r[--a]) / (r[a + 1] - r[a]) * i, c = h(l, e, n);
                            return c >= .001 ? function (t, e, i, n) {
                                for (var r = 0; r < 4; ++r) {
                                    var s = h(e, i, n);
                                    if (0 === s) return e;
                                    e -= (o(e, i, n) - t) / s
                                }
                                return e
                            }(t, l, e, n) : 0 === c ? l : function (t, e, i, n, r) {
                                var s, a, h = 0;
                                do {
                                    (s = o(a = e + (i - e) / 2, n, r) - t) > 0 ? i = a : e = a
                                } while (Math.abs(s) > 1e-7 && ++h < 10);
                                return a
                            }(t, s, s + i, e, n)
                        }
                    }, t
                }();

                function extendPrototype(t, e) {
                    var i, n, r = t.length;
                    for (i = 0; i < r; i += 1) for (var s in n = t[i].prototype) Object.prototype.hasOwnProperty.call(n, s) && (e.prototype[s] = n[s])
                }

                function getDescriptor(t, e) {
                    return Object.getOwnPropertyDescriptor(t, e)
                }

                function createProxyFunction(t) {
                    function e() {
                    }

                    return e.prototype = t, e
                }

                function bezFunction() {
                    var t = Math;

                    function e(t, e, i, n, r, s) {
                        var a = t * n + e * r + i * s - r * n - s * t - i * e;
                        return a > -.001 && a < .001
                    }

                    var i = function (t, e, i, n) {
                        var r, s, a, o, h, l, c = defaultCurveSegments, u = 0, p = [], d = [],
                            f = bezierLengthPool.newElement();
                        for (a = i.length, r = 0; r < c; r += 1) {
                            for (h = r / (c - 1), l = 0, s = 0; s < a; s += 1) o = bmPow(1 - h, 3) * t[s] + 3 * bmPow(1 - h, 2) * h * i[s] + 3 * (1 - h) * bmPow(h, 2) * n[s] + bmPow(h, 3) * e[s], p[s] = o, null !== d[s] && (l += bmPow(p[s] - d[s], 2)), d[s] = p[s];
                            l && (u += l = bmSqrt(l)), f.percents[r] = h, f.lengths[r] = u
                        }
                        return f.addedLength = u, f
                    };

                    function n(t) {
                        this.segmentLength = 0, this.points = new Array(t)
                    }

                    function r(t, e) {
                        this.partialLength = t, this.point = e
                    }

                    var s, a = (s = {}, function (t, i, a, o) {
                        var h = (t[0] + "_" + t[1] + "_" + i[0] + "_" + i[1] + "_" + a[0] + "_" + a[1] + "_" + o[0] + "_" + o[1]).replace(/\./g, "p");
                        if (!s[h]) {
                            var l, c, u, p, d, f, m, g = defaultCurveSegments, v = 0, y = null;
                            2 === t.length && (t[0] !== i[0] || t[1] !== i[1]) && e(t[0], t[1], i[0], i[1], t[0] + a[0], t[1] + a[1]) && e(t[0], t[1], i[0], i[1], i[0] + o[0], i[1] + o[1]) && (g = 2);
                            var b = new n(g);
                            for (u = a.length, l = 0; l < g; l += 1) {
                                for (m = createSizedArray(u), d = l / (g - 1), f = 0, c = 0; c < u; c += 1) p = bmPow(1 - d, 3) * t[c] + 3 * bmPow(1 - d, 2) * d * (t[c] + a[c]) + 3 * (1 - d) * bmPow(d, 2) * (i[c] + o[c]) + bmPow(d, 3) * i[c], m[c] = p, null !== y && (f += bmPow(m[c] - y[c], 2));
                                v += f = bmSqrt(f), b.points[l] = new r(f, m), y = m
                            }
                            b.segmentLength = v, s[h] = b
                        }
                        return s[h]
                    });

                    function o(t, e) {
                        var i = e.percents, n = e.lengths, r = i.length, s = bmFloor((r - 1) * t),
                            a = t * e.addedLength, o = 0;
                        if (s === r - 1 || 0 === s || a === n[s]) return i[s];
                        for (var h = n[s] > a ? -1 : 1, l = !0; l;) if (n[s] <= a && n[s + 1] > a ? (o = (a - n[s]) / (n[s + 1] - n[s]), l = !1) : s += h, s < 0 || s >= r - 1) {
                            if (s === r - 1) return i[s];
                            l = !1
                        }
                        return i[s] + (i[s + 1] - i[s]) * o
                    }

                    var h = createTypedArray("float32", 8);
                    return {
                        getSegmentsLength: function (t) {
                            var e, n = segmentsLengthPool.newElement(), r = t.c, s = t.v, a = t.o, o = t.i,
                                h = t._length, l = n.lengths, c = 0;
                            for (e = 0; e < h - 1; e += 1) l[e] = i(s[e], s[e + 1], a[e], o[e + 1]), c += l[e].addedLength;
                            return r && h && (l[e] = i(s[e], s[0], a[e], o[0]), c += l[e].addedLength), n.totalLength = c, n
                        }, getNewSegment: function (e, i, n, r, s, a, l) {
                            s < 0 ? s = 0 : s > 1 && (s = 1);
                            var c, u = o(s, l), p = o(a = a > 1 ? 1 : a, l), d = e.length, f = 1 - u, m = 1 - p,
                                g = f * f * f, v = u * f * f * 3, y = u * u * f * 3, b = u * u * u, x = f * f * m,
                                w = u * f * m + f * u * m + f * f * p, _ = u * u * m + f * u * p + u * f * p,
                                E = u * u * p, M = f * m * m, A = u * m * m + f * p * m + f * m * p,
                                S = u * p * m + f * p * p + u * m * p, T = u * p * p, D = m * m * m,
                                C = p * m * m + m * p * m + m * m * p, P = p * p * m + m * p * p + p * m * p,
                                I = p * p * p;
                            for (c = 0; c < d; c += 1) h[4 * c] = t.round(1e3 * (g * e[c] + v * n[c] + y * r[c] + b * i[c])) / 1e3, h[4 * c + 1] = t.round(1e3 * (x * e[c] + w * n[c] + _ * r[c] + E * i[c])) / 1e3, h[4 * c + 2] = t.round(1e3 * (M * e[c] + A * n[c] + S * r[c] + T * i[c])) / 1e3, h[4 * c + 3] = t.round(1e3 * (D * e[c] + C * n[c] + P * r[c] + I * i[c])) / 1e3;
                            return h
                        }, getPointInSegment: function (e, i, n, r, s, a) {
                            var h = o(s, a), l = 1 - h;
                            return [t.round(1e3 * (l * l * l * e[0] + (h * l * l + l * h * l + l * l * h) * n[0] + (h * h * l + l * h * h + h * l * h) * r[0] + h * h * h * i[0])) / 1e3, t.round(1e3 * (l * l * l * e[1] + (h * l * l + l * h * l + l * l * h) * n[1] + (h * h * l + l * h * h + h * l * h) * r[1] + h * h * h * i[1])) / 1e3]
                        }, buildBezierData: a, pointOnLine2D: e, pointOnLine3D: function (i, n, r, s, a, o, h, l, c) {
                            if (0 === r && 0 === o && 0 === c) return e(i, n, s, a, h, l);
                            var u, p = t.sqrt(t.pow(s - i, 2) + t.pow(a - n, 2) + t.pow(o - r, 2)),
                                d = t.sqrt(t.pow(h - i, 2) + t.pow(l - n, 2) + t.pow(c - r, 2)),
                                f = t.sqrt(t.pow(h - s, 2) + t.pow(l - a, 2) + t.pow(c - o, 2));
                            return (u = p > d ? p > f ? p - d - f : f - d - p : f > d ? f - d - p : d - p - f) > -1e-4 && u < 1e-4
                        }
                    }
                }

                !function () {
                    for (var t = 0, e = ["ms", "moz", "webkit", "o"], i = 0; i < e.length && !window.requestAnimationFrame; ++i) window.requestAnimationFrame = window[e[i] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[e[i] + "CancelAnimationFrame"] || window[e[i] + "CancelRequestAnimationFrame"];
                    window.requestAnimationFrame || (window.requestAnimationFrame = function (e) {
                        var i = (new Date).getTime(), n = Math.max(0, 16 - (i - t)), r = setTimeout((function () {
                            e(i + n)
                        }), n);
                        return t = i + n, r
                    }), window.cancelAnimationFrame || (window.cancelAnimationFrame = function (t) {
                        clearTimeout(t)
                    })
                }();
                var bez = bezFunction(), dataManager = function () {
                    var t, e, i = 1, n = [], r = {
                        onmessage: function () {
                        }, postMessage: function (e) {
                            t({data: e})
                        }
                    }, s = {
                        postMessage: function (t) {
                            r.onmessage({data: t})
                        }
                    };

                    function a() {
                        e || (e = function (e) {
                            if (window.Worker && window.Blob && _useWebWorker) {
                                var i = new Blob(["var _workerSelf = self; self.onmessage = ", e.toString()], {type: "text/javascript"}),
                                    n = URL.createObjectURL(i);
                                return new Worker(n)
                            }
                            return t = e, r
                        }((function (t) {
                            if (s.dataManager || (s.dataManager = function () {
                                function t(r, s) {
                                    var a, o, h, l, c, p, d = r.length;
                                    for (o = 0; o < d; o += 1) if ("ks" in (a = r[o]) && !a.completed) {
                                        if (a.completed = !0, a.tt && (r[o - 1].td = a.tt), a.hasMask) {
                                            var f = a.masksProperties;
                                            for (l = f.length, h = 0; h < l; h += 1) if (f[h].pt.k.i) n(f[h].pt.k); else for (p = f[h].pt.k.length, c = 0; c < p; c += 1) f[h].pt.k[c].s && n(f[h].pt.k[c].s[0]), f[h].pt.k[c].e && n(f[h].pt.k[c].e[0])
                                        }
                                        0 === a.ty ? (a.layers = e(a.refId, s), t(a.layers, s)) : 4 === a.ty ? i(a.shapes) : 5 === a.ty && u(a)
                                    }
                                }

                                function e(t, e) {
                                    for (var i = 0, n = e.length; i < n;) {
                                        if (e[i].id === t) return e[i].layers.__used ? JSON.parse(JSON.stringify(e[i].layers)) : (e[i].layers.__used = !0, e[i].layers);
                                        i += 1
                                    }
                                    return null
                                }

                                function i(t) {
                                    var e, r, s;
                                    for (e = t.length - 1; e >= 0; e -= 1) if ("sh" === t[e].ty) if (t[e].ks.k.i) n(t[e].ks.k); else for (s = t[e].ks.k.length, r = 0; r < s; r += 1) t[e].ks.k[r].s && n(t[e].ks.k[r].s[0]), t[e].ks.k[r].e && n(t[e].ks.k[r].e[0]); else "gr" === t[e].ty && i(t[e].it)
                                }

                                function n(t) {
                                    var e, i = t.i.length;
                                    for (e = 0; e < i; e += 1) t.i[e][0] += t.v[e][0], t.i[e][1] += t.v[e][1], t.o[e][0] += t.v[e][0], t.o[e][1] += t.v[e][1]
                                }

                                function r(t, e) {
                                    var i = e ? e.split(".") : [100, 100, 100];
                                    return t[0] > i[0] || !(i[0] > t[0]) && (t[1] > i[1] || !(i[1] > t[1]) && (t[2] > i[2] || !(i[2] > t[2]) && null))
                                }

                                var s, a = function () {
                                    var t = [4, 4, 14];

                                    function e(t) {
                                        var e, i, n, r = t.length;
                                        for (e = 0; e < r; e += 1) 5 === t[e].ty && (n = void 0, n = (i = t[e]).t.d, i.t.d = {
                                            k: [{
                                                s: n,
                                                t: 0
                                            }]
                                        })
                                    }

                                    return function (i) {
                                        if (r(t, i.v) && (e(i.layers), i.assets)) {
                                            var n, s = i.assets.length;
                                            for (n = 0; n < s; n += 1) i.assets[n].layers && e(i.assets[n].layers)
                                        }
                                    }
                                }(), o = (s = [4, 7, 99], function (t) {
                                    if (t.chars && !r(s, t.v)) {
                                        var e, i, a, o, h, l = t.chars.length;
                                        for (e = 0; e < l; e += 1) if (t.chars[e].data && t.chars[e].data.shapes) for (a = (h = t.chars[e].data.shapes[0].it).length, i = 0; i < a; i += 1) (o = h[i].ks.k).__converted || (n(h[i].ks.k), o.__converted = !0)
                                    }
                                }), h = function () {
                                    var t = [5, 7, 15];

                                    function e(t) {
                                        var e, i, n = t.length;
                                        for (e = 0; e < n; e += 1) 5 === t[e].ty && (i = void 0, "number" == typeof (i = t[e].t.p).a && (i.a = {
                                            a: 0,
                                            k: i.a
                                        }), "number" == typeof i.p && (i.p = {
                                            a: 0,
                                            k: i.p
                                        }), "number" == typeof i.r && (i.r = {a: 0, k: i.r}))
                                    }

                                    return function (i) {
                                        if (r(t, i.v) && (e(i.layers), i.assets)) {
                                            var n, s = i.assets.length;
                                            for (n = 0; n < s; n += 1) i.assets[n].layers && e(i.assets[n].layers)
                                        }
                                    }
                                }(), l = function () {
                                    var t = [4, 1, 9];

                                    function e(t) {
                                        var i, n, r, s = t.length;
                                        for (i = 0; i < s; i += 1) if ("gr" === t[i].ty) e(t[i].it); else if ("fl" === t[i].ty || "st" === t[i].ty) if (t[i].c.k && t[i].c.k[0].i) for (r = t[i].c.k.length, n = 0; n < r; n += 1) t[i].c.k[n].s && (t[i].c.k[n].s[0] /= 255, t[i].c.k[n].s[1] /= 255, t[i].c.k[n].s[2] /= 255, t[i].c.k[n].s[3] /= 255), t[i].c.k[n].e && (t[i].c.k[n].e[0] /= 255, t[i].c.k[n].e[1] /= 255, t[i].c.k[n].e[2] /= 255, t[i].c.k[n].e[3] /= 255); else t[i].c.k[0] /= 255, t[i].c.k[1] /= 255, t[i].c.k[2] /= 255, t[i].c.k[3] /= 255
                                    }

                                    function i(t) {
                                        var i, n = t.length;
                                        for (i = 0; i < n; i += 1) 4 === t[i].ty && e(t[i].shapes)
                                    }

                                    return function (e) {
                                        if (r(t, e.v) && (i(e.layers), e.assets)) {
                                            var n, s = e.assets.length;
                                            for (n = 0; n < s; n += 1) e.assets[n].layers && i(e.assets[n].layers)
                                        }
                                    }
                                }(), c = function () {
                                    var t = [4, 4, 18];

                                    function e(t) {
                                        var i, n, r;
                                        for (i = t.length - 1; i >= 0; i -= 1) if ("sh" === t[i].ty) if (t[i].ks.k.i) t[i].ks.k.c = t[i].closed; else for (r = t[i].ks.k.length, n = 0; n < r; n += 1) t[i].ks.k[n].s && (t[i].ks.k[n].s[0].c = t[i].closed), t[i].ks.k[n].e && (t[i].ks.k[n].e[0].c = t[i].closed); else "gr" === t[i].ty && e(t[i].it)
                                    }

                                    function i(t) {
                                        var i, n, r, s, a, o, h = t.length;
                                        for (n = 0; n < h; n += 1) {
                                            if ((i = t[n]).hasMask) {
                                                var l = i.masksProperties;
                                                for (s = l.length, r = 0; r < s; r += 1) if (l[r].pt.k.i) l[r].pt.k.c = l[r].cl; else for (o = l[r].pt.k.length, a = 0; a < o; a += 1) l[r].pt.k[a].s && (l[r].pt.k[a].s[0].c = l[r].cl), l[r].pt.k[a].e && (l[r].pt.k[a].e[0].c = l[r].cl)
                                            }
                                            4 === i.ty && e(i.shapes)
                                        }
                                    }

                                    return function (e) {
                                        if (r(t, e.v) && (i(e.layers), e.assets)) {
                                            var n, s = e.assets.length;
                                            for (n = 0; n < s; n += 1) e.assets[n].layers && i(e.assets[n].layers)
                                        }
                                    }
                                }();

                                function u(t) {
                                    0 !== t.t.a.length || "m" in t.t.p || (t.singleShape = !0)
                                }

                                var p = {
                                    completeData: function (e) {
                                        e.__complete || (l(e), a(e), o(e), h(e), c(e), t(e.layers, e.assets), e.__complete = !0)
                                    }
                                };
                                return p.checkColors = l, p.checkChars = o, p.checkPathProperties = h, p.checkShapes = c, p.completeLayers = t, p
                            }()), s.assetLoader || (s.assetLoader = function () {
                                function t(t) {
                                    var e = t.getResponseHeader("content-type");
                                    return e && "json" === t.responseType && -1 !== e.indexOf("json") || t.response && "object" == typeof t.response ? t.response : t.response && "string" == typeof t.response ? JSON.parse(t.response) : t.responseText ? JSON.parse(t.responseText) : null
                                }

                                return {
                                    load: function (e, i, n, r) {
                                        var s, a = new XMLHttpRequest;
                                        try {
                                            a.responseType = "json"
                                        } catch (t) {
                                        }
                                        a.onreadystatechange = function () {
                                            if (4 === a.readyState) if (200 === a.status) s = t(a), n(s); else try {
                                                s = t(a), n(s)
                                            } catch (t) {
                                                r && r(t)
                                            }
                                        };
                                        try {
                                            a.open("GET", e, !0)
                                        } catch (t) {
                                            a.open("GET", i + "/" + e, !0)
                                        }
                                        a.send()
                                    }
                                }
                            }()), "loadAnimation" === t.data.type) s.assetLoader.load(t.data.path, t.data.fullPath, (function (e) {
                                s.dataManager.completeData(e), s.postMessage({
                                    id: t.data.id,
                                    payload: e,
                                    status: "success"
                                })
                            }), (function () {
                                s.postMessage({id: t.data.id, status: "error"})
                            })); else if ("complete" === t.data.type) {
                                var e = t.data.animation;
                                s.dataManager.completeData(e), s.postMessage({
                                    id: t.data.id,
                                    payload: e,
                                    status: "success"
                                })
                            } else "loadData" === t.data.type && s.assetLoader.load(t.data.path, t.data.fullPath, (function (e) {
                                s.postMessage({id: t.data.id, payload: e, status: "success"})
                            }), (function () {
                                s.postMessage({id: t.data.id, status: "error"})
                            }))
                        })), e.onmessage = function (t) {
                            var e = t.data, i = e.id, r = n[i];
                            n[i] = null, "success" === e.status ? r.onComplete(e.payload) : r.onError && r.onError()
                        })
                    }

                    function o(t, e) {
                        var r = "processId_" + (i += 1);
                        return n[r] = {onComplete: t, onError: e}, r
                    }

                    return {
                        loadAnimation: function (t, i, n) {
                            a();
                            var r = o(i, n);
                            e.postMessage({
                                type: "loadAnimation",
                                path: t,
                                fullPath: window.location.origin + window.location.pathname,
                                id: r
                            })
                        }, loadData: function (t, i, n) {
                            a();
                            var r = o(i, n);
                            e.postMessage({
                                type: "loadData",
                                path: t,
                                fullPath: window.location.origin + window.location.pathname,
                                id: r
                            })
                        }, completeAnimation: function (t, i, n) {
                            a();
                            var r = o(i, n);
                            e.postMessage({type: "complete", animation: t, id: r})
                        }
                    }
                }();

                function getFontProperties(t) {
                    for (var e = t.fStyle ? t.fStyle.split(" ") : [], i = "normal", n = "normal", r = e.length, s = 0; s < r; s += 1) switch (e[s].toLowerCase()) {
                        case"italic":
                            n = "italic";
                            break;
                        case"bold":
                            i = "700";
                            break;
                        case"black":
                            i = "900";
                            break;
                        case"medium":
                            i = "500";
                            break;
                        case"regular":
                        case"normal":
                            i = "400";
                            break;
                        case"light":
                        case"thin":
                            i = "200"
                    }
                    return {style: n, weight: t.fWeight || i}
                }

                var FontManager = function () {
                    var t = {w: 0, size: 0, shapes: []}, e = [];
                    e = e.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
                    var i = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"], n = [65039, 8205];

                    function r(t, e) {
                        var i = createTag("span");
                        i.setAttribute("aria-hidden", !0), i.style.fontFamily = e;
                        var n = createTag("span");
                        n.innerText = "giItT1WQy@!-/#", i.style.position = "absolute", i.style.left = "-10000px", i.style.top = "-10000px", i.style.fontSize = "300px", i.style.fontVariant = "normal", i.style.fontStyle = "normal", i.style.fontWeight = "normal", i.style.letterSpacing = "0", i.appendChild(n), document.body.appendChild(i);
                        var r = n.offsetWidth;
                        return n.style.fontFamily = function (t) {
                            var e, i = t.split(","), n = i.length, r = [];
                            for (e = 0; e < n; e += 1) "sans-serif" !== i[e] && "monospace" !== i[e] && r.push(i[e]);
                            return r.join(",")
                        }(t) + ", " + e, {node: n, w: r, parent: i}
                    }

                    function s(t, e) {
                        var i = createNS("text");
                        i.style.fontSize = "100px";
                        var n = getFontProperties(e);
                        return i.setAttribute("font-family", e.fFamily), i.setAttribute("font-style", n.style), i.setAttribute("font-weight", n.weight), i.textContent = "1", e.fClass ? (i.style.fontFamily = "inherit", i.setAttribute("class", e.fClass)) : i.style.fontFamily = e.fFamily, t.appendChild(i), createTag("canvas").getContext("2d").font = e.fWeight + " " + e.fStyle + " 100px " + e.fFamily, i
                    }

                    var a = function () {
                        this.fonts = [], this.chars = null, this.typekitLoaded = 0, this.isLoaded = !1, this._warned = !1, this.initTime = Date.now(), this.setIsLoadedBinded = this.setIsLoaded.bind(this), this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this)
                    };
                    a.isModifier = function (t, e) {
                        var n = t.toString(16) + e.toString(16);
                        return -1 !== i.indexOf(n)
                    }, a.isZeroWidthJoiner = function (t, e) {
                        return e ? t === n[0] && e === n[1] : t === n[1]
                    }, a.isCombinedCharacter = function (t) {
                        return -1 !== e.indexOf(t)
                    };
                    var o = {
                        addChars: function (t) {
                            if (t) {
                                var e;
                                this.chars || (this.chars = []);
                                var i, n, r = t.length, s = this.chars.length;
                                for (e = 0; e < r; e += 1) {
                                    for (i = 0, n = !1; i < s;) this.chars[i].style === t[e].style && this.chars[i].fFamily === t[e].fFamily && this.chars[i].ch === t[e].ch && (n = !0), i += 1;
                                    n || (this.chars.push(t[e]), s += 1)
                                }
                            }
                        }, addFonts: function (t, e) {
                            if (t) {
                                if (this.chars) return this.isLoaded = !0, void (this.fonts = t.list);
                                var i, n = t.list, a = n.length, o = a;
                                for (i = 0; i < a; i += 1) {
                                    var h, l, c = !0;
                                    if (n[i].loaded = !1, n[i].monoCase = r(n[i].fFamily, "monospace"), n[i].sansCase = r(n[i].fFamily, "sans-serif"), n[i].fPath) {
                                        if ("p" === n[i].fOrigin || 3 === n[i].origin) {
                                            if ((h = document.querySelectorAll('style[f-forigin="p"][f-family="' + n[i].fFamily + '"], style[f-origin="3"][f-family="' + n[i].fFamily + '"]')).length > 0 && (c = !1), c) {
                                                var u = createTag("style");
                                                u.setAttribute("f-forigin", n[i].fOrigin), u.setAttribute("f-origin", n[i].origin), u.setAttribute("f-family", n[i].fFamily), u.type = "text/css", u.innerText = "@font-face {font-family: " + n[i].fFamily + "; font-style: normal; src: url('" + n[i].fPath + "');}", e.appendChild(u)
                                            }
                                        } else if ("g" === n[i].fOrigin || 1 === n[i].origin) {
                                            for (h = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]'), l = 0; l < h.length; l += 1) -1 !== h[l].href.indexOf(n[i].fPath) && (c = !1);
                                            if (c) {
                                                var p = createTag("link");
                                                p.setAttribute("f-forigin", n[i].fOrigin), p.setAttribute("f-origin", n[i].origin), p.type = "text/css", p.rel = "stylesheet", p.href = n[i].fPath, document.body.appendChild(p)
                                            }
                                        } else if ("t" === n[i].fOrigin || 2 === n[i].origin) {
                                            for (h = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]'), l = 0; l < h.length; l += 1) n[i].fPath === h[l].src && (c = !1);
                                            if (c) {
                                                var d = createTag("link");
                                                d.setAttribute("f-forigin", n[i].fOrigin), d.setAttribute("f-origin", n[i].origin), d.setAttribute("rel", "stylesheet"), d.setAttribute("href", n[i].fPath), e.appendChild(d)
                                            }
                                        }
                                    } else n[i].loaded = !0, o -= 1;
                                    n[i].helper = s(e, n[i]), n[i].cache = {}, this.fonts.push(n[i])
                                }
                                0 === o ? this.isLoaded = !0 : setTimeout(this.checkLoadedFonts.bind(this), 100)
                            } else this.isLoaded = !0
                        }, getCharData: function (e, i, n) {
                            for (var r = 0, s = this.chars.length; r < s;) {
                                if (this.chars[r].ch === e && this.chars[r].style === i && this.chars[r].fFamily === n) return this.chars[r];
                                r += 1
                            }
                            return ("string" == typeof e && 13 !== e.charCodeAt(0) || !e) && console && console.warn && !this._warned && (this._warned = !0, console.warn("Missing character from exported characters list: ", e, i, n)), t
                        }, getFontByName: function (t) {
                            for (var e = 0, i = this.fonts.length; e < i;) {
                                if (this.fonts[e].fName === t) return this.fonts[e];
                                e += 1
                            }
                            return this.fonts[0]
                        }, measureText: function (t, e, i) {
                            var n = this.getFontByName(e), r = t.charCodeAt(0);
                            if (!n.cache[r + 1]) {
                                var s = n.helper;
                                if (" " === t) {
                                    s.textContent = "|" + t + "|";
                                    var a = s.getComputedTextLength();
                                    s.textContent = "||";
                                    var o = s.getComputedTextLength();
                                    n.cache[r + 1] = (a - o) / 100
                                } else s.textContent = t, n.cache[r + 1] = s.getComputedTextLength() / 100
                            }
                            return n.cache[r + 1] * i
                        }, checkLoadedFonts: function () {
                            var t, e, i, n = this.fonts.length, r = n;
                            for (t = 0; t < n; t += 1) this.fonts[t].loaded ? r -= 1 : "n" === this.fonts[t].fOrigin || 0 === this.fonts[t].origin ? this.fonts[t].loaded = !0 : (e = this.fonts[t].monoCase.node, i = this.fonts[t].monoCase.w, e.offsetWidth !== i ? (r -= 1, this.fonts[t].loaded = !0) : (e = this.fonts[t].sansCase.node, i = this.fonts[t].sansCase.w, e.offsetWidth !== i && (r -= 1, this.fonts[t].loaded = !0)), this.fonts[t].loaded && (this.fonts[t].sansCase.parent.parentNode.removeChild(this.fonts[t].sansCase.parent), this.fonts[t].monoCase.parent.parentNode.removeChild(this.fonts[t].monoCase.parent)));
                            0 !== r && Date.now() - this.initTime < 5e3 ? setTimeout(this.checkLoadedFontsBinded, 20) : setTimeout(this.setIsLoadedBinded, 10)
                        }, setIsLoaded: function () {
                            this.isLoaded = !0
                        }
                    };
                    return a.prototype = o, a
                }(), PropertyFactory = function () {
                    var t = initialDefaultFrame, e = Math.abs;

                    function i(t, e) {
                        var i, r = this.offsetTime;
                        "multidimensional" === this.propType && (i = createTypedArray("float32", this.pv.length));
                        for (var s, a, o, h, l, c, u, p, d, f = e.lastIndex, m = f, g = this.keyframes.length - 1, v = !0; v;) {
                            if (s = this.keyframes[m], a = this.keyframes[m + 1], m === g - 1 && t >= a.t - r) {
                                s.h && (s = a), f = 0;
                                break
                            }
                            if (a.t - r > t) {
                                f = m;
                                break
                            }
                            m < g - 1 ? m += 1 : (f = 0, v = !1)
                        }
                        o = this.keyframesMetadata[m] || {};
                        var y, b, x, w, _, E, M, A, S, T, D = a.t - r, C = s.t - r;
                        if (s.to) {
                            o.bezierData || (o.bezierData = bez.buildBezierData(s.s, a.s || s.e, s.to, s.ti));
                            var P = o.bezierData;
                            if (t >= D || t < C) {
                                var I = t >= D ? P.points.length - 1 : 0;
                                for (l = P.points[I].point.length, h = 0; h < l; h += 1) i[h] = P.points[I].point[h]
                            } else {
                                o.__fnct ? d = o.__fnct : (d = BezierFactory.getBezierEasing(s.o.x, s.o.y, s.i.x, s.i.y, s.n).get, o.__fnct = d), c = d((t - C) / (D - C));
                                var L, R = P.segmentLength * c,
                                    F = e.lastFrame < t && e._lastKeyframeIndex === m ? e._lastAddedLength : 0;
                                for (p = e.lastFrame < t && e._lastKeyframeIndex === m ? e._lastPoint : 0, v = !0, u = P.points.length; v;) {
                                    if (F += P.points[p].partialLength, 0 === R || 0 === c || p === P.points.length - 1) {
                                        for (l = P.points[p].point.length, h = 0; h < l; h += 1) i[h] = P.points[p].point[h];
                                        break
                                    }
                                    if (R >= F && R < F + P.points[p + 1].partialLength) {
                                        for (L = (R - F) / P.points[p + 1].partialLength, l = P.points[p].point.length, h = 0; h < l; h += 1) i[h] = P.points[p].point[h] + (P.points[p + 1].point[h] - P.points[p].point[h]) * L;
                                        break
                                    }
                                    p < u - 1 ? p += 1 : v = !1
                                }
                                e._lastPoint = p, e._lastAddedLength = F - P.points[p].partialLength, e._lastKeyframeIndex = m
                            }
                        } else {
                            var k, O, z, B, N;
                            if (g = s.s.length, y = a.s || s.e, this.sh && 1 !== s.h) if (t >= D) i[0] = y[0], i[1] = y[1], i[2] = y[2]; else if (t <= C) i[0] = s.s[0], i[1] = s.s[1], i[2] = s.s[2]; else {
                                var j = n(s.s), V = n(y);
                                b = i, x = function (t, e, i) {
                                    var n, r, s, a, o, h = [], l = t[0], c = t[1], u = t[2], p = t[3], d = e[0],
                                        f = e[1], m = e[2], g = e[3];
                                    return (r = l * d + c * f + u * m + p * g) < 0 && (r = -r, d = -d, f = -f, m = -m, g = -g), 1 - r > 1e-6 ? (n = Math.acos(r), s = Math.sin(n), a = Math.sin((1 - i) * n) / s, o = Math.sin(i * n) / s) : (a = 1 - i, o = i), h[0] = a * l + o * d, h[1] = a * c + o * f, h[2] = a * u + o * m, h[3] = a * p + o * g, h
                                }(j, V, (t - C) / (D - C)), w = x[0], _ = x[1], E = x[2], M = x[3], A = Math.atan2(2 * _ * M - 2 * w * E, 1 - 2 * _ * _ - 2 * E * E), S = Math.asin(2 * w * _ + 2 * E * M), T = Math.atan2(2 * w * M - 2 * _ * E, 1 - 2 * w * w - 2 * E * E), b[0] = A / degToRads, b[1] = S / degToRads, b[2] = T / degToRads
                            } else for (m = 0; m < g; m += 1) 1 !== s.h && (t >= D ? c = 1 : t < C ? c = 0 : (s.o.x.constructor === Array ? (o.__fnct || (o.__fnct = []), o.__fnct[m] ? d = o.__fnct[m] : (k = void 0 === s.o.x[m] ? s.o.x[0] : s.o.x[m], O = void 0 === s.o.y[m] ? s.o.y[0] : s.o.y[m], z = void 0 === s.i.x[m] ? s.i.x[0] : s.i.x[m], B = void 0 === s.i.y[m] ? s.i.y[0] : s.i.y[m], d = BezierFactory.getBezierEasing(k, O, z, B).get, o.__fnct[m] = d)) : o.__fnct ? d = o.__fnct : (k = s.o.x, O = s.o.y, z = s.i.x, B = s.i.y, d = BezierFactory.getBezierEasing(k, O, z, B).get, s.keyframeMetadata = d), c = d((t - C) / (D - C)))), y = a.s || s.e, N = 1 === s.h ? s.s[m] : s.s[m] + (y[m] - s.s[m]) * c, "multidimensional" === this.propType ? i[m] = N : i = N
                        }
                        return e.lastIndex = f, i
                    }

                    function n(t) {
                        var e = t[0] * degToRads, i = t[1] * degToRads, n = t[2] * degToRads, r = Math.cos(e / 2),
                            s = Math.cos(i / 2), a = Math.cos(n / 2), o = Math.sin(e / 2), h = Math.sin(i / 2),
                            l = Math.sin(n / 2);
                        return [o * h * a + r * s * l, o * s * a + r * h * l, r * h * a - o * s * l, r * s * a - o * h * l]
                    }

                    function r() {
                        var e = this.comp.renderedFrame - this.offsetTime, i = this.keyframes[0].t - this.offsetTime,
                            n = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
                        if (!(e === this._caching.lastFrame || this._caching.lastFrame !== t && (this._caching.lastFrame >= n && e >= n || this._caching.lastFrame < i && e < i))) {
                            this._caching.lastFrame >= e && (this._caching._lastKeyframeIndex = -1, this._caching.lastIndex = 0);
                            var r = this.interpolateValue(e, this._caching);
                            this.pv = r
                        }
                        return this._caching.lastFrame = e, this.pv
                    }

                    function s(t) {
                        var i;
                        if ("unidimensional" === this.propType) i = t * this.mult, e(this.v - i) > 1e-5 && (this.v = i, this._mdf = !0); else for (var n = 0, r = this.v.length; n < r;) i = t[n] * this.mult, e(this.v[n] - i) > 1e-5 && (this.v[n] = i, this._mdf = !0), n += 1
                    }

                    function a() {
                        if (this.elem.globalData.frameId !== this.frameId && this.effectsSequence.length) if (this.lock) this.setVValue(this.pv); else {
                            var t;
                            this.lock = !0, this._mdf = this._isFirstFrame;
                            var e = this.effectsSequence.length, i = this.kf ? this.pv : this.data.k;
                            for (t = 0; t < e; t += 1) i = this.effectsSequence[t](i);
                            this.setVValue(i), this._isFirstFrame = !1, this.lock = !1, this.frameId = this.elem.globalData.frameId
                        }
                    }

                    function o(t) {
                        this.effectsSequence.push(t), this.container.addDynamicProperty(this)
                    }

                    function h(t, e, i, n) {
                        this.propType = "unidimensional", this.mult = i || 1, this.data = e, this.v = i ? e.k * i : e.k, this.pv = e.k, this._mdf = !1, this.elem = t, this.container = n, this.comp = t.comp, this.k = !1, this.kf = !1, this.vel = 0, this.effectsSequence = [], this._isFirstFrame = !0, this.getValue = a, this.setVValue = s, this.addEffect = o
                    }

                    function l(t, e, i, n) {
                        var r;
                        this.propType = "multidimensional", this.mult = i || 1, this.data = e, this._mdf = !1, this.elem = t, this.container = n, this.comp = t.comp, this.k = !1, this.kf = !1, this.frameId = -1;
                        var h = e.k.length;
                        for (this.v = createTypedArray("float32", h), this.pv = createTypedArray("float32", h), this.vel = createTypedArray("float32", h), r = 0; r < h; r += 1) this.v[r] = e.k[r] * this.mult, this.pv[r] = e.k[r];
                        this._isFirstFrame = !0, this.effectsSequence = [], this.getValue = a, this.setVValue = s, this.addEffect = o
                    }

                    function c(e, n, h, l) {
                        this.propType = "unidimensional", this.keyframes = n.k, this.keyframesMetadata = [], this.offsetTime = e.data.st, this.frameId = -1, this._caching = {
                            lastFrame: t,
                            lastIndex: 0,
                            value: 0,
                            _lastKeyframeIndex: -1
                        }, this.k = !0, this.kf = !0, this.data = n, this.mult = h || 1, this.elem = e, this.container = l, this.comp = e.comp, this.v = t, this.pv = t, this._isFirstFrame = !0, this.getValue = a, this.setVValue = s, this.interpolateValue = i, this.effectsSequence = [r.bind(this)], this.addEffect = o
                    }

                    function u(e, n, h, l) {
                        var c;
                        this.propType = "multidimensional";
                        var u, p, d, f, m = n.k.length;
                        for (c = 0; c < m - 1; c += 1) n.k[c].to && n.k[c].s && n.k[c + 1] && n.k[c + 1].s && (u = n.k[c].s, p = n.k[c + 1].s, d = n.k[c].to, f = n.k[c].ti, (2 === u.length && (u[0] !== p[0] || u[1] !== p[1]) && bez.pointOnLine2D(u[0], u[1], p[0], p[1], u[0] + d[0], u[1] + d[1]) && bez.pointOnLine2D(u[0], u[1], p[0], p[1], p[0] + f[0], p[1] + f[1]) || 3 === u.length && (u[0] !== p[0] || u[1] !== p[1] || u[2] !== p[2]) && bez.pointOnLine3D(u[0], u[1], u[2], p[0], p[1], p[2], u[0] + d[0], u[1] + d[1], u[2] + d[2]) && bez.pointOnLine3D(u[0], u[1], u[2], p[0], p[1], p[2], p[0] + f[0], p[1] + f[1], p[2] + f[2])) && (n.k[c].to = null, n.k[c].ti = null), u[0] === p[0] && u[1] === p[1] && 0 === d[0] && 0 === d[1] && 0 === f[0] && 0 === f[1] && (2 === u.length || u[2] === p[2] && 0 === d[2] && 0 === f[2]) && (n.k[c].to = null, n.k[c].ti = null));
                        this.effectsSequence = [r.bind(this)], this.data = n, this.keyframes = n.k, this.keyframesMetadata = [], this.offsetTime = e.data.st, this.k = !0, this.kf = !0, this._isFirstFrame = !0, this.mult = h || 1, this.elem = e, this.container = l, this.comp = e.comp, this.getValue = a, this.setVValue = s, this.interpolateValue = i, this.frameId = -1;
                        var g = n.k[0].s.length;
                        for (this.v = createTypedArray("float32", g), this.pv = createTypedArray("float32", g), c = 0; c < g; c += 1) this.v[c] = t, this.pv[c] = t;
                        this._caching = {
                            lastFrame: t,
                            lastIndex: 0,
                            value: createTypedArray("float32", g)
                        }, this.addEffect = o
                    }

                    return {
                        getProp: function (t, e, i, n, r) {
                            var s;
                            if (e.k.length) if ("number" == typeof e.k[0]) s = new l(t, e, n, r); else switch (i) {
                                case 0:
                                    s = new c(t, e, n, r);
                                    break;
                                case 1:
                                    s = new u(t, e, n, r)
                            } else s = new h(t, e, n, r);
                            return s.effectsSequence.length && r.addDynamicProperty(s), s
                        }
                    }
                }(), TransformPropertyFactory = function () {
                    var t = [0, 0];

                    function e(t, e, i) {
                        if (this.elem = t, this.frameId = -1, this.propType = "transform", this.data = e, this.v = new Matrix, this.pre = new Matrix, this.appliedTransformations = 0, this.initDynamicPropertyContainer(i || t), e.p && e.p.s ? (this.px = PropertyFactory.getProp(t, e.p.x, 0, 0, this), this.py = PropertyFactory.getProp(t, e.p.y, 0, 0, this), e.p.z && (this.pz = PropertyFactory.getProp(t, e.p.z, 0, 0, this))) : this.p = PropertyFactory.getProp(t, e.p || {k: [0, 0, 0]}, 1, 0, this), e.rx) {
                            if (this.rx = PropertyFactory.getProp(t, e.rx, 0, degToRads, this), this.ry = PropertyFactory.getProp(t, e.ry, 0, degToRads, this), this.rz = PropertyFactory.getProp(t, e.rz, 0, degToRads, this), e.or.k[0].ti) {
                                var n, r = e.or.k.length;
                                for (n = 0; n < r; n += 1) e.or.k[n].to = null, e.or.k[n].ti = null
                            }
                            this.or = PropertyFactory.getProp(t, e.or, 1, degToRads, this), this.or.sh = !0
                        } else this.r = PropertyFactory.getProp(t, e.r || {k: 0}, 0, degToRads, this);
                        e.sk && (this.sk = PropertyFactory.getProp(t, e.sk, 0, degToRads, this), this.sa = PropertyFactory.getProp(t, e.sa, 0, degToRads, this)), this.a = PropertyFactory.getProp(t, e.a || {k: [0, 0, 0]}, 1, 0, this), this.s = PropertyFactory.getProp(t, e.s || {k: [100, 100, 100]}, 1, .01, this), e.o ? this.o = PropertyFactory.getProp(t, e.o, 0, .01, t) : this.o = {
                            _mdf: !1,
                            v: 1
                        }, this._isDirty = !0, this.dynamicProperties.length || this.getValue(!0)
                    }

                    return e.prototype = {
                        applyToMatrix: function (t) {
                            var e = this._mdf;
                            this.iterateDynamicProperties(), this._mdf = this._mdf || e, this.a && t.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.s && t.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && t.skewFromAxis(-this.sk.v, this.sa.v), this.r ? t.rotate(-this.r.v) : t.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.data.p.s ? this.data.p.z ? t.translate(this.px.v, this.py.v, -this.pz.v) : t.translate(this.px.v, this.py.v, 0) : t.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
                        }, getValue: function (e) {
                            if (this.elem.globalData.frameId !== this.frameId) {
                                if (this._isDirty && (this.precalculateMatrix(), this._isDirty = !1), this.iterateDynamicProperties(), this._mdf || e) {
                                    var i;
                                    if (this.v.cloneFromProps(this.pre.props), this.appliedTransformations < 1 && this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations < 2 && this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && this.appliedTransformations < 3 && this.v.skewFromAxis(-this.sk.v, this.sa.v), this.r && this.appliedTransformations < 4 ? this.v.rotate(-this.r.v) : !this.r && this.appliedTransformations < 4 && this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.autoOriented) {
                                        var n, r;
                                        if (i = this.elem.globalData.frameRate, this.p && this.p.keyframes && this.p.getValueAtTime) this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t ? (n = this.p.getValueAtTime((this.p.keyframes[0].t + .01) / i, 0), r = this.p.getValueAtTime(this.p.keyframes[0].t / i, 0)) : this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t ? (n = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / i, 0), r = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - .05) / i, 0)) : (n = this.p.pv, r = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - .01) / i, this.p.offsetTime)); else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                                            n = [], r = [];
                                            var s = this.px, a = this.py;
                                            s._caching.lastFrame + s.offsetTime <= s.keyframes[0].t ? (n[0] = s.getValueAtTime((s.keyframes[0].t + .01) / i, 0), n[1] = a.getValueAtTime((a.keyframes[0].t + .01) / i, 0), r[0] = s.getValueAtTime(s.keyframes[0].t / i, 0), r[1] = a.getValueAtTime(a.keyframes[0].t / i, 0)) : s._caching.lastFrame + s.offsetTime >= s.keyframes[s.keyframes.length - 1].t ? (n[0] = s.getValueAtTime(s.keyframes[s.keyframes.length - 1].t / i, 0), n[1] = a.getValueAtTime(a.keyframes[a.keyframes.length - 1].t / i, 0), r[0] = s.getValueAtTime((s.keyframes[s.keyframes.length - 1].t - .01) / i, 0), r[1] = a.getValueAtTime((a.keyframes[a.keyframes.length - 1].t - .01) / i, 0)) : (n = [s.pv, a.pv], r[0] = s.getValueAtTime((s._caching.lastFrame + s.offsetTime - .01) / i, s.offsetTime), r[1] = a.getValueAtTime((a._caching.lastFrame + a.offsetTime - .01) / i, a.offsetTime))
                                        } else n = r = t;
                                        this.v.rotate(-Math.atan2(n[1] - r[1], n[0] - r[0]))
                                    }
                                    this.data.p && this.data.p.s ? this.data.p.z ? this.v.translate(this.px.v, this.py.v, -this.pz.v) : this.v.translate(this.px.v, this.py.v, 0) : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
                                }
                                this.frameId = this.elem.globalData.frameId
                            }
                        }, precalculateMatrix: function () {
                            if (!this.a.k && (this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations = 1, !this.s.effectsSequence.length)) {
                                if (this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.appliedTransformations = 2, this.sk) {
                                    if (this.sk.effectsSequence.length || this.sa.effectsSequence.length) return;
                                    this.pre.skewFromAxis(-this.sk.v, this.sa.v), this.appliedTransformations = 3
                                }
                                this.r ? this.r.effectsSequence.length || (this.pre.rotate(-this.r.v), this.appliedTransformations = 4) : this.rz.effectsSequence.length || this.ry.effectsSequence.length || this.rx.effectsSequence.length || this.or.effectsSequence.length || (this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.appliedTransformations = 4)
                            }
                        }, autoOrient: function () {
                        }
                    }, extendPrototype([DynamicPropertyContainer], e), e.prototype.addDynamicProperty = function (t) {
                        this._addDynamicProperty(t), this.elem.addDynamicProperty(t), this._isDirty = !0
                    }, e.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty, {
                        getTransformProperty: function (t, i, n) {
                            return new e(t, i, n)
                        }
                    }
                }();

                function ShapePath() {
                    this.c = !1, this._length = 0, this._maxLength = 8, this.v = createSizedArray(this._maxLength), this.o = createSizedArray(this._maxLength), this.i = createSizedArray(this._maxLength)
                }

                ShapePath.prototype.setPathData = function (t, e) {
                    this.c = t, this.setLength(e);
                    for (var i = 0; i < e;) this.v[i] = pointPool.newElement(), this.o[i] = pointPool.newElement(), this.i[i] = pointPool.newElement(), i += 1
                }, ShapePath.prototype.setLength = function (t) {
                    for (; this._maxLength < t;) this.doubleArrayLength();
                    this._length = t
                }, ShapePath.prototype.doubleArrayLength = function () {
                    this.v = this.v.concat(createSizedArray(this._maxLength)), this.i = this.i.concat(createSizedArray(this._maxLength)), this.o = this.o.concat(createSizedArray(this._maxLength)), this._maxLength *= 2
                }, ShapePath.prototype.setXYAt = function (t, e, i, n, r) {
                    var s;
                    switch (this._length = Math.max(this._length, n + 1), this._length >= this._maxLength && this.doubleArrayLength(), i) {
                        case"v":
                            s = this.v;
                            break;
                        case"i":
                            s = this.i;
                            break;
                        case"o":
                            s = this.o;
                            break;
                        default:
                            s = []
                    }
                    (!s[n] || s[n] && !r) && (s[n] = pointPool.newElement()), s[n][0] = t, s[n][1] = e
                }, ShapePath.prototype.setTripleAt = function (t, e, i, n, r, s, a, o) {
                    this.setXYAt(t, e, "v", a, o), this.setXYAt(i, n, "o", a, o), this.setXYAt(r, s, "i", a, o)
                }, ShapePath.prototype.reverse = function () {
                    var t = new ShapePath;
                    t.setPathData(this.c, this._length);
                    var e = this.v, i = this.o, n = this.i, r = 0;
                    this.c && (t.setTripleAt(e[0][0], e[0][1], n[0][0], n[0][1], i[0][0], i[0][1], 0, !1), r = 1);
                    var s, a = this._length - 1, o = this._length;
                    for (s = r; s < o; s += 1) t.setTripleAt(e[a][0], e[a][1], n[a][0], n[a][1], i[a][0], i[a][1], s, !1), a -= 1;
                    return t
                };
                var ShapePropertyFactory = function () {
                    var t = -999999;

                    function e(t, e, i) {
                        var n, r, s, a, o, h, l, c, u, p = i.lastIndex, d = this.keyframes;
                        if (t < d[0].t - this.offsetTime) n = d[0].s[0], s = !0, p = 0; else if (t >= d[d.length - 1].t - this.offsetTime) n = d[d.length - 1].s ? d[d.length - 1].s[0] : d[d.length - 2].e[0], s = !0; else {
                            for (var f, m, g, v = p, y = d.length - 1, b = !0; b && (f = d[v], !((m = d[v + 1]).t - this.offsetTime > t));) v < y - 1 ? v += 1 : b = !1;
                            if (g = this.keyframesMetadata[v] || {}, p = v, !(s = 1 === f.h)) {
                                if (t >= m.t - this.offsetTime) c = 1; else if (t < f.t - this.offsetTime) c = 0; else {
                                    var x;
                                    g.__fnct ? x = g.__fnct : (x = BezierFactory.getBezierEasing(f.o.x, f.o.y, f.i.x, f.i.y).get, g.__fnct = x), c = x((t - (f.t - this.offsetTime)) / (m.t - this.offsetTime - (f.t - this.offsetTime)))
                                }
                                r = m.s ? m.s[0] : f.e[0]
                            }
                            n = f.s[0]
                        }
                        for (h = e._length, l = n.i[0].length, i.lastIndex = p, a = 0; a < h; a += 1) for (o = 0; o < l; o += 1) u = s ? n.i[a][o] : n.i[a][o] + (r.i[a][o] - n.i[a][o]) * c, e.i[a][o] = u, u = s ? n.o[a][o] : n.o[a][o] + (r.o[a][o] - n.o[a][o]) * c, e.o[a][o] = u, u = s ? n.v[a][o] : n.v[a][o] + (r.v[a][o] - n.v[a][o]) * c, e.v[a][o] = u
                    }

                    function i() {
                        var e = this.comp.renderedFrame - this.offsetTime, i = this.keyframes[0].t - this.offsetTime,
                            n = this.keyframes[this.keyframes.length - 1].t - this.offsetTime,
                            r = this._caching.lastFrame;
                        return r !== t && (r < i && e < i || r > n && e > n) || (this._caching.lastIndex = r < e ? this._caching.lastIndex : 0, this.interpolateShape(e, this.pv, this._caching)), this._caching.lastFrame = e, this.pv
                    }

                    function n() {
                        this.paths = this.localShapeCollection
                    }

                    function r(t) {
                        (function (t, e) {
                            if (t._length !== e._length || t.c !== e.c) return !1;
                            var i, n = t._length;
                            for (i = 0; i < n; i += 1) if (t.v[i][0] !== e.v[i][0] || t.v[i][1] !== e.v[i][1] || t.o[i][0] !== e.o[i][0] || t.o[i][1] !== e.o[i][1] || t.i[i][0] !== e.i[i][0] || t.i[i][1] !== e.i[i][1]) return !1;
                            return !0
                        })(this.v, t) || (this.v = shapePool.clone(t), this.localShapeCollection.releaseShapes(), this.localShapeCollection.addShape(this.v), this._mdf = !0, this.paths = this.localShapeCollection)
                    }

                    function s() {
                        if (this.elem.globalData.frameId !== this.frameId) if (this.effectsSequence.length) if (this.lock) this.setVValue(this.pv); else {
                            var t, e;
                            this.lock = !0, this._mdf = !1, t = this.kf ? this.pv : this.data.ks ? this.data.ks.k : this.data.pt.k;
                            var i = this.effectsSequence.length;
                            for (e = 0; e < i; e += 1) t = this.effectsSequence[e](t);
                            this.setVValue(t), this.lock = !1, this.frameId = this.elem.globalData.frameId
                        } else this._mdf = !1
                    }

                    function a(t, e, i) {
                        this.propType = "shape", this.comp = t.comp, this.container = t, this.elem = t, this.data = e, this.k = !1, this.kf = !1, this._mdf = !1;
                        var r = 3 === i ? e.pt.k : e.ks.k;
                        this.v = shapePool.clone(r), this.pv = shapePool.clone(this.v), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.reset = n, this.effectsSequence = []
                    }

                    function o(t) {
                        this.effectsSequence.push(t), this.container.addDynamicProperty(this)
                    }

                    function h(e, r, s) {
                        this.propType = "shape", this.comp = e.comp, this.elem = e, this.container = e, this.offsetTime = e.data.st, this.keyframes = 3 === s ? r.pt.k : r.ks.k, this.keyframesMetadata = [], this.k = !0, this.kf = !0;
                        var a = this.keyframes[0].s[0].i.length;
                        this.v = shapePool.newElement(), this.v.setPathData(this.keyframes[0].s[0].c, a), this.pv = shapePool.clone(this.v), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.lastFrame = t, this.reset = n, this._caching = {
                            lastFrame: t,
                            lastIndex: 0
                        }, this.effectsSequence = [i.bind(this)]
                    }

                    a.prototype.interpolateShape = e, a.prototype.getValue = s, a.prototype.setVValue = r, a.prototype.addEffect = o, h.prototype.getValue = s, h.prototype.interpolateShape = e, h.prototype.setVValue = r, h.prototype.addEffect = o;
                    var l = function () {
                        var t = roundCorner;

                        function e(t, e) {
                            this.v = shapePool.newElement(), this.v.setPathData(!0, 4), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.localShapeCollection.addShape(this.v), this.d = e.d, this.elem = t, this.comp = t.comp, this.frameId = -1, this.initDynamicPropertyContainer(t), this.p = PropertyFactory.getProp(t, e.p, 1, 0, this), this.s = PropertyFactory.getProp(t, e.s, 1, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertEllToPath())
                        }

                        return e.prototype = {
                            reset: n, getValue: function () {
                                this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertEllToPath())
                            }, convertEllToPath: function () {
                                var e = this.p.v[0], i = this.p.v[1], n = this.s.v[0] / 2, r = this.s.v[1] / 2,
                                    s = 3 !== this.d, a = this.v;
                                a.v[0][0] = e, a.v[0][1] = i - r, a.v[1][0] = s ? e + n : e - n, a.v[1][1] = i, a.v[2][0] = e, a.v[2][1] = i + r, a.v[3][0] = s ? e - n : e + n, a.v[3][1] = i, a.i[0][0] = s ? e - n * t : e + n * t, a.i[0][1] = i - r, a.i[1][0] = s ? e + n : e - n, a.i[1][1] = i - r * t, a.i[2][0] = s ? e + n * t : e - n * t, a.i[2][1] = i + r, a.i[3][0] = s ? e - n : e + n, a.i[3][1] = i + r * t, a.o[0][0] = s ? e + n * t : e - n * t, a.o[0][1] = i - r, a.o[1][0] = s ? e + n : e - n, a.o[1][1] = i + r * t, a.o[2][0] = s ? e - n * t : e + n * t, a.o[2][1] = i + r, a.o[3][0] = s ? e - n : e + n, a.o[3][1] = i - r * t
                            }
                        }, extendPrototype([DynamicPropertyContainer], e), e
                    }(), c = function () {
                        function t(t, e) {
                            this.v = shapePool.newElement(), this.v.setPathData(!0, 0), this.elem = t, this.comp = t.comp, this.data = e, this.frameId = -1, this.d = e.d, this.initDynamicPropertyContainer(t), 1 === e.sy ? (this.ir = PropertyFactory.getProp(t, e.ir, 0, 0, this), this.is = PropertyFactory.getProp(t, e.is, 0, .01, this), this.convertToPath = this.convertStarToPath) : this.convertToPath = this.convertPolygonToPath, this.pt = PropertyFactory.getProp(t, e.pt, 0, 0, this), this.p = PropertyFactory.getProp(t, e.p, 1, 0, this), this.r = PropertyFactory.getProp(t, e.r, 0, degToRads, this), this.or = PropertyFactory.getProp(t, e.or, 0, 0, this), this.os = PropertyFactory.getProp(t, e.os, 0, .01, this), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertToPath())
                        }

                        return t.prototype = {
                            reset: n, getValue: function () {
                                this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertToPath())
                            }, convertStarToPath: function () {
                                var t, e, i, n, r = 2 * Math.floor(this.pt.v), s = 2 * Math.PI / r, a = !0,
                                    o = this.or.v, h = this.ir.v, l = this.os.v, c = this.is.v,
                                    u = 2 * Math.PI * o / (2 * r), p = 2 * Math.PI * h / (2 * r), d = -Math.PI / 2;
                                d += this.r.v;
                                var f = 3 === this.data.d ? -1 : 1;
                                for (this.v._length = 0, t = 0; t < r; t += 1) {
                                    i = a ? l : c, n = a ? u : p;
                                    var m = (e = a ? o : h) * Math.cos(d), g = e * Math.sin(d),
                                        v = 0 === m && 0 === g ? 0 : g / Math.sqrt(m * m + g * g),
                                        y = 0 === m && 0 === g ? 0 : -m / Math.sqrt(m * m + g * g);
                                    m += +this.p.v[0], g += +this.p.v[1], this.v.setTripleAt(m, g, m - v * n * i * f, g - y * n * i * f, m + v * n * i * f, g + y * n * i * f, t, !0), a = !a, d += s * f
                                }
                            }, convertPolygonToPath: function () {
                                var t, e = Math.floor(this.pt.v), i = 2 * Math.PI / e, n = this.or.v, r = this.os.v,
                                    s = 2 * Math.PI * n / (4 * e), a = .5 * -Math.PI, o = 3 === this.data.d ? -1 : 1;
                                for (a += this.r.v, this.v._length = 0, t = 0; t < e; t += 1) {
                                    var h = n * Math.cos(a), l = n * Math.sin(a),
                                        c = 0 === h && 0 === l ? 0 : l / Math.sqrt(h * h + l * l),
                                        u = 0 === h && 0 === l ? 0 : -h / Math.sqrt(h * h + l * l);
                                    h += +this.p.v[0], l += +this.p.v[1], this.v.setTripleAt(h, l, h - c * s * r * o, l - u * s * r * o, h + c * s * r * o, l + u * s * r * o, t, !0), a += i * o
                                }
                                this.paths.length = 0, this.paths[0] = this.v
                            }
                        }, extendPrototype([DynamicPropertyContainer], t), t
                    }(), u = function () {
                        function t(t, e) {
                            this.v = shapePool.newElement(), this.v.c = !0, this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.elem = t, this.comp = t.comp, this.frameId = -1, this.d = e.d, this.initDynamicPropertyContainer(t), this.p = PropertyFactory.getProp(t, e.p, 1, 0, this), this.s = PropertyFactory.getProp(t, e.s, 1, 0, this), this.r = PropertyFactory.getProp(t, e.r, 0, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertRectToPath())
                        }

                        return t.prototype = {
                            convertRectToPath: function () {
                                var t = this.p.v[0], e = this.p.v[1], i = this.s.v[0] / 2, n = this.s.v[1] / 2,
                                    r = bmMin(i, n, this.r.v), s = r * (1 - roundCorner);
                                this.v._length = 0, 2 === this.d || 1 === this.d ? (this.v.setTripleAt(t + i, e - n + r, t + i, e - n + r, t + i, e - n + s, 0, !0), this.v.setTripleAt(t + i, e + n - r, t + i, e + n - s, t + i, e + n - r, 1, !0), 0 !== r ? (this.v.setTripleAt(t + i - r, e + n, t + i - r, e + n, t + i - s, e + n, 2, !0), this.v.setTripleAt(t - i + r, e + n, t - i + s, e + n, t - i + r, e + n, 3, !0), this.v.setTripleAt(t - i, e + n - r, t - i, e + n - r, t - i, e + n - s, 4, !0), this.v.setTripleAt(t - i, e - n + r, t - i, e - n + s, t - i, e - n + r, 5, !0), this.v.setTripleAt(t - i + r, e - n, t - i + r, e - n, t - i + s, e - n, 6, !0), this.v.setTripleAt(t + i - r, e - n, t + i - s, e - n, t + i - r, e - n, 7, !0)) : (this.v.setTripleAt(t - i, e + n, t - i + s, e + n, t - i, e + n, 2), this.v.setTripleAt(t - i, e - n, t - i, e - n + s, t - i, e - n, 3))) : (this.v.setTripleAt(t + i, e - n + r, t + i, e - n + s, t + i, e - n + r, 0, !0), 0 !== r ? (this.v.setTripleAt(t + i - r, e - n, t + i - r, e - n, t + i - s, e - n, 1, !0), this.v.setTripleAt(t - i + r, e - n, t - i + s, e - n, t - i + r, e - n, 2, !0), this.v.setTripleAt(t - i, e - n + r, t - i, e - n + r, t - i, e - n + s, 3, !0), this.v.setTripleAt(t - i, e + n - r, t - i, e + n - s, t - i, e + n - r, 4, !0), this.v.setTripleAt(t - i + r, e + n, t - i + r, e + n, t - i + s, e + n, 5, !0), this.v.setTripleAt(t + i - r, e + n, t + i - s, e + n, t + i - r, e + n, 6, !0), this.v.setTripleAt(t + i, e + n - r, t + i, e + n - r, t + i, e + n - s, 7, !0)) : (this.v.setTripleAt(t - i, e - n, t - i + s, e - n, t - i, e - n, 1, !0), this.v.setTripleAt(t - i, e + n, t - i, e + n - s, t - i, e + n, 2, !0), this.v.setTripleAt(t + i, e + n, t + i - s, e + n, t + i, e + n, 3, !0)))
                            }, getValue: function () {
                                this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertRectToPath())
                            }, reset: n
                        }, extendPrototype([DynamicPropertyContainer], t), t
                    }(), p = {
                        getShapeProp: function (t, e, i) {
                            var n;
                            return 3 === i || 4 === i ? n = (3 === i ? e.pt : e.ks).k.length ? new h(t, e, i) : new a(t, e, i) : 5 === i ? n = new u(t, e) : 6 === i ? n = new l(t, e) : 7 === i && (n = new c(t, e)), n.k && t.addDynamicProperty(n), n
                        }, getConstructorFunction: function () {
                            return a
                        }, getKeyframedConstructorFunction: function () {
                            return h
                        }
                    };
                    return p
                }(), ShapeModifiers = (ob = {}, modifiers = {}, ob.registerModifier = function (t, e) {
                    modifiers[t] || (modifiers[t] = e)
                }, ob.getModifier = function (t, e, i) {
                    return new modifiers[t](e, i)
                }, ob), ob, modifiers;

                function ShapeModifier() {
                }

                function TrimModifier() {
                }

                function RoundCornersModifier() {
                }

                function PuckerAndBloatModifier() {
                }

                function RepeaterModifier() {
                }

                function ShapeCollection() {
                    this._length = 0, this._maxLength = 4, this.shapes = createSizedArray(this._maxLength)
                }

                function DashProperty(t, e, i, n) {
                    var r;
                    this.elem = t, this.frameId = -1, this.dataProps = createSizedArray(e.length), this.renderer = i, this.k = !1, this.dashStr = "", this.dashArray = createTypedArray("float32", e.length ? e.length - 1 : 0), this.dashoffset = createTypedArray("float32", 1), this.initDynamicPropertyContainer(n);
                    var s, a = e.length || 0;
                    for (r = 0; r < a; r += 1) s = PropertyFactory.getProp(t, e[r].v, 0, 0, this), this.k = s.k || this.k, this.dataProps[r] = {
                        n: e[r].n,
                        p: s
                    };
                    this.k || this.getValue(!0), this._isAnimated = this.k
                }

                function GradientProperty(t, e, i) {
                    this.data = e, this.c = createTypedArray("uint8c", 4 * e.p);
                    var n = e.k.k[0].s ? e.k.k[0].s.length - 4 * e.p : e.k.k.length - 4 * e.p;
                    this.o = createTypedArray("float32", n), this._cmdf = !1, this._omdf = !1, this._collapsable = this.checkCollapsable(), this._hasOpacity = n, this.initDynamicPropertyContainer(i), this.prop = PropertyFactory.getProp(t, e.k, 1, null, this), this.k = this.prop.k, this.getValue(!0)
                }

                ShapeModifier.prototype.initModifierProperties = function () {
                }, ShapeModifier.prototype.addShapeToModifier = function () {
                }, ShapeModifier.prototype.addShape = function (t) {
                    if (!this.closed) {
                        t.sh.container.addDynamicProperty(t.sh);
                        var e = {shape: t.sh, data: t, localShapeCollection: shapeCollectionPool.newShapeCollection()};
                        this.shapes.push(e), this.addShapeToModifier(e), this._isAnimated && t.setAsAnimated()
                    }
                }, ShapeModifier.prototype.init = function (t, e) {
                    this.shapes = [], this.elem = t, this.initDynamicPropertyContainer(t), this.initModifierProperties(t, e), this.frameId = initialDefaultFrame, this.closed = !1, this.k = !1, this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
                }, ShapeModifier.prototype.processKeys = function () {
                    this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties())
                }, extendPrototype([DynamicPropertyContainer], ShapeModifier), extendPrototype([ShapeModifier], TrimModifier), TrimModifier.prototype.initModifierProperties = function (t, e) {
                    this.s = PropertyFactory.getProp(t, e.s, 0, .01, this), this.e = PropertyFactory.getProp(t, e.e, 0, .01, this), this.o = PropertyFactory.getProp(t, e.o, 0, 0, this), this.sValue = 0, this.eValue = 0, this.getValue = this.processKeys, this.m = e.m, this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length
                }, TrimModifier.prototype.addShapeToModifier = function (t) {
                    t.pathsData = []
                }, TrimModifier.prototype.calculateShapeEdges = function (t, e, i, n, r) {
                    var s = [];
                    e <= 1 ? s.push({s: t, e}) : t >= 1 ? s.push({s: t - 1, e: e - 1}) : (s.push({
                        s: t,
                        e: 1
                    }), s.push({s: 0, e: e - 1}));
                    var a, o, h = [], l = s.length;
                    for (a = 0; a < l; a += 1) {
                        var c, u;
                        (o = s[a]).e * r < n || o.s * r > n + i || (c = o.s * r <= n ? 0 : (o.s * r - n) / i, u = o.e * r >= n + i ? 1 : (o.e * r - n) / i, h.push([c, u]))
                    }
                    return h.length || h.push([0, 0]), h
                }, TrimModifier.prototype.releasePathsData = function (t) {
                    var e, i = t.length;
                    for (e = 0; e < i; e += 1) segmentsLengthPool.release(t[e]);
                    return t.length = 0, t
                }, TrimModifier.prototype.processShapes = function (t) {
                    var e, i, n, r;
                    if (this._mdf || t) {
                        var s = this.o.v % 360 / 360;
                        if (s < 0 && (s += 1), (e = this.s.v > 1 ? 1 + s : this.s.v < 0 ? 0 + s : this.s.v + s) > (i = this.e.v > 1 ? 1 + s : this.e.v < 0 ? 0 + s : this.e.v + s)) {
                            var a = e;
                            e = i, i = a
                        }
                        e = 1e-4 * Math.round(1e4 * e), i = 1e-4 * Math.round(1e4 * i), this.sValue = e, this.eValue = i
                    } else e = this.sValue, i = this.eValue;
                    var o, h, l, c, u, p = this.shapes.length, d = 0;
                    if (i === e) for (r = 0; r < p; r += 1) this.shapes[r].localShapeCollection.releaseShapes(), this.shapes[r].shape._mdf = !0, this.shapes[r].shape.paths = this.shapes[r].localShapeCollection, this._mdf && (this.shapes[r].pathsData.length = 0); else if (1 === i && 0 === e || 0 === i && 1 === e) {
                        if (this._mdf) for (r = 0; r < p; r += 1) this.shapes[r].pathsData.length = 0, this.shapes[r].shape._mdf = !0
                    } else {
                        var f, m, g = [];
                        for (r = 0; r < p; r += 1) if ((f = this.shapes[r]).shape._mdf || this._mdf || t || 2 === this.m) {
                            if (h = (n = f.shape.paths)._length, u = 0, !f.shape._mdf && f.pathsData.length) u = f.totalShapeLength; else {
                                for (l = this.releasePathsData(f.pathsData), o = 0; o < h; o += 1) c = bez.getSegmentsLength(n.shapes[o]), l.push(c), u += c.totalLength;
                                f.totalShapeLength = u, f.pathsData = l
                            }
                            d += u, f.shape._mdf = !0
                        } else f.shape.paths = f.localShapeCollection;
                        var v, y = e, b = i, x = 0;
                        for (r = p - 1; r >= 0; r -= 1) if ((f = this.shapes[r]).shape._mdf) {
                            for ((m = f.localShapeCollection).releaseShapes(), 2 === this.m && p > 1 ? (v = this.calculateShapeEdges(e, i, f.totalShapeLength, x, d), x += f.totalShapeLength) : v = [[y, b]], h = v.length, o = 0; o < h; o += 1) {
                                y = v[o][0], b = v[o][1], g.length = 0, b <= 1 ? g.push({
                                    s: f.totalShapeLength * y,
                                    e: f.totalShapeLength * b
                                }) : y >= 1 ? g.push({
                                    s: f.totalShapeLength * (y - 1),
                                    e: f.totalShapeLength * (b - 1)
                                }) : (g.push({s: f.totalShapeLength * y, e: f.totalShapeLength}), g.push({
                                    s: 0,
                                    e: f.totalShapeLength * (b - 1)
                                }));
                                var w = this.addShapes(f, g[0]);
                                if (g[0].s !== g[0].e) {
                                    if (g.length > 1) if (f.shape.paths.shapes[f.shape.paths._length - 1].c) {
                                        var _ = w.pop();
                                        this.addPaths(w, m), w = this.addShapes(f, g[1], _)
                                    } else this.addPaths(w, m), w = this.addShapes(f, g[1]);
                                    this.addPaths(w, m)
                                }
                            }
                            f.shape.paths = m
                        }
                    }
                }, TrimModifier.prototype.addPaths = function (t, e) {
                    var i, n = t.length;
                    for (i = 0; i < n; i += 1) e.addShape(t[i])
                }, TrimModifier.prototype.addSegment = function (t, e, i, n, r, s, a) {
                    r.setXYAt(e[0], e[1], "o", s), r.setXYAt(i[0], i[1], "i", s + 1), a && r.setXYAt(t[0], t[1], "v", s), r.setXYAt(n[0], n[1], "v", s + 1)
                }, TrimModifier.prototype.addSegmentFromArray = function (t, e, i, n) {
                    e.setXYAt(t[1], t[5], "o", i), e.setXYAt(t[2], t[6], "i", i + 1), n && e.setXYAt(t[0], t[4], "v", i), e.setXYAt(t[3], t[7], "v", i + 1)
                }, TrimModifier.prototype.addShapes = function (t, e, i) {
                    var n, r, s, a, o, h, l, c, u = t.pathsData, p = t.shape.paths.shapes, d = t.shape.paths._length,
                        f = 0, m = [], g = !0;
                    for (i ? (o = i._length, c = i._length) : (i = shapePool.newElement(), o = 0, c = 0), m.push(i), n = 0; n < d; n += 1) {
                        for (h = u[n].lengths, i.c = p[n].c, s = p[n].c ? h.length : h.length + 1, r = 1; r < s; r += 1) if (f + (a = h[r - 1]).addedLength < e.s) f += a.addedLength, i.c = !1; else {
                            if (f > e.e) {
                                i.c = !1;
                                break
                            }
                            e.s <= f && e.e >= f + a.addedLength ? (this.addSegment(p[n].v[r - 1], p[n].o[r - 1], p[n].i[r], p[n].v[r], i, o, g), g = !1) : (l = bez.getNewSegment(p[n].v[r - 1], p[n].v[r], p[n].o[r - 1], p[n].i[r], (e.s - f) / a.addedLength, (e.e - f) / a.addedLength, h[r - 1]), this.addSegmentFromArray(l, i, o, g), g = !1, i.c = !1), f += a.addedLength, o += 1
                        }
                        if (p[n].c && h.length) {
                            if (a = h[r - 1], f <= e.e) {
                                var v = h[r - 1].addedLength;
                                e.s <= f && e.e >= f + v ? (this.addSegment(p[n].v[r - 1], p[n].o[r - 1], p[n].i[0], p[n].v[0], i, o, g), g = !1) : (l = bez.getNewSegment(p[n].v[r - 1], p[n].v[0], p[n].o[r - 1], p[n].i[0], (e.s - f) / v, (e.e - f) / v, h[r - 1]), this.addSegmentFromArray(l, i, o, g), g = !1, i.c = !1)
                            } else i.c = !1;
                            f += a.addedLength, o += 1
                        }
                        if (i._length && (i.setXYAt(i.v[c][0], i.v[c][1], "i", c), i.setXYAt(i.v[i._length - 1][0], i.v[i._length - 1][1], "o", i._length - 1)), f > e.e) break;
                        n < d - 1 && (i = shapePool.newElement(), g = !0, m.push(i), o = 0)
                    }
                    return m
                }, ShapeModifiers.registerModifier("tm", TrimModifier), extendPrototype([ShapeModifier], RoundCornersModifier), RoundCornersModifier.prototype.initModifierProperties = function (t, e) {
                    this.getValue = this.processKeys, this.rd = PropertyFactory.getProp(t, e.r, 0, null, this), this._isAnimated = !!this.rd.effectsSequence.length
                }, RoundCornersModifier.prototype.processPath = function (t, e) {
                    var i, n = shapePool.newElement();
                    n.c = t.c;
                    var r, s, a, o, h, l, c, u, p, d, f, m, g = t._length, v = 0;
                    for (i = 0; i < g; i += 1) r = t.v[i], a = t.o[i], s = t.i[i], r[0] === a[0] && r[1] === a[1] && r[0] === s[0] && r[1] === s[1] ? 0 !== i && i !== g - 1 || t.c ? (o = 0 === i ? t.v[g - 1] : t.v[i - 1], l = (h = Math.sqrt(Math.pow(r[0] - o[0], 2) + Math.pow(r[1] - o[1], 2))) ? Math.min(h / 2, e) / h : 0, c = f = r[0] + (o[0] - r[0]) * l, u = m = r[1] - (r[1] - o[1]) * l, p = c - (c - r[0]) * roundCorner, d = u - (u - r[1]) * roundCorner, n.setTripleAt(c, u, p, d, f, m, v), v += 1, o = i === g - 1 ? t.v[0] : t.v[i + 1], l = (h = Math.sqrt(Math.pow(r[0] - o[0], 2) + Math.pow(r[1] - o[1], 2))) ? Math.min(h / 2, e) / h : 0, c = p = r[0] + (o[0] - r[0]) * l, u = d = r[1] + (o[1] - r[1]) * l, f = c - (c - r[0]) * roundCorner, m = u - (u - r[1]) * roundCorner, n.setTripleAt(c, u, p, d, f, m, v), v += 1) : (n.setTripleAt(r[0], r[1], a[0], a[1], s[0], s[1], v), v += 1) : (n.setTripleAt(t.v[i][0], t.v[i][1], t.o[i][0], t.o[i][1], t.i[i][0], t.i[i][1], v), v += 1);
                    return n
                }, RoundCornersModifier.prototype.processShapes = function (t) {
                    var e, i, n, r, s, a, o = this.shapes.length, h = this.rd.v;
                    if (0 !== h) for (i = 0; i < o; i += 1) {
                        if (a = (s = this.shapes[i]).localShapeCollection, s.shape._mdf || this._mdf || t) for (a.releaseShapes(), s.shape._mdf = !0, e = s.shape.paths.shapes, r = s.shape.paths._length, n = 0; n < r; n += 1) a.addShape(this.processPath(e[n], h));
                        s.shape.paths = s.localShapeCollection
                    }
                    this.dynamicProperties.length || (this._mdf = !1)
                }, ShapeModifiers.registerModifier("rd", RoundCornersModifier), extendPrototype([ShapeModifier], PuckerAndBloatModifier), PuckerAndBloatModifier.prototype.initModifierProperties = function (t, e) {
                    this.getValue = this.processKeys, this.amount = PropertyFactory.getProp(t, e.a, 0, null, this), this._isAnimated = !!this.amount.effectsSequence.length
                }, PuckerAndBloatModifier.prototype.processPath = function (t, e) {
                    var i = e / 100, n = [0, 0], r = t._length, s = 0;
                    for (s = 0; s < r; s += 1) n[0] += t.v[s][0], n[1] += t.v[s][1];
                    n[0] /= r, n[1] /= r;
                    var a, o, h, l, c, u, p = shapePool.newElement();
                    for (p.c = t.c, s = 0; s < r; s += 1) a = t.v[s][0] + (n[0] - t.v[s][0]) * i, o = t.v[s][1] + (n[1] - t.v[s][1]) * i, h = t.o[s][0] + (n[0] - t.o[s][0]) * -i, l = t.o[s][1] + (n[1] - t.o[s][1]) * -i, c = t.i[s][0] + (n[0] - t.i[s][0]) * -i, u = t.i[s][1] + (n[1] - t.i[s][1]) * -i, p.setTripleAt(a, o, h, l, c, u, s);
                    return p
                }, PuckerAndBloatModifier.prototype.processShapes = function (t) {
                    var e, i, n, r, s, a, o = this.shapes.length, h = this.amount.v;
                    if (0 !== h) for (i = 0; i < o; i += 1) {
                        if (a = (s = this.shapes[i]).localShapeCollection, s.shape._mdf || this._mdf || t) for (a.releaseShapes(), s.shape._mdf = !0, e = s.shape.paths.shapes, r = s.shape.paths._length, n = 0; n < r; n += 1) a.addShape(this.processPath(e[n], h));
                        s.shape.paths = s.localShapeCollection
                    }
                    this.dynamicProperties.length || (this._mdf = !1)
                }, ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier), extendPrototype([ShapeModifier], RepeaterModifier), RepeaterModifier.prototype.initModifierProperties = function (t, e) {
                    this.getValue = this.processKeys, this.c = PropertyFactory.getProp(t, e.c, 0, null, this), this.o = PropertyFactory.getProp(t, e.o, 0, null, this), this.tr = TransformPropertyFactory.getTransformProperty(t, e.tr, this), this.so = PropertyFactory.getProp(t, e.tr.so, 0, .01, this), this.eo = PropertyFactory.getProp(t, e.tr.eo, 0, .01, this), this.data = e, this.dynamicProperties.length || this.getValue(!0), this._isAnimated = !!this.dynamicProperties.length, this.pMatrix = new Matrix, this.rMatrix = new Matrix, this.sMatrix = new Matrix, this.tMatrix = new Matrix, this.matrix = new Matrix
                }, RepeaterModifier.prototype.applyTransforms = function (t, e, i, n, r, s) {
                    var a = s ? -1 : 1, o = n.s.v[0] + (1 - n.s.v[0]) * (1 - r),
                        h = n.s.v[1] + (1 - n.s.v[1]) * (1 - r);
                    t.translate(n.p.v[0] * a * r, n.p.v[1] * a * r, n.p.v[2]), e.translate(-n.a.v[0], -n.a.v[1], n.a.v[2]), e.rotate(-n.r.v * a * r), e.translate(n.a.v[0], n.a.v[1], n.a.v[2]), i.translate(-n.a.v[0], -n.a.v[1], n.a.v[2]), i.scale(s ? 1 / o : o, s ? 1 / h : h), i.translate(n.a.v[0], n.a.v[1], n.a.v[2])
                }, RepeaterModifier.prototype.init = function (t, e, i, n) {
                    for (this.elem = t, this.arr = e, this.pos = i, this.elemsData = n, this._currentCopies = 0, this._elements = [], this._groups = [], this.frameId = -1, this.initDynamicPropertyContainer(t), this.initModifierProperties(t, e[i]); i > 0;) i -= 1, this._elements.unshift(e[i]);
                    this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
                }, RepeaterModifier.prototype.resetElements = function (t) {
                    var e, i = t.length;
                    for (e = 0; e < i; e += 1) t[e]._processed = !1, "gr" === t[e].ty && this.resetElements(t[e].it)
                }, RepeaterModifier.prototype.cloneElements = function (t) {
                    var e = JSON.parse(JSON.stringify(t));
                    return this.resetElements(e), e
                }, RepeaterModifier.prototype.changeGroupRender = function (t, e) {
                    var i, n = t.length;
                    for (i = 0; i < n; i += 1) t[i]._render = e, "gr" === t[i].ty && this.changeGroupRender(t[i].it, e)
                }, RepeaterModifier.prototype.processShapes = function (t) {
                    var e, i, n, r, s, a = !1;
                    if (this._mdf || t) {
                        var o, h = Math.ceil(this.c.v);
                        if (this._groups.length < h) {
                            for (; this._groups.length < h;) {
                                var l = {it: this.cloneElements(this._elements), ty: "gr"};
                                l.it.push({
                                    a: {a: 0, ix: 1, k: [0, 0]},
                                    nm: "Transform",
                                    o: {a: 0, ix: 7, k: 100},
                                    p: {a: 0, ix: 2, k: [0, 0]},
                                    r: {a: 1, ix: 6, k: [{s: 0, e: 0, t: 0}, {s: 0, e: 0, t: 1}]},
                                    s: {a: 0, ix: 3, k: [100, 100]},
                                    sa: {a: 0, ix: 5, k: 0},
                                    sk: {a: 0, ix: 4, k: 0},
                                    ty: "tr"
                                }), this.arr.splice(0, 0, l), this._groups.splice(0, 0, l), this._currentCopies += 1
                            }
                            this.elem.reloadShapes(), a = !0
                        }
                        for (s = 0, n = 0; n <= this._groups.length - 1; n += 1) {
                            if (o = s < h, this._groups[n]._render = o, this.changeGroupRender(this._groups[n].it, o), !o) {
                                var c = this.elemsData[n].it, u = c[c.length - 1];
                                0 !== u.transform.op.v ? (u.transform.op._mdf = !0, u.transform.op.v = 0) : u.transform.op._mdf = !1
                            }
                            s += 1
                        }
                        this._currentCopies = h;
                        var p = this.o.v, d = p % 1, f = p > 0 ? Math.floor(p) : Math.ceil(p), m = this.pMatrix.props,
                            g = this.rMatrix.props, v = this.sMatrix.props;
                        this.pMatrix.reset(), this.rMatrix.reset(), this.sMatrix.reset(), this.tMatrix.reset(), this.matrix.reset();
                        var y, b, x = 0;
                        if (p > 0) {
                            for (; x < f;) this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), x += 1;
                            d && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, d, !1), x += d)
                        } else if (p < 0) {
                            for (; x > f;) this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !0), x -= 1;
                            d && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -d, !0), x -= d)
                        }
                        for (n = 1 === this.data.m ? 0 : this._currentCopies - 1, r = 1 === this.data.m ? 1 : -1, s = this._currentCopies; s;) {
                            if (b = (i = (e = this.elemsData[n].it)[e.length - 1].transform.mProps.v.props).length, e[e.length - 1].transform.mProps._mdf = !0, e[e.length - 1].transform.op._mdf = !0, e[e.length - 1].transform.op.v = 1 === this._currentCopies ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (n / (this._currentCopies - 1)), 0 !== x) {
                                for ((0 !== n && 1 === r || n !== this._currentCopies - 1 && -1 === r) && this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), this.matrix.transform(g[0], g[1], g[2], g[3], g[4], g[5], g[6], g[7], g[8], g[9], g[10], g[11], g[12], g[13], g[14], g[15]), this.matrix.transform(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8], v[9], v[10], v[11], v[12], v[13], v[14], v[15]), this.matrix.transform(m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15]), y = 0; y < b; y += 1) i[y] = this.matrix.props[y];
                                this.matrix.reset()
                            } else for (this.matrix.reset(), y = 0; y < b; y += 1) i[y] = this.matrix.props[y];
                            x += 1, s -= 1, n += r
                        }
                    } else for (s = this._currentCopies, n = 0, r = 1; s;) i = (e = this.elemsData[n].it)[e.length - 1].transform.mProps.v.props, e[e.length - 1].transform.mProps._mdf = !1, e[e.length - 1].transform.op._mdf = !1, s -= 1, n += r;
                    return a
                }, RepeaterModifier.prototype.addShape = function () {
                }, ShapeModifiers.registerModifier("rp", RepeaterModifier), ShapeCollection.prototype.addShape = function (t) {
                    this._length === this._maxLength && (this.shapes = this.shapes.concat(createSizedArray(this._maxLength)), this._maxLength *= 2), this.shapes[this._length] = t, this._length += 1
                }, ShapeCollection.prototype.releaseShapes = function () {
                    var t;
                    for (t = 0; t < this._length; t += 1) shapePool.release(this.shapes[t]);
                    this._length = 0
                }, DashProperty.prototype.getValue = function (t) {
                    if ((this.elem.globalData.frameId !== this.frameId || t) && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf = this._mdf || t, this._mdf)) {
                        var e = 0, i = this.dataProps.length;
                        for ("svg" === this.renderer && (this.dashStr = ""), e = 0; e < i; e += 1) "o" !== this.dataProps[e].n ? "svg" === this.renderer ? this.dashStr += " " + this.dataProps[e].p.v : this.dashArray[e] = this.dataProps[e].p.v : this.dashoffset[0] = this.dataProps[e].p.v
                    }
                }, extendPrototype([DynamicPropertyContainer], DashProperty), GradientProperty.prototype.comparePoints = function (t, e) {
                    for (var i = 0, n = this.o.length / 2; i < n;) {
                        if (Math.abs(t[4 * i] - t[4 * e + 2 * i]) > .01) return !1;
                        i += 1
                    }
                    return !0
                }, GradientProperty.prototype.checkCollapsable = function () {
                    if (this.o.length / 2 != this.c.length / 4) return !1;
                    if (this.data.k.k[0].s) for (var t = 0, e = this.data.k.k.length; t < e;) {
                        if (!this.comparePoints(this.data.k.k[t].s, this.data.p)) return !1;
                        t += 1
                    } else if (!this.comparePoints(this.data.k.k, this.data.p)) return !1;
                    return !0
                }, GradientProperty.prototype.getValue = function (t) {
                    if (this.prop.getValue(), this._mdf = !1, this._cmdf = !1, this._omdf = !1, this.prop._mdf || t) {
                        var e, i, n, r = 4 * this.data.p;
                        for (e = 0; e < r; e += 1) i = e % 4 == 0 ? 100 : 255, n = Math.round(this.prop.v[e] * i), this.c[e] !== n && (this.c[e] = n, this._cmdf = !t);
                        if (this.o.length) for (r = this.prop.v.length, e = 4 * this.data.p; e < r; e += 1) i = e % 2 == 0 ? 100 : 1, n = e % 2 == 0 ? Math.round(100 * this.prop.v[e]) : this.prop.v[e], this.o[e - 4 * this.data.p] !== n && (this.o[e - 4 * this.data.p] = n, this._omdf = !t);
                        this._mdf = !t
                    }
                }, extendPrototype([DynamicPropertyContainer], GradientProperty);
                var buildShapeString = function (t, e, i, n) {
                    if (0 === e) return "";
                    var r, s = t.o, a = t.i, o = t.v, h = " M" + n.applyToPointStringified(o[0][0], o[0][1]);
                    for (r = 1; r < e; r += 1) h += " C" + n.applyToPointStringified(s[r - 1][0], s[r - 1][1]) + " " + n.applyToPointStringified(a[r][0], a[r][1]) + " " + n.applyToPointStringified(o[r][0], o[r][1]);
                    return i && e && (h += " C" + n.applyToPointStringified(s[r - 1][0], s[r - 1][1]) + " " + n.applyToPointStringified(a[0][0], a[0][1]) + " " + n.applyToPointStringified(o[0][0], o[0][1]), h += "z"), h
                }, audioControllerFactory = function () {
                    function t(t) {
                        this.audios = [], this.audioFactory = t, this._volume = 1, this._isMuted = !1
                    }

                    return t.prototype = {
                        addAudio: function (t) {
                            this.audios.push(t)
                        }, pause: function () {
                            var t, e = this.audios.length;
                            for (t = 0; t < e; t += 1) this.audios[t].pause()
                        }, resume: function () {
                            var t, e = this.audios.length;
                            for (t = 0; t < e; t += 1) this.audios[t].resume()
                        }, setRate: function (t) {
                            var e, i = this.audios.length;
                            for (e = 0; e < i; e += 1) this.audios[e].setRate(t)
                        }, createAudio: function (t) {
                            return this.audioFactory ? this.audioFactory(t) : Howl ? new Howl({src: [t]}) : {
                                isPlaying: !1,
                                play: function () {
                                    this.isPlaying = !0
                                },
                                seek: function () {
                                    this.isPlaying = !1
                                },
                                playing: function () {
                                },
                                rate: function () {
                                },
                                setVolume: function () {
                                }
                            }
                        }, setAudioFactory: function (t) {
                            this.audioFactory = t
                        }, setVolume: function (t) {
                            this._volume = t, this._updateVolume()
                        }, mute: function () {
                            this._isMuted = !0, this._updateVolume()
                        }, unmute: function () {
                            this._isMuted = !1, this._updateVolume()
                        }, getVolume: function () {
                            return this._volume
                        }, _updateVolume: function () {
                            var t, e = this.audios.length;
                            for (t = 0; t < e; t += 1) this.audios[t].volume(this._volume * (this._isMuted ? 0 : 1))
                        }
                    }, function () {
                        return new t
                    }
                }(), ImagePreloader = function () {
                    var t = function () {
                        var t = createTag("canvas");
                        t.width = 1, t.height = 1;
                        var e = t.getContext("2d");
                        return e.fillStyle = "rgba(0,0,0,0)", e.fillRect(0, 0, 1, 1), t
                    }();

                    function e() {
                        this.loadedAssets += 1, this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null)
                    }

                    function i() {
                        this.loadedFootagesCount += 1, this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null)
                    }

                    function n(t, e, i) {
                        var n = "";
                        if (t.e) n = t.p; else if (e) {
                            var r = t.p;
                            -1 !== r.indexOf("images/") && (r = r.split("/")[1]), n = e + r
                        } else n = i, n += t.u ? t.u : "", n += t.p;
                        return n
                    }

                    function r(t) {
                        var e = 0, i = setInterval(function () {
                            (t.getBBox().width || e > 500) && (this._imageLoaded(), clearInterval(i)), e += 1
                        }.bind(this), 50)
                    }

                    function s(t) {
                        var e = {assetData: t}, i = n(t, this.assetsPath, this.path);
                        return dataManager.loadData(i, function (t) {
                            e.img = t, this._footageLoaded()
                        }.bind(this), function () {
                            e.img = {}, this._footageLoaded()
                        }.bind(this)), e
                    }

                    function a() {
                        this._imageLoaded = e.bind(this), this._footageLoaded = i.bind(this), this.testImageLoaded = r.bind(this), this.createFootageData = s.bind(this), this.assetsPath = "", this.path = "", this.totalImages = 0, this.totalFootages = 0, this.loadedAssets = 0, this.loadedFootagesCount = 0, this.imagesLoadedCb = null, this.images = []
                    }

                    return a.prototype = {
                        loadAssets: function (t, e) {
                            var i;
                            this.imagesLoadedCb = e;
                            var n = t.length;
                            for (i = 0; i < n; i += 1) t[i].layers || (t[i].t && "seq" !== t[i].t ? 3 === t[i].t && (this.totalFootages += 1, this.images.push(this.createFootageData(t[i]))) : (this.totalImages += 1, this.images.push(this._createImageData(t[i]))))
                        }, setAssetsPath: function (t) {
                            this.assetsPath = t || ""
                        }, setPath: function (t) {
                            this.path = t || ""
                        }, loadedImages: function () {
                            return this.totalImages === this.loadedAssets
                        }, loadedFootages: function () {
                            return this.totalFootages === this.loadedFootagesCount
                        }, destroy: function () {
                            this.imagesLoadedCb = null, this.images.length = 0
                        }, getAsset: function (t) {
                            for (var e = 0, i = this.images.length; e < i;) {
                                if (this.images[e].assetData === t) return this.images[e].img;
                                e += 1
                            }
                            return null
                        }, createImgData: function (e) {
                            var i = n(e, this.assetsPath, this.path), r = createTag("img");
                            r.crossOrigin = "anonymous", r.addEventListener("load", this._imageLoaded, !1), r.addEventListener("error", function () {
                                s.img = t, this._imageLoaded()
                            }.bind(this), !1), r.src = i;
                            var s = {img: r, assetData: e};
                            return s
                        }, createImageData: function (e) {
                            var i = n(e, this.assetsPath, this.path), r = createNS("image");
                            isSafari ? this.testImageLoaded(r) : r.addEventListener("load", this._imageLoaded, !1), r.addEventListener("error", function () {
                                s.img = t, this._imageLoaded()
                            }.bind(this), !1), r.setAttributeNS("http://www.w3.org/1999/xlink", "href", i), this._elementHelper.append ? this._elementHelper.append(r) : this._elementHelper.appendChild(r);
                            var s = {img: r, assetData: e};
                            return s
                        }, imageLoaded: e, footageLoaded: i, setCacheType: function (t, e) {
                            "svg" === t ? (this._elementHelper = e, this._createImageData = this.createImageData.bind(this)) : this._createImageData = this.createImgData.bind(this)
                        }
                    }, a
                }(), featureSupport = function () {
                    var t = {maskType: !0};
                    return (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) && (t.maskType = !1), t
                }(), filtersFactory = function () {
                    var t = {
                        createFilter: function (t, e) {
                            var i = createNS("filter");
                            return i.setAttribute("id", t), !0 !== e && (i.setAttribute("filterUnits", "objectBoundingBox"), i.setAttribute("x", "0%"), i.setAttribute("y", "0%"), i.setAttribute("width", "100%"), i.setAttribute("height", "100%")), i
                        }, createAlphaToLuminanceFilter: function () {
                            var t = createNS("feColorMatrix");
                            return t.setAttribute("type", "matrix"), t.setAttribute("color-interpolation-filters", "sRGB"), t.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"), t
                        }
                    };
                    return t
                }();

                function TextAnimatorProperty(t, e, i) {
                    this._isFirstFrame = !0, this._hasMaskedPath = !1, this._frameId = -1, this._textData = t, this._renderType = e, this._elem = i, this._animatorsData = createSizedArray(this._textData.a.length), this._pathData = {}, this._moreOptions = {alignment: {}}, this.renderedLetters = [], this.lettersChangedFlag = !1, this.initDynamicPropertyContainer(i)
                }

                function TextAnimatorDataProperty(t, e, i) {
                    var n = {propType: !1}, r = PropertyFactory.getProp, s = e.a;
                    this.a = {
                        r: s.r ? r(t, s.r, 0, degToRads, i) : n,
                        rx: s.rx ? r(t, s.rx, 0, degToRads, i) : n,
                        ry: s.ry ? r(t, s.ry, 0, degToRads, i) : n,
                        sk: s.sk ? r(t, s.sk, 0, degToRads, i) : n,
                        sa: s.sa ? r(t, s.sa, 0, degToRads, i) : n,
                        s: s.s ? r(t, s.s, 1, .01, i) : n,
                        a: s.a ? r(t, s.a, 1, 0, i) : n,
                        o: s.o ? r(t, s.o, 0, .01, i) : n,
                        p: s.p ? r(t, s.p, 1, 0, i) : n,
                        sw: s.sw ? r(t, s.sw, 0, 0, i) : n,
                        sc: s.sc ? r(t, s.sc, 1, 0, i) : n,
                        fc: s.fc ? r(t, s.fc, 1, 0, i) : n,
                        fh: s.fh ? r(t, s.fh, 0, 0, i) : n,
                        fs: s.fs ? r(t, s.fs, 0, .01, i) : n,
                        fb: s.fb ? r(t, s.fb, 0, .01, i) : n,
                        t: s.t ? r(t, s.t, 0, 0, i) : n
                    }, this.s = TextSelectorProp.getTextSelectorProp(t, e.s, i), this.s.t = e.s.t
                }

                function LetterProps(t, e, i, n, r, s) {
                    this.o = t, this.sw = e, this.sc = i, this.fc = n, this.m = r, this.p = s, this._mdf = {
                        o: !0,
                        sw: !!e,
                        sc: !!i,
                        fc: !!n,
                        m: !0,
                        p: !0
                    }
                }

                function TextProperty(t, e) {
                    this._frameId = initialDefaultFrame, this.pv = "", this.v = "", this.kf = !1, this._isFirstFrame = !0, this._mdf = !1, this.data = e, this.elem = t, this.comp = this.elem.comp, this.keysIndex = 0, this.canResize = !1, this.minimumFontSize = 1, this.effectsSequence = [], this.currentData = {
                        ascent: 0,
                        boxWidth: this.defaultBoxWidth,
                        f: "",
                        fStyle: "",
                        fWeight: "",
                        fc: "",
                        j: "",
                        justifyOffset: "",
                        l: [],
                        lh: 0,
                        lineWidths: [],
                        ls: "",
                        of: "",
                        s: "",
                        sc: "",
                        sw: 0,
                        t: 0,
                        tr: 0,
                        sz: 0,
                        ps: null,
                        fillColorAnim: !1,
                        strokeColorAnim: !1,
                        strokeWidthAnim: !1,
                        yOffset: 0,
                        finalSize: 0,
                        finalText: [],
                        finalLineHeight: 0,
                        __complete: !1
                    }, this.copyData(this.currentData, this.data.d.k[0].s), this.searchProperty() || this.completeTextData(this.currentData)
                }

                TextAnimatorProperty.prototype.searchProperties = function () {
                    var t, e, i = this._textData.a.length, n = PropertyFactory.getProp;
                    for (t = 0; t < i; t += 1) e = this._textData.a[t], this._animatorsData[t] = new TextAnimatorDataProperty(this._elem, e, this);
                    this._textData.p && "m" in this._textData.p ? (this._pathData = {
                        a: n(this._elem, this._textData.p.a, 0, 0, this),
                        f: n(this._elem, this._textData.p.f, 0, 0, this),
                        l: n(this._elem, this._textData.p.l, 0, 0, this),
                        r: n(this._elem, this._textData.p.r, 0, 0, this),
                        p: n(this._elem, this._textData.p.p, 0, 0, this),
                        m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
                    }, this._hasMaskedPath = !0) : this._hasMaskedPath = !1, this._moreOptions.alignment = n(this._elem, this._textData.m.a, 1, 0, this)
                }, TextAnimatorProperty.prototype.getMeasures = function (t, e) {
                    if (this.lettersChangedFlag = e, this._mdf || this._isFirstFrame || e || this._hasMaskedPath && this._pathData.m._mdf) {
                        this._isFirstFrame = !1;
                        var i, n, r, s, a, o, h, l, c, u, p, d, f, m, g, v, y, b, x, w = this._moreOptions.alignment.v,
                            _ = this._animatorsData, E = this._textData, M = this.mHelper, A = this._renderType,
                            S = this.renderedLetters.length, T = t.l;
                        if (this._hasMaskedPath) {
                            if (x = this._pathData.m, !this._pathData.n || this._pathData._mdf) {
                                var D, C = x.v;
                                for (this._pathData.r.v && (C = C.reverse()), a = {
                                    tLength: 0,
                                    segments: []
                                }, s = C._length - 1, v = 0, r = 0; r < s; r += 1) D = bez.buildBezierData(C.v[r], C.v[r + 1], [C.o[r][0] - C.v[r][0], C.o[r][1] - C.v[r][1]], [C.i[r + 1][0] - C.v[r + 1][0], C.i[r + 1][1] - C.v[r + 1][1]]), a.tLength += D.segmentLength, a.segments.push(D), v += D.segmentLength;
                                r = s, x.v.c && (D = bez.buildBezierData(C.v[r], C.v[0], [C.o[r][0] - C.v[r][0], C.o[r][1] - C.v[r][1]], [C.i[0][0] - C.v[0][0], C.i[0][1] - C.v[0][1]]), a.tLength += D.segmentLength, a.segments.push(D), v += D.segmentLength), this._pathData.pi = a
                            }
                            if (a = this._pathData.pi, o = this._pathData.f.v, p = 0, u = 1, l = 0, c = !0, m = a.segments, o < 0 && x.v.c) for (a.tLength < Math.abs(o) && (o = -Math.abs(o) % a.tLength), u = (f = m[p = m.length - 1].points).length - 1; o < 0;) o += f[u].partialLength, (u -= 1) < 0 && (u = (f = m[p -= 1].points).length - 1);
                            d = (f = m[p].points)[u - 1], g = (h = f[u]).partialLength
                        }
                        s = T.length, i = 0, n = 0;
                        var P, I, L, R, F, k = 1.2 * t.finalSize * .714, O = !0;
                        L = _.length;
                        var z, B, N, j, V, G, U, H, W, q, X, Y, Z = -1, J = o, Q = p, K = u, $ = -1, tt = "",
                            et = this.defaultPropsArray;
                        if (2 === t.j || 1 === t.j) {
                            var it = 0, nt = 0, rt = 2 === t.j ? -.5 : -1, st = 0, at = !0;
                            for (r = 0; r < s; r += 1) if (T[r].n) {
                                for (it && (it += nt); st < r;) T[st].animatorJustifyOffset = it, st += 1;
                                it = 0, at = !0
                            } else {
                                for (I = 0; I < L; I += 1) (P = _[I].a).t.propType && (at && 2 === t.j && (nt += P.t.v * rt), (F = _[I].s.getMult(T[r].anIndexes[I], E.a[I].s.totalChars)).length ? it += P.t.v * F[0] * rt : it += P.t.v * F * rt);
                                at = !1
                            }
                            for (it && (it += nt); st < r;) T[st].animatorJustifyOffset = it, st += 1
                        }
                        for (r = 0; r < s; r += 1) {
                            if (M.reset(), j = 1, T[r].n) i = 0, n += t.yOffset, n += O ? 1 : 0, o = J, O = !1, this._hasMaskedPath && (u = K, d = (f = m[p = Q].points)[u - 1], g = (h = f[u]).partialLength, l = 0), tt = "", X = "", W = "", Y = "", et = this.defaultPropsArray; else {
                                if (this._hasMaskedPath) {
                                    if ($ !== T[r].line) {
                                        switch (t.j) {
                                            case 1:
                                                o += v - t.lineWidths[T[r].line];
                                                break;
                                            case 2:
                                                o += (v - t.lineWidths[T[r].line]) / 2
                                        }
                                        $ = T[r].line
                                    }
                                    Z !== T[r].ind && (T[Z] && (o += T[Z].extra), o += T[r].an / 2, Z = T[r].ind), o += w[0] * T[r].an * .005;
                                    var ot = 0;
                                    for (I = 0; I < L; I += 1) (P = _[I].a).p.propType && ((F = _[I].s.getMult(T[r].anIndexes[I], E.a[I].s.totalChars)).length ? ot += P.p.v[0] * F[0] : ot += P.p.v[0] * F), P.a.propType && ((F = _[I].s.getMult(T[r].anIndexes[I], E.a[I].s.totalChars)).length ? ot += P.a.v[0] * F[0] : ot += P.a.v[0] * F);
                                    for (c = !0, this._pathData.a.v && (o = .5 * T[0].an + (v - this._pathData.f.v - .5 * T[0].an - .5 * T[T.length - 1].an) * Z / (s - 1), o += this._pathData.f.v); c;) l + g >= o + ot || !f ? (y = (o + ot - l) / h.partialLength, B = d.point[0] + (h.point[0] - d.point[0]) * y, N = d.point[1] + (h.point[1] - d.point[1]) * y, M.translate(-w[0] * T[r].an * .005, -w[1] * k * .01), c = !1) : f && (l += h.partialLength, (u += 1) >= f.length && (u = 0, m[p += 1] ? f = m[p].points : x.v.c ? (u = 0, f = m[p = 0].points) : (l -= h.partialLength, f = null)), f && (d = h, g = (h = f[u]).partialLength));
                                    z = T[r].an / 2 - T[r].add, M.translate(-z, 0, 0)
                                } else z = T[r].an / 2 - T[r].add, M.translate(-z, 0, 0), M.translate(-w[0] * T[r].an * .005, -w[1] * k * .01, 0);
                                for (I = 0; I < L; I += 1) (P = _[I].a).t.propType && (F = _[I].s.getMult(T[r].anIndexes[I], E.a[I].s.totalChars), 0 === i && 0 === t.j || (this._hasMaskedPath ? F.length ? o += P.t.v * F[0] : o += P.t.v * F : F.length ? i += P.t.v * F[0] : i += P.t.v * F));
                                for (t.strokeWidthAnim && (G = t.sw || 0), t.strokeColorAnim && (V = t.sc ? [t.sc[0], t.sc[1], t.sc[2]] : [0, 0, 0]), t.fillColorAnim && t.fc && (U = [t.fc[0], t.fc[1], t.fc[2]]), I = 0; I < L; I += 1) (P = _[I].a).a.propType && ((F = _[I].s.getMult(T[r].anIndexes[I], E.a[I].s.totalChars)).length ? M.translate(-P.a.v[0] * F[0], -P.a.v[1] * F[1], P.a.v[2] * F[2]) : M.translate(-P.a.v[0] * F, -P.a.v[1] * F, P.a.v[2] * F));
                                for (I = 0; I < L; I += 1) (P = _[I].a).s.propType && ((F = _[I].s.getMult(T[r].anIndexes[I], E.a[I].s.totalChars)).length ? M.scale(1 + (P.s.v[0] - 1) * F[0], 1 + (P.s.v[1] - 1) * F[1], 1) : M.scale(1 + (P.s.v[0] - 1) * F, 1 + (P.s.v[1] - 1) * F, 1));
                                for (I = 0; I < L; I += 1) {
                                    if (P = _[I].a, F = _[I].s.getMult(T[r].anIndexes[I], E.a[I].s.totalChars), P.sk.propType && (F.length ? M.skewFromAxis(-P.sk.v * F[0], P.sa.v * F[1]) : M.skewFromAxis(-P.sk.v * F, P.sa.v * F)), P.r.propType && (F.length ? M.rotateZ(-P.r.v * F[2]) : M.rotateZ(-P.r.v * F)), P.ry.propType && (F.length ? M.rotateY(P.ry.v * F[1]) : M.rotateY(P.ry.v * F)), P.rx.propType && (F.length ? M.rotateX(P.rx.v * F[0]) : M.rotateX(P.rx.v * F)), P.o.propType && (F.length ? j += (P.o.v * F[0] - j) * F[0] : j += (P.o.v * F - j) * F), t.strokeWidthAnim && P.sw.propType && (F.length ? G += P.sw.v * F[0] : G += P.sw.v * F), t.strokeColorAnim && P.sc.propType) for (H = 0; H < 3; H += 1) F.length ? V[H] += (P.sc.v[H] - V[H]) * F[0] : V[H] += (P.sc.v[H] - V[H]) * F;
                                    if (t.fillColorAnim && t.fc) {
                                        if (P.fc.propType) for (H = 0; H < 3; H += 1) F.length ? U[H] += (P.fc.v[H] - U[H]) * F[0] : U[H] += (P.fc.v[H] - U[H]) * F;
                                        P.fh.propType && (U = F.length ? addHueToRGB(U, P.fh.v * F[0]) : addHueToRGB(U, P.fh.v * F)), P.fs.propType && (U = F.length ? addSaturationToRGB(U, P.fs.v * F[0]) : addSaturationToRGB(U, P.fs.v * F)), P.fb.propType && (U = F.length ? addBrightnessToRGB(U, P.fb.v * F[0]) : addBrightnessToRGB(U, P.fb.v * F))
                                    }
                                }
                                for (I = 0; I < L; I += 1) (P = _[I].a).p.propType && (F = _[I].s.getMult(T[r].anIndexes[I], E.a[I].s.totalChars), this._hasMaskedPath ? F.length ? M.translate(0, P.p.v[1] * F[0], -P.p.v[2] * F[1]) : M.translate(0, P.p.v[1] * F, -P.p.v[2] * F) : F.length ? M.translate(P.p.v[0] * F[0], P.p.v[1] * F[1], -P.p.v[2] * F[2]) : M.translate(P.p.v[0] * F, P.p.v[1] * F, -P.p.v[2] * F));
                                if (t.strokeWidthAnim && (W = G < 0 ? 0 : G), t.strokeColorAnim && (q = "rgb(" + Math.round(255 * V[0]) + "," + Math.round(255 * V[1]) + "," + Math.round(255 * V[2]) + ")"), t.fillColorAnim && t.fc && (X = "rgb(" + Math.round(255 * U[0]) + "," + Math.round(255 * U[1]) + "," + Math.round(255 * U[2]) + ")"), this._hasMaskedPath) {
                                    if (M.translate(0, -t.ls), M.translate(0, w[1] * k * .01 + n, 0), this._pathData.p.v) {
                                        b = (h.point[1] - d.point[1]) / (h.point[0] - d.point[0]);
                                        var ht = 180 * Math.atan(b) / Math.PI;
                                        h.point[0] < d.point[0] && (ht += 180), M.rotate(-ht * Math.PI / 180)
                                    }
                                    M.translate(B, N, 0), o -= w[0] * T[r].an * .005, T[r + 1] && Z !== T[r + 1].ind && (o += T[r].an / 2, o += .001 * t.tr * t.finalSize)
                                } else {
                                    switch (M.translate(i, n, 0), t.ps && M.translate(t.ps[0], t.ps[1] + t.ascent, 0), t.j) {
                                        case 1:
                                            M.translate(T[r].animatorJustifyOffset + t.justifyOffset + (t.boxWidth - t.lineWidths[T[r].line]), 0, 0);
                                            break;
                                        case 2:
                                            M.translate(T[r].animatorJustifyOffset + t.justifyOffset + (t.boxWidth - t.lineWidths[T[r].line]) / 2, 0, 0)
                                    }
                                    M.translate(0, -t.ls), M.translate(z, 0, 0), M.translate(w[0] * T[r].an * .005, w[1] * k * .01, 0), i += T[r].l + .001 * t.tr * t.finalSize
                                }
                                "html" === A ? tt = M.toCSS() : "svg" === A ? tt = M.to2dCSS() : et = [M.props[0], M.props[1], M.props[2], M.props[3], M.props[4], M.props[5], M.props[6], M.props[7], M.props[8], M.props[9], M.props[10], M.props[11], M.props[12], M.props[13], M.props[14], M.props[15]], Y = j
                            }
                            S <= r ? (R = new LetterProps(Y, W, q, X, tt, et), this.renderedLetters.push(R), S += 1, this.lettersChangedFlag = !0) : (R = this.renderedLetters[r], this.lettersChangedFlag = R.update(Y, W, q, X, tt, et) || this.lettersChangedFlag)
                        }
                    }
                }, TextAnimatorProperty.prototype.getValue = function () {
                    this._elem.globalData.frameId !== this._frameId && (this._frameId = this._elem.globalData.frameId, this.iterateDynamicProperties())
                }, TextAnimatorProperty.prototype.mHelper = new Matrix, TextAnimatorProperty.prototype.defaultPropsArray = [], extendPrototype([DynamicPropertyContainer], TextAnimatorProperty), LetterProps.prototype.update = function (t, e, i, n, r, s) {
                    this._mdf.o = !1, this._mdf.sw = !1, this._mdf.sc = !1, this._mdf.fc = !1, this._mdf.m = !1, this._mdf.p = !1;
                    var a = !1;
                    return this.o !== t && (this.o = t, this._mdf.o = !0, a = !0), this.sw !== e && (this.sw = e, this._mdf.sw = !0, a = !0), this.sc !== i && (this.sc = i, this._mdf.sc = !0, a = !0), this.fc !== n && (this.fc = n, this._mdf.fc = !0, a = !0), this.m !== r && (this.m = r, this._mdf.m = !0, a = !0), !s.length || this.p[0] === s[0] && this.p[1] === s[1] && this.p[4] === s[4] && this.p[5] === s[5] && this.p[12] === s[12] && this.p[13] === s[13] || (this.p = s, this._mdf.p = !0, a = !0), a
                }, TextProperty.prototype.defaultBoxWidth = [0, 0], TextProperty.prototype.copyData = function (t, e) {
                    for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
                    return t
                }, TextProperty.prototype.setCurrentData = function (t) {
                    t.__complete || this.completeTextData(t), this.currentData = t, this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth, this._mdf = !0
                }, TextProperty.prototype.searchProperty = function () {
                    return this.searchKeyframes()
                }, TextProperty.prototype.searchKeyframes = function () {
                    return this.kf = this.data.d.k.length > 1, this.kf && this.addEffect(this.getKeyframeValue.bind(this)), this.kf
                }, TextProperty.prototype.addEffect = function (t) {
                    this.effectsSequence.push(t), this.elem.addDynamicProperty(this)
                }, TextProperty.prototype.getValue = function (t) {
                    if (this.elem.globalData.frameId !== this.frameId && this.effectsSequence.length || t) {
                        this.currentData.t = this.data.d.k[this.keysIndex].s.t;
                        var e = this.currentData, i = this.keysIndex;
                        if (this.lock) this.setCurrentData(this.currentData); else {
                            var n;
                            this.lock = !0, this._mdf = !1;
                            var r = this.effectsSequence.length, s = t || this.data.d.k[this.keysIndex].s;
                            for (n = 0; n < r; n += 1) s = i !== this.keysIndex ? this.effectsSequence[n](s, s.t) : this.effectsSequence[n](this.currentData, s.t);
                            e !== s && this.setCurrentData(s), this.v = this.currentData, this.pv = this.v, this.lock = !1, this.frameId = this.elem.globalData.frameId
                        }
                    }
                }, TextProperty.prototype.getKeyframeValue = function () {
                    for (var t = this.data.d.k, e = this.elem.comp.renderedFrame, i = 0, n = t.length; i <= n - 1 && !(i === n - 1 || t[i + 1].t > e);) i += 1;
                    return this.keysIndex !== i && (this.keysIndex = i), this.data.d.k[this.keysIndex].s
                }, TextProperty.prototype.buildFinalText = function (t) {
                    for (var e, i, n = [], r = 0, s = t.length, a = !1; r < s;) e = t.charCodeAt(r), FontManager.isCombinedCharacter(e) ? n[n.length - 1] += t.charAt(r) : e >= 55296 && e <= 56319 ? (i = t.charCodeAt(r + 1)) >= 56320 && i <= 57343 ? (a || FontManager.isModifier(e, i) ? (n[n.length - 1] += t.substr(r, 2), a = !1) : n.push(t.substr(r, 2)), r += 1) : n.push(t.charAt(r)) : e > 56319 ? (i = t.charCodeAt(r + 1), FontManager.isZeroWidthJoiner(e, i) ? (a = !0, n[n.length - 1] += t.substr(r, 2), r += 1) : n.push(t.charAt(r))) : FontManager.isZeroWidthJoiner(e) ? (n[n.length - 1] += t.charAt(r), a = !0) : n.push(t.charAt(r)), r += 1;
                    return n
                }, TextProperty.prototype.completeTextData = function (t) {
                    t.__complete = !0;
                    var e, i, n, r, s, a, o, h = this.elem.globalData.fontManager, l = this.data, c = [], u = 0,
                        p = l.m.g, d = 0, f = 0, m = 0, g = [], v = 0, y = 0, b = h.getFontByName(t.f), x = 0,
                        w = getFontProperties(b);
                    t.fWeight = w.weight, t.fStyle = w.style, t.finalSize = t.s, t.finalText = this.buildFinalText(t.t), i = t.finalText.length, t.finalLineHeight = t.lh;
                    var _, E = t.tr / 1e3 * t.finalSize;
                    if (t.sz) for (var M, A, S = !0, T = t.sz[0], D = t.sz[1]; S;) {
                        M = 0, v = 0, i = (A = this.buildFinalText(t.t)).length, E = t.tr / 1e3 * t.finalSize;
                        var C = -1;
                        for (e = 0; e < i; e += 1) _ = A[e].charCodeAt(0), n = !1, " " === A[e] ? C = e : 13 !== _ && 3 !== _ || (v = 0, n = !0, M += t.finalLineHeight || 1.2 * t.finalSize), h.chars ? (o = h.getCharData(A[e], b.fStyle, b.fFamily), x = n ? 0 : o.w * t.finalSize / 100) : x = h.measureText(A[e], t.f, t.finalSize), v + x > T && " " !== A[e] ? (-1 === C ? i += 1 : e = C, M += t.finalLineHeight || 1.2 * t.finalSize, A.splice(e, C === e ? 1 : 0, "\r"), C = -1, v = 0) : (v += x, v += E);
                        M += b.ascent * t.finalSize / 100, this.canResize && t.finalSize > this.minimumFontSize && D < M ? (t.finalSize -= 1, t.finalLineHeight = t.finalSize * t.lh / t.s) : (t.finalText = A, i = t.finalText.length, S = !1)
                    }
                    v = -E, x = 0;
                    var P, I = 0;
                    for (e = 0; e < i; e += 1) if (n = !1, 13 === (_ = (P = t.finalText[e]).charCodeAt(0)) || 3 === _ ? (I = 0, g.push(v), y = v > y ? v : y, v = -2 * E, r = "", n = !0, m += 1) : r = P, h.chars ? (o = h.getCharData(P, b.fStyle, h.getFontByName(t.f).fFamily), x = n ? 0 : o.w * t.finalSize / 100) : x = h.measureText(r, t.f, t.finalSize), " " === P ? I += x + E : (v += x + E + I, I = 0), c.push({
                        l: x,
                        an: x,
                        add: d,
                        n,
                        anIndexes: [],
                        val: r,
                        line: m,
                        animatorJustifyOffset: 0
                    }), 2 == p) {
                        if (d += x, "" === r || " " === r || e === i - 1) {
                            for ("" !== r && " " !== r || (d -= x); f <= e;) c[f].an = d, c[f].ind = u, c[f].extra = x, f += 1;
                            u += 1, d = 0
                        }
                    } else if (3 == p) {
                        if (d += x, "" === r || e === i - 1) {
                            for ("" === r && (d -= x); f <= e;) c[f].an = d, c[f].ind = u, c[f].extra = x, f += 1;
                            d = 0, u += 1
                        }
                    } else c[u].ind = u, c[u].extra = 0, u += 1;
                    if (t.l = c, y = v > y ? v : y, g.push(v), t.sz) t.boxWidth = t.sz[0], t.justifyOffset = 0; else switch (t.boxWidth = y, t.j) {
                        case 1:
                            t.justifyOffset = -t.boxWidth;
                            break;
                        case 2:
                            t.justifyOffset = -t.boxWidth / 2;
                            break;
                        default:
                            t.justifyOffset = 0
                    }
                    t.lineWidths = g;
                    var L, R, F, k, O = l.a;
                    a = O.length;
                    var z = [];
                    for (s = 0; s < a; s += 1) {
                        for ((L = O[s]).a.sc && (t.strokeColorAnim = !0), L.a.sw && (t.strokeWidthAnim = !0), (L.a.fc || L.a.fh || L.a.fs || L.a.fb) && (t.fillColorAnim = !0), k = 0, F = L.s.b, e = 0; e < i; e += 1) (R = c[e]).anIndexes[s] = k, (1 == F && "" !== R.val || 2 == F && "" !== R.val && " " !== R.val || 3 == F && (R.n || " " == R.val || e == i - 1) || 4 == F && (R.n || e == i - 1)) && (1 === L.s.rn && z.push(k), k += 1);
                        l.a[s].s.totalChars = k;
                        var B, N = -1;
                        if (1 === L.s.rn) for (e = 0; e < i; e += 1) N != (R = c[e]).anIndexes[s] && (N = R.anIndexes[s], B = z.splice(Math.floor(Math.random() * z.length), 1)[0]), R.anIndexes[s] = B
                    }
                    t.yOffset = t.finalLineHeight || 1.2 * t.finalSize, t.ls = t.ls || 0, t.ascent = b.ascent * t.finalSize / 100
                }, TextProperty.prototype.updateDocumentData = function (t, e) {
                    e = void 0 === e ? this.keysIndex : e;
                    var i = this.copyData({}, this.data.d.k[e].s);
                    i = this.copyData(i, t), this.data.d.k[e].s = i, this.recalculate(e), this.elem.addDynamicProperty(this)
                }, TextProperty.prototype.recalculate = function (t) {
                    var e = this.data.d.k[t].s;
                    e.__complete = !1, this.keysIndex = 0, this._isFirstFrame = !0, this.getValue(e)
                }, TextProperty.prototype.canResizeFont = function (t) {
                    this.canResize = t, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this)
                }, TextProperty.prototype.setMinimumFontSize = function (t) {
                    this.minimumFontSize = Math.floor(t) || 1, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this)
                };
                var TextSelectorProp = function () {
                    var t = Math.max, e = Math.min, i = Math.floor;

                    function n(t, e) {
                        this._currentTextLength = -1, this.k = !1, this.data = e, this.elem = t, this.comp = t.comp, this.finalS = 0, this.finalE = 0, this.initDynamicPropertyContainer(t), this.s = PropertyFactory.getProp(t, e.s || {k: 0}, 0, 0, this), this.e = "e" in e ? PropertyFactory.getProp(t, e.e, 0, 0, this) : {v: 100}, this.o = PropertyFactory.getProp(t, e.o || {k: 0}, 0, 0, this), this.xe = PropertyFactory.getProp(t, e.xe || {k: 0}, 0, 0, this), this.ne = PropertyFactory.getProp(t, e.ne || {k: 0}, 0, 0, this), this.sm = PropertyFactory.getProp(t, e.sm || {k: 100}, 0, 0, this), this.a = PropertyFactory.getProp(t, e.a, 0, .01, this), this.dynamicProperties.length || this.getValue()
                    }

                    return n.prototype = {
                        getMult: function (n) {
                            this._currentTextLength !== this.elem.textProperty.currentData.l.length && this.getValue();
                            var r = 0, s = 0, a = 1, o = 1;
                            this.ne.v > 0 ? r = this.ne.v / 100 : s = -this.ne.v / 100, this.xe.v > 0 ? a = 1 - this.xe.v / 100 : o = 1 + this.xe.v / 100;
                            var h = BezierFactory.getBezierEasing(r, s, a, o).get, l = 0, c = this.finalS,
                                u = this.finalE, p = this.data.sh;
                            if (2 === p) l = h(l = u === c ? n >= u ? 1 : 0 : t(0, e(.5 / (u - c) + (n - c) / (u - c), 1))); else if (3 === p) l = h(l = u === c ? n >= u ? 0 : 1 : 1 - t(0, e(.5 / (u - c) + (n - c) / (u - c), 1))); else if (4 === p) u === c ? l = 0 : (l = t(0, e(.5 / (u - c) + (n - c) / (u - c), 1))) < .5 ? l *= 2 : l = 1 - 2 * (l - .5), l = h(l); else if (5 === p) {
                                if (u === c) l = 0; else {
                                    var d = u - c, f = -d / 2 + (n = e(t(0, n + .5 - c), u - c)), m = d / 2;
                                    l = Math.sqrt(1 - f * f / (m * m))
                                }
                                l = h(l)
                            } else 6 === p ? (u === c ? l = 0 : (n = e(t(0, n + .5 - c), u - c), l = (1 + Math.cos(Math.PI + 2 * Math.PI * n / (u - c))) / 2), l = h(l)) : (n >= i(c) && (l = t(0, e(n - c < 0 ? e(u, 1) - (c - n) : u - n, 1))), l = h(l));
                            if (100 !== this.sm.v) {
                                var g = .01 * this.sm.v;
                                0 === g && (g = 1e-8);
                                var v = .5 - .5 * g;
                                l < v ? l = 0 : (l = (l - v) / g) > 1 && (l = 1)
                            }
                            return l * this.a.v
                        }, getValue: function (t) {
                            this.iterateDynamicProperties(), this._mdf = t || this._mdf, this._currentTextLength = this.elem.textProperty.currentData.l.length || 0, t && 2 === this.data.r && (this.e.v = this._currentTextLength);
                            var e = 2 === this.data.r ? 1 : 100 / this.data.totalChars, i = this.o.v / e,
                                n = this.s.v / e + i, r = this.e.v / e + i;
                            if (n > r) {
                                var s = n;
                                n = r, r = s
                            }
                            this.finalS = n, this.finalE = r
                        }
                    }, extendPrototype([DynamicPropertyContainer], n), {
                        getTextSelectorProp: function (t, e, i) {
                            return new n(t, e, i)
                        }
                    }
                }(), poolFactory = function (t, e, i) {
                    var n = 0, r = t, s = createSizedArray(r);
                    return {
                        newElement: function () {
                            return n ? s[n -= 1] : e()
                        }, release: function (t) {
                            n === r && (s = pooling.double(s), r *= 2), i && i(t), s[n] = t, n += 1
                        }
                    }
                }, pooling = {
                    double: function (t) {
                        return t.concat(createSizedArray(t.length))
                    }
                }, pointPool = poolFactory(8, (function () {
                    return createTypedArray("float32", 2)
                })), shapePool = (factory = poolFactory(4, (function () {
                    return new ShapePath
                }), (function (t) {
                    var e, i = t._length;
                    for (e = 0; e < i; e += 1) pointPool.release(t.v[e]), pointPool.release(t.i[e]), pointPool.release(t.o[e]), t.v[e] = null, t.i[e] = null, t.o[e] = null;
                    t._length = 0, t.c = !1
                })), factory.clone = function (t) {
                    var e, i = factory.newElement(), n = void 0 === t._length ? t.v.length : t._length;
                    for (i.setLength(n), i.c = t.c, e = 0; e < n; e += 1) i.setTripleAt(t.v[e][0], t.v[e][1], t.o[e][0], t.o[e][1], t.i[e][0], t.i[e][1], e);
                    return i
                }, factory), factory, shapeCollectionPool = function () {
                    var t = {
                        newShapeCollection: function () {
                            return e ? n[e -= 1] : new ShapeCollection
                        }, release: function (t) {
                            var r, s = t._length;
                            for (r = 0; r < s; r += 1) shapePool.release(t.shapes[r]);
                            t._length = 0, e === i && (n = pooling.double(n), i *= 2), n[e] = t, e += 1
                        }
                    }, e = 0, i = 4, n = createSizedArray(i);
                    return t
                }(), segmentsLengthPool = poolFactory(8, (function () {
                    return {lengths: [], totalLength: 0}
                }), (function (t) {
                    var e, i = t.lengths.length;
                    for (e = 0; e < i; e += 1) bezierLengthPool.release(t.lengths[e]);
                    t.lengths.length = 0
                })), bezierLengthPool = poolFactory(8, (function () {
                    return {
                        addedLength: 0,
                        percents: createTypedArray("float32", defaultCurveSegments),
                        lengths: createTypedArray("float32", defaultCurveSegments)
                    }
                })), markerParser = function () {
                    function t(t) {
                        for (var e, i = t.split("\r\n"), n = {}, r = 0, s = 0; s < i.length; s += 1) 2 === (e = i[s].split(":")).length && (n[e[0]] = e[1].trim(), r += 1);
                        if (0 === r) throw new Error;
                        return n
                    }

                    return function (e) {
                        for (var i = [], n = 0; n < e.length; n += 1) {
                            var r = e[n], s = {time: r.tm, duration: r.dr};
                            try {
                                s.payload = JSON.parse(e[n].cm)
                            } catch (i) {
                                try {
                                    s.payload = t(e[n].cm)
                                } catch (t) {
                                    s.payload = {name: e[n]}
                                }
                            }
                            i.push(s)
                        }
                        return i
                    }
                }();

                function BaseRenderer() {
                }

                function SVGRenderer(t, e) {
                    this.animationItem = t, this.layers = null, this.renderedFrame = -1, this.svgElement = createNS("svg");
                    var i = "";
                    if (e && e.title) {
                        var n = createNS("title"), r = createElementID();
                        n.setAttribute("id", r), n.textContent = e.title, this.svgElement.appendChild(n), i += r
                    }
                    if (e && e.description) {
                        var s = createNS("desc"), a = createElementID();
                        s.setAttribute("id", a), s.textContent = e.description, this.svgElement.appendChild(s), i += " " + a
                    }
                    i && this.svgElement.setAttribute("aria-labelledby", i);
                    var o = createNS("defs");
                    this.svgElement.appendChild(o);
                    var h = createNS("g");
                    this.svgElement.appendChild(h), this.layerElement = h, this.renderConfig = {
                        preserveAspectRatio: e && e.preserveAspectRatio || "xMidYMid meet",
                        imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || "xMidYMid slice",
                        contentVisibility: e && e.contentVisibility || "visible",
                        progressiveLoad: e && e.progressiveLoad || !1,
                        hideOnTransparent: !(e && !1 === e.hideOnTransparent),
                        viewBoxOnly: e && e.viewBoxOnly || !1,
                        viewBoxSize: e && e.viewBoxSize || !1,
                        className: e && e.className || "",
                        id: e && e.id || "",
                        focusable: e && e.focusable,
                        filterSize: {
                            width: e && e.filterSize && e.filterSize.width || "100%",
                            height: e && e.filterSize && e.filterSize.height || "100%",
                            x: e && e.filterSize && e.filterSize.x || "0%",
                            y: e && e.filterSize && e.filterSize.y || "0%"
                        }
                    }, this.globalData = {
                        _mdf: !1,
                        frameNum: -1,
                        defs: o,
                        renderConfig: this.renderConfig
                    }, this.elements = [], this.pendingElements = [], this.destroyed = !1, this.rendererType = "svg"
                }

                function CanvasRenderer(t, e) {
                    this.animationItem = t, this.renderConfig = {
                        clearCanvas: !e || void 0 === e.clearCanvas || e.clearCanvas,
                        context: e && e.context || null,
                        progressiveLoad: e && e.progressiveLoad || !1,
                        preserveAspectRatio: e && e.preserveAspectRatio || "xMidYMid meet",
                        imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || "xMidYMid slice",
                        contentVisibility: e && e.contentVisibility || "visible",
                        className: e && e.className || "",
                        id: e && e.id || ""
                    }, this.renderConfig.dpr = e && e.dpr || 1, this.animationItem.wrapper && (this.renderConfig.dpr = e && e.dpr || window.devicePixelRatio || 1), this.renderedFrame = -1, this.globalData = {
                        frameNum: -1,
                        _mdf: !1,
                        renderConfig: this.renderConfig,
                        currentGlobalAlpha: -1
                    }, this.contextData = new CVContextData, this.elements = [], this.pendingElements = [], this.transformMat = new Matrix, this.completeLayers = !1, this.rendererType = "canvas"
                }

                function HybridRenderer(t, e) {
                    this.animationItem = t, this.layers = null, this.renderedFrame = -1, this.renderConfig = {
                        className: e && e.className || "",
                        imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || "xMidYMid slice",
                        hideOnTransparent: !(e && !1 === e.hideOnTransparent),
                        filterSize: {
                            width: e && e.filterSize && e.filterSize.width || "400%",
                            height: e && e.filterSize && e.filterSize.height || "400%",
                            x: e && e.filterSize && e.filterSize.x || "-100%",
                            y: e && e.filterSize && e.filterSize.y || "-100%"
                        }
                    }, this.globalData = {
                        _mdf: !1,
                        frameNum: -1,
                        renderConfig: this.renderConfig
                    }, this.pendingElements = [], this.elements = [], this.threeDElements = [], this.destroyed = !1, this.camera = null, this.supports3d = !0, this.rendererType = "html"
                }

                function MaskElement(t, e, i) {
                    this.data = t, this.element = e, this.globalData = i, this.storedData = [], this.masksProperties = this.data.masksProperties || [], this.maskElement = null;
                    var n, r, s = this.globalData.defs, a = this.masksProperties ? this.masksProperties.length : 0;
                    this.viewData = createSizedArray(a), this.solidPath = "";
                    var o, h, l, c, u, p, d = this.masksProperties, f = 0, m = [], g = createElementID(),
                        v = "clipPath", y = "clip-path";
                    for (n = 0; n < a; n += 1) if (("a" !== d[n].mode && "n" !== d[n].mode || d[n].inv || 100 !== d[n].o.k || d[n].o.x) && (v = "mask", y = "mask"), "s" !== d[n].mode && "i" !== d[n].mode || 0 !== f ? l = null : ((l = createNS("rect")).setAttribute("fill", "#ffffff"), l.setAttribute("width", this.element.comp.data.w || 0), l.setAttribute("height", this.element.comp.data.h || 0), m.push(l)), r = createNS("path"), "n" === d[n].mode) this.viewData[n] = {
                        op: PropertyFactory.getProp(this.element, d[n].o, 0, .01, this.element),
                        prop: ShapePropertyFactory.getShapeProp(this.element, d[n], 3),
                        elem: r,
                        lastPath: ""
                    }, s.appendChild(r); else {
                        var b;
                        if (f += 1, r.setAttribute("fill", "s" === d[n].mode ? "#000000" : "#ffffff"), r.setAttribute("clip-rule", "nonzero"), 0 !== d[n].x.k ? (v = "mask", y = "mask", p = PropertyFactory.getProp(this.element, d[n].x, 0, null, this.element), b = createElementID(), (c = createNS("filter")).setAttribute("id", b), (u = createNS("feMorphology")).setAttribute("operator", "erode"), u.setAttribute("in", "SourceGraphic"), u.setAttribute("radius", "0"), c.appendChild(u), s.appendChild(c), r.setAttribute("stroke", "s" === d[n].mode ? "#000000" : "#ffffff")) : (u = null, p = null), this.storedData[n] = {
                            elem: r,
                            x: p,
                            expan: u,
                            lastPath: "",
                            lastOperator: "",
                            filterId: b,
                            lastRadius: 0
                        }, "i" === d[n].mode) {
                            h = m.length;
                            var x = createNS("g");
                            for (o = 0; o < h; o += 1) x.appendChild(m[o]);
                            var w = createNS("mask");
                            w.setAttribute("mask-type", "alpha"), w.setAttribute("id", g + "_" + f), w.appendChild(r), s.appendChild(w), x.setAttribute("mask", "url(" + locationHref + "#" + g + "_" + f + ")"), m.length = 0, m.push(x)
                        } else m.push(r);
                        d[n].inv && !this.solidPath && (this.solidPath = this.createLayerSolidPath()), this.viewData[n] = {
                            elem: r,
                            lastPath: "",
                            op: PropertyFactory.getProp(this.element, d[n].o, 0, .01, this.element),
                            prop: ShapePropertyFactory.getShapeProp(this.element, d[n], 3),
                            invRect: l
                        }, this.viewData[n].prop.k || this.drawPath(d[n], this.viewData[n].prop.v, this.viewData[n])
                    }
                    for (this.maskElement = createNS(v), a = m.length, n = 0; n < a; n += 1) this.maskElement.appendChild(m[n]);
                    f > 0 && (this.maskElement.setAttribute("id", g), this.element.maskedElement.setAttribute(y, "url(" + locationHref + "#" + g + ")"), s.appendChild(this.maskElement)), this.viewData.length && this.element.addRenderableComponent(this)
                }

                function HierarchyElement() {
                }

                function FrameElement() {
                }

                function TransformElement() {
                }

                function RenderableElement() {
                }

                function RenderableDOMElement() {
                }

                function ProcessedElement(t, e) {
                    this.elem = t, this.pos = e
                }

                function SVGStyleData(t, e) {
                    this.data = t, this.type = t.ty, this.d = "", this.lvl = e, this._mdf = !1, this.closed = !0 === t.hd, this.pElem = createNS("path"), this.msElem = null
                }

                function SVGShapeData(t, e, i) {
                    this.caches = [], this.styles = [], this.transformers = t, this.lStr = "", this.sh = i, this.lvl = e, this._isAnimated = !!i.k;
                    for (var n = 0, r = t.length; n < r;) {
                        if (t[n].mProps.dynamicProperties.length) {
                            this._isAnimated = !0;
                            break
                        }
                        n += 1
                    }
                }

                function SVGTransformData(t, e, i) {
                    this.transform = {
                        mProps: t,
                        op: e,
                        container: i
                    }, this.elements = [], this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length
                }

                function SVGStrokeStyleData(t, e, i) {
                    this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(t, e.o, 0, .01, this), this.w = PropertyFactory.getProp(t, e.w, 0, null, this), this.d = new DashProperty(t, e.d || {}, "svg", this), this.c = PropertyFactory.getProp(t, e.c, 1, 255, this), this.style = i, this._isAnimated = !!this._isAnimated
                }

                function SVGFillStyleData(t, e, i) {
                    this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(t, e.o, 0, .01, this), this.c = PropertyFactory.getProp(t, e.c, 1, 255, this), this.style = i
                }

                function SVGGradientFillStyleData(t, e, i) {
                    this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.initGradientData(t, e, i)
                }

                function SVGGradientStrokeStyleData(t, e, i) {
                    this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.w = PropertyFactory.getProp(t, e.w, 0, null, this), this.d = new DashProperty(t, e.d || {}, "svg", this), this.initGradientData(t, e, i), this._isAnimated = !!this._isAnimated
                }

                function ShapeGroupData() {
                    this.it = [], this.prevViewData = [], this.gr = createNS("g")
                }

                BaseRenderer.prototype.checkLayers = function (t) {
                    var e, i, n = this.layers.length;
                    for (this.completeLayers = !0, e = n - 1; e >= 0; e -= 1) this.elements[e] || (i = this.layers[e]).ip - i.st <= t - this.layers[e].st && i.op - i.st > t - this.layers[e].st && this.buildItem(e), this.completeLayers = !!this.elements[e] && this.completeLayers;
                    this.checkPendingElements()
                }, BaseRenderer.prototype.createItem = function (t) {
                    switch (t.ty) {
                        case 2:
                            return this.createImage(t);
                        case 0:
                            return this.createComp(t);
                        case 1:
                            return this.createSolid(t);
                        case 3:
                        default:
                            return this.createNull(t);
                        case 4:
                            return this.createShape(t);
                        case 5:
                            return this.createText(t);
                        case 6:
                            return this.createAudio(t);
                        case 13:
                            return this.createCamera(t);
                        case 15:
                            return this.createFootage(t)
                    }
                }, BaseRenderer.prototype.createCamera = function () {
                    throw new Error("You're using a 3d camera. Try the html renderer.")
                }, BaseRenderer.prototype.createAudio = function (t) {
                    return new AudioElement(t, this.globalData, this)
                }, BaseRenderer.prototype.createFootage = function (t) {
                    return new FootageElement(t, this.globalData, this)
                }, BaseRenderer.prototype.buildAllItems = function () {
                    var t, e = this.layers.length;
                    for (t = 0; t < e; t += 1) this.buildItem(t);
                    this.checkPendingElements()
                }, BaseRenderer.prototype.includeLayers = function (t) {
                    var e;
                    this.completeLayers = !1;
                    var i, n = t.length, r = this.layers.length;
                    for (e = 0; e < n; e += 1) for (i = 0; i < r;) {
                        if (this.layers[i].id === t[e].id) {
                            this.layers[i] = t[e];
                            break
                        }
                        i += 1
                    }
                }, BaseRenderer.prototype.setProjectInterface = function (t) {
                    this.globalData.projectInterface = t
                }, BaseRenderer.prototype.initItems = function () {
                    this.globalData.progressiveLoad || this.buildAllItems()
                }, BaseRenderer.prototype.buildElementParenting = function (t, e, i) {
                    for (var n = this.elements, r = this.layers, s = 0, a = r.length; s < a;) r[s].ind == e && (n[s] && !0 !== n[s] ? (i.push(n[s]), n[s].setAsParent(), void 0 !== r[s].parent ? this.buildElementParenting(t, r[s].parent, i) : t.setHierarchy(i)) : (this.buildItem(s), this.addPendingElement(t))), s += 1
                }, BaseRenderer.prototype.addPendingElement = function (t) {
                    this.pendingElements.push(t)
                }, BaseRenderer.prototype.searchExtraCompositions = function (t) {
                    var e, i = t.length;
                    for (e = 0; e < i; e += 1) if (t[e].xt) {
                        var n = this.createComp(t[e]);
                        n.initExpressions(), this.globalData.projectInterface.registerComposition(n)
                    }
                }, BaseRenderer.prototype.setupGlobalData = function (t, e) {
                    this.globalData.fontManager = new FontManager, this.globalData.fontManager.addChars(t.chars), this.globalData.fontManager.addFonts(t.fonts, e), this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem), this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem), this.globalData.imageLoader = this.animationItem.imagePreloader, this.globalData.audioController = this.animationItem.audioController, this.globalData.frameId = 0, this.globalData.frameRate = t.fr, this.globalData.nm = t.nm, this.globalData.compSize = {
                        w: t.w,
                        h: t.h
                    }
                }, extendPrototype([BaseRenderer], SVGRenderer), SVGRenderer.prototype.createNull = function (t) {
                    return new NullElement(t, this.globalData, this)
                }, SVGRenderer.prototype.createShape = function (t) {
                    return new SVGShapeElement(t, this.globalData, this)
                }, SVGRenderer.prototype.createText = function (t) {
                    return new SVGTextLottieElement(t, this.globalData, this)
                }, SVGRenderer.prototype.createImage = function (t) {
                    return new IImageElement(t, this.globalData, this)
                }, SVGRenderer.prototype.createComp = function (t) {
                    return new SVGCompElement(t, this.globalData, this)
                }, SVGRenderer.prototype.createSolid = function (t) {
                    return new ISolidElement(t, this.globalData, this)
                }, SVGRenderer.prototype.configAnimation = function (t) {
                    this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg"), this.renderConfig.viewBoxSize ? this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize) : this.svgElement.setAttribute("viewBox", "0 0 " + t.w + " " + t.h), this.renderConfig.viewBoxOnly || (this.svgElement.setAttribute("width", t.w), this.svgElement.setAttribute("height", t.h), this.svgElement.style.width = "100%", this.svgElement.style.height = "100%", this.svgElement.style.transform = "translate3d(0,0,0)", this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility), this.renderConfig.className && this.svgElement.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.svgElement.setAttribute("id", this.renderConfig.id), void 0 !== this.renderConfig.focusable && this.svgElement.setAttribute("focusable", this.renderConfig.focusable), this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio), this.animationItem.wrapper.appendChild(this.svgElement);
                    var e = this.globalData.defs;
                    this.setupGlobalData(t, e), this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.data = t;
                    var i = createNS("clipPath"), n = createNS("rect");
                    n.setAttribute("width", t.w), n.setAttribute("height", t.h), n.setAttribute("x", 0), n.setAttribute("y", 0);
                    var r = createElementID();
                    i.setAttribute("id", r), i.appendChild(n), this.layerElement.setAttribute("clip-path", "url(" + locationHref + "#" + r + ")"), e.appendChild(i), this.layers = t.layers, this.elements = createSizedArray(t.layers.length)
                }, SVGRenderer.prototype.destroy = function () {
                    var t;
                    this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.layerElement = null, this.globalData.defs = null;
                    var e = this.layers ? this.layers.length : 0;
                    for (t = 0; t < e; t += 1) this.elements[t] && this.elements[t].destroy();
                    this.elements.length = 0, this.destroyed = !0, this.animationItem = null
                }, SVGRenderer.prototype.updateContainerSize = function () {
                }, SVGRenderer.prototype.buildItem = function (t) {
                    var e = this.elements;
                    if (!e[t] && 99 !== this.layers[t].ty) {
                        e[t] = !0;
                        var i = this.createItem(this.layers[t]);
                        e[t] = i, expressionsPlugin && (0 === this.layers[t].ty && this.globalData.projectInterface.registerComposition(i), i.initExpressions()), this.appendElementInPos(i, t), this.layers[t].tt && (this.elements[t - 1] && !0 !== this.elements[t - 1] ? i.setMatte(e[t - 1].layerId) : (this.buildItem(t - 1), this.addPendingElement(i)))
                    }
                }, SVGRenderer.prototype.checkPendingElements = function () {
                    for (; this.pendingElements.length;) {
                        var t = this.pendingElements.pop();
                        if (t.checkParenting(), t.data.tt) for (var e = 0, i = this.elements.length; e < i;) {
                            if (this.elements[e] === t) {
                                t.setMatte(this.elements[e - 1].layerId);
                                break
                            }
                            e += 1
                        }
                    }
                }, SVGRenderer.prototype.renderFrame = function (t) {
                    if (this.renderedFrame !== t && !this.destroyed) {
                        var e;
                        null === t ? t = this.renderedFrame : this.renderedFrame = t, this.globalData.frameNum = t, this.globalData.frameId += 1, this.globalData.projectInterface.currentFrame = t, this.globalData._mdf = !1;
                        var i = this.layers.length;
                        for (this.completeLayers || this.checkLayers(t), e = i - 1; e >= 0; e -= 1) (this.completeLayers || this.elements[e]) && this.elements[e].prepareFrame(t - this.layers[e].st);
                        if (this.globalData._mdf) for (e = 0; e < i; e += 1) (this.completeLayers || this.elements[e]) && this.elements[e].renderFrame()
                    }
                }, SVGRenderer.prototype.appendElementInPos = function (t, e) {
                    var i = t.getBaseElement();
                    if (i) {
                        for (var n, r = 0; r < e;) this.elements[r] && !0 !== this.elements[r] && this.elements[r].getBaseElement() && (n = this.elements[r].getBaseElement()), r += 1;
                        n ? this.layerElement.insertBefore(i, n) : this.layerElement.appendChild(i)
                    }
                }, SVGRenderer.prototype.hide = function () {
                    this.layerElement.style.display = "none"
                }, SVGRenderer.prototype.show = function () {
                    this.layerElement.style.display = "block"
                }, extendPrototype([BaseRenderer], CanvasRenderer), CanvasRenderer.prototype.createShape = function (t) {
                    return new CVShapeElement(t, this.globalData, this)
                }, CanvasRenderer.prototype.createText = function (t) {
                    return new CVTextElement(t, this.globalData, this)
                }, CanvasRenderer.prototype.createImage = function (t) {
                    return new CVImageElement(t, this.globalData, this)
                }, CanvasRenderer.prototype.createComp = function (t) {
                    return new CVCompElement(t, this.globalData, this)
                }, CanvasRenderer.prototype.createSolid = function (t) {
                    return new CVSolidElement(t, this.globalData, this)
                }, CanvasRenderer.prototype.createNull = SVGRenderer.prototype.createNull, CanvasRenderer.prototype.ctxTransform = function (t) {
                    if (1 !== t[0] || 0 !== t[1] || 0 !== t[4] || 1 !== t[5] || 0 !== t[12] || 0 !== t[13]) if (this.renderConfig.clearCanvas) {
                        this.transformMat.cloneFromProps(t);
                        var e = this.contextData.cTr.props;
                        this.transformMat.transform(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]), this.contextData.cTr.cloneFromProps(this.transformMat.props);
                        var i = this.contextData.cTr.props;
                        this.canvasContext.setTransform(i[0], i[1], i[4], i[5], i[12], i[13])
                    } else this.canvasContext.transform(t[0], t[1], t[4], t[5], t[12], t[13])
                }, CanvasRenderer.prototype.ctxOpacity = function (t) {
                    if (!this.renderConfig.clearCanvas) return this.canvasContext.globalAlpha *= t < 0 ? 0 : t, void (this.globalData.currentGlobalAlpha = this.contextData.cO);
                    this.contextData.cO *= t < 0 ? 0 : t, this.globalData.currentGlobalAlpha !== this.contextData.cO && (this.canvasContext.globalAlpha = this.contextData.cO, this.globalData.currentGlobalAlpha = this.contextData.cO)
                }, CanvasRenderer.prototype.reset = function () {
                    this.renderConfig.clearCanvas ? this.contextData.reset() : this.canvasContext.restore()
                }, CanvasRenderer.prototype.save = function (t) {
                    if (this.renderConfig.clearCanvas) {
                        t && this.canvasContext.save();
                        var e, i = this.contextData.cTr.props;
                        this.contextData._length <= this.contextData.cArrPos && this.contextData.duplicate();
                        var n = this.contextData.saved[this.contextData.cArrPos];
                        for (e = 0; e < 16; e += 1) n[e] = i[e];
                        this.contextData.savedOp[this.contextData.cArrPos] = this.contextData.cO, this.contextData.cArrPos += 1
                    } else this.canvasContext.save()
                }, CanvasRenderer.prototype.restore = function (t) {
                    if (this.renderConfig.clearCanvas) {
                        t && (this.canvasContext.restore(), this.globalData.blendMode = "source-over"), this.contextData.cArrPos -= 1;
                        var e, i = this.contextData.saved[this.contextData.cArrPos], n = this.contextData.cTr.props;
                        for (e = 0; e < 16; e += 1) n[e] = i[e];
                        this.canvasContext.setTransform(i[0], i[1], i[4], i[5], i[12], i[13]), i = this.contextData.savedOp[this.contextData.cArrPos], this.contextData.cO = i, this.globalData.currentGlobalAlpha !== i && (this.canvasContext.globalAlpha = i, this.globalData.currentGlobalAlpha = i)
                    } else this.canvasContext.restore()
                }, CanvasRenderer.prototype.configAnimation = function (t) {
                    if (this.animationItem.wrapper) {
                        this.animationItem.container = createTag("canvas");
                        var e = this.animationItem.container.style;
                        e.width = "100%", e.height = "100%";
                        var i = "0px 0px 0px";
                        e.transformOrigin = i, e.mozTransformOrigin = i, e.webkitTransformOrigin = i, e["-webkit-transform"] = i, e.contentVisibility = this.renderConfig.contentVisibility, this.animationItem.wrapper.appendChild(this.animationItem.container), this.canvasContext = this.animationItem.container.getContext("2d"), this.renderConfig.className && this.animationItem.container.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.animationItem.container.setAttribute("id", this.renderConfig.id)
                    } else this.canvasContext = this.renderConfig.context;
                    this.data = t, this.layers = t.layers, this.transformCanvas = {
                        w: t.w,
                        h: t.h,
                        sx: 0,
                        sy: 0,
                        tx: 0,
                        ty: 0
                    }, this.setupGlobalData(t, document.body), this.globalData.canvasContext = this.canvasContext, this.globalData.renderer = this, this.globalData.isDashed = !1, this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.globalData.transformCanvas = this.transformCanvas, this.elements = createSizedArray(t.layers.length), this.updateContainerSize()
                }, CanvasRenderer.prototype.updateContainerSize = function () {
                    var t, e, i, n;
                    if (this.reset(), this.animationItem.wrapper && this.animationItem.container ? (t = this.animationItem.wrapper.offsetWidth, e = this.animationItem.wrapper.offsetHeight, this.animationItem.container.setAttribute("width", t * this.renderConfig.dpr), this.animationItem.container.setAttribute("height", e * this.renderConfig.dpr)) : (t = this.canvasContext.canvas.width * this.renderConfig.dpr, e = this.canvasContext.canvas.height * this.renderConfig.dpr), -1 !== this.renderConfig.preserveAspectRatio.indexOf("meet") || -1 !== this.renderConfig.preserveAspectRatio.indexOf("slice")) {
                        var r = this.renderConfig.preserveAspectRatio.split(" "), s = r[1] || "meet",
                            a = r[0] || "xMidYMid", o = a.substr(0, 4), h = a.substr(4);
                        i = t / e, (n = this.transformCanvas.w / this.transformCanvas.h) > i && "meet" === s || n < i && "slice" === s ? (this.transformCanvas.sx = t / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = t / (this.transformCanvas.w / this.renderConfig.dpr)) : (this.transformCanvas.sx = e / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.sy = e / (this.transformCanvas.h / this.renderConfig.dpr)), this.transformCanvas.tx = "xMid" === o && (n < i && "meet" === s || n > i && "slice" === s) ? (t - this.transformCanvas.w * (e / this.transformCanvas.h)) / 2 * this.renderConfig.dpr : "xMax" === o && (n < i && "meet" === s || n > i && "slice" === s) ? (t - this.transformCanvas.w * (e / this.transformCanvas.h)) * this.renderConfig.dpr : 0, this.transformCanvas.ty = "YMid" === h && (n > i && "meet" === s || n < i && "slice" === s) ? (e - this.transformCanvas.h * (t / this.transformCanvas.w)) / 2 * this.renderConfig.dpr : "YMax" === h && (n > i && "meet" === s || n < i && "slice" === s) ? (e - this.transformCanvas.h * (t / this.transformCanvas.w)) * this.renderConfig.dpr : 0
                    } else "none" === this.renderConfig.preserveAspectRatio ? (this.transformCanvas.sx = t / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = e / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.tx = 0, this.transformCanvas.ty = 0) : (this.transformCanvas.sx = this.renderConfig.dpr, this.transformCanvas.sy = this.renderConfig.dpr, this.transformCanvas.tx = 0, this.transformCanvas.ty = 0);
                    this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1], this.ctxTransform(this.transformCanvas.props), this.canvasContext.beginPath(), this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h), this.canvasContext.closePath(), this.canvasContext.clip(), this.renderFrame(this.renderedFrame, !0)
                }, CanvasRenderer.prototype.destroy = function () {
                    var t;
                    for (this.renderConfig.clearCanvas && this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), t = (this.layers ? this.layers.length : 0) - 1; t >= 0; t -= 1) this.elements[t] && this.elements[t].destroy();
                    this.elements.length = 0, this.globalData.canvasContext = null, this.animationItem.container = null, this.destroyed = !0
                }, CanvasRenderer.prototype.renderFrame = function (t, e) {
                    if ((this.renderedFrame !== t || !0 !== this.renderConfig.clearCanvas || e) && !this.destroyed && -1 !== t) {
                        var i;
                        this.renderedFrame = t, this.globalData.frameNum = t - this.animationItem._isFirstFrame, this.globalData.frameId += 1, this.globalData._mdf = !this.renderConfig.clearCanvas || e, this.globalData.projectInterface.currentFrame = t;
                        var n = this.layers.length;
                        for (this.completeLayers || this.checkLayers(t), i = 0; i < n; i += 1) (this.completeLayers || this.elements[i]) && this.elements[i].prepareFrame(t - this.layers[i].st);
                        if (this.globalData._mdf) {
                            for (!0 === this.renderConfig.clearCanvas ? this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h) : this.save(), i = n - 1; i >= 0; i -= 1) (this.completeLayers || this.elements[i]) && this.elements[i].renderFrame();
                            !0 !== this.renderConfig.clearCanvas && this.restore()
                        }
                    }
                }, CanvasRenderer.prototype.buildItem = function (t) {
                    var e = this.elements;
                    if (!e[t] && 99 !== this.layers[t].ty) {
                        var i = this.createItem(this.layers[t], this, this.globalData);
                        e[t] = i, i.initExpressions()
                    }
                }, CanvasRenderer.prototype.checkPendingElements = function () {
                    for (; this.pendingElements.length;) this.pendingElements.pop().checkParenting()
                }, CanvasRenderer.prototype.hide = function () {
                    this.animationItem.container.style.display = "none"
                }, CanvasRenderer.prototype.show = function () {
                    this.animationItem.container.style.display = "block"
                }, extendPrototype([BaseRenderer], HybridRenderer), HybridRenderer.prototype.buildItem = SVGRenderer.prototype.buildItem, HybridRenderer.prototype.checkPendingElements = function () {
                    for (; this.pendingElements.length;) this.pendingElements.pop().checkParenting()
                }, HybridRenderer.prototype.appendElementInPos = function (t, e) {
                    var i = t.getBaseElement();
                    if (i) {
                        var n = this.layers[e];
                        if (n.ddd && this.supports3d) this.addTo3dContainer(i, e); else if (this.threeDElements) this.addTo3dContainer(i, e); else {
                            for (var r, s, a = 0; a < e;) this.elements[a] && !0 !== this.elements[a] && this.elements[a].getBaseElement && (s = this.elements[a], r = (this.layers[a].ddd ? this.getThreeDContainerByPos(a) : s.getBaseElement()) || r), a += 1;
                            r ? n.ddd && this.supports3d || this.layerElement.insertBefore(i, r) : n.ddd && this.supports3d || this.layerElement.appendChild(i)
                        }
                    }
                }, HybridRenderer.prototype.createShape = function (t) {
                    return this.supports3d ? new HShapeElement(t, this.globalData, this) : new SVGShapeElement(t, this.globalData, this)
                }, HybridRenderer.prototype.createText = function (t) {
                    return this.supports3d ? new HTextElement(t, this.globalData, this) : new SVGTextLottieElement(t, this.globalData, this)
                }, HybridRenderer.prototype.createCamera = function (t) {
                    return this.camera = new HCameraElement(t, this.globalData, this), this.camera
                }, HybridRenderer.prototype.createImage = function (t) {
                    return this.supports3d ? new HImageElement(t, this.globalData, this) : new IImageElement(t, this.globalData, this)
                }, HybridRenderer.prototype.createComp = function (t) {
                    return this.supports3d ? new HCompElement(t, this.globalData, this) : new SVGCompElement(t, this.globalData, this)
                }, HybridRenderer.prototype.createSolid = function (t) {
                    return this.supports3d ? new HSolidElement(t, this.globalData, this) : new ISolidElement(t, this.globalData, this)
                }, HybridRenderer.prototype.createNull = SVGRenderer.prototype.createNull, HybridRenderer.prototype.getThreeDContainerByPos = function (t) {
                    for (var e = 0, i = this.threeDElements.length; e < i;) {
                        if (this.threeDElements[e].startPos <= t && this.threeDElements[e].endPos >= t) return this.threeDElements[e].perspectiveElem;
                        e += 1
                    }
                    return null
                }, HybridRenderer.prototype.createThreeDContainer = function (t, e) {
                    var i, n, r = createTag("div");
                    styleDiv(r);
                    var s = createTag("div");
                    if (styleDiv(s), "3d" === e) {
                        (i = r.style).width = this.globalData.compSize.w + "px", i.height = this.globalData.compSize.h + "px";
                        var a = "50% 50%";
                        i.webkitTransformOrigin = a, i.mozTransformOrigin = a, i.transformOrigin = a;
                        var o = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
                        (n = s.style).transform = o, n.webkitTransform = o
                    }
                    r.appendChild(s);
                    var h = {container: s, perspectiveElem: r, startPos: t, endPos: t, type: e};
                    return this.threeDElements.push(h), h
                }, HybridRenderer.prototype.build3dContainers = function () {
                    var t, e, i = this.layers.length, n = "";
                    for (t = 0; t < i; t += 1) this.layers[t].ddd && 3 !== this.layers[t].ty ? ("3d" !== n && (n = "3d", e = this.createThreeDContainer(t, "3d")), e.endPos = Math.max(e.endPos, t)) : ("2d" !== n && (n = "2d", e = this.createThreeDContainer(t, "2d")), e.endPos = Math.max(e.endPos, t));
                    for (t = (i = this.threeDElements.length) - 1; t >= 0; t -= 1) this.resizerElem.appendChild(this.threeDElements[t].perspectiveElem)
                }, HybridRenderer.prototype.addTo3dContainer = function (t, e) {
                    for (var i = 0, n = this.threeDElements.length; i < n;) {
                        if (e <= this.threeDElements[i].endPos) {
                            for (var r, s = this.threeDElements[i].startPos; s < e;) this.elements[s] && this.elements[s].getBaseElement && (r = this.elements[s].getBaseElement()), s += 1;
                            r ? this.threeDElements[i].container.insertBefore(t, r) : this.threeDElements[i].container.appendChild(t);
                            break
                        }
                        i += 1
                    }
                }, HybridRenderer.prototype.configAnimation = function (t) {
                    var e = createTag("div"), i = this.animationItem.wrapper, n = e.style;
                    n.width = t.w + "px", n.height = t.h + "px", this.resizerElem = e, styleDiv(e), n.transformStyle = "flat", n.mozTransformStyle = "flat", n.webkitTransformStyle = "flat", this.renderConfig.className && e.setAttribute("class", this.renderConfig.className), i.appendChild(e), n.overflow = "hidden";
                    var r = createNS("svg");
                    r.setAttribute("width", "1"), r.setAttribute("height", "1"), styleDiv(r), this.resizerElem.appendChild(r);
                    var s = createNS("defs");
                    r.appendChild(s), this.data = t, this.setupGlobalData(t, r), this.globalData.defs = s, this.layers = t.layers, this.layerElement = this.resizerElem, this.build3dContainers(), this.updateContainerSize()
                }, HybridRenderer.prototype.destroy = function () {
                    var t;
                    this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.animationItem.container = null, this.globalData.defs = null;
                    var e = this.layers ? this.layers.length : 0;
                    for (t = 0; t < e; t += 1) this.elements[t].destroy();
                    this.elements.length = 0, this.destroyed = !0, this.animationItem = null
                }, HybridRenderer.prototype.updateContainerSize = function () {
                    var t, e, i, n, r = this.animationItem.wrapper.offsetWidth,
                        s = this.animationItem.wrapper.offsetHeight, a = r / s;
                    this.globalData.compSize.w / this.globalData.compSize.h > a ? (t = r / this.globalData.compSize.w, e = r / this.globalData.compSize.w, i = 0, n = (s - this.globalData.compSize.h * (r / this.globalData.compSize.w)) / 2) : (t = s / this.globalData.compSize.h, e = s / this.globalData.compSize.h, i = (r - this.globalData.compSize.w * (s / this.globalData.compSize.h)) / 2, n = 0);
                    var o = this.resizerElem.style;
                    o.webkitTransform = "matrix3d(" + t + ",0,0,0,0," + e + ",0,0,0,0,1,0," + i + "," + n + ",0,1)", o.transform = o.webkitTransform
                }, HybridRenderer.prototype.renderFrame = SVGRenderer.prototype.renderFrame, HybridRenderer.prototype.hide = function () {
                    this.resizerElem.style.display = "none"
                }, HybridRenderer.prototype.show = function () {
                    this.resizerElem.style.display = "block"
                }, HybridRenderer.prototype.initItems = function () {
                    if (this.buildAllItems(), this.camera) this.camera.setup(); else {
                        var t, e = this.globalData.compSize.w, i = this.globalData.compSize.h,
                            n = this.threeDElements.length;
                        for (t = 0; t < n; t += 1) {
                            var r = this.threeDElements[t].perspectiveElem.style;
                            r.webkitPerspective = Math.sqrt(Math.pow(e, 2) + Math.pow(i, 2)) + "px", r.perspective = r.webkitPerspective
                        }
                    }
                }, HybridRenderer.prototype.searchExtraCompositions = function (t) {
                    var e, i = t.length, n = createTag("div");
                    for (e = 0; e < i; e += 1) if (t[e].xt) {
                        var r = this.createComp(t[e], n, this.globalData.comp, null);
                        r.initExpressions(), this.globalData.projectInterface.registerComposition(r)
                    }
                }, MaskElement.prototype.getMaskProperty = function (t) {
                    return this.viewData[t].prop
                }, MaskElement.prototype.renderFrame = function (t) {
                    var e, i = this.element.finalTransform.mat, n = this.masksProperties.length;
                    for (e = 0; e < n; e += 1) if ((this.viewData[e].prop._mdf || t) && this.drawPath(this.masksProperties[e], this.viewData[e].prop.v, this.viewData[e]), (this.viewData[e].op._mdf || t) && this.viewData[e].elem.setAttribute("fill-opacity", this.viewData[e].op.v), "n" !== this.masksProperties[e].mode && (this.viewData[e].invRect && (this.element.finalTransform.mProp._mdf || t) && this.viewData[e].invRect.setAttribute("transform", i.getInverseMatrix().to2dCSS()), this.storedData[e].x && (this.storedData[e].x._mdf || t))) {
                        var r = this.storedData[e].expan;
                        this.storedData[e].x.v < 0 ? ("erode" !== this.storedData[e].lastOperator && (this.storedData[e].lastOperator = "erode", this.storedData[e].elem.setAttribute("filter", "url(" + locationHref + "#" + this.storedData[e].filterId + ")")), r.setAttribute("radius", -this.storedData[e].x.v)) : ("dilate" !== this.storedData[e].lastOperator && (this.storedData[e].lastOperator = "dilate", this.storedData[e].elem.setAttribute("filter", null)), this.storedData[e].elem.setAttribute("stroke-width", 2 * this.storedData[e].x.v))
                    }
                }, MaskElement.prototype.getMaskelement = function () {
                    return this.maskElement
                }, MaskElement.prototype.createLayerSolidPath = function () {
                    var t = "M0,0 ";
                    return t += " h" + this.globalData.compSize.w, t += " v" + this.globalData.compSize.h, t += " h-" + this.globalData.compSize.w, t += " v-" + this.globalData.compSize.h + " "
                }, MaskElement.prototype.drawPath = function (t, e, i) {
                    var n, r, s = " M" + e.v[0][0] + "," + e.v[0][1];
                    for (r = e._length, n = 1; n < r; n += 1) s += " C" + e.o[n - 1][0] + "," + e.o[n - 1][1] + " " + e.i[n][0] + "," + e.i[n][1] + " " + e.v[n][0] + "," + e.v[n][1];
                    if (e.c && r > 1 && (s += " C" + e.o[n - 1][0] + "," + e.o[n - 1][1] + " " + e.i[0][0] + "," + e.i[0][1] + " " + e.v[0][0] + "," + e.v[0][1]), i.lastPath !== s) {
                        var a = "";
                        i.elem && (e.c && (a = t.inv ? this.solidPath + s : s), i.elem.setAttribute("d", a)), i.lastPath = s
                    }
                }, MaskElement.prototype.destroy = function () {
                    this.element = null, this.globalData = null, this.maskElement = null, this.data = null, this.masksProperties = null
                }, HierarchyElement.prototype = {
                    initHierarchy: function () {
                        this.hierarchy = [], this._isParent = !1, this.checkParenting()
                    }, setHierarchy: function (t) {
                        this.hierarchy = t
                    }, setAsParent: function () {
                        this._isParent = !0
                    }, checkParenting: function () {
                        void 0 !== this.data.parent && this.comp.buildElementParenting(this, this.data.parent, [])
                    }
                }, FrameElement.prototype = {
                    initFrame: function () {
                        this._isFirstFrame = !1, this.dynamicProperties = [], this._mdf = !1
                    }, prepareProperties: function (t, e) {
                        var i, n = this.dynamicProperties.length;
                        for (i = 0; i < n; i += 1) (e || this._isParent && "transform" === this.dynamicProperties[i].propType) && (this.dynamicProperties[i].getValue(), this.dynamicProperties[i]._mdf && (this.globalData._mdf = !0, this._mdf = !0))
                    }, addDynamicProperty: function (t) {
                        -1 === this.dynamicProperties.indexOf(t) && this.dynamicProperties.push(t)
                    }
                }, TransformElement.prototype = {
                    initTransform: function () {
                        this.finalTransform = {
                            mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {o: 0},
                            _matMdf: !1,
                            _opMdf: !1,
                            mat: new Matrix
                        }, this.data.ao && (this.finalTransform.mProp.autoOriented = !0), this.data.ty
                    }, renderTransform: function () {
                        if (this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame, this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame, this.hierarchy) {
                            var t, e = this.finalTransform.mat, i = 0, n = this.hierarchy.length;
                            if (!this.finalTransform._matMdf) for (; i < n;) {
                                if (this.hierarchy[i].finalTransform.mProp._mdf) {
                                    this.finalTransform._matMdf = !0;
                                    break
                                }
                                i += 1
                            }
                            if (this.finalTransform._matMdf) for (t = this.finalTransform.mProp.v.props, e.cloneFromProps(t), i = 0; i < n; i += 1) t = this.hierarchy[i].finalTransform.mProp.v.props, e.transform(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15])
                        }
                    }, globalToLocal: function (t) {
                        var e = [];
                        e.push(this.finalTransform);
                        for (var i, n = !0, r = this.comp; n;) r.finalTransform ? (r.data.hasMask && e.splice(0, 0, r.finalTransform), r = r.comp) : n = !1;
                        var s, a = e.length;
                        for (i = 0; i < a; i += 1) s = e[i].mat.applyToPointArray(0, 0, 0), t = [t[0] - s[0], t[1] - s[1], 0];
                        return t
                    }, mHelper: new Matrix
                }, RenderableElement.prototype = {
                    initRenderable: function () {
                        this.isInRange = !1, this.hidden = !1, this.isTransparent = !1, this.renderableComponents = []
                    }, addRenderableComponent: function (t) {
                        -1 === this.renderableComponents.indexOf(t) && this.renderableComponents.push(t)
                    }, removeRenderableComponent: function (t) {
                        -1 !== this.renderableComponents.indexOf(t) && this.renderableComponents.splice(this.renderableComponents.indexOf(t), 1)
                    }, prepareRenderableFrame: function (t) {
                        this.checkLayerLimits(t)
                    }, checkTransparency: function () {
                        this.finalTransform.mProp.o.v <= 0 ? !this.isTransparent && this.globalData.renderConfig.hideOnTransparent && (this.isTransparent = !0, this.hide()) : this.isTransparent && (this.isTransparent = !1, this.show())
                    }, checkLayerLimits: function (t) {
                        this.data.ip - this.data.st <= t && this.data.op - this.data.st > t ? !0 !== this.isInRange && (this.globalData._mdf = !0, this._mdf = !0, this.isInRange = !0, this.show()) : !1 !== this.isInRange && (this.globalData._mdf = !0, this.isInRange = !1, this.hide())
                    }, renderRenderable: function () {
                        var t, e = this.renderableComponents.length;
                        for (t = 0; t < e; t += 1) this.renderableComponents[t].renderFrame(this._isFirstFrame)
                    }, sourceRectAtTime: function () {
                        return {top: 0, left: 0, width: 100, height: 100}
                    }, getLayerSize: function () {
                        return 5 === this.data.ty ? {
                            w: this.data.textData.width,
                            h: this.data.textData.height
                        } : {w: this.data.width, h: this.data.height}
                    }
                }, extendPrototype([RenderableElement, createProxyFunction({
                    initElement: function (t, e, i) {
                        this.initFrame(), this.initBaseData(t, e, i), this.initTransform(t, e, i), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide()
                    }, hide: function () {
                        this.hidden || this.isInRange && !this.isTransparent || ((this.baseElement || this.layerElement).style.display = "none", this.hidden = !0)
                    }, show: function () {
                        this.isInRange && !this.isTransparent && (this.data.hd || ((this.baseElement || this.layerElement).style.display = "block"), this.hidden = !1, this._isFirstFrame = !0)
                    }, renderFrame: function () {
                        this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1))
                    }, renderInnerContent: function () {
                    }, prepareFrame: function (t) {
                        this._mdf = !1, this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange), this.checkTransparency()
                    }, destroy: function () {
                        this.innerElem = null, this.destroyBaseElement()
                    }
                })], RenderableDOMElement), SVGStyleData.prototype.reset = function () {
                    this.d = "", this._mdf = !1
                }, SVGShapeData.prototype.setAsAnimated = function () {
                    this._isAnimated = !0
                }, extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData), extendPrototype([DynamicPropertyContainer], SVGFillStyleData), SVGGradientFillStyleData.prototype.initGradientData = function (t, e, i) {
                    this.o = PropertyFactory.getProp(t, e.o, 0, .01, this), this.s = PropertyFactory.getProp(t, e.s, 1, null, this), this.e = PropertyFactory.getProp(t, e.e, 1, null, this), this.h = PropertyFactory.getProp(t, e.h || {k: 0}, 0, .01, this), this.a = PropertyFactory.getProp(t, e.a || {k: 0}, 0, degToRads, this), this.g = new GradientProperty(t, e.g, this), this.style = i, this.stops = [], this.setGradientData(i.pElem, e), this.setGradientOpacity(e, i), this._isAnimated = !!this._isAnimated
                }, SVGGradientFillStyleData.prototype.setGradientData = function (t, e) {
                    var i = createElementID(), n = createNS(1 === e.t ? "linearGradient" : "radialGradient");
                    n.setAttribute("id", i), n.setAttribute("spreadMethod", "pad"), n.setAttribute("gradientUnits", "userSpaceOnUse");
                    var r, s, a, o = [];
                    for (a = 4 * e.g.p, s = 0; s < a; s += 4) r = createNS("stop"), n.appendChild(r), o.push(r);
                    t.setAttribute("gf" === e.ty ? "fill" : "stroke", "url(" + locationHref + "#" + i + ")"), this.gf = n, this.cst = o
                }, SVGGradientFillStyleData.prototype.setGradientOpacity = function (t, e) {
                    if (this.g._hasOpacity && !this.g._collapsable) {
                        var i, n, r, s = createNS("mask"), a = createNS("path");
                        s.appendChild(a);
                        var o = createElementID(), h = createElementID();
                        s.setAttribute("id", h);
                        var l = createNS(1 === t.t ? "linearGradient" : "radialGradient");
                        l.setAttribute("id", o), l.setAttribute("spreadMethod", "pad"), l.setAttribute("gradientUnits", "userSpaceOnUse"), r = t.g.k.k[0].s ? t.g.k.k[0].s.length : t.g.k.k.length;
                        var c = this.stops;
                        for (n = 4 * t.g.p; n < r; n += 2) (i = createNS("stop")).setAttribute("stop-color", "rgb(255,255,255)"), l.appendChild(i), c.push(i);
                        a.setAttribute("gf" === t.ty ? "fill" : "stroke", "url(" + locationHref + "#" + o + ")"), "gs" === t.ty && (a.setAttribute("stroke-linecap", lineCapEnum[t.lc || 2]), a.setAttribute("stroke-linejoin", lineJoinEnum[t.lj || 2]), 1 === t.lj && a.setAttribute("stroke-miterlimit", t.ml)), this.of = l, this.ms = s, this.ost = c, this.maskId = h, e.msElem = a
                    }
                }, extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData), extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
                var SVGElementsRenderer = function () {
                    var t = new Matrix, e = new Matrix;

                    function i(t, e, i) {
                        (i || e.transform.op._mdf) && e.transform.container.setAttribute("opacity", e.transform.op.v), (i || e.transform.mProps._mdf) && e.transform.container.setAttribute("transform", e.transform.mProps.v.to2dCSS())
                    }

                    function n(i, n, r) {
                        var s, a, o, h, l, c, u, p, d, f, m, g = n.styles.length, v = n.lvl;
                        for (c = 0; c < g; c += 1) {
                            if (h = n.sh._mdf || r, n.styles[c].lvl < v) {
                                for (p = e.reset(), f = v - n.styles[c].lvl, m = n.transformers.length - 1; !h && f > 0;) h = n.transformers[m].mProps._mdf || h, f -= 1, m -= 1;
                                if (h) for (f = v - n.styles[c].lvl, m = n.transformers.length - 1; f > 0;) d = n.transformers[m].mProps.v.props, p.transform(d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7], d[8], d[9], d[10], d[11], d[12], d[13], d[14], d[15]), f -= 1, m -= 1
                            } else p = t;
                            if (a = (u = n.sh.paths)._length, h) {
                                for (o = "", s = 0; s < a; s += 1) (l = u.shapes[s]) && l._length && (o += buildShapeString(l, l._length, l.c, p));
                                n.caches[c] = o
                            } else o = n.caches[c];
                            n.styles[c].d += !0 === i.hd ? "" : o, n.styles[c]._mdf = h || n.styles[c]._mdf
                        }
                    }

                    function r(t, e, i) {
                        var n = e.style;
                        (e.c._mdf || i) && n.pElem.setAttribute("fill", "rgb(" + bmFloor(e.c.v[0]) + "," + bmFloor(e.c.v[1]) + "," + bmFloor(e.c.v[2]) + ")"), (e.o._mdf || i) && n.pElem.setAttribute("fill-opacity", e.o.v)
                    }

                    function s(t, e, i) {
                        a(t, e, i), o(0, e, i)
                    }

                    function a(t, e, i) {
                        var n, r, s, a, o, h = e.gf, l = e.g._hasOpacity, c = e.s.v, u = e.e.v;
                        if (e.o._mdf || i) {
                            var p = "gf" === t.ty ? "fill-opacity" : "stroke-opacity";
                            e.style.pElem.setAttribute(p, e.o.v)
                        }
                        if (e.s._mdf || i) {
                            var d = 1 === t.t ? "x1" : "cx", f = "x1" === d ? "y1" : "cy";
                            h.setAttribute(d, c[0]), h.setAttribute(f, c[1]), l && !e.g._collapsable && (e.of.setAttribute(d, c[0]), e.of.setAttribute(f, c[1]))
                        }
                        if (e.g._cmdf || i) {
                            n = e.cst;
                            var m = e.g.c;
                            for (s = n.length, r = 0; r < s; r += 1) (a = n[r]).setAttribute("offset", m[4 * r] + "%"), a.setAttribute("stop-color", "rgb(" + m[4 * r + 1] + "," + m[4 * r + 2] + "," + m[4 * r + 3] + ")")
                        }
                        if (l && (e.g._omdf || i)) {
                            var g = e.g.o;
                            for (s = (n = e.g._collapsable ? e.cst : e.ost).length, r = 0; r < s; r += 1) a = n[r], e.g._collapsable || a.setAttribute("offset", g[2 * r] + "%"), a.setAttribute("stop-opacity", g[2 * r + 1])
                        }
                        if (1 === t.t) (e.e._mdf || i) && (h.setAttribute("x2", u[0]), h.setAttribute("y2", u[1]), l && !e.g._collapsable && (e.of.setAttribute("x2", u[0]), e.of.setAttribute("y2", u[1]))); else if ((e.s._mdf || e.e._mdf || i) && (o = Math.sqrt(Math.pow(c[0] - u[0], 2) + Math.pow(c[1] - u[1], 2)), h.setAttribute("r", o), l && !e.g._collapsable && e.of.setAttribute("r", o)), e.e._mdf || e.h._mdf || e.a._mdf || i) {
                            o || (o = Math.sqrt(Math.pow(c[0] - u[0], 2) + Math.pow(c[1] - u[1], 2)));
                            var v = Math.atan2(u[1] - c[1], u[0] - c[0]), y = e.h.v;
                            y >= 1 ? y = .99 : y <= -1 && (y = -.99);
                            var b = o * y, x = Math.cos(v + e.a.v) * b + c[0], w = Math.sin(v + e.a.v) * b + c[1];
                            h.setAttribute("fx", x), h.setAttribute("fy", w), l && !e.g._collapsable && (e.of.setAttribute("fx", x), e.of.setAttribute("fy", w))
                        }
                    }

                    function o(t, e, i) {
                        var n = e.style, r = e.d;
                        r && (r._mdf || i) && r.dashStr && (n.pElem.setAttribute("stroke-dasharray", r.dashStr), n.pElem.setAttribute("stroke-dashoffset", r.dashoffset[0])), e.c && (e.c._mdf || i) && n.pElem.setAttribute("stroke", "rgb(" + bmFloor(e.c.v[0]) + "," + bmFloor(e.c.v[1]) + "," + bmFloor(e.c.v[2]) + ")"), (e.o._mdf || i) && n.pElem.setAttribute("stroke-opacity", e.o.v), (e.w._mdf || i) && (n.pElem.setAttribute("stroke-width", e.w.v), n.msElem && n.msElem.setAttribute("stroke-width", e.w.v))
                    }

                    return {
                        createRenderFunction: function (t) {
                            switch (t.ty) {
                                case"fl":
                                    return r;
                                case"gf":
                                    return a;
                                case"gs":
                                    return s;
                                case"st":
                                    return o;
                                case"sh":
                                case"el":
                                case"rc":
                                case"sr":
                                    return n;
                                case"tr":
                                    return i;
                                default:
                                    return null
                            }
                        }
                    }
                }();

                function ShapeTransformManager() {
                    this.sequences = {}, this.sequenceList = [], this.transform_key_count = 0
                }

                function CVShapeData(t, e, i, n) {
                    this.styledShapes = [], this.tr = [0, 0, 0, 0, 0, 0];
                    var r, s = 4;
                    "rc" === e.ty ? s = 5 : "el" === e.ty ? s = 6 : "sr" === e.ty && (s = 7), this.sh = ShapePropertyFactory.getShapeProp(t, e, s, t);
                    var a, o = i.length;
                    for (r = 0; r < o; r += 1) i[r].closed || (a = {
                        transforms: n.addTransformSequence(i[r].transforms),
                        trNodes: []
                    }, this.styledShapes.push(a), i[r].elements.push(a))
                }

                function BaseElement() {
                }

                function NullElement(t, e, i) {
                    this.initFrame(), this.initBaseData(t, e, i), this.initFrame(), this.initTransform(t, e, i), this.initHierarchy()
                }

                function SVGBaseElement() {
                }

                function IShapeElement() {
                }

                function ITextElement() {
                }

                function ICompElement() {
                }

                function IImageElement(t, e, i) {
                    this.assetData = e.getAssetData(t.refId), this.initElement(t, e, i), this.sourceRect = {
                        top: 0,
                        left: 0,
                        width: this.assetData.w,
                        height: this.assetData.h
                    }
                }

                function ISolidElement(t, e, i) {
                    this.initElement(t, e, i)
                }

                function AudioElement(t, e, i) {
                    this.initFrame(), this.initRenderable(), this.assetData = e.getAssetData(t.refId), this.initBaseData(t, e, i), this._isPlaying = !1, this._canPlay = !1;
                    var n = this.globalData.getAssetsPath(this.assetData);
                    this.audio = this.globalData.audioController.createAudio(n), this._currentTime = 0, this.globalData.audioController.addAudio(this), this.tm = t.tm ? PropertyFactory.getProp(this, t.tm, 0, e.frameRate, this) : {_placeholder: !0}
                }

                function FootageElement(t, e, i) {
                    this.initFrame(), this.initRenderable(), this.assetData = e.getAssetData(t.refId), this.footageData = e.imageLoader.getAsset(this.assetData), this.initBaseData(t, e, i)
                }

                function SVGCompElement(t, e, i) {
                    this.layers = t.layers, this.supports3d = !0, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(t, e, i), this.tm = t.tm ? PropertyFactory.getProp(this, t.tm, 0, e.frameRate, this) : {_placeholder: !0}
                }

                function SVGTextLottieElement(t, e, i) {
                    this.textSpans = [], this.renderType = "svg", this.initElement(t, e, i)
                }

                function SVGShapeElement(t, e, i) {
                    this.shapes = [], this.shapesData = t.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.initElement(t, e, i), this.prevViewData = []
                }

                function SVGTintFilter(t, e) {
                    this.filterManager = e;
                    var i = createNS("feColorMatrix");
                    if (i.setAttribute("type", "matrix"), i.setAttribute("color-interpolation-filters", "linearRGB"), i.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"), i.setAttribute("result", "f1"), t.appendChild(i), (i = createNS("feColorMatrix")).setAttribute("type", "matrix"), i.setAttribute("color-interpolation-filters", "sRGB"), i.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), i.setAttribute("result", "f2"), t.appendChild(i), this.matrixFilter = i, 100 !== e.effectElements[2].p.v || e.effectElements[2].p.k) {
                        var n, r = createNS("feMerge");
                        t.appendChild(r), (n = createNS("feMergeNode")).setAttribute("in", "SourceGraphic"), r.appendChild(n), (n = createNS("feMergeNode")).setAttribute("in", "f2"), r.appendChild(n)
                    }
                }

                function SVGFillFilter(t, e) {
                    this.filterManager = e;
                    var i = createNS("feColorMatrix");
                    i.setAttribute("type", "matrix"), i.setAttribute("color-interpolation-filters", "sRGB"), i.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), t.appendChild(i), this.matrixFilter = i
                }

                function SVGGaussianBlurEffect(t, e) {
                    t.setAttribute("x", "-100%"), t.setAttribute("y", "-100%"), t.setAttribute("width", "300%"), t.setAttribute("height", "300%"), this.filterManager = e;
                    var i = createNS("feGaussianBlur");
                    t.appendChild(i), this.feGaussianBlur = i
                }

                function SVGStrokeEffect(t, e) {
                    this.initialized = !1, this.filterManager = e, this.elem = t, this.paths = []
                }

                function SVGTritoneFilter(t, e) {
                    this.filterManager = e;
                    var i = createNS("feColorMatrix");
                    i.setAttribute("type", "matrix"), i.setAttribute("color-interpolation-filters", "linearRGB"), i.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"), i.setAttribute("result", "f1"), t.appendChild(i);
                    var n = createNS("feComponentTransfer");
                    n.setAttribute("color-interpolation-filters", "sRGB"), t.appendChild(n), this.matrixFilter = n;
                    var r = createNS("feFuncR");
                    r.setAttribute("type", "table"), n.appendChild(r), this.feFuncR = r;
                    var s = createNS("feFuncG");
                    s.setAttribute("type", "table"), n.appendChild(s), this.feFuncG = s;
                    var a = createNS("feFuncB");
                    a.setAttribute("type", "table"), n.appendChild(a), this.feFuncB = a
                }

                function SVGProLevelsFilter(t, e) {
                    this.filterManager = e;
                    var i = this.filterManager.effectElements, n = createNS("feComponentTransfer");
                    (i[10].p.k || 0 !== i[10].p.v || i[11].p.k || 1 !== i[11].p.v || i[12].p.k || 1 !== i[12].p.v || i[13].p.k || 0 !== i[13].p.v || i[14].p.k || 1 !== i[14].p.v) && (this.feFuncR = this.createFeFunc("feFuncR", n)), (i[17].p.k || 0 !== i[17].p.v || i[18].p.k || 1 !== i[18].p.v || i[19].p.k || 1 !== i[19].p.v || i[20].p.k || 0 !== i[20].p.v || i[21].p.k || 1 !== i[21].p.v) && (this.feFuncG = this.createFeFunc("feFuncG", n)), (i[24].p.k || 0 !== i[24].p.v || i[25].p.k || 1 !== i[25].p.v || i[26].p.k || 1 !== i[26].p.v || i[27].p.k || 0 !== i[27].p.v || i[28].p.k || 1 !== i[28].p.v) && (this.feFuncB = this.createFeFunc("feFuncB", n)), (i[31].p.k || 0 !== i[31].p.v || i[32].p.k || 1 !== i[32].p.v || i[33].p.k || 1 !== i[33].p.v || i[34].p.k || 0 !== i[34].p.v || i[35].p.k || 1 !== i[35].p.v) && (this.feFuncA = this.createFeFunc("feFuncA", n)), (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) && (n.setAttribute("color-interpolation-filters", "sRGB"), t.appendChild(n), n = createNS("feComponentTransfer")), (i[3].p.k || 0 !== i[3].p.v || i[4].p.k || 1 !== i[4].p.v || i[5].p.k || 1 !== i[5].p.v || i[6].p.k || 0 !== i[6].p.v || i[7].p.k || 1 !== i[7].p.v) && (n.setAttribute("color-interpolation-filters", "sRGB"), t.appendChild(n), this.feFuncRComposed = this.createFeFunc("feFuncR", n), this.feFuncGComposed = this.createFeFunc("feFuncG", n), this.feFuncBComposed = this.createFeFunc("feFuncB", n))
                }

                function SVGDropShadowEffect(t, e) {
                    var i = e.container.globalData.renderConfig.filterSize;
                    t.setAttribute("x", i.x), t.setAttribute("y", i.y), t.setAttribute("width", i.width), t.setAttribute("height", i.height), this.filterManager = e;
                    var n = createNS("feGaussianBlur");
                    n.setAttribute("in", "SourceAlpha"), n.setAttribute("result", "drop_shadow_1"), n.setAttribute("stdDeviation", "0"), this.feGaussianBlur = n, t.appendChild(n);
                    var r = createNS("feOffset");
                    r.setAttribute("dx", "25"), r.setAttribute("dy", "0"), r.setAttribute("in", "drop_shadow_1"), r.setAttribute("result", "drop_shadow_2"), this.feOffset = r, t.appendChild(r);
                    var s = createNS("feFlood");
                    s.setAttribute("flood-color", "#00ff00"), s.setAttribute("flood-opacity", "1"), s.setAttribute("result", "drop_shadow_3"), this.feFlood = s, t.appendChild(s);
                    var a = createNS("feComposite");
                    a.setAttribute("in", "drop_shadow_3"), a.setAttribute("in2", "drop_shadow_2"), a.setAttribute("operator", "in"), a.setAttribute("result", "drop_shadow_4"), t.appendChild(a);
                    var o, h = createNS("feMerge");
                    t.appendChild(h), o = createNS("feMergeNode"), h.appendChild(o), (o = createNS("feMergeNode")).setAttribute("in", "SourceGraphic"), this.feMergeNode = o, this.feMerge = h, this.originalNodeAdded = !1, h.appendChild(o)
                }

                ShapeTransformManager.prototype = {
                    addTransformSequence: function (t) {
                        var e, i = t.length, n = "_";
                        for (e = 0; e < i; e += 1) n += t[e].transform.key + "_";
                        var r = this.sequences[n];
                        return r || (r = {
                            transforms: [].concat(t),
                            finalTransform: new Matrix,
                            _mdf: !1
                        }, this.sequences[n] = r, this.sequenceList.push(r)), r
                    }, processSequence: function (t, e) {
                        for (var i, n = 0, r = t.transforms.length, s = e; n < r && !e;) {
                            if (t.transforms[n].transform.mProps._mdf) {
                                s = !0;
                                break
                            }
                            n += 1
                        }
                        if (s) for (t.finalTransform.reset(), n = r - 1; n >= 0; n -= 1) i = t.transforms[n].transform.mProps.v.props, t.finalTransform.transform(i[0], i[1], i[2], i[3], i[4], i[5], i[6], i[7], i[8], i[9], i[10], i[11], i[12], i[13], i[14], i[15]);
                        t._mdf = s
                    }, processSequences: function (t) {
                        var e, i = this.sequenceList.length;
                        for (e = 0; e < i; e += 1) this.processSequence(this.sequenceList[e], t)
                    }, getNewKey: function () {
                        return this.transform_key_count += 1, "_" + this.transform_key_count
                    }
                }, CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated, BaseElement.prototype = {
                    checkMasks: function () {
                        if (!this.data.hasMask) return !1;
                        for (var t = 0, e = this.data.masksProperties.length; t < e;) {
                            if ("n" !== this.data.masksProperties[t].mode && !1 !== this.data.masksProperties[t].cl) return !0;
                            t += 1
                        }
                        return !1
                    }, initExpressions: function () {
                        this.layerInterface = LayerExpressionInterface(this), this.data.hasMask && this.maskManager && this.layerInterface.registerMaskInterface(this.maskManager);
                        var t = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface);
                        this.layerInterface.registerEffectsInterface(t), 0 === this.data.ty || this.data.xt ? this.compInterface = CompExpressionInterface(this) : 4 === this.data.ty ? (this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface), this.layerInterface.content = this.layerInterface.shapeInterface) : 5 === this.data.ty && (this.layerInterface.textInterface = TextExpressionInterface(this), this.layerInterface.text = this.layerInterface.textInterface)
                    }, setBlendMode: function () {
                        var t = getBlendMode(this.data.bm);
                        (this.baseElement || this.layerElement).style["mix-blend-mode"] = t
                    }, initBaseData: function (t, e, i) {
                        this.globalData = e, this.comp = i, this.data = t, this.layerId = createElementID(), this.data.sr || (this.data.sr = 1), this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties)
                    }, getType: function () {
                        return this.type
                    }, sourceRectAtTime: function () {
                    }
                }, NullElement.prototype.prepareFrame = function (t) {
                    this.prepareProperties(t, !0)
                }, NullElement.prototype.renderFrame = function () {
                }, NullElement.prototype.getBaseElement = function () {
                    return null
                }, NullElement.prototype.destroy = function () {
                }, NullElement.prototype.sourceRectAtTime = function () {
                }, NullElement.prototype.hide = function () {
                }, extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement), SVGBaseElement.prototype = {
                    initRendererElement: function () {
                        this.layerElement = createNS("g")
                    }, createContainerElements: function () {
                        this.matteElement = createNS("g"), this.transformedElement = this.layerElement, this.maskedElement = this.layerElement, this._sizeChanged = !1;
                        var t, e, i, n = null;
                        if (this.data.td) {
                            if (3 == this.data.td || 1 == this.data.td) {
                                var r = createNS("mask");
                                r.setAttribute("id", this.layerId), r.setAttribute("mask-type", 3 == this.data.td ? "luminance" : "alpha"), r.appendChild(this.layerElement), n = r, this.globalData.defs.appendChild(r), featureSupport.maskType || 1 != this.data.td || (r.setAttribute("mask-type", "luminance"), t = createElementID(), e = filtersFactory.createFilter(t), this.globalData.defs.appendChild(e), e.appendChild(filtersFactory.createAlphaToLuminanceFilter()), (i = createNS("g")).appendChild(this.layerElement), n = i, r.appendChild(i), i.setAttribute("filter", "url(" + locationHref + "#" + t + ")"))
                            } else if (2 == this.data.td) {
                                var s = createNS("mask");
                                s.setAttribute("id", this.layerId), s.setAttribute("mask-type", "alpha");
                                var a = createNS("g");
                                s.appendChild(a), t = createElementID(), e = filtersFactory.createFilter(t);
                                var o = createNS("feComponentTransfer");
                                o.setAttribute("in", "SourceGraphic"), e.appendChild(o);
                                var h = createNS("feFuncA");
                                h.setAttribute("type", "table"), h.setAttribute("tableValues", "1.0 0.0"), o.appendChild(h), this.globalData.defs.appendChild(e);
                                var l = createNS("rect");
                                l.setAttribute("width", this.comp.data.w), l.setAttribute("height", this.comp.data.h), l.setAttribute("x", "0"), l.setAttribute("y", "0"), l.setAttribute("fill", "#ffffff"), l.setAttribute("opacity", "0"), a.setAttribute("filter", "url(" + locationHref + "#" + t + ")"), a.appendChild(l), a.appendChild(this.layerElement), n = a, featureSupport.maskType || (s.setAttribute("mask-type", "luminance"), e.appendChild(filtersFactory.createAlphaToLuminanceFilter()), i = createNS("g"), a.appendChild(l), i.appendChild(this.layerElement), n = i, a.appendChild(i)), this.globalData.defs.appendChild(s)
                            }
                        } else this.data.tt ? (this.matteElement.appendChild(this.layerElement), n = this.matteElement, this.baseElement = this.matteElement) : this.baseElement = this.layerElement;
                        if (this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), 0 === this.data.ty && !this.data.hd) {
                            var c = createNS("clipPath"), u = createNS("path");
                            u.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
                            var p = createElementID();
                            if (c.setAttribute("id", p), c.appendChild(u), this.globalData.defs.appendChild(c), this.checkMasks()) {
                                var d = createNS("g");
                                d.setAttribute("clip-path", "url(" + locationHref + "#" + p + ")"), d.appendChild(this.layerElement), this.transformedElement = d, n ? n.appendChild(this.transformedElement) : this.baseElement = this.transformedElement
                            } else this.layerElement.setAttribute("clip-path", "url(" + locationHref + "#" + p + ")")
                        }
                        0 !== this.data.bm && this.setBlendMode()
                    }, renderElement: function () {
                        this.finalTransform._matMdf && this.transformedElement.setAttribute("transform", this.finalTransform.mat.to2dCSS()), this.finalTransform._opMdf && this.transformedElement.setAttribute("opacity", this.finalTransform.mProp.o.v)
                    }, destroyBaseElement: function () {
                        this.layerElement = null, this.matteElement = null, this.maskManager.destroy()
                    }, getBaseElement: function () {
                        return this.data.hd ? null : this.baseElement
                    }, createRenderableComponents: function () {
                        this.maskManager = new MaskElement(this.data, this, this.globalData), this.renderableEffectsManager = new SVGEffects(this)
                    }, setMatte: function (t) {
                        this.matteElement && this.matteElement.setAttribute("mask", "url(" + locationHref + "#" + t + ")")
                    }
                }, IShapeElement.prototype = {
                    addShapeToModifiers: function (t) {
                        var e, i = this.shapeModifiers.length;
                        for (e = 0; e < i; e += 1) this.shapeModifiers[e].addShape(t)
                    }, isShapeInAnimatedModifiers: function (t) {
                        for (var e = this.shapeModifiers.length; 0 < e;) if (this.shapeModifiers[0].isAnimatedWithShape(t)) return !0;
                        return !1
                    }, renderModifiers: function () {
                        if (this.shapeModifiers.length) {
                            var t, e = this.shapes.length;
                            for (t = 0; t < e; t += 1) this.shapes[t].sh.reset();
                            for (t = (e = this.shapeModifiers.length) - 1; t >= 0 && !this.shapeModifiers[t].processShapes(this._isFirstFrame); t -= 1) ;
                        }
                    }, searchProcessedElement: function (t) {
                        for (var e = this.processedElements, i = 0, n = e.length; i < n;) {
                            if (e[i].elem === t) return e[i].pos;
                            i += 1
                        }
                        return 0
                    }, addProcessedElement: function (t, e) {
                        for (var i = this.processedElements, n = i.length; n;) if (i[n -= 1].elem === t) return void (i[n].pos = e);
                        i.push(new ProcessedElement(t, e))
                    }, prepareFrame: function (t) {
                        this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange)
                    }
                }, ITextElement.prototype.initElement = function (t, e, i) {
                    this.lettersChangedFlag = !0, this.initFrame(), this.initBaseData(t, e, i), this.textProperty = new TextProperty(this, t.t, this.dynamicProperties), this.textAnimator = new TextAnimatorProperty(t.t, this.renderType, this), this.initTransform(t, e, i), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide(), this.textAnimator.searchProperties(this.dynamicProperties)
                }, ITextElement.prototype.prepareFrame = function (t) {
                    this._mdf = !1, this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange), (this.textProperty._mdf || this.textProperty._isFirstFrame) && (this.buildNewText(), this.textProperty._isFirstFrame = !1, this.textProperty._mdf = !1)
                }, ITextElement.prototype.createPathShape = function (t, e) {
                    var i, n, r = e.length, s = "";
                    for (i = 0; i < r; i += 1) n = e[i].ks.k, s += buildShapeString(n, n.i.length, !0, t);
                    return s
                }, ITextElement.prototype.updateDocumentData = function (t, e) {
                    this.textProperty.updateDocumentData(t, e)
                }, ITextElement.prototype.canResizeFont = function (t) {
                    this.textProperty.canResizeFont(t)
                }, ITextElement.prototype.setMinimumFontSize = function (t) {
                    this.textProperty.setMinimumFontSize(t)
                }, ITextElement.prototype.applyTextPropertiesToMatrix = function (t, e, i, n, r) {
                    switch (t.ps && e.translate(t.ps[0], t.ps[1] + t.ascent, 0), e.translate(0, -t.ls, 0), t.j) {
                        case 1:
                            e.translate(t.justifyOffset + (t.boxWidth - t.lineWidths[i]), 0, 0);
                            break;
                        case 2:
                            e.translate(t.justifyOffset + (t.boxWidth - t.lineWidths[i]) / 2, 0, 0)
                    }
                    e.translate(n, r, 0)
                }, ITextElement.prototype.buildColor = function (t) {
                    return "rgb(" + Math.round(255 * t[0]) + "," + Math.round(255 * t[1]) + "," + Math.round(255 * t[2]) + ")"
                }, ITextElement.prototype.emptyProp = new LetterProps, ITextElement.prototype.destroy = function () {
                }, extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement), ICompElement.prototype.initElement = function (t, e, i) {
                    this.initFrame(), this.initBaseData(t, e, i), this.initTransform(t, e, i), this.initRenderable(), this.initHierarchy(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), !this.data.xt && e.progressiveLoad || this.buildAllItems(), this.hide()
                }, ICompElement.prototype.prepareFrame = function (t) {
                    if (this._mdf = !1, this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange), this.isInRange || this.data.xt) {
                        if (this.tm._placeholder) this.renderedFrame = t / this.data.sr; else {
                            var e = this.tm.v;
                            e === this.data.op && (e = this.data.op - 1), this.renderedFrame = e
                        }
                        var i, n = this.elements.length;
                        for (this.completeLayers || this.checkLayers(this.renderedFrame), i = n - 1; i >= 0; i -= 1) (this.completeLayers || this.elements[i]) && (this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st), this.elements[i]._mdf && (this._mdf = !0))
                    }
                }, ICompElement.prototype.renderInnerContent = function () {
                    var t, e = this.layers.length;
                    for (t = 0; t < e; t += 1) (this.completeLayers || this.elements[t]) && this.elements[t].renderFrame()
                }, ICompElement.prototype.setElements = function (t) {
                    this.elements = t
                }, ICompElement.prototype.getElements = function () {
                    return this.elements
                }, ICompElement.prototype.destroyElements = function () {
                    var t, e = this.layers.length;
                    for (t = 0; t < e; t += 1) this.elements[t] && this.elements[t].destroy()
                }, ICompElement.prototype.destroy = function () {
                    this.destroyElements(), this.destroyBaseElement()
                }, extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement), IImageElement.prototype.createContent = function () {
                    var t = this.globalData.getAssetsPath(this.assetData);
                    this.innerElem = createNS("image"), this.innerElem.setAttribute("width", this.assetData.w + "px"), this.innerElem.setAttribute("height", this.assetData.h + "px"), this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio), this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", t), this.layerElement.appendChild(this.innerElem)
                }, IImageElement.prototype.sourceRectAtTime = function () {
                    return this.sourceRect
                }, extendPrototype([IImageElement], ISolidElement), ISolidElement.prototype.createContent = function () {
                    var t = createNS("rect");
                    t.setAttribute("width", this.data.sw), t.setAttribute("height", this.data.sh), t.setAttribute("fill", this.data.sc), this.layerElement.appendChild(t)
                }, AudioElement.prototype.prepareFrame = function (t) {
                    if (this.prepareRenderableFrame(t, !0), this.prepareProperties(t, !0), this.tm._placeholder) this._currentTime = t / this.data.sr; else {
                        var e = this.tm.v;
                        this._currentTime = e
                    }
                }, extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement), AudioElement.prototype.renderFrame = function () {
                    this.isInRange && this._canPlay && (this._isPlaying ? (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > .1) && this.audio.seek(this._currentTime / this.globalData.frameRate) : (this.audio.play(), this.audio.seek(this._currentTime / this.globalData.frameRate), this._isPlaying = !0))
                }, AudioElement.prototype.show = function () {
                }, AudioElement.prototype.hide = function () {
                    this.audio.pause(), this._isPlaying = !1
                }, AudioElement.prototype.pause = function () {
                    this.audio.pause(), this._isPlaying = !1, this._canPlay = !1
                }, AudioElement.prototype.resume = function () {
                    this._canPlay = !0
                }, AudioElement.prototype.setRate = function (t) {
                    this.audio.rate(t)
                }, AudioElement.prototype.volume = function (t) {
                    this.audio.volume(t)
                }, AudioElement.prototype.getBaseElement = function () {
                    return null
                }, AudioElement.prototype.destroy = function () {
                }, AudioElement.prototype.sourceRectAtTime = function () {
                }, AudioElement.prototype.initExpressions = function () {
                }, FootageElement.prototype.prepareFrame = function () {
                }, extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement), FootageElement.prototype.getBaseElement = function () {
                    return null
                }, FootageElement.prototype.renderFrame = function () {
                }, FootageElement.prototype.destroy = function () {
                }, FootageElement.prototype.initExpressions = function () {
                    this.layerInterface = FootageInterface(this)
                }, FootageElement.prototype.getFootageData = function () {
                    return this.footageData
                }, extendPrototype([SVGRenderer, ICompElement, SVGBaseElement], SVGCompElement), extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement), SVGTextLottieElement.prototype.createContent = function () {
                    this.data.singleShape && !this.globalData.fontManager.chars && (this.textContainer = createNS("text"))
                }, SVGTextLottieElement.prototype.buildTextContents = function (t) {
                    for (var e = 0, i = t.length, n = [], r = ""; e < i;) t[e] === String.fromCharCode(13) || t[e] === String.fromCharCode(3) ? (n.push(r), r = "") : r += t[e], e += 1;
                    return n.push(r), n
                }, SVGTextLottieElement.prototype.buildNewText = function () {
                    var t, e, i = this.textProperty.currentData;
                    this.renderedLetters = createSizedArray(i ? i.l.length : 0), i.fc ? this.layerElement.setAttribute("fill", this.buildColor(i.fc)) : this.layerElement.setAttribute("fill", "rgba(0,0,0,0)"), i.sc && (this.layerElement.setAttribute("stroke", this.buildColor(i.sc)), this.layerElement.setAttribute("stroke-width", i.sw)), this.layerElement.setAttribute("font-size", i.finalSize);
                    var n = this.globalData.fontManager.getFontByName(i.f);
                    if (n.fClass) this.layerElement.setAttribute("class", n.fClass); else {
                        this.layerElement.setAttribute("font-family", n.fFamily);
                        var r = i.fWeight, s = i.fStyle;
                        this.layerElement.setAttribute("font-style", s), this.layerElement.setAttribute("font-weight", r)
                    }
                    this.layerElement.setAttribute("aria-label", i.t);
                    var a, o = i.l || [], h = !!this.globalData.fontManager.chars;
                    e = o.length;
                    var l, c = this.mHelper, u = "", p = this.data.singleShape, d = 0, f = 0, m = !0,
                        g = .001 * i.tr * i.finalSize;
                    if (!p || h || i.sz) {
                        var v, y, b = this.textSpans.length;
                        for (t = 0; t < e; t += 1) h && p && 0 !== t || (a = b > t ? this.textSpans[t] : createNS(h ? "path" : "text"), b <= t && (a.setAttribute("stroke-linecap", "butt"), a.setAttribute("stroke-linejoin", "round"), a.setAttribute("stroke-miterlimit", "4"), this.textSpans[t] = a, this.layerElement.appendChild(a)), a.style.display = "inherit"), c.reset(), c.scale(i.finalSize / 100, i.finalSize / 100), p && (o[t].n && (d = -g, f += i.yOffset, f += m ? 1 : 0, m = !1), this.applyTextPropertiesToMatrix(i, c, o[t].line, d, f), d += o[t].l || 0, d += g), h ? (l = (v = (y = this.globalData.fontManager.getCharData(i.finalText[t], n.fStyle, this.globalData.fontManager.getFontByName(i.f).fFamily)) && y.data || {}).shapes ? v.shapes[0].it : [], p ? u += this.createPathShape(c, l) : a.setAttribute("d", this.createPathShape(c, l))) : (p && a.setAttribute("transform", "translate(" + c.props[12] + "," + c.props[13] + ")"), a.textContent = o[t].val, a.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"));
                        p && a && a.setAttribute("d", u)
                    } else {
                        var x = this.textContainer, w = "start";
                        switch (i.j) {
                            case 1:
                                w = "end";
                                break;
                            case 2:
                                w = "middle";
                                break;
                            default:
                                w = "start"
                        }
                        x.setAttribute("text-anchor", w), x.setAttribute("letter-spacing", g);
                        var _ = this.buildTextContents(i.finalText);
                        for (e = _.length, f = i.ps ? i.ps[1] + i.ascent : 0, t = 0; t < e; t += 1) (a = this.textSpans[t] || createNS("tspan")).textContent = _[t], a.setAttribute("x", 0), a.setAttribute("y", f), a.style.display = "inherit", x.appendChild(a), this.textSpans[t] = a, f += i.finalLineHeight;
                        this.layerElement.appendChild(x)
                    }
                    for (; t < this.textSpans.length;) this.textSpans[t].style.display = "none", t += 1;
                    this._sizeChanged = !0
                }, SVGTextLottieElement.prototype.sourceRectAtTime = function () {
                    if (this.prepareFrame(this.comp.renderedFrame - this.data.st), this.renderInnerContent(), this._sizeChanged) {
                        this._sizeChanged = !1;
                        var t = this.layerElement.getBBox();
                        this.bbox = {top: t.y, left: t.x, width: t.width, height: t.height}
                    }
                    return this.bbox
                }, SVGTextLottieElement.prototype.renderInnerContent = function () {
                    if (!this.data.singleShape && (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), this.lettersChangedFlag || this.textAnimator.lettersChangedFlag)) {
                        var t, e;
                        this._sizeChanged = !0;
                        var i, n, r = this.textAnimator.renderedLetters, s = this.textProperty.currentData.l;
                        for (e = s.length, t = 0; t < e; t += 1) s[t].n || (i = r[t], n = this.textSpans[t], i._mdf.m && n.setAttribute("transform", i.m), i._mdf.o && n.setAttribute("opacity", i.o), i._mdf.sw && n.setAttribute("stroke-width", i.sw), i._mdf.sc && n.setAttribute("stroke", i.sc), i._mdf.fc && n.setAttribute("fill", i.fc))
                    }
                }, extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement), SVGShapeElement.prototype.initSecondaryElement = function () {
                }, SVGShapeElement.prototype.identityMatrix = new Matrix, SVGShapeElement.prototype.buildExpressionInterface = function () {
                }, SVGShapeElement.prototype.createContent = function () {
                    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes()
                }, SVGShapeElement.prototype.filterUniqueShapes = function () {
                    var t, e, i, n, r = this.shapes.length, s = this.stylesList.length, a = [], o = !1;
                    for (i = 0; i < s; i += 1) {
                        for (n = this.stylesList[i], o = !1, a.length = 0, t = 0; t < r; t += 1) -1 !== (e = this.shapes[t]).styles.indexOf(n) && (a.push(e), o = e._isAnimated || o);
                        a.length > 1 && o && this.setShapesAsAnimated(a)
                    }
                }, SVGShapeElement.prototype.setShapesAsAnimated = function (t) {
                    var e, i = t.length;
                    for (e = 0; e < i; e += 1) t[e].setAsAnimated()
                }, SVGShapeElement.prototype.createStyleElement = function (t, e) {
                    var i, n = new SVGStyleData(t, e), r = n.pElem;
                    return "st" === t.ty ? i = new SVGStrokeStyleData(this, t, n) : "fl" === t.ty ? i = new SVGFillStyleData(this, t, n) : "gf" !== t.ty && "gs" !== t.ty || (i = new ("gf" === t.ty ? SVGGradientFillStyleData : SVGGradientStrokeStyleData)(this, t, n), this.globalData.defs.appendChild(i.gf), i.maskId && (this.globalData.defs.appendChild(i.ms), this.globalData.defs.appendChild(i.of), r.setAttribute("mask", "url(" + locationHref + "#" + i.maskId + ")"))), "st" !== t.ty && "gs" !== t.ty || (r.setAttribute("stroke-linecap", lineCapEnum[t.lc || 2]), r.setAttribute("stroke-linejoin", lineJoinEnum[t.lj || 2]), r.setAttribute("fill-opacity", "0"), 1 === t.lj && r.setAttribute("stroke-miterlimit", t.ml)), 2 === t.r && r.setAttribute("fill-rule", "evenodd"), t.ln && r.setAttribute("id", t.ln), t.cl && r.setAttribute("class", t.cl), t.bm && (r.style["mix-blend-mode"] = getBlendMode(t.bm)), this.stylesList.push(n), this.addToAnimatedContents(t, i), i
                }, SVGShapeElement.prototype.createGroupElement = function (t) {
                    var e = new ShapeGroupData;
                    return t.ln && e.gr.setAttribute("id", t.ln), t.cl && e.gr.setAttribute("class", t.cl), t.bm && (e.gr.style["mix-blend-mode"] = getBlendMode(t.bm)), e
                }, SVGShapeElement.prototype.createTransformElement = function (t, e) {
                    var i = TransformPropertyFactory.getTransformProperty(this, t, this),
                        n = new SVGTransformData(i, i.o, e);
                    return this.addToAnimatedContents(t, n), n
                }, SVGShapeElement.prototype.createShapeElement = function (t, e, i) {
                    var n = 4;
                    "rc" === t.ty ? n = 5 : "el" === t.ty ? n = 6 : "sr" === t.ty && (n = 7);
                    var r = new SVGShapeData(e, i, ShapePropertyFactory.getShapeProp(this, t, n, this));
                    return this.shapes.push(r), this.addShapeToModifiers(r), this.addToAnimatedContents(t, r), r
                }, SVGShapeElement.prototype.addToAnimatedContents = function (t, e) {
                    for (var i = 0, n = this.animatedContents.length; i < n;) {
                        if (this.animatedContents[i].element === e) return;
                        i += 1
                    }
                    this.animatedContents.push({fn: SVGElementsRenderer.createRenderFunction(t), element: e, data: t})
                }, SVGShapeElement.prototype.setElementStyles = function (t) {
                    var e, i = t.styles, n = this.stylesList.length;
                    for (e = 0; e < n; e += 1) this.stylesList[e].closed || i.push(this.stylesList[e])
                }, SVGShapeElement.prototype.reloadShapes = function () {
                    var t;
                    this._isFirstFrame = !0;
                    var e = this.itemsData.length;
                    for (t = 0; t < e; t += 1) this.prevViewData[t] = this.itemsData[t];
                    for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes(), e = this.dynamicProperties.length, t = 0; t < e; t += 1) this.dynamicProperties[t].getValue();
                    this.renderModifiers()
                }, SVGShapeElement.prototype.searchShapes = function (t, e, i, n, r, s, a) {
                    var o, h, l, c, u, p, d = [].concat(s), f = t.length - 1, m = [], g = [];
                    for (o = f; o >= 0; o -= 1) {
                        if ((p = this.searchProcessedElement(t[o])) ? e[o] = i[p - 1] : t[o]._render = a, "fl" === t[o].ty || "st" === t[o].ty || "gf" === t[o].ty || "gs" === t[o].ty) p ? e[o].style.closed = !1 : e[o] = this.createStyleElement(t[o], r), t[o]._render && e[o].style.pElem.parentNode !== n && n.appendChild(e[o].style.pElem), m.push(e[o].style); else if ("gr" === t[o].ty) {
                            if (p) for (l = e[o].it.length, h = 0; h < l; h += 1) e[o].prevViewData[h] = e[o].it[h]; else e[o] = this.createGroupElement(t[o]);
                            this.searchShapes(t[o].it, e[o].it, e[o].prevViewData, e[o].gr, r + 1, d, a), t[o]._render && e[o].gr.parentNode !== n && n.appendChild(e[o].gr)
                        } else "tr" === t[o].ty ? (p || (e[o] = this.createTransformElement(t[o], n)), c = e[o].transform, d.push(c)) : "sh" === t[o].ty || "rc" === t[o].ty || "el" === t[o].ty || "sr" === t[o].ty ? (p || (e[o] = this.createShapeElement(t[o], d, r)), this.setElementStyles(e[o])) : "tm" === t[o].ty || "rd" === t[o].ty || "ms" === t[o].ty || "pb" === t[o].ty ? (p ? (u = e[o]).closed = !1 : ((u = ShapeModifiers.getModifier(t[o].ty)).init(this, t[o]), e[o] = u, this.shapeModifiers.push(u)), g.push(u)) : "rp" === t[o].ty && (p ? (u = e[o]).closed = !0 : (u = ShapeModifiers.getModifier(t[o].ty), e[o] = u, u.init(this, t, o, e), this.shapeModifiers.push(u), a = !1), g.push(u));
                        this.addProcessedElement(t[o], o + 1)
                    }
                    for (f = m.length, o = 0; o < f; o += 1) m[o].closed = !0;
                    for (f = g.length, o = 0; o < f; o += 1) g[o].closed = !0
                }, SVGShapeElement.prototype.renderInnerContent = function () {
                    var t;
                    this.renderModifiers();
                    var e = this.stylesList.length;
                    for (t = 0; t < e; t += 1) this.stylesList[t].reset();
                    for (this.renderShape(), t = 0; t < e; t += 1) (this.stylesList[t]._mdf || this._isFirstFrame) && (this.stylesList[t].msElem && (this.stylesList[t].msElem.setAttribute("d", this.stylesList[t].d), this.stylesList[t].d = "M0 0" + this.stylesList[t].d), this.stylesList[t].pElem.setAttribute("d", this.stylesList[t].d || "M0 0"))
                }, SVGShapeElement.prototype.renderShape = function () {
                    var t, e, i = this.animatedContents.length;
                    for (t = 0; t < i; t += 1) e = this.animatedContents[t], (this._isFirstFrame || e.element._isAnimated) && !0 !== e.data && e.fn(e.data, e.element, this._isFirstFrame)
                }, SVGShapeElement.prototype.destroy = function () {
                    this.destroyBaseElement(), this.shapesData = null, this.itemsData = null
                }, SVGTintFilter.prototype.renderFrame = function (t) {
                    if (t || this.filterManager._mdf) {
                        var e = this.filterManager.effectElements[0].p.v, i = this.filterManager.effectElements[1].p.v,
                            n = this.filterManager.effectElements[2].p.v / 100;
                        this.matrixFilter.setAttribute("values", i[0] - e[0] + " 0 0 0 " + e[0] + " " + (i[1] - e[1]) + " 0 0 0 " + e[1] + " " + (i[2] - e[2]) + " 0 0 0 " + e[2] + " 0 0 0 " + n + " 0")
                    }
                }, SVGFillFilter.prototype.renderFrame = function (t) {
                    if (t || this.filterManager._mdf) {
                        var e = this.filterManager.effectElements[2].p.v, i = this.filterManager.effectElements[6].p.v;
                        this.matrixFilter.setAttribute("values", "0 0 0 0 " + e[0] + " 0 0 0 0 " + e[1] + " 0 0 0 0 " + e[2] + " 0 0 0 " + i + " 0")
                    }
                }, SVGGaussianBlurEffect.prototype.renderFrame = function (t) {
                    if (t || this.filterManager._mdf) {
                        var e = .3 * this.filterManager.effectElements[0].p.v,
                            i = this.filterManager.effectElements[1].p.v, n = 3 == i ? 0 : e, r = 2 == i ? 0 : e;
                        this.feGaussianBlur.setAttribute("stdDeviation", n + " " + r);
                        var s = 1 == this.filterManager.effectElements[2].p.v ? "wrap" : "duplicate";
                        this.feGaussianBlur.setAttribute("edgeMode", s)
                    }
                }, SVGStrokeEffect.prototype.initialize = function () {
                    var t, e, i, n, r = this.elem.layerElement.children || this.elem.layerElement.childNodes;
                    for (1 === this.filterManager.effectElements[1].p.v ? (n = this.elem.maskManager.masksProperties.length, i = 0) : n = 1 + (i = this.filterManager.effectElements[0].p.v - 1), (e = createNS("g")).setAttribute("fill", "none"), e.setAttribute("stroke-linecap", "round"), e.setAttribute("stroke-dashoffset", 1); i < n; i += 1) t = createNS("path"), e.appendChild(t), this.paths.push({
                        p: t,
                        m: i
                    });
                    if (3 === this.filterManager.effectElements[10].p.v) {
                        var s = createNS("mask"), a = createElementID();
                        s.setAttribute("id", a), s.setAttribute("mask-type", "alpha"), s.appendChild(e), this.elem.globalData.defs.appendChild(s);
                        var o = createNS("g");
                        for (o.setAttribute("mask", "url(" + locationHref + "#" + a + ")"); r[0];) o.appendChild(r[0]);
                        this.elem.layerElement.appendChild(o), this.masker = s, e.setAttribute("stroke", "#fff")
                    } else if (1 === this.filterManager.effectElements[10].p.v || 2 === this.filterManager.effectElements[10].p.v) {
                        if (2 === this.filterManager.effectElements[10].p.v) for (r = this.elem.layerElement.children || this.elem.layerElement.childNodes; r.length;) this.elem.layerElement.removeChild(r[0]);
                        this.elem.layerElement.appendChild(e), this.elem.layerElement.removeAttribute("mask"), e.setAttribute("stroke", "#fff")
                    }
                    this.initialized = !0, this.pathMasker = e
                }, SVGStrokeEffect.prototype.renderFrame = function (t) {
                    var e;
                    this.initialized || this.initialize();
                    var i, n, r = this.paths.length;
                    for (e = 0; e < r; e += 1) if (-1 !== this.paths[e].m && (i = this.elem.maskManager.viewData[this.paths[e].m], n = this.paths[e].p, (t || this.filterManager._mdf || i.prop._mdf) && n.setAttribute("d", i.lastPath), t || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || i.prop._mdf)) {
                        var s;
                        if (0 !== this.filterManager.effectElements[7].p.v || 100 !== this.filterManager.effectElements[8].p.v) {
                            var a = .01 * Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v),
                                o = .01 * Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v),
                                h = n.getTotalLength();
                            s = "0 0 0 " + h * a + " ";
                            var l, c = h * (o - a),
                                u = 1 + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v * .01,
                                p = Math.floor(c / u);
                            for (l = 0; l < p; l += 1) s += "1 " + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v * .01 + " ";
                            s += "0 " + 10 * h + " 0 0"
                        } else s = "1 " + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v * .01;
                        n.setAttribute("stroke-dasharray", s)
                    }
                    if ((t || this.filterManager.effectElements[4].p._mdf) && this.pathMasker.setAttribute("stroke-width", 2 * this.filterManager.effectElements[4].p.v), (t || this.filterManager.effectElements[6].p._mdf) && this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v), (1 === this.filterManager.effectElements[10].p.v || 2 === this.filterManager.effectElements[10].p.v) && (t || this.filterManager.effectElements[3].p._mdf)) {
                        var d = this.filterManager.effectElements[3].p.v;
                        this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(255 * d[0]) + "," + bmFloor(255 * d[1]) + "," + bmFloor(255 * d[2]) + ")")
                    }
                }, SVGTritoneFilter.prototype.renderFrame = function (t) {
                    if (t || this.filterManager._mdf) {
                        var e = this.filterManager.effectElements[0].p.v, i = this.filterManager.effectElements[1].p.v,
                            n = this.filterManager.effectElements[2].p.v, r = n[0] + " " + i[0] + " " + e[0],
                            s = n[1] + " " + i[1] + " " + e[1], a = n[2] + " " + i[2] + " " + e[2];
                        this.feFuncR.setAttribute("tableValues", r), this.feFuncG.setAttribute("tableValues", s), this.feFuncB.setAttribute("tableValues", a)
                    }
                }, SVGProLevelsFilter.prototype.createFeFunc = function (t, e) {
                    var i = createNS(t);
                    return i.setAttribute("type", "table"), e.appendChild(i), i
                }, SVGProLevelsFilter.prototype.getTableValue = function (t, e, i, n, r) {
                    for (var s, a, o = 0, h = Math.min(t, e), l = Math.max(t, e), c = Array.call(null, {length: 256}), u = 0, p = r - n, d = e - t; o <= 256;) a = (s = o / 256) <= h ? d < 0 ? r : n : s >= l ? d < 0 ? n : r : n + p * Math.pow((s - t) / d, 1 / i), c[u] = a, u += 1, o += 256 / 255;
                    return c.join(" ")
                }, SVGProLevelsFilter.prototype.renderFrame = function (t) {
                    if (t || this.filterManager._mdf) {
                        var e, i = this.filterManager.effectElements;
                        this.feFuncRComposed && (t || i[3].p._mdf || i[4].p._mdf || i[5].p._mdf || i[6].p._mdf || i[7].p._mdf) && (e = this.getTableValue(i[3].p.v, i[4].p.v, i[5].p.v, i[6].p.v, i[7].p.v), this.feFuncRComposed.setAttribute("tableValues", e), this.feFuncGComposed.setAttribute("tableValues", e), this.feFuncBComposed.setAttribute("tableValues", e)), this.feFuncR && (t || i[10].p._mdf || i[11].p._mdf || i[12].p._mdf || i[13].p._mdf || i[14].p._mdf) && (e = this.getTableValue(i[10].p.v, i[11].p.v, i[12].p.v, i[13].p.v, i[14].p.v), this.feFuncR.setAttribute("tableValues", e)), this.feFuncG && (t || i[17].p._mdf || i[18].p._mdf || i[19].p._mdf || i[20].p._mdf || i[21].p._mdf) && (e = this.getTableValue(i[17].p.v, i[18].p.v, i[19].p.v, i[20].p.v, i[21].p.v), this.feFuncG.setAttribute("tableValues", e)), this.feFuncB && (t || i[24].p._mdf || i[25].p._mdf || i[26].p._mdf || i[27].p._mdf || i[28].p._mdf) && (e = this.getTableValue(i[24].p.v, i[25].p.v, i[26].p.v, i[27].p.v, i[28].p.v), this.feFuncB.setAttribute("tableValues", e)), this.feFuncA && (t || i[31].p._mdf || i[32].p._mdf || i[33].p._mdf || i[34].p._mdf || i[35].p._mdf) && (e = this.getTableValue(i[31].p.v, i[32].p.v, i[33].p.v, i[34].p.v, i[35].p.v), this.feFuncA.setAttribute("tableValues", e))
                    }
                }, SVGDropShadowEffect.prototype.renderFrame = function (t) {
                    if (t || this.filterManager._mdf) {
                        if ((t || this.filterManager.effectElements[4].p._mdf) && this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4), t || this.filterManager.effectElements[0].p._mdf) {
                            var e = this.filterManager.effectElements[0].p.v;
                            this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(255 * e[0]), Math.round(255 * e[1]), Math.round(255 * e[2])))
                        }
                        if ((t || this.filterManager.effectElements[1].p._mdf) && this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255), t || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
                            var i = this.filterManager.effectElements[3].p.v,
                                n = (this.filterManager.effectElements[2].p.v - 90) * degToRads, r = i * Math.cos(n),
                                s = i * Math.sin(n);
                            this.feOffset.setAttribute("dx", r), this.feOffset.setAttribute("dy", s)
                        }
                    }
                };
                var _svgMatteSymbols = [];

                function SVGMatte3Effect(t, e, i) {
                    this.initialized = !1, this.filterManager = e, this.filterElem = t, this.elem = i, i.matteElement = createNS("g"), i.matteElement.appendChild(i.layerElement), i.matteElement.appendChild(i.transformedElement), i.baseElement = i.matteElement
                }

                function SVGEffects(t) {
                    var e, i, n = t.data.ef ? t.data.ef.length : 0, r = createElementID(),
                        s = filtersFactory.createFilter(r, !0), a = 0;
                    for (this.filters = [], e = 0; e < n; e += 1) i = null, 20 === t.data.ef[e].ty ? (a += 1, i = new SVGTintFilter(s, t.effectsManager.effectElements[e])) : 21 === t.data.ef[e].ty ? (a += 1, i = new SVGFillFilter(s, t.effectsManager.effectElements[e])) : 22 === t.data.ef[e].ty ? i = new SVGStrokeEffect(t, t.effectsManager.effectElements[e]) : 23 === t.data.ef[e].ty ? (a += 1, i = new SVGTritoneFilter(s, t.effectsManager.effectElements[e])) : 24 === t.data.ef[e].ty ? (a += 1, i = new SVGProLevelsFilter(s, t.effectsManager.effectElements[e])) : 25 === t.data.ef[e].ty ? (a += 1, i = new SVGDropShadowEffect(s, t.effectsManager.effectElements[e])) : 28 === t.data.ef[e].ty ? i = new SVGMatte3Effect(s, t.effectsManager.effectElements[e], t) : 29 === t.data.ef[e].ty && (a += 1, i = new SVGGaussianBlurEffect(s, t.effectsManager.effectElements[e])), i && this.filters.push(i);
                    a && (t.globalData.defs.appendChild(s), t.layerElement.setAttribute("filter", "url(" + locationHref + "#" + r + ")")), this.filters.length && t.addRenderableComponent(this)
                }

                function CVContextData() {
                    var t;
                    for (this.saved = [], this.cArrPos = 0, this.cTr = new Matrix, this.cO = 1, this.savedOp = createTypedArray("float32", 15), t = 0; t < 15; t += 1) this.saved[t] = createTypedArray("float32", 16);
                    this._length = 15
                }

                function CVBaseElement() {
                }

                function CVImageElement(t, e, i) {
                    this.assetData = e.getAssetData(t.refId), this.img = e.imageLoader.getAsset(this.assetData), this.initElement(t, e, i)
                }

                function CVCompElement(t, e, i) {
                    this.completeLayers = !1, this.layers = t.layers, this.pendingElements = [], this.elements = createSizedArray(this.layers.length), this.initElement(t, e, i), this.tm = t.tm ? PropertyFactory.getProp(this, t.tm, 0, e.frameRate, this) : {_placeholder: !0}
                }

                function CVMaskElement(t, e) {
                    var i;
                    this.data = t, this.element = e, this.masksProperties = this.data.masksProperties || [], this.viewData = createSizedArray(this.masksProperties.length);
                    var n = this.masksProperties.length, r = !1;
                    for (i = 0; i < n; i += 1) "n" !== this.masksProperties[i].mode && (r = !0), this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i], 3);
                    this.hasMasks = r, r && this.element.addRenderableComponent(this)
                }

                function CVShapeElement(t, e, i) {
                    this.shapes = [], this.shapesData = t.shapes, this.stylesList = [], this.itemsData = [], this.prevViewData = [], this.shapeModifiers = [], this.processedElements = [], this.transformsManager = new ShapeTransformManager, this.initElement(t, e, i)
                }

                function CVSolidElement(t, e, i) {
                    this.initElement(t, e, i)
                }

                function CVTextElement(t, e, i) {
                    this.textSpans = [], this.yOffset = 0, this.fillColorAnim = !1, this.strokeColorAnim = !1, this.strokeWidthAnim = !1, this.stroke = !1, this.fill = !1, this.justifyOffset = 0, this.currentRender = null, this.renderType = "canvas", this.values = {
                        fill: "rgba(0,0,0,0)",
                        stroke: "rgba(0,0,0,0)",
                        sWidth: 0,
                        fValue: ""
                    }, this.initElement(t, e, i)
                }

                function CVEffects() {
                }

                function HBaseElement() {
                }

                function HSolidElement(t, e, i) {
                    this.initElement(t, e, i)
                }

                function HCompElement(t, e, i) {
                    this.layers = t.layers, this.supports3d = !t.hasMask, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(t, e, i), this.tm = t.tm ? PropertyFactory.getProp(this, t.tm, 0, e.frameRate, this) : {_placeholder: !0}
                }

                function HShapeElement(t, e, i) {
                    this.shapes = [], this.shapesData = t.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.shapesContainer = createNS("g"), this.initElement(t, e, i), this.prevViewData = [], this.currentBBox = {
                        x: 999999,
                        y: -999999,
                        h: 0,
                        w: 0
                    }
                }

                function HTextElement(t, e, i) {
                    this.textSpans = [], this.textPaths = [], this.currentBBox = {
                        x: 999999,
                        y: -999999,
                        h: 0,
                        w: 0
                    }, this.renderType = "svg", this.isMasked = !1, this.initElement(t, e, i)
                }

                function HImageElement(t, e, i) {
                    this.assetData = e.getAssetData(t.refId), this.initElement(t, e, i)
                }

                function HCameraElement(t, e, i) {
                    this.initFrame(), this.initBaseData(t, e, i), this.initHierarchy();
                    var n = PropertyFactory.getProp;
                    if (this.pe = n(this, t.pe, 0, 0, this), t.ks.p.s ? (this.px = n(this, t.ks.p.x, 1, 0, this), this.py = n(this, t.ks.p.y, 1, 0, this), this.pz = n(this, t.ks.p.z, 1, 0, this)) : this.p = n(this, t.ks.p, 1, 0, this), t.ks.a && (this.a = n(this, t.ks.a, 1, 0, this)), t.ks.or.k.length && t.ks.or.k[0].to) {
                        var r, s = t.ks.or.k.length;
                        for (r = 0; r < s; r += 1) t.ks.or.k[r].to = null, t.ks.or.k[r].ti = null
                    }
                    this.or = n(this, t.ks.or, 1, degToRads, this), this.or.sh = !0, this.rx = n(this, t.ks.rx, 0, degToRads, this), this.ry = n(this, t.ks.ry, 0, degToRads, this), this.rz = n(this, t.ks.rz, 0, degToRads, this), this.mat = new Matrix, this._prevMat = new Matrix, this._isFirstFrame = !0, this.finalTransform = {mProp: this}
                }

                function HEffects() {
                }

                SVGMatte3Effect.prototype.findSymbol = function (t) {
                    for (var e = 0, i = _svgMatteSymbols.length; e < i;) {
                        if (_svgMatteSymbols[e] === t) return _svgMatteSymbols[e];
                        e += 1
                    }
                    return null
                }, SVGMatte3Effect.prototype.replaceInParent = function (t, e) {
                    var i = t.layerElement.parentNode;
                    if (i) {
                        for (var n, r = i.children, s = 0, a = r.length; s < a && r[s] !== t.layerElement;) s += 1;
                        s <= a - 2 && (n = r[s + 1]);
                        var o = createNS("use");
                        o.setAttribute("href", "#" + e), n ? i.insertBefore(o, n) : i.appendChild(o)
                    }
                }, SVGMatte3Effect.prototype.setElementAsMask = function (t, e) {
                    if (!this.findSymbol(e)) {
                        var i = createElementID(), n = createNS("mask");
                        n.setAttribute("id", e.layerId), n.setAttribute("mask-type", "alpha"), _svgMatteSymbols.push(e);
                        var r = t.globalData.defs;
                        r.appendChild(n);
                        var s = createNS("symbol");
                        s.setAttribute("id", i), this.replaceInParent(e, i), s.appendChild(e.layerElement), r.appendChild(s);
                        var a = createNS("use");
                        a.setAttribute("href", "#" + i), n.appendChild(a), e.data.hd = !1, e.show()
                    }
                    t.setMatte(e.layerId)
                }, SVGMatte3Effect.prototype.initialize = function () {
                    for (var t = this.filterManager.effectElements[0].p.v, e = this.elem.comp.elements, i = 0, n = e.length; i < n;) e[i] && e[i].data.ind === t && this.setElementAsMask(this.elem, e[i]), i += 1;
                    this.initialized = !0
                }, SVGMatte3Effect.prototype.renderFrame = function () {
                    this.initialized || this.initialize()
                }, SVGEffects.prototype.renderFrame = function (t) {
                    var e, i = this.filters.length;
                    for (e = 0; e < i; e += 1) this.filters[e].renderFrame(t)
                }, CVContextData.prototype.duplicate = function () {
                    var t = 2 * this._length, e = this.savedOp;
                    this.savedOp = createTypedArray("float32", t), this.savedOp.set(e);
                    var i = 0;
                    for (i = this._length; i < t; i += 1) this.saved[i] = createTypedArray("float32", 16);
                    this._length = t
                }, CVContextData.prototype.reset = function () {
                    this.cArrPos = 0, this.cTr.reset(), this.cO = 1
                }, CVBaseElement.prototype = {
                    createElements: function () {
                    }, initRendererElement: function () {
                    }, createContainerElements: function () {
                        this.canvasContext = this.globalData.canvasContext, this.renderableEffectsManager = new CVEffects(this)
                    }, createContent: function () {
                    }, setBlendMode: function () {
                        var t = this.globalData;
                        if (t.blendMode !== this.data.bm) {
                            t.blendMode = this.data.bm;
                            var e = getBlendMode(this.data.bm);
                            t.canvasContext.globalCompositeOperation = e
                        }
                    }, createRenderableComponents: function () {
                        this.maskManager = new CVMaskElement(this.data, this)
                    }, hideElement: function () {
                        this.hidden || this.isInRange && !this.isTransparent || (this.hidden = !0)
                    }, showElement: function () {
                        this.isInRange && !this.isTransparent && (this.hidden = !1, this._isFirstFrame = !0, this.maskManager._isFirstFrame = !0)
                    }, renderFrame: function () {
                        if (!this.hidden && !this.data.hd) {
                            this.renderTransform(), this.renderRenderable(), this.setBlendMode();
                            var t = 0 === this.data.ty;
                            this.globalData.renderer.save(t), this.globalData.renderer.ctxTransform(this.finalTransform.mat.props), this.globalData.renderer.ctxOpacity(this.finalTransform.mProp.o.v), this.renderInnerContent(), this.globalData.renderer.restore(t), this.maskManager.hasMasks && this.globalData.renderer.restore(!0), this._isFirstFrame && (this._isFirstFrame = !1)
                        }
                    }, destroy: function () {
                        this.canvasContext = null, this.data = null, this.globalData = null, this.maskManager.destroy()
                    }, mHelper: new Matrix
                }, CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement, CVBaseElement.prototype.show = CVBaseElement.prototype.showElement, extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement), CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVImageElement.prototype.createContent = function () {
                    if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
                        var t = createTag("canvas");
                        t.width = this.assetData.w, t.height = this.assetData.h;
                        var e, i, n = t.getContext("2d"), r = this.img.width, s = this.img.height, a = r / s,
                            o = this.assetData.w / this.assetData.h,
                            h = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
                        a > o && "xMidYMid slice" === h || a < o && "xMidYMid slice" !== h ? e = (i = s) * o : i = (e = r) / o, n.drawImage(this.img, (r - e) / 2, (s - i) / 2, e, i, 0, 0, this.assetData.w, this.assetData.h), this.img = t
                    }
                }, CVImageElement.prototype.renderInnerContent = function () {
                    this.canvasContext.drawImage(this.img, 0, 0)
                }, CVImageElement.prototype.destroy = function () {
                    this.img = null
                }, extendPrototype([CanvasRenderer, ICompElement, CVBaseElement], CVCompElement), CVCompElement.prototype.renderInnerContent = function () {
                    var t, e = this.canvasContext;
                    for (e.beginPath(), e.moveTo(0, 0), e.lineTo(this.data.w, 0), e.lineTo(this.data.w, this.data.h), e.lineTo(0, this.data.h), e.lineTo(0, 0), e.clip(), t = this.layers.length - 1; t >= 0; t -= 1) (this.completeLayers || this.elements[t]) && this.elements[t].renderFrame()
                }, CVCompElement.prototype.destroy = function () {
                    var t;
                    for (t = this.layers.length - 1; t >= 0; t -= 1) this.elements[t] && this.elements[t].destroy();
                    this.layers = null, this.elements = null
                }, CVMaskElement.prototype.renderFrame = function () {
                    if (this.hasMasks) {
                        var t, e, i, n, r = this.element.finalTransform.mat, s = this.element.canvasContext,
                            a = this.masksProperties.length;
                        for (s.beginPath(), t = 0; t < a; t += 1) if ("n" !== this.masksProperties[t].mode) {
                            var o;
                            this.masksProperties[t].inv && (s.moveTo(0, 0), s.lineTo(this.element.globalData.compSize.w, 0), s.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h), s.lineTo(0, this.element.globalData.compSize.h), s.lineTo(0, 0)), n = this.viewData[t].v, e = r.applyToPointArray(n.v[0][0], n.v[0][1], 0), s.moveTo(e[0], e[1]);
                            var h = n._length;
                            for (o = 1; o < h; o += 1) i = r.applyToTriplePoints(n.o[o - 1], n.i[o], n.v[o]), s.bezierCurveTo(i[0], i[1], i[2], i[3], i[4], i[5]);
                            i = r.applyToTriplePoints(n.o[o - 1], n.i[0], n.v[0]), s.bezierCurveTo(i[0], i[1], i[2], i[3], i[4], i[5])
                        }
                        this.element.globalData.renderer.save(!0), s.clip()
                    }
                }, CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty, CVMaskElement.prototype.destroy = function () {
                    this.element = null
                }, extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement), CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement, CVShapeElement.prototype.transformHelper = {
                    opacity: 1,
                    _opMdf: !1
                }, CVShapeElement.prototype.dashResetter = [], CVShapeElement.prototype.createContent = function () {
                    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, [])
                }, CVShapeElement.prototype.createStyleElement = function (t, e) {
                    var i = {
                        data: t,
                        type: t.ty,
                        preTransforms: this.transformsManager.addTransformSequence(e),
                        transforms: [],
                        elements: [],
                        closed: !0 === t.hd
                    }, n = {};
                    if ("fl" === t.ty || "st" === t.ty ? (n.c = PropertyFactory.getProp(this, t.c, 1, 255, this), n.c.k || (i.co = "rgb(" + bmFloor(n.c.v[0]) + "," + bmFloor(n.c.v[1]) + "," + bmFloor(n.c.v[2]) + ")")) : "gf" !== t.ty && "gs" !== t.ty || (n.s = PropertyFactory.getProp(this, t.s, 1, null, this), n.e = PropertyFactory.getProp(this, t.e, 1, null, this), n.h = PropertyFactory.getProp(this, t.h || {k: 0}, 0, .01, this), n.a = PropertyFactory.getProp(this, t.a || {k: 0}, 0, degToRads, this), n.g = new GradientProperty(this, t.g, this)), n.o = PropertyFactory.getProp(this, t.o, 0, .01, this), "st" === t.ty || "gs" === t.ty) {
                        if (i.lc = lineCapEnum[t.lc || 2], i.lj = lineJoinEnum[t.lj || 2], 1 == t.lj && (i.ml = t.ml), n.w = PropertyFactory.getProp(this, t.w, 0, null, this), n.w.k || (i.wi = n.w.v), t.d) {
                            var r = new DashProperty(this, t.d, "canvas", this);
                            n.d = r, n.d.k || (i.da = n.d.dashArray, i.do = n.d.dashoffset[0])
                        }
                    } else i.r = 2 === t.r ? "evenodd" : "nonzero";
                    return this.stylesList.push(i), n.style = i, n
                }, CVShapeElement.prototype.createGroupElement = function () {
                    return {it: [], prevViewData: []}
                }, CVShapeElement.prototype.createTransformElement = function (t) {
                    return {
                        transform: {
                            opacity: 1,
                            _opMdf: !1,
                            key: this.transformsManager.getNewKey(),
                            op: PropertyFactory.getProp(this, t.o, 0, .01, this),
                            mProps: TransformPropertyFactory.getTransformProperty(this, t, this)
                        }
                    }
                }, CVShapeElement.prototype.createShapeElement = function (t) {
                    var e = new CVShapeData(this, t, this.stylesList, this.transformsManager);
                    return this.shapes.push(e), this.addShapeToModifiers(e), e
                }, CVShapeElement.prototype.reloadShapes = function () {
                    var t;
                    this._isFirstFrame = !0;
                    var e = this.itemsData.length;
                    for (t = 0; t < e; t += 1) this.prevViewData[t] = this.itemsData[t];
                    for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []), e = this.dynamicProperties.length, t = 0; t < e; t += 1) this.dynamicProperties[t].getValue();
                    this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame)
                }, CVShapeElement.prototype.addTransformToStyleList = function (t) {
                    var e, i = this.stylesList.length;
                    for (e = 0; e < i; e += 1) this.stylesList[e].closed || this.stylesList[e].transforms.push(t)
                }, CVShapeElement.prototype.removeTransformFromStyleList = function () {
                    var t, e = this.stylesList.length;
                    for (t = 0; t < e; t += 1) this.stylesList[t].closed || this.stylesList[t].transforms.pop()
                }, CVShapeElement.prototype.closeStyles = function (t) {
                    var e, i = t.length;
                    for (e = 0; e < i; e += 1) t[e].closed = !0
                }, CVShapeElement.prototype.searchShapes = function (t, e, i, n, r) {
                    var s, a, o, h, l, c, u = t.length - 1, p = [], d = [], f = [].concat(r);
                    for (s = u; s >= 0; s -= 1) {
                        if ((h = this.searchProcessedElement(t[s])) ? e[s] = i[h - 1] : t[s]._shouldRender = n, "fl" === t[s].ty || "st" === t[s].ty || "gf" === t[s].ty || "gs" === t[s].ty) h ? e[s].style.closed = !1 : e[s] = this.createStyleElement(t[s], f), p.push(e[s].style); else if ("gr" === t[s].ty) {
                            if (h) for (o = e[s].it.length, a = 0; a < o; a += 1) e[s].prevViewData[a] = e[s].it[a]; else e[s] = this.createGroupElement(t[s]);
                            this.searchShapes(t[s].it, e[s].it, e[s].prevViewData, n, f)
                        } else "tr" === t[s].ty ? (h || (c = this.createTransformElement(t[s]), e[s] = c), f.push(e[s]), this.addTransformToStyleList(e[s])) : "sh" === t[s].ty || "rc" === t[s].ty || "el" === t[s].ty || "sr" === t[s].ty ? h || (e[s] = this.createShapeElement(t[s])) : "tm" === t[s].ty || "rd" === t[s].ty || "pb" === t[s].ty ? (h ? (l = e[s]).closed = !1 : ((l = ShapeModifiers.getModifier(t[s].ty)).init(this, t[s]), e[s] = l, this.shapeModifiers.push(l)), d.push(l)) : "rp" === t[s].ty && (h ? (l = e[s]).closed = !0 : (l = ShapeModifiers.getModifier(t[s].ty), e[s] = l, l.init(this, t, s, e), this.shapeModifiers.push(l), n = !1), d.push(l));
                        this.addProcessedElement(t[s], s + 1)
                    }
                    for (this.removeTransformFromStyleList(), this.closeStyles(p), u = d.length, s = 0; s < u; s += 1) d[s].closed = !0
                }, CVShapeElement.prototype.renderInnerContent = function () {
                    this.transformHelper.opacity = 1, this.transformHelper._opMdf = !1, this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame), this.renderShape(this.transformHelper, this.shapesData, this.itemsData, !0)
                }, CVShapeElement.prototype.renderShapeTransform = function (t, e) {
                    (t._opMdf || e.op._mdf || this._isFirstFrame) && (e.opacity = t.opacity, e.opacity *= e.op.v, e._opMdf = !0)
                }, CVShapeElement.prototype.drawLayer = function () {
                    var t, e, i, n, r, s, a, o, h, l = this.stylesList.length, c = this.globalData.renderer,
                        u = this.globalData.canvasContext;
                    for (t = 0; t < l; t += 1) if (("st" !== (o = (h = this.stylesList[t]).type) && "gs" !== o || 0 !== h.wi) && h.data._shouldRender && 0 !== h.coOp && 0 !== this.globalData.currentGlobalAlpha) {
                        for (c.save(), s = h.elements, "st" === o || "gs" === o ? (u.strokeStyle = "st" === o ? h.co : h.grd, u.lineWidth = h.wi, u.lineCap = h.lc, u.lineJoin = h.lj, u.miterLimit = h.ml || 0) : u.fillStyle = "fl" === o ? h.co : h.grd, c.ctxOpacity(h.coOp), "st" !== o && "gs" !== o && u.beginPath(), c.ctxTransform(h.preTransforms.finalTransform.props), i = s.length, e = 0; e < i; e += 1) {
                            for ("st" !== o && "gs" !== o || (u.beginPath(), h.da && (u.setLineDash(h.da), u.lineDashOffset = h.do)), r = (a = s[e].trNodes).length, n = 0; n < r; n += 1) "m" === a[n].t ? u.moveTo(a[n].p[0], a[n].p[1]) : "c" === a[n].t ? u.bezierCurveTo(a[n].pts[0], a[n].pts[1], a[n].pts[2], a[n].pts[3], a[n].pts[4], a[n].pts[5]) : u.closePath();
                            "st" !== o && "gs" !== o || (u.stroke(), h.da && u.setLineDash(this.dashResetter))
                        }
                        "st" !== o && "gs" !== o && u.fill(h.r), c.restore()
                    }
                }, CVShapeElement.prototype.renderShape = function (t, e, i, n) {
                    var r, s;
                    for (s = t, r = e.length - 1; r >= 0; r -= 1) "tr" === e[r].ty ? (s = i[r].transform, this.renderShapeTransform(t, s)) : "sh" === e[r].ty || "el" === e[r].ty || "rc" === e[r].ty || "sr" === e[r].ty ? this.renderPath(e[r], i[r]) : "fl" === e[r].ty ? this.renderFill(e[r], i[r], s) : "st" === e[r].ty ? this.renderStroke(e[r], i[r], s) : "gf" === e[r].ty || "gs" === e[r].ty ? this.renderGradientFill(e[r], i[r], s) : "gr" === e[r].ty ? this.renderShape(s, e[r].it, i[r].it) : e[r].ty;
                    n && this.drawLayer()
                }, CVShapeElement.prototype.renderStyledShape = function (t, e) {
                    if (this._isFirstFrame || e._mdf || t.transforms._mdf) {
                        var i, n, r, s = t.trNodes, a = e.paths, o = a._length;
                        s.length = 0;
                        var h = t.transforms.finalTransform;
                        for (r = 0; r < o; r += 1) {
                            var l = a.shapes[r];
                            if (l && l.v) {
                                for (n = l._length, i = 1; i < n; i += 1) 1 === i && s.push({
                                    t: "m",
                                    p: h.applyToPointArray(l.v[0][0], l.v[0][1], 0)
                                }), s.push({t: "c", pts: h.applyToTriplePoints(l.o[i - 1], l.i[i], l.v[i])});
                                1 === n && s.push({
                                    t: "m",
                                    p: h.applyToPointArray(l.v[0][0], l.v[0][1], 0)
                                }), l.c && n && (s.push({
                                    t: "c",
                                    pts: h.applyToTriplePoints(l.o[i - 1], l.i[0], l.v[0])
                                }), s.push({t: "z"}))
                            }
                        }
                        t.trNodes = s
                    }
                }, CVShapeElement.prototype.renderPath = function (t, e) {
                    if (!0 !== t.hd && t._shouldRender) {
                        var i, n = e.styledShapes.length;
                        for (i = 0; i < n; i += 1) this.renderStyledShape(e.styledShapes[i], e.sh)
                    }
                }, CVShapeElement.prototype.renderFill = function (t, e, i) {
                    var n = e.style;
                    (e.c._mdf || this._isFirstFrame) && (n.co = "rgb(" + bmFloor(e.c.v[0]) + "," + bmFloor(e.c.v[1]) + "," + bmFloor(e.c.v[2]) + ")"), (e.o._mdf || i._opMdf || this._isFirstFrame) && (n.coOp = e.o.v * i.opacity)
                }, CVShapeElement.prototype.renderGradientFill = function (t, e, i) {
                    var n, r = e.style;
                    if (!r.grd || e.g._mdf || e.s._mdf || e.e._mdf || 1 !== t.t && (e.h._mdf || e.a._mdf)) {
                        var s, a = this.globalData.canvasContext, o = e.s.v, h = e.e.v;
                        if (1 === t.t) n = a.createLinearGradient(o[0], o[1], h[0], h[1]); else {
                            var l = Math.sqrt(Math.pow(o[0] - h[0], 2) + Math.pow(o[1] - h[1], 2)),
                                c = Math.atan2(h[1] - o[1], h[0] - o[0]), u = e.h.v;
                            u >= 1 ? u = .99 : u <= -1 && (u = -.99);
                            var p = l * u, d = Math.cos(c + e.a.v) * p + o[0], f = Math.sin(c + e.a.v) * p + o[1];
                            n = a.createRadialGradient(d, f, 0, o[0], o[1], l)
                        }
                        var m = t.g.p, g = e.g.c, v = 1;
                        for (s = 0; s < m; s += 1) e.g._hasOpacity && e.g._collapsable && (v = e.g.o[2 * s + 1]), n.addColorStop(g[4 * s] / 100, "rgba(" + g[4 * s + 1] + "," + g[4 * s + 2] + "," + g[4 * s + 3] + "," + v + ")");
                        r.grd = n
                    }
                    r.coOp = e.o.v * i.opacity
                }, CVShapeElement.prototype.renderStroke = function (t, e, i) {
                    var n = e.style, r = e.d;
                    r && (r._mdf || this._isFirstFrame) && (n.da = r.dashArray, n.do = r.dashoffset[0]), (e.c._mdf || this._isFirstFrame) && (n.co = "rgb(" + bmFloor(e.c.v[0]) + "," + bmFloor(e.c.v[1]) + "," + bmFloor(e.c.v[2]) + ")"), (e.o._mdf || i._opMdf || this._isFirstFrame) && (n.coOp = e.o.v * i.opacity), (e.w._mdf || this._isFirstFrame) && (n.wi = e.w.v)
                }, CVShapeElement.prototype.destroy = function () {
                    this.shapesData = null, this.globalData = null, this.canvasContext = null, this.stylesList.length = 0, this.itemsData.length = 0
                }, extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement), CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVSolidElement.prototype.renderInnerContent = function () {
                    var t = this.canvasContext;
                    t.fillStyle = this.data.sc, t.fillRect(0, 0, this.data.sw, this.data.sh)
                }, extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement), CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d"), CVTextElement.prototype.buildNewText = function () {
                    var t = this.textProperty.currentData;
                    this.renderedLetters = createSizedArray(t.l ? t.l.length : 0);
                    var e = !1;
                    t.fc ? (e = !0, this.values.fill = this.buildColor(t.fc)) : this.values.fill = "rgba(0,0,0,0)", this.fill = e;
                    var i = !1;
                    t.sc && (i = !0, this.values.stroke = this.buildColor(t.sc), this.values.sWidth = t.sw);
                    var n, r, s, a, o, h, l, c, u, p, d, f, m = this.globalData.fontManager.getFontByName(t.f), g = t.l,
                        v = this.mHelper;
                    this.stroke = i, this.values.fValue = t.finalSize + "px " + this.globalData.fontManager.getFontByName(t.f).fFamily, r = t.finalText.length;
                    var y = this.data.singleShape, b = .001 * t.tr * t.finalSize, x = 0, w = 0, _ = !0, E = 0;
                    for (n = 0; n < r; n += 1) {
                        for (a = (s = this.globalData.fontManager.getCharData(t.finalText[n], m.fStyle, this.globalData.fontManager.getFontByName(t.f).fFamily)) && s.data || {}, v.reset(), y && g[n].n && (x = -b, w += t.yOffset, w += _ ? 1 : 0, _ = !1), u = (l = a.shapes ? a.shapes[0].it : []).length, v.scale(t.finalSize / 100, t.finalSize / 100), y && this.applyTextPropertiesToMatrix(t, v, g[n].line, x, w), d = createSizedArray(u), c = 0; c < u; c += 1) {
                            for (h = l[c].ks.k.i.length, p = l[c].ks.k, f = [], o = 1; o < h; o += 1) 1 === o && f.push(v.applyToX(p.v[0][0], p.v[0][1], 0), v.applyToY(p.v[0][0], p.v[0][1], 0)), f.push(v.applyToX(p.o[o - 1][0], p.o[o - 1][1], 0), v.applyToY(p.o[o - 1][0], p.o[o - 1][1], 0), v.applyToX(p.i[o][0], p.i[o][1], 0), v.applyToY(p.i[o][0], p.i[o][1], 0), v.applyToX(p.v[o][0], p.v[o][1], 0), v.applyToY(p.v[o][0], p.v[o][1], 0));
                            f.push(v.applyToX(p.o[o - 1][0], p.o[o - 1][1], 0), v.applyToY(p.o[o - 1][0], p.o[o - 1][1], 0), v.applyToX(p.i[0][0], p.i[0][1], 0), v.applyToY(p.i[0][0], p.i[0][1], 0), v.applyToX(p.v[0][0], p.v[0][1], 0), v.applyToY(p.v[0][0], p.v[0][1], 0)), d[c] = f
                        }
                        y && (x += g[n].l, x += b), this.textSpans[E] ? this.textSpans[E].elem = d : this.textSpans[E] = {elem: d}, E += 1
                    }
                }, CVTextElement.prototype.renderInnerContent = function () {
                    var t, e, i, n, r, s, a = this.canvasContext;
                    a.font = this.values.fValue, a.lineCap = "butt", a.lineJoin = "miter", a.miterLimit = 4, this.data.singleShape || this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
                    var o, h = this.textAnimator.renderedLetters, l = this.textProperty.currentData.l;
                    e = l.length;
                    var c, u, p = null, d = null, f = null;
                    for (t = 0; t < e; t += 1) if (!l[t].n) {
                        if ((o = h[t]) && (this.globalData.renderer.save(), this.globalData.renderer.ctxTransform(o.p), this.globalData.renderer.ctxOpacity(o.o)), this.fill) {
                            for (o && o.fc ? p !== o.fc && (p = o.fc, a.fillStyle = o.fc) : p !== this.values.fill && (p = this.values.fill, a.fillStyle = this.values.fill), n = (c = this.textSpans[t].elem).length, this.globalData.canvasContext.beginPath(), i = 0; i < n; i += 1) for (s = (u = c[i]).length, this.globalData.canvasContext.moveTo(u[0], u[1]), r = 2; r < s; r += 6) this.globalData.canvasContext.bezierCurveTo(u[r], u[r + 1], u[r + 2], u[r + 3], u[r + 4], u[r + 5]);
                            this.globalData.canvasContext.closePath(), this.globalData.canvasContext.fill()
                        }
                        if (this.stroke) {
                            for (o && o.sw ? f !== o.sw && (f = o.sw, a.lineWidth = o.sw) : f !== this.values.sWidth && (f = this.values.sWidth, a.lineWidth = this.values.sWidth), o && o.sc ? d !== o.sc && (d = o.sc, a.strokeStyle = o.sc) : d !== this.values.stroke && (d = this.values.stroke, a.strokeStyle = this.values.stroke), n = (c = this.textSpans[t].elem).length, this.globalData.canvasContext.beginPath(), i = 0; i < n; i += 1) for (s = (u = c[i]).length, this.globalData.canvasContext.moveTo(u[0], u[1]), r = 2; r < s; r += 6) this.globalData.canvasContext.bezierCurveTo(u[r], u[r + 1], u[r + 2], u[r + 3], u[r + 4], u[r + 5]);
                            this.globalData.canvasContext.closePath(), this.globalData.canvasContext.stroke()
                        }
                        o && this.globalData.renderer.restore()
                    }
                }, CVEffects.prototype.renderFrame = function () {
                }, HBaseElement.prototype = {
                    checkBlendMode: function () {
                    }, initRendererElement: function () {
                        this.baseElement = createTag(this.data.tg || "div"), this.data.hasMask ? (this.svgElement = createNS("svg"), this.layerElement = createNS("g"), this.maskedElement = this.layerElement, this.svgElement.appendChild(this.layerElement), this.baseElement.appendChild(this.svgElement)) : this.layerElement = this.baseElement, styleDiv(this.baseElement)
                    }, createContainerElements: function () {
                        this.renderableEffectsManager = new CVEffects(this), this.transformedElement = this.baseElement, this.maskedElement = this.layerElement, this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), 0 !== this.data.bm && this.setBlendMode()
                    }, renderElement: function () {
                        var t = this.transformedElement ? this.transformedElement.style : {};
                        if (this.finalTransform._matMdf) {
                            var e = this.finalTransform.mat.toCSS();
                            t.transform = e, t.webkitTransform = e
                        }
                        this.finalTransform._opMdf && (t.opacity = this.finalTransform.mProp.o.v)
                    }, renderFrame: function () {
                        this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1))
                    }, destroy: function () {
                        this.layerElement = null, this.transformedElement = null, this.matteElement && (this.matteElement = null), this.maskManager && (this.maskManager.destroy(), this.maskManager = null)
                    }, createRenderableComponents: function () {
                        this.maskManager = new MaskElement(this.data, this, this.globalData)
                    }, addEffects: function () {
                    }, setMatte: function () {
                    }
                }, HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement, HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy, HBaseElement.prototype.buildElementParenting = HybridRenderer.prototype.buildElementParenting, extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement), HSolidElement.prototype.createContent = function () {
                    var t;
                    this.data.hasMask ? ((t = createNS("rect")).setAttribute("width", this.data.sw), t.setAttribute("height", this.data.sh), t.setAttribute("fill", this.data.sc), this.svgElement.setAttribute("width", this.data.sw), this.svgElement.setAttribute("height", this.data.sh)) : ((t = createTag("div")).style.width = this.data.sw + "px", t.style.height = this.data.sh + "px", t.style.backgroundColor = this.data.sc), this.layerElement.appendChild(t)
                }, extendPrototype([HybridRenderer, ICompElement, HBaseElement], HCompElement), HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements, HCompElement.prototype.createContainerElements = function () {
                    this._createBaseContainerElements(), this.data.hasMask ? (this.svgElement.setAttribute("width", this.data.w), this.svgElement.setAttribute("height", this.data.h), this.transformedElement = this.baseElement) : this.transformedElement = this.layerElement
                }, HCompElement.prototype.addTo3dContainer = function (t, e) {
                    for (var i, n = 0; n < e;) this.elements[n] && this.elements[n].getBaseElement && (i = this.elements[n].getBaseElement()), n += 1;
                    i ? this.layerElement.insertBefore(t, i) : this.layerElement.appendChild(t)
                }, extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement), HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent, HShapeElement.prototype.createContent = function () {
                    var t;
                    if (this.baseElement.style.fontSize = 0, this.data.hasMask) this.layerElement.appendChild(this.shapesContainer), t = this.svgElement; else {
                        t = createNS("svg");
                        var e = this.comp.data ? this.comp.data : this.globalData.compSize;
                        t.setAttribute("width", e.w), t.setAttribute("height", e.h), t.appendChild(this.shapesContainer), this.layerElement.appendChild(t)
                    }
                    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], !0), this.filterUniqueShapes(), this.shapeCont = t
                }, HShapeElement.prototype.getTransformedPoint = function (t, e) {
                    var i, n = t.length;
                    for (i = 0; i < n; i += 1) e = t[i].mProps.v.applyToPointArray(e[0], e[1], 0);
                    return e
                }, HShapeElement.prototype.calculateShapeBoundingBox = function (t, e) {
                    var i, n, r, s, a, o = t.sh.v, h = t.transformers, l = o._length;
                    if (!(l <= 1)) {
                        for (i = 0; i < l - 1; i += 1) n = this.getTransformedPoint(h, o.v[i]), r = this.getTransformedPoint(h, o.o[i]), s = this.getTransformedPoint(h, o.i[i + 1]), a = this.getTransformedPoint(h, o.v[i + 1]), this.checkBounds(n, r, s, a, e);
                        o.c && (n = this.getTransformedPoint(h, o.v[i]), r = this.getTransformedPoint(h, o.o[i]), s = this.getTransformedPoint(h, o.i[0]), a = this.getTransformedPoint(h, o.v[0]), this.checkBounds(n, r, s, a, e))
                    }
                }, HShapeElement.prototype.checkBounds = function (t, e, i, n, r) {
                    this.getBoundsOfCurve(t, e, i, n);
                    var s = this.shapeBoundingBox;
                    r.x = bmMin(s.left, r.x), r.xMax = bmMax(s.right, r.xMax), r.y = bmMin(s.top, r.y), r.yMax = bmMax(s.bottom, r.yMax)
                }, HShapeElement.prototype.shapeBoundingBox = {
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                }, HShapeElement.prototype.tempBoundingBox = {
                    x: 0,
                    xMax: 0,
                    y: 0,
                    yMax: 0,
                    width: 0,
                    height: 0
                }, HShapeElement.prototype.getBoundsOfCurve = function (t, e, i, n) {
                    for (var r, s, a, o, h, l, c, u = [[t[0], n[0]], [t[1], n[1]]], p = 0; p < 2; ++p) s = 6 * t[p] - 12 * e[p] + 6 * i[p], r = -3 * t[p] + 9 * e[p] - 9 * i[p] + 3 * n[p], a = 3 * e[p] - 3 * t[p], s |= 0, a |= 0, 0 == (r |= 0) && 0 === s || (0 === r ? (o = -a / s) > 0 && o < 1 && u[p].push(this.calculateF(o, t, e, i, n, p)) : (h = s * s - 4 * a * r) >= 0 && ((l = (-s + bmSqrt(h)) / (2 * r)) > 0 && l < 1 && u[p].push(this.calculateF(l, t, e, i, n, p)), (c = (-s - bmSqrt(h)) / (2 * r)) > 0 && c < 1 && u[p].push(this.calculateF(c, t, e, i, n, p))));
                    this.shapeBoundingBox.left = bmMin.apply(null, u[0]), this.shapeBoundingBox.top = bmMin.apply(null, u[1]), this.shapeBoundingBox.right = bmMax.apply(null, u[0]), this.shapeBoundingBox.bottom = bmMax.apply(null, u[1])
                }, HShapeElement.prototype.calculateF = function (t, e, i, n, r, s) {
                    return bmPow(1 - t, 3) * e[s] + 3 * bmPow(1 - t, 2) * t * i[s] + 3 * (1 - t) * bmPow(t, 2) * n[s] + bmPow(t, 3) * r[s]
                }, HShapeElement.prototype.calculateBoundingBox = function (t, e) {
                    var i, n = t.length;
                    for (i = 0; i < n; i += 1) t[i] && t[i].sh ? this.calculateShapeBoundingBox(t[i], e) : t[i] && t[i].it && this.calculateBoundingBox(t[i].it, e)
                }, HShapeElement.prototype.currentBoxContains = function (t) {
                    return this.currentBBox.x <= t.x && this.currentBBox.y <= t.y && this.currentBBox.width + this.currentBBox.x >= t.x + t.width && this.currentBBox.height + this.currentBBox.y >= t.y + t.height
                }, HShapeElement.prototype.renderInnerContent = function () {
                    if (this._renderShapeFrame(), !this.hidden && (this._isFirstFrame || this._mdf)) {
                        var t = this.tempBoundingBox, e = 999999;
                        if (t.x = e, t.xMax = -e, t.y = e, t.yMax = -e, this.calculateBoundingBox(this.itemsData, t), t.width = t.xMax < t.x ? 0 : t.xMax - t.x, t.height = t.yMax < t.y ? 0 : t.yMax - t.y, this.currentBoxContains(t)) return;
                        var i = !1;
                        if (this.currentBBox.w !== t.width && (this.currentBBox.w = t.width, this.shapeCont.setAttribute("width", t.width), i = !0), this.currentBBox.h !== t.height && (this.currentBBox.h = t.height, this.shapeCont.setAttribute("height", t.height), i = !0), i || this.currentBBox.x !== t.x || this.currentBBox.y !== t.y) {
                            this.currentBBox.w = t.width, this.currentBBox.h = t.height, this.currentBBox.x = t.x, this.currentBBox.y = t.y, this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
                            var n = this.shapeCont.style,
                                r = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
                            n.transform = r, n.webkitTransform = r
                        }
                    }
                }, extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement), HTextElement.prototype.createContent = function () {
                    if (this.isMasked = this.checkMasks(), this.isMasked) {
                        this.renderType = "svg", this.compW = this.comp.data.w, this.compH = this.comp.data.h, this.svgElement.setAttribute("width", this.compW), this.svgElement.setAttribute("height", this.compH);
                        var t = createNS("g");
                        this.maskedElement.appendChild(t), this.innerElem = t
                    } else this.renderType = "html", this.innerElem = this.layerElement;
                    this.checkParenting()
                }, HTextElement.prototype.buildNewText = function () {
                    var t = this.textProperty.currentData;
                    this.renderedLetters = createSizedArray(t.l ? t.l.length : 0);
                    var e = this.innerElem.style, i = t.fc ? this.buildColor(t.fc) : "rgba(0,0,0,0)";
                    e.fill = i, e.color = i, t.sc && (e.stroke = this.buildColor(t.sc), e.strokeWidth = t.sw + "px");
                    var n, r, s = this.globalData.fontManager.getFontByName(t.f);
                    if (!this.globalData.fontManager.chars) if (e.fontSize = t.finalSize + "px", e.lineHeight = t.finalSize + "px", s.fClass) this.innerElem.className = s.fClass; else {
                        e.fontFamily = s.fFamily;
                        var a = t.fWeight, o = t.fStyle;
                        e.fontStyle = o, e.fontWeight = a
                    }
                    var h, l, c, u = t.l;
                    r = u.length;
                    var p, d = this.mHelper, f = "", m = 0;
                    for (n = 0; n < r; n += 1) {
                        if (this.globalData.fontManager.chars ? (this.textPaths[m] ? h = this.textPaths[m] : ((h = createNS("path")).setAttribute("stroke-linecap", lineCapEnum[1]), h.setAttribute("stroke-linejoin", lineJoinEnum[2]), h.setAttribute("stroke-miterlimit", "4")), this.isMasked || (this.textSpans[m] ? c = (l = this.textSpans[m]).children[0] : ((l = createTag("div")).style.lineHeight = 0, (c = createNS("svg")).appendChild(h), styleDiv(l)))) : this.isMasked ? h = this.textPaths[m] ? this.textPaths[m] : createNS("text") : this.textSpans[m] ? (l = this.textSpans[m], h = this.textPaths[m]) : (styleDiv(l = createTag("span")), styleDiv(h = createTag("span")), l.appendChild(h)), this.globalData.fontManager.chars) {
                            var g,
                                v = this.globalData.fontManager.getCharData(t.finalText[n], s.fStyle, this.globalData.fontManager.getFontByName(t.f).fFamily);
                            if (g = v ? v.data : null, d.reset(), g && g.shapes && (p = g.shapes[0].it, d.scale(t.finalSize / 100, t.finalSize / 100), f = this.createPathShape(d, p), h.setAttribute("d", f)), this.isMasked) this.innerElem.appendChild(h); else {
                                if (this.innerElem.appendChild(l), g && g.shapes) {
                                    document.body.appendChild(c);
                                    var y = c.getBBox();
                                    c.setAttribute("width", y.width + 2), c.setAttribute("height", y.height + 2), c.setAttribute("viewBox", y.x - 1 + " " + (y.y - 1) + " " + (y.width + 2) + " " + (y.height + 2));
                                    var b = c.style, x = "translate(" + (y.x - 1) + "px," + (y.y - 1) + "px)";
                                    b.transform = x, b.webkitTransform = x, u[n].yOffset = y.y - 1
                                } else c.setAttribute("width", 1), c.setAttribute("height", 1);
                                l.appendChild(c)
                            }
                        } else if (h.textContent = u[n].val, h.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), this.isMasked) this.innerElem.appendChild(h); else {
                            this.innerElem.appendChild(l);
                            var w = h.style, _ = "translate3d(0," + -t.finalSize / 1.2 + "px,0)";
                            w.transform = _, w.webkitTransform = _
                        }
                        this.isMasked ? this.textSpans[m] = h : this.textSpans[m] = l, this.textSpans[m].style.display = "block", this.textPaths[m] = h, m += 1
                    }
                    for (; m < this.textSpans.length;) this.textSpans[m].style.display = "none", m += 1
                }, HTextElement.prototype.renderInnerContent = function () {
                    var t;
                    if (this.data.singleShape) {
                        if (!this._isFirstFrame && !this.lettersChangedFlag) return;
                        if (this.isMasked && this.finalTransform._matMdf) {
                            this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH), t = this.svgElement.style;
                            var e = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)";
                            t.transform = e, t.webkitTransform = e
                        }
                    }
                    if (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
                        var i, n, r, s, a, o = 0, h = this.textAnimator.renderedLetters,
                            l = this.textProperty.currentData.l;
                        for (n = l.length, i = 0; i < n; i += 1) l[i].n ? o += 1 : (s = this.textSpans[i], a = this.textPaths[i], r = h[o], o += 1, r._mdf.m && (this.isMasked ? s.setAttribute("transform", r.m) : (s.style.webkitTransform = r.m, s.style.transform = r.m)), s.style.opacity = r.o, r.sw && r._mdf.sw && a.setAttribute("stroke-width", r.sw), r.sc && r._mdf.sc && a.setAttribute("stroke", r.sc), r.fc && r._mdf.fc && (a.setAttribute("fill", r.fc), a.style.color = r.fc));
                        if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
                            var c = this.innerElem.getBBox();
                            if (this.currentBBox.w !== c.width && (this.currentBBox.w = c.width, this.svgElement.setAttribute("width", c.width)), this.currentBBox.h !== c.height && (this.currentBBox.h = c.height, this.svgElement.setAttribute("height", c.height)), this.currentBBox.w !== c.width + 2 || this.currentBBox.h !== c.height + 2 || this.currentBBox.x !== c.x - 1 || this.currentBBox.y !== c.y - 1) {
                                this.currentBBox.w = c.width + 2, this.currentBBox.h = c.height + 2, this.currentBBox.x = c.x - 1, this.currentBBox.y = c.y - 1, this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h), t = this.svgElement.style;
                                var u = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
                                t.transform = u, t.webkitTransform = u
                            }
                        }
                    }
                }, extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement), HImageElement.prototype.createContent = function () {
                    var t = this.globalData.getAssetsPath(this.assetData), e = new Image;
                    this.data.hasMask ? (this.imageElem = createNS("image"), this.imageElem.setAttribute("width", this.assetData.w + "px"), this.imageElem.setAttribute("height", this.assetData.h + "px"), this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", t), this.layerElement.appendChild(this.imageElem), this.baseElement.setAttribute("width", this.assetData.w), this.baseElement.setAttribute("height", this.assetData.h)) : this.layerElement.appendChild(e), e.crossOrigin = "anonymous", e.src = t, this.data.ln && this.baseElement.setAttribute("id", this.data.ln)
                }, extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement), HCameraElement.prototype.setup = function () {
                    var t, e, i, n, r = this.comp.threeDElements.length;
                    for (t = 0; t < r; t += 1) if ("3d" === (e = this.comp.threeDElements[t]).type) {
                        i = e.perspectiveElem.style, n = e.container.style;
                        var s = this.pe.v + "px", a = "0px 0px 0px", o = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
                        i.perspective = s, i.webkitPerspective = s, n.transformOrigin = a, n.mozTransformOrigin = a, n.webkitTransformOrigin = a, i.transform = o, i.webkitTransform = o
                    }
                }, HCameraElement.prototype.createElements = function () {
                }, HCameraElement.prototype.hide = function () {
                }, HCameraElement.prototype.renderFrame = function () {
                    var t, e, i = this._isFirstFrame;
                    if (this.hierarchy) for (e = this.hierarchy.length, t = 0; t < e; t += 1) i = this.hierarchy[t].finalTransform.mProp._mdf || i;
                    if (i || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
                        if (this.mat.reset(), this.hierarchy) for (t = e = this.hierarchy.length - 1; t >= 0; t -= 1) {
                            var n = this.hierarchy[t].finalTransform.mProp;
                            this.mat.translate(-n.p.v[0], -n.p.v[1], n.p.v[2]), this.mat.rotateX(-n.or.v[0]).rotateY(-n.or.v[1]).rotateZ(n.or.v[2]), this.mat.rotateX(-n.rx.v).rotateY(-n.ry.v).rotateZ(n.rz.v), this.mat.scale(1 / n.s.v[0], 1 / n.s.v[1], 1 / n.s.v[2]), this.mat.translate(n.a.v[0], n.a.v[1], n.a.v[2])
                        }
                        if (this.p ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]) : this.mat.translate(-this.px.v, -this.py.v, this.pz.v), this.a) {
                            var r;
                            r = this.p ? [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]] : [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
                            var s = Math.sqrt(Math.pow(r[0], 2) + Math.pow(r[1], 2) + Math.pow(r[2], 2)),
                                a = [r[0] / s, r[1] / s, r[2] / s], o = Math.sqrt(a[2] * a[2] + a[0] * a[0]),
                                h = Math.atan2(a[1], o), l = Math.atan2(a[0], -a[2]);
                            this.mat.rotateY(l).rotateX(-h)
                        }
                        this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v), this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]), this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0), this.mat.translate(0, 0, this.pe.v);
                        var c = !this._prevMat.equals(this.mat);
                        if ((c || this.pe._mdf) && this.comp.threeDElements) {
                            var u, p, d;
                            for (e = this.comp.threeDElements.length, t = 0; t < e; t += 1) if ("3d" === (u = this.comp.threeDElements[t]).type) {
                                if (c) {
                                    var f = this.mat.toCSS();
                                    (d = u.container.style).transform = f, d.webkitTransform = f
                                }
                                this.pe._mdf && ((p = u.perspectiveElem.style).perspective = this.pe.v + "px", p.webkitPerspective = this.pe.v + "px")
                            }
                            this.mat.clone(this._prevMat)
                        }
                    }
                    this._isFirstFrame = !1
                }, HCameraElement.prototype.prepareFrame = function (t) {
                    this.prepareProperties(t, !0)
                }, HCameraElement.prototype.destroy = function () {
                }, HCameraElement.prototype.getBaseElement = function () {
                    return null
                }, HEffects.prototype.renderFrame = function () {
                };
                var animationManager = function () {
                    var t = {}, e = [], i = 0, n = 0, r = 0, s = !0, a = !1;

                    function o(t) {
                        for (var i = 0, r = t.target; i < n;) e[i].animation === r && (e.splice(i, 1), i -= 1, n -= 1, r.isPaused || c()), i += 1
                    }

                    function h(t, i) {
                        if (!t) return null;
                        for (var r = 0; r < n;) {
                            if (e[r].elem === t && null !== e[r].elem) return e[r].animation;
                            r += 1
                        }
                        var s = new AnimationItem;
                        return u(s, t), s.setData(t, i), s
                    }

                    function l() {
                        r += 1, f()
                    }

                    function c() {
                        r -= 1
                    }

                    function u(t, i) {
                        t.addEventListener("destroy", o), t.addEventListener("_active", l), t.addEventListener("_idle", c), e.push({
                            elem: i,
                            animation: t
                        }), n += 1
                    }

                    function p(t) {
                        var o, h = t - i;
                        for (o = 0; o < n; o += 1) e[o].animation.advanceTime(h);
                        i = t, r && !a ? window.requestAnimationFrame(p) : s = !0
                    }

                    function d(t) {
                        i = t, window.requestAnimationFrame(p)
                    }

                    function f() {
                        !a && r && s && (window.requestAnimationFrame(d), s = !1)
                    }

                    return t.registerAnimation = h, t.loadAnimation = function (t) {
                        var e = new AnimationItem;
                        return u(e, null), e.setParams(t), e
                    }, t.setSpeed = function (t, i) {
                        var r;
                        for (r = 0; r < n; r += 1) e[r].animation.setSpeed(t, i)
                    }, t.setDirection = function (t, i) {
                        var r;
                        for (r = 0; r < n; r += 1) e[r].animation.setDirection(t, i)
                    }, t.play = function (t) {
                        var i;
                        for (i = 0; i < n; i += 1) e[i].animation.play(t)
                    }, t.pause = function (t) {
                        var i;
                        for (i = 0; i < n; i += 1) e[i].animation.pause(t)
                    }, t.stop = function (t) {
                        var i;
                        for (i = 0; i < n; i += 1) e[i].animation.stop(t)
                    }, t.togglePause = function (t) {
                        var i;
                        for (i = 0; i < n; i += 1) e[i].animation.togglePause(t)
                    }, t.searchAnimations = function (t, e, i) {
                        var n,
                            r = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin"))),
                            s = r.length;
                        for (n = 0; n < s; n += 1) i && r[n].setAttribute("data-bm-type", i), h(r[n], t);
                        if (e && 0 === s) {
                            i || (i = "svg");
                            var a = document.getElementsByTagName("body")[0];
                            a.innerText = "";
                            var o = createTag("div");
                            o.style.width = "100%", o.style.height = "100%", o.setAttribute("data-bm-type", i), a.appendChild(o), h(o, t)
                        }
                    }, t.resize = function () {
                        var t;
                        for (t = 0; t < n; t += 1) e[t].animation.resize()
                    }, t.goToAndStop = function (t, i, r) {
                        var s;
                        for (s = 0; s < n; s += 1) e[s].animation.goToAndStop(t, i, r)
                    }, t.destroy = function (t) {
                        var i;
                        for (i = n - 1; i >= 0; i -= 1) e[i].animation.destroy(t)
                    }, t.freeze = function () {
                        a = !0
                    }, t.unfreeze = function () {
                        a = !1, f()
                    }, t.setVolume = function (t, i) {
                        var r;
                        for (r = 0; r < n; r += 1) e[r].animation.setVolume(t, i)
                    }, t.mute = function (t) {
                        var i;
                        for (i = 0; i < n; i += 1) e[i].animation.mute(t)
                    }, t.unmute = function (t) {
                        var i;
                        for (i = 0; i < n; i += 1) e[i].animation.unmute(t)
                    }, t.getRegisteredAnimations = function () {
                        var t, i = e.length, n = [];
                        for (t = 0; t < i; t += 1) n.push(e[t].animation);
                        return n
                    }, t
                }(), AnimationItem = function () {
                    this._cbs = [], this.name = "", this.path = "", this.isLoaded = !1, this.currentFrame = 0, this.currentRawFrame = 0, this.firstFrame = 0, this.totalFrames = 0, this.frameRate = 0, this.frameMult = 0, this.playSpeed = 1, this.playDirection = 1, this.playCount = 0, this.animationData = {}, this.assets = [], this.isPaused = !0, this.autoplay = !1, this.loop = !0, this.renderer = null, this.animationID = createElementID(), this.assetsPath = "", this.timeCompleted = 0, this.segmentPos = 0, this.isSubframeEnabled = subframeEnabled, this.segments = [], this._idle = !0, this._completedLoop = !1, this.projectInterface = ProjectInterface(), this.imagePreloader = new ImagePreloader, this.audioController = audioControllerFactory(), this.markers = [], this.configAnimation = this.configAnimation.bind(this), this.onSetupError = this.onSetupError.bind(this), this.onSegmentComplete = this.onSegmentComplete.bind(this)
                };
                extendPrototype([BaseEvent], AnimationItem), AnimationItem.prototype.setParams = function (t) {
                    (t.wrapper || t.container) && (this.wrapper = t.wrapper || t.container);
                    var e = "svg";
                    switch (t.animType ? e = t.animType : t.renderer && (e = t.renderer), e) {
                        case"canvas":
                            this.renderer = new CanvasRenderer(this, t.rendererSettings);
                            break;
                        case"svg":
                            this.renderer = new SVGRenderer(this, t.rendererSettings);
                            break;
                        default:
                            this.renderer = new HybridRenderer(this, t.rendererSettings)
                    }
                    this.imagePreloader.setCacheType(e, this.renderer.globalData.defs), this.renderer.setProjectInterface(this.projectInterface), this.animType = e, "" === t.loop || null === t.loop || void 0 === t.loop || !0 === t.loop ? this.loop = !0 : !1 === t.loop ? this.loop = !1 : this.loop = parseInt(t.loop, 10), this.autoplay = !("autoplay" in t) || t.autoplay, this.name = t.name ? t.name : "", this.autoloadSegments = !Object.prototype.hasOwnProperty.call(t, "autoloadSegments") || t.autoloadSegments, this.assetsPath = t.assetsPath, this.initialSegment = t.initialSegment, t.audioFactory && this.audioController.setAudioFactory(t.audioFactory), t.animationData ? this.setupAnimation(t.animationData) : t.path && (-1 !== t.path.lastIndexOf("\\") ? this.path = t.path.substr(0, t.path.lastIndexOf("\\") + 1) : this.path = t.path.substr(0, t.path.lastIndexOf("/") + 1), this.fileName = t.path.substr(t.path.lastIndexOf("/") + 1), this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json")), dataManager.loadAnimation(t.path, this.configAnimation, this.onSetupError))
                }, AnimationItem.prototype.onSetupError = function () {
                    this.trigger("data_failed")
                }, AnimationItem.prototype.setupAnimation = function (t) {
                    dataManager.completeAnimation(t, this.configAnimation)
                }, AnimationItem.prototype.setData = function (t, e) {
                    e && "object" != typeof e && (e = JSON.parse(e));
                    var i = {wrapper: t, animationData: e}, n = t.attributes;
                    i.path = n.getNamedItem("data-animation-path") ? n.getNamedItem("data-animation-path").value : n.getNamedItem("data-bm-path") ? n.getNamedItem("data-bm-path").value : n.getNamedItem("bm-path") ? n.getNamedItem("bm-path").value : "", i.animType = n.getNamedItem("data-anim-type") ? n.getNamedItem("data-anim-type").value : n.getNamedItem("data-bm-type") ? n.getNamedItem("data-bm-type").value : n.getNamedItem("bm-type") ? n.getNamedItem("bm-type").value : n.getNamedItem("data-bm-renderer") ? n.getNamedItem("data-bm-renderer").value : n.getNamedItem("bm-renderer") ? n.getNamedItem("bm-renderer").value : "canvas";
                    var r = n.getNamedItem("data-anim-loop") ? n.getNamedItem("data-anim-loop").value : n.getNamedItem("data-bm-loop") ? n.getNamedItem("data-bm-loop").value : n.getNamedItem("bm-loop") ? n.getNamedItem("bm-loop").value : "";
                    "false" === r ? i.loop = !1 : "true" === r ? i.loop = !0 : "" !== r && (i.loop = parseInt(r, 10));
                    var s = n.getNamedItem("data-anim-autoplay") ? n.getNamedItem("data-anim-autoplay").value : n.getNamedItem("data-bm-autoplay") ? n.getNamedItem("data-bm-autoplay").value : !n.getNamedItem("bm-autoplay") || n.getNamedItem("bm-autoplay").value;
                    i.autoplay = "false" !== s, i.name = n.getNamedItem("data-name") ? n.getNamedItem("data-name").value : n.getNamedItem("data-bm-name") ? n.getNamedItem("data-bm-name").value : n.getNamedItem("bm-name") ? n.getNamedItem("bm-name").value : "", "false" === (n.getNamedItem("data-anim-prerender") ? n.getNamedItem("data-anim-prerender").value : n.getNamedItem("data-bm-prerender") ? n.getNamedItem("data-bm-prerender").value : n.getNamedItem("bm-prerender") ? n.getNamedItem("bm-prerender").value : "") && (i.prerender = !1), this.setParams(i)
                }, AnimationItem.prototype.includeLayers = function (t) {
                    t.op > this.animationData.op && (this.animationData.op = t.op, this.totalFrames = Math.floor(t.op - this.animationData.ip));
                    var e, i, n = this.animationData.layers, r = n.length, s = t.layers, a = s.length;
                    for (i = 0; i < a; i += 1) for (e = 0; e < r;) {
                        if (n[e].id === s[i].id) {
                            n[e] = s[i];
                            break
                        }
                        e += 1
                    }
                    if ((t.chars || t.fonts) && (this.renderer.globalData.fontManager.addChars(t.chars), this.renderer.globalData.fontManager.addFonts(t.fonts, this.renderer.globalData.defs)), t.assets) for (r = t.assets.length, e = 0; e < r; e += 1) this.animationData.assets.push(t.assets[e]);
                    this.animationData.__complete = !1, dataManager.completeAnimation(this.animationData, this.onSegmentComplete)
                }, AnimationItem.prototype.onSegmentComplete = function (t) {
                    this.animationData = t, expressionsPlugin && expressionsPlugin.initExpressions(this), this.loadNextSegment()
                }, AnimationItem.prototype.loadNextSegment = function () {
                    var t = this.animationData.segments;
                    if (!t || 0 === t.length || !this.autoloadSegments) return this.trigger("data_ready"), void (this.timeCompleted = this.totalFrames);
                    var e = t.shift();
                    this.timeCompleted = e.time * this.frameRate;
                    var i = this.path + this.fileName + "_" + this.segmentPos + ".json";
                    this.segmentPos += 1, dataManager.loadData(i, this.includeLayers.bind(this), function () {
                        this.trigger("data_failed")
                    }.bind(this))
                }, AnimationItem.prototype.loadSegments = function () {
                    this.animationData.segments || (this.timeCompleted = this.totalFrames), this.loadNextSegment()
                }, AnimationItem.prototype.imagesLoaded = function () {
                    this.trigger("loaded_images"), this.checkLoaded()
                }, AnimationItem.prototype.preloadImages = function () {
                    this.imagePreloader.setAssetsPath(this.assetsPath), this.imagePreloader.setPath(this.path), this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this))
                }, AnimationItem.prototype.configAnimation = function (t) {
                    if (this.renderer) try {
                        this.animationData = t, this.initialSegment ? (this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]), this.firstFrame = Math.round(this.initialSegment[0])) : (this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip), this.firstFrame = Math.round(this.animationData.ip)), this.renderer.configAnimation(t), t.assets || (t.assets = []), this.assets = this.animationData.assets, this.frameRate = this.animationData.fr, this.frameMult = this.animationData.fr / 1e3, this.renderer.searchExtraCompositions(t.assets), this.markers = markerParser(t.markers || []), this.trigger("config_ready"), this.preloadImages(), this.loadSegments(), this.updaFrameModifier(), this.waitForFontsLoaded(), this.isPaused && this.audioController.pause()
                    } catch (t) {
                        this.triggerConfigError(t)
                    }
                }, AnimationItem.prototype.waitForFontsLoaded = function () {
                    this.renderer && (this.renderer.globalData.fontManager.isLoaded ? this.checkLoaded() : setTimeout(this.waitForFontsLoaded.bind(this), 20))
                }, AnimationItem.prototype.checkLoaded = function () {
                    !this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || "canvas" !== this.renderer.rendererType) && this.imagePreloader.loadedFootages() && (this.isLoaded = !0, expressionsPlugin && expressionsPlugin.initExpressions(this), this.renderer.initItems(), setTimeout(function () {
                        this.trigger("DOMLoaded")
                    }.bind(this), 0), this.gotoFrame(), this.autoplay && this.play())
                }, AnimationItem.prototype.resize = function () {
                    this.renderer.updateContainerSize()
                }, AnimationItem.prototype.setSubframe = function (t) {
                    this.isSubframeEnabled = !!t
                }, AnimationItem.prototype.gotoFrame = function () {
                    this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame, this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted && (this.currentFrame = this.timeCompleted), this.trigger("enterFrame"), this.renderFrame(), this.trigger("drawnFrame")
                }, AnimationItem.prototype.renderFrame = function () {
                    if (!1 !== this.isLoaded && this.renderer) try {
                        this.renderer.renderFrame(this.currentFrame + this.firstFrame)
                    } catch (t) {
                        this.triggerRenderFrameError(t)
                    }
                }, AnimationItem.prototype.play = function (t) {
                    t && this.name !== t || !0 === this.isPaused && (this.isPaused = !1, this.audioController.resume(), this._idle && (this._idle = !1, this.trigger("_active")))
                }, AnimationItem.prototype.pause = function (t) {
                    t && this.name !== t || !1 === this.isPaused && (this.isPaused = !0, this._idle = !0, this.trigger("_idle"), this.audioController.pause())
                }, AnimationItem.prototype.togglePause = function (t) {
                    t && this.name !== t || (!0 === this.isPaused ? this.play() : this.pause())
                }, AnimationItem.prototype.stop = function (t) {
                    t && this.name !== t || (this.pause(), this.playCount = 0, this._completedLoop = !1, this.setCurrentRawFrameValue(0))
                }, AnimationItem.prototype.getMarkerData = function (t) {
                    for (var e, i = 0; i < this.markers.length; i += 1) if ((e = this.markers[i]).payload && e.payload.name === t) return e;
                    return null
                }, AnimationItem.prototype.goToAndStop = function (t, e, i) {
                    if (!i || this.name === i) {
                        var n = Number(t);
                        if (isNaN(n)) {
                            var r = this.getMarkerData(t);
                            r && this.goToAndStop(r.time, !0)
                        } else e ? this.setCurrentRawFrameValue(t) : this.setCurrentRawFrameValue(t * this.frameModifier);
                        this.pause()
                    }
                }, AnimationItem.prototype.goToAndPlay = function (t, e, i) {
                    if (!i || this.name === i) {
                        var n = Number(t);
                        if (isNaN(n)) {
                            var r = this.getMarkerData(t);
                            r && (r.duration ? this.playSegments([r.time, r.time + r.duration], !0) : this.goToAndStop(r.time, !0))
                        } else this.goToAndStop(n, e, i);
                        this.play()
                    }
                }, AnimationItem.prototype.advanceTime = function (t) {
                    if (!0 !== this.isPaused && !1 !== this.isLoaded) {
                        var e = this.currentRawFrame + t * this.frameModifier, i = !1;
                        e >= this.totalFrames - 1 && this.frameModifier > 0 ? this.loop && this.playCount !== this.loop ? e >= this.totalFrames ? (this.playCount += 1, this.checkSegments(e % this.totalFrames) || (this.setCurrentRawFrameValue(e % this.totalFrames), this._completedLoop = !0, this.trigger("loopComplete"))) : this.setCurrentRawFrameValue(e) : this.checkSegments(e > this.totalFrames ? e % this.totalFrames : 0) || (i = !0, e = this.totalFrames - 1) : e < 0 ? this.checkSegments(e % this.totalFrames) || (!this.loop || this.playCount-- <= 0 && !0 !== this.loop ? (i = !0, e = 0) : (this.setCurrentRawFrameValue(this.totalFrames + e % this.totalFrames), this._completedLoop ? this.trigger("loopComplete") : this._completedLoop = !0)) : this.setCurrentRawFrameValue(e), i && (this.setCurrentRawFrameValue(e), this.pause(), this.trigger("complete"))
                    }
                }, AnimationItem.prototype.adjustSegment = function (t, e) {
                    this.playCount = 0, t[1] < t[0] ? (this.frameModifier > 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(-1)), this.totalFrames = t[0] - t[1], this.timeCompleted = this.totalFrames, this.firstFrame = t[1], this.setCurrentRawFrameValue(this.totalFrames - .001 - e)) : t[1] > t[0] && (this.frameModifier < 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(1)), this.totalFrames = t[1] - t[0], this.timeCompleted = this.totalFrames, this.firstFrame = t[0], this.setCurrentRawFrameValue(.001 + e)), this.trigger("segmentStart")
                }, AnimationItem.prototype.setSegment = function (t, e) {
                    var i = -1;
                    this.isPaused && (this.currentRawFrame + this.firstFrame < t ? i = t : this.currentRawFrame + this.firstFrame > e && (i = e - t)), this.firstFrame = t, this.totalFrames = e - t, this.timeCompleted = this.totalFrames, -1 !== i && this.goToAndStop(i, !0)
                }, AnimationItem.prototype.playSegments = function (t, e) {
                    if (e && (this.segments.length = 0), "object" == typeof t[0]) {
                        var i, n = t.length;
                        for (i = 0; i < n; i += 1) this.segments.push(t[i])
                    } else this.segments.push(t);
                    this.segments.length && e && this.adjustSegment(this.segments.shift(), 0), this.isPaused && this.play()
                }, AnimationItem.prototype.resetSegments = function (t) {
                    this.segments.length = 0, this.segments.push([this.animationData.ip, this.animationData.op]), t && this.checkSegments(0)
                }, AnimationItem.prototype.checkSegments = function (t) {
                    return !!this.segments.length && (this.adjustSegment(this.segments.shift(), t), !0)
                }, AnimationItem.prototype.destroy = function (t) {
                    t && this.name !== t || !this.renderer || (this.renderer.destroy(), this.imagePreloader.destroy(), this.trigger("destroy"), this._cbs = null, this.onEnterFrame = null, this.onLoopComplete = null, this.onComplete = null, this.onSegmentStart = null, this.onDestroy = null, this.renderer = null, this.renderer = null, this.imagePreloader = null, this.projectInterface = null)
                }, AnimationItem.prototype.setCurrentRawFrameValue = function (t) {
                    this.currentRawFrame = t, this.gotoFrame()
                }, AnimationItem.prototype.setSpeed = function (t) {
                    this.playSpeed = t, this.updaFrameModifier()
                }, AnimationItem.prototype.setDirection = function (t) {
                    this.playDirection = t < 0 ? -1 : 1, this.updaFrameModifier()
                }, AnimationItem.prototype.setVolume = function (t, e) {
                    e && this.name !== e || this.audioController.setVolume(t)
                }, AnimationItem.prototype.getVolume = function () {
                    return this.audioController.getVolume()
                }, AnimationItem.prototype.mute = function (t) {
                    t && this.name !== t || this.audioController.mute()
                }, AnimationItem.prototype.unmute = function (t) {
                    t && this.name !== t || this.audioController.unmute()
                }, AnimationItem.prototype.updaFrameModifier = function () {
                    this.frameModifier = this.frameMult * this.playSpeed * this.playDirection, this.audioController.setRate(this.playSpeed * this.playDirection)
                }, AnimationItem.prototype.getPath = function () {
                    return this.path
                }, AnimationItem.prototype.getAssetsPath = function (t) {
                    var e = "";
                    if (t.e) e = t.p; else if (this.assetsPath) {
                        var i = t.p;
                        -1 !== i.indexOf("images/") && (i = i.split("/")[1]), e = this.assetsPath + i
                    } else e = this.path, e += t.u ? t.u : "", e += t.p;
                    return e
                }, AnimationItem.prototype.getAssetData = function (t) {
                    for (var e = 0, i = this.assets.length; e < i;) {
                        if (t === this.assets[e].id) return this.assets[e];
                        e += 1
                    }
                    return null
                }, AnimationItem.prototype.hide = function () {
                    this.renderer.hide()
                }, AnimationItem.prototype.show = function () {
                    this.renderer.show()
                }, AnimationItem.prototype.getDuration = function (t) {
                    return t ? this.totalFrames : this.totalFrames / this.frameRate
                }, AnimationItem.prototype.trigger = function (t) {
                    if (this._cbs && this._cbs[t]) switch (t) {
                        case"enterFrame":
                        case"drawnFrame":
                            this.triggerEvent(t, new BMEnterFrameEvent(t, this.currentFrame, this.totalFrames, this.frameModifier));
                            break;
                        case"loopComplete":
                            this.triggerEvent(t, new BMCompleteLoopEvent(t, this.loop, this.playCount, this.frameMult));
                            break;
                        case"complete":
                            this.triggerEvent(t, new BMCompleteEvent(t, this.frameMult));
                            break;
                        case"segmentStart":
                            this.triggerEvent(t, new BMSegmentStartEvent(t, this.firstFrame, this.totalFrames));
                            break;
                        case"destroy":
                            this.triggerEvent(t, new BMDestroyEvent(t, this));
                            break;
                        default:
                            this.triggerEvent(t)
                    }
                    "enterFrame" === t && this.onEnterFrame && this.onEnterFrame.call(this, new BMEnterFrameEvent(t, this.currentFrame, this.totalFrames, this.frameMult)), "loopComplete" === t && this.onLoopComplete && this.onLoopComplete.call(this, new BMCompleteLoopEvent(t, this.loop, this.playCount, this.frameMult)), "complete" === t && this.onComplete && this.onComplete.call(this, new BMCompleteEvent(t, this.frameMult)), "segmentStart" === t && this.onSegmentStart && this.onSegmentStart.call(this, new BMSegmentStartEvent(t, this.firstFrame, this.totalFrames)), "destroy" === t && this.onDestroy && this.onDestroy.call(this, new BMDestroyEvent(t, this))
                }, AnimationItem.prototype.triggerRenderFrameError = function (t) {
                    var e = new BMRenderFrameErrorEvent(t, this.currentFrame);
                    this.triggerEvent("error", e), this.onError && this.onError.call(this, e)
                }, AnimationItem.prototype.triggerConfigError = function (t) {
                    var e = new BMConfigErrorEvent(t, this.currentFrame);
                    this.triggerEvent("error", e), this.onError && this.onError.call(this, e)
                };
                var Expressions = function () {
                    var t = {
                        initExpressions: function (t) {
                            var e = 0, i = [];
                            t.renderer.compInterface = CompExpressionInterface(t.renderer), t.renderer.globalData.projectInterface.registerComposition(t.renderer), t.renderer.globalData.pushExpression = function () {
                                e += 1
                            }, t.renderer.globalData.popExpression = function () {
                                0 == (e -= 1) && function () {
                                    var t, e = i.length;
                                    for (t = 0; t < e; t += 1) i[t].release();
                                    i.length = 0
                                }()
                            }, t.renderer.globalData.registerExpressionProperty = function (t) {
                                -1 === i.indexOf(t) && i.push(t)
                            }
                        }
                    };
                    return t
                }();
                expressionsPlugin = Expressions;
                var ExpressionManager = function () {
                    var ob = {}, Math = BMMath, window = null, document = null, XMLHttpRequest = null, fetch = null,
                        frames = null;

                    function $bm_isInstanceOfArray(t) {
                        return t.constructor === Array || t.constructor === Float32Array
                    }

                    function isNumerable(t, e) {
                        return "number" === t || "boolean" === t || "string" === t || e instanceof Number
                    }

                    function $bm_neg(t) {
                        var e = typeof t;
                        if ("number" === e || "boolean" === e || t instanceof Number) return -t;
                        if ($bm_isInstanceOfArray(t)) {
                            var i, n = t.length, r = [];
                            for (i = 0; i < n; i += 1) r[i] = -t[i];
                            return r
                        }
                        return t.propType ? t.v : -t
                    }

                    var easeInBez = BezierFactory.getBezierEasing(.333, 0, .833, .833, "easeIn").get,
                        easeOutBez = BezierFactory.getBezierEasing(.167, .167, .667, 1, "easeOut").get,
                        easeInOutBez = BezierFactory.getBezierEasing(.33, 0, .667, 1, "easeInOut").get;

                    function sum(t, e) {
                        var i = typeof t, n = typeof e;
                        if ("string" === i || "string" === n) return t + e;
                        if (isNumerable(i, t) && isNumerable(n, e)) return t + e;
                        if ($bm_isInstanceOfArray(t) && isNumerable(n, e)) return (t = t.slice(0))[0] += e, t;
                        if (isNumerable(i, t) && $bm_isInstanceOfArray(e)) return (e = e.slice(0))[0] = t + e[0], e;
                        if ($bm_isInstanceOfArray(t) && $bm_isInstanceOfArray(e)) {
                            for (var r = 0, s = t.length, a = e.length, o = []; r < s || r < a;) ("number" == typeof t[r] || t[r] instanceof Number) && ("number" == typeof e[r] || e[r] instanceof Number) ? o[r] = t[r] + e[r] : o[r] = void 0 === e[r] ? t[r] : t[r] || e[r], r += 1;
                            return o
                        }
                        return 0
                    }

                    var add = sum;

                    function sub(t, e) {
                        var i = typeof t, n = typeof e;
                        if (isNumerable(i, t) && isNumerable(n, e)) return "string" === i && (t = parseInt(t, 10)), "string" === n && (e = parseInt(e, 10)), t - e;
                        if ($bm_isInstanceOfArray(t) && isNumerable(n, e)) return (t = t.slice(0))[0] -= e, t;
                        if (isNumerable(i, t) && $bm_isInstanceOfArray(e)) return (e = e.slice(0))[0] = t - e[0], e;
                        if ($bm_isInstanceOfArray(t) && $bm_isInstanceOfArray(e)) {
                            for (var r = 0, s = t.length, a = e.length, o = []; r < s || r < a;) ("number" == typeof t[r] || t[r] instanceof Number) && ("number" == typeof e[r] || e[r] instanceof Number) ? o[r] = t[r] - e[r] : o[r] = void 0 === e[r] ? t[r] : t[r] || e[r], r += 1;
                            return o
                        }
                        return 0
                    }

                    function mul(t, e) {
                        var i, n, r, s = typeof t, a = typeof e;
                        if (isNumerable(s, t) && isNumerable(a, e)) return t * e;
                        if ($bm_isInstanceOfArray(t) && isNumerable(a, e)) {
                            for (r = t.length, i = createTypedArray("float32", r), n = 0; n < r; n += 1) i[n] = t[n] * e;
                            return i
                        }
                        if (isNumerable(s, t) && $bm_isInstanceOfArray(e)) {
                            for (r = e.length, i = createTypedArray("float32", r), n = 0; n < r; n += 1) i[n] = t * e[n];
                            return i
                        }
                        return 0
                    }

                    function div(t, e) {
                        var i, n, r, s = typeof t, a = typeof e;
                        if (isNumerable(s, t) && isNumerable(a, e)) return t / e;
                        if ($bm_isInstanceOfArray(t) && isNumerable(a, e)) {
                            for (r = t.length, i = createTypedArray("float32", r), n = 0; n < r; n += 1) i[n] = t[n] / e;
                            return i
                        }
                        if (isNumerable(s, t) && $bm_isInstanceOfArray(e)) {
                            for (r = e.length, i = createTypedArray("float32", r), n = 0; n < r; n += 1) i[n] = t / e[n];
                            return i
                        }
                        return 0
                    }

                    function mod(t, e) {
                        return "string" == typeof t && (t = parseInt(t, 10)), "string" == typeof e && (e = parseInt(e, 10)), t % e
                    }

                    var $bm_sum = sum, $bm_sub = sub, $bm_mul = mul, $bm_div = div, $bm_mod = mod;

                    function clamp(t, e, i) {
                        if (e > i) {
                            var n = i;
                            i = e, e = n
                        }
                        return Math.min(Math.max(t, e), i)
                    }

                    function radiansToDegrees(t) {
                        return t / degToRads
                    }

                    var radians_to_degrees = radiansToDegrees;

                    function degreesToRadians(t) {
                        return t * degToRads
                    }

                    var degrees_to_radians = radiansToDegrees, helperLengthArray = [0, 0, 0, 0, 0, 0];

                    function length(t, e) {
                        if ("number" == typeof t || t instanceof Number) return e = e || 0, Math.abs(t - e);
                        var i;
                        e || (e = helperLengthArray);
                        var n = Math.min(t.length, e.length), r = 0;
                        for (i = 0; i < n; i += 1) r += Math.pow(e[i] - t[i], 2);
                        return Math.sqrt(r)
                    }

                    function normalize(t) {
                        return div(t, length(t))
                    }

                    function rgbToHsl(t) {
                        var e, i, n = t[0], r = t[1], s = t[2], a = Math.max(n, r, s), o = Math.min(n, r, s),
                            h = (a + o) / 2;
                        if (a === o) e = 0, i = 0; else {
                            var l = a - o;
                            switch (i = h > .5 ? l / (2 - a - o) : l / (a + o), a) {
                                case n:
                                    e = (r - s) / l + (r < s ? 6 : 0);
                                    break;
                                case r:
                                    e = (s - n) / l + 2;
                                    break;
                                case s:
                                    e = (n - r) / l + 4
                            }
                            e /= 6
                        }
                        return [e, i, h, t[3]]
                    }

                    function hue2rgb(t, e, i) {
                        return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t
                    }

                    function hslToRgb(t) {
                        var e, i, n, r = t[0], s = t[1], a = t[2];
                        if (0 === s) e = a, n = a, i = a; else {
                            var o = a < .5 ? a * (1 + s) : a + s - a * s, h = 2 * a - o;
                            e = hue2rgb(h, o, r + 1 / 3), i = hue2rgb(h, o, r), n = hue2rgb(h, o, r - 1 / 3)
                        }
                        return [e, i, n, t[3]]
                    }

                    function linear(t, e, i, n, r) {
                        if (void 0 !== n && void 0 !== r || (n = e, r = i, e = 0, i = 1), i < e) {
                            var s = i;
                            i = e, e = s
                        }
                        if (t <= e) return n;
                        if (t >= i) return r;
                        var a, o = i === e ? 0 : (t - e) / (i - e);
                        if (!n.length) return n + (r - n) * o;
                        var h = n.length, l = createTypedArray("float32", h);
                        for (a = 0; a < h; a += 1) l[a] = n[a] + (r[a] - n[a]) * o;
                        return l
                    }

                    function random(t, e) {
                        if (void 0 === e && (void 0 === t ? (t = 0, e = 1) : (e = t, t = void 0)), e.length) {
                            var i, n = e.length;
                            t || (t = createTypedArray("float32", n));
                            var r = createTypedArray("float32", n), s = BMMath.random();
                            for (i = 0; i < n; i += 1) r[i] = t[i] + s * (e[i] - t[i]);
                            return r
                        }
                        return void 0 === t && (t = 0), t + BMMath.random() * (e - t)
                    }

                    function createPath(t, e, i, n) {
                        var r, s = t.length, a = shapePool.newElement();
                        a.setPathData(!!n, s);
                        var o, h, l = [0, 0];
                        for (r = 0; r < s; r += 1) o = e && e[r] ? e[r] : l, h = i && i[r] ? i[r] : l, a.setTripleAt(t[r][0], t[r][1], h[0] + t[r][0], h[1] + t[r][1], o[0] + t[r][0], o[1] + t[r][1], r, !0);
                        return a
                    }

                    function initiateExpression(elem, data, property) {
                        var val = data.x, needsVelocity = /velocity(?![\w\d])/.test(val),
                            _needsRandom = -1 !== val.indexOf("random"), elemType = elem.data.ty, transform,
                            $bm_transform, content, effect, thisProperty = property;
                        thisProperty.valueAtTime = thisProperty.getValueAtTime, Object.defineProperty(thisProperty, "value", {
                            get: function () {
                                return thisProperty.v
                            }
                        }), elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate, elem.comp.displayStartTime = 0;
                        var inPoint = elem.data.ip / elem.comp.globalData.frameRate,
                            outPoint = elem.data.op / elem.comp.globalData.frameRate,
                            width = elem.data.sw ? elem.data.sw : 0, height = elem.data.sh ? elem.data.sh : 0,
                            name = elem.data.nm, loopIn, loop_in, loopOut, loop_out, smooth, toWorld, fromWorld,
                            fromComp, toComp, fromCompToSurface, position, rotation, anchorPoint, scale, thisLayer,
                            thisComp, mask, valueAtTime, velocityAtTime, scoped_bm_rt,
                            expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0],
                            numKeys = property.kf ? data.k.length : 0, active = !this.data || !0 !== this.data.hd,
                            wiggle = function (t, e) {
                                var i, n, r = this.pv.length ? this.pv.length : 1, s = createTypedArray("float32", r),
                                    a = Math.floor(5 * time);
                                for (i = 0, n = 0; i < a;) {
                                    for (n = 0; n < r; n += 1) s[n] += -e + 2 * e * BMMath.random();
                                    i += 1
                                }
                                var o = 5 * time, h = o - Math.floor(o), l = createTypedArray("float32", r);
                                if (r > 1) {
                                    for (n = 0; n < r; n += 1) l[n] = this.pv[n] + s[n] + (-e + 2 * e * BMMath.random()) * h;
                                    return l
                                }
                                return this.pv + s[0] + (-e + 2 * e * BMMath.random()) * h
                            }.bind(this);

                        function loopInDuration(t, e) {
                            return loopIn(t, e, !0)
                        }

                        function loopOutDuration(t, e) {
                            return loopOut(t, e, !0)
                        }

                        thisProperty.loopIn && (loopIn = thisProperty.loopIn.bind(thisProperty), loop_in = loopIn), thisProperty.loopOut && (loopOut = thisProperty.loopOut.bind(thisProperty), loop_out = loopOut), thisProperty.smooth && (smooth = thisProperty.smooth.bind(thisProperty)), this.getValueAtTime && (valueAtTime = this.getValueAtTime.bind(this)), this.getVelocityAtTime && (velocityAtTime = this.getVelocityAtTime.bind(this));
                        var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface),
                            time, velocity, value, text, textIndex, textTotal, selectorValue;

                        function lookAt(t, e) {
                            var i = [e[0] - t[0], e[1] - t[1], e[2] - t[2]],
                                n = Math.atan2(i[0], Math.sqrt(i[1] * i[1] + i[2] * i[2])) / degToRads;
                            return [-Math.atan2(i[1], i[2]) / degToRads, n, 0]
                        }

                        function easeOut(t, e, i, n, r) {
                            return applyEase(easeOutBez, t, e, i, n, r)
                        }

                        function easeIn(t, e, i, n, r) {
                            return applyEase(easeInBez, t, e, i, n, r)
                        }

                        function ease(t, e, i, n, r) {
                            return applyEase(easeInOutBez, t, e, i, n, r)
                        }

                        function applyEase(t, e, i, n, r, s) {
                            void 0 === r ? (r = i, s = n) : e = (e - i) / (n - i), e > 1 ? e = 1 : e < 0 && (e = 0);
                            var a = t(e);
                            if ($bm_isInstanceOfArray(r)) {
                                var o, h = r.length, l = createTypedArray("float32", h);
                                for (o = 0; o < h; o += 1) l[o] = (s[o] - r[o]) * a + r[o];
                                return l
                            }
                            return (s - r) * a + r
                        }

                        function nearestKey(t) {
                            var e, i, n, r = data.k.length;
                            if (data.k.length && "number" != typeof data.k[0]) if (i = -1, (t *= elem.comp.globalData.frameRate) < data.k[0].t) i = 1, n = data.k[0].t; else {
                                for (e = 0; e < r - 1; e += 1) {
                                    if (t === data.k[e].t) {
                                        i = e + 1, n = data.k[e].t;
                                        break
                                    }
                                    if (t > data.k[e].t && t < data.k[e + 1].t) {
                                        t - data.k[e].t > data.k[e + 1].t - t ? (i = e + 2, n = data.k[e + 1].t) : (i = e + 1, n = data.k[e].t);
                                        break
                                    }
                                }
                                -1 === i && (i = e + 1, n = data.k[e].t)
                            } else i = 0, n = 0;
                            var s = {};
                            return s.index = i, s.time = n / elem.comp.globalData.frameRate, s
                        }

                        function key(t) {
                            var e, i, n;
                            if (!data.k.length || "number" == typeof data.k[0]) throw new Error("The property has no keyframe at index " + t);
                            t -= 1, e = {time: data.k[t].t / elem.comp.globalData.frameRate, value: []};
                            var r = Object.prototype.hasOwnProperty.call(data.k[t], "s") ? data.k[t].s : data.k[t - 1].e;
                            for (n = r.length, i = 0; i < n; i += 1) e[i] = r[i], e.value[i] = r[i];
                            return e
                        }

                        function framesToTime(t, e) {
                            return e || (e = elem.comp.globalData.frameRate), t / e
                        }

                        function timeToFrames(t, e) {
                            return t || 0 === t || (t = time), e || (e = elem.comp.globalData.frameRate), t * e
                        }

                        function seedRandom(t) {
                            BMMath.seedrandom(randSeed + t)
                        }

                        function sourceRectAtTime() {
                            return elem.sourceRectAtTime()
                        }

                        function substring(t, e) {
                            return "string" == typeof value ? void 0 === e ? value.substring(t) : value.substring(t, e) : ""
                        }

                        function substr(t, e) {
                            return "string" == typeof value ? void 0 === e ? value.substr(t) : value.substr(t, e) : ""
                        }

                        function posterizeTime(t) {
                            time = 0 === t ? 0 : Math.floor(time * t) / t, value = valueAtTime(time)
                        }

                        var index = elem.data.ind, hasParent = !(!elem.hierarchy || !elem.hierarchy.length), parent,
                            randSeed = Math.floor(1e6 * Math.random()), globalData = elem.globalData;

                        function executeExpression(t) {
                            return value = t, this.frameExpressionId === elem.globalData.frameId && "textSelector" !== this.propType ? value : ("textSelector" === this.propType && (textIndex = this.textIndex, textTotal = this.textTotal, selectorValue = this.selectorValue), thisLayer || (text = elem.layerInterface.text, thisLayer = elem.layerInterface, thisComp = elem.comp.compInterface, toWorld = thisLayer.toWorld.bind(thisLayer), fromWorld = thisLayer.fromWorld.bind(thisLayer), fromComp = thisLayer.fromComp.bind(thisLayer), toComp = thisLayer.toComp.bind(thisLayer), mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null, fromCompToSurface = fromComp), transform || (transform = elem.layerInterface("ADBE Transform Group"), $bm_transform = transform, transform && (anchorPoint = transform.anchorPoint)), 4 !== elemType || content || (content = thisLayer("ADBE Root Vectors Group")), effect || (effect = thisLayer(4)), (hasParent = !(!elem.hierarchy || !elem.hierarchy.length)) && !parent && (parent = elem.hierarchy[0].layerInterface), time = this.comp.renderedFrame / this.comp.globalData.frameRate, _needsRandom && seedRandom(randSeed + time), needsVelocity && (velocity = velocityAtTime(time)), expression_function(), this.frameExpressionId = elem.globalData.frameId, "shape" === scoped_bm_rt.propType && (scoped_bm_rt = scoped_bm_rt.v), scoped_bm_rt)
                        }

                        return executeExpression
                    }

                    return ob.initiateExpression = initiateExpression, ob
                }(), expressionHelpers = {
                    searchExpressions: function (t, e, i) {
                        e.x && (i.k = !0, i.x = !0, i.initiateExpression = ExpressionManager.initiateExpression, i.effectsSequence.push(i.initiateExpression(t, e, i).bind(i)))
                    }, getSpeedAtTime: function (t) {
                        var e = this.getValueAtTime(t), i = this.getValueAtTime(t + -.01), n = 0;
                        if (e.length) {
                            var r;
                            for (r = 0; r < e.length; r += 1) n += Math.pow(i[r] - e[r], 2);
                            n = 100 * Math.sqrt(n)
                        } else n = 0;
                        return n
                    }, getVelocityAtTime: function (t) {
                        if (void 0 !== this.vel) return this.vel;
                        var e, i, n = -.001, r = this.getValueAtTime(t), s = this.getValueAtTime(t + n);
                        if (r.length) for (e = createTypedArray("float32", r.length), i = 0; i < r.length; i += 1) e[i] = (s[i] - r[i]) / n; else e = (s - r) / n;
                        return e
                    }, getValueAtTime: function (t) {
                        return t *= this.elem.globalData.frameRate, (t -= this.offsetTime) !== this._cachingAtTime.lastFrame && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < t ? this._cachingAtTime.lastIndex : 0, this._cachingAtTime.value = this.interpolateValue(t, this._cachingAtTime), this._cachingAtTime.lastFrame = t), this._cachingAtTime.value
                    }, getStaticValueAtTime: function () {
                        return this.pv
                    }, setGroupProperty: function (t) {
                        this.propertyGroup = t
                    }
                };
                !function () {
                    function t(t, e, i) {
                        if (!this.k || !this.keyframes) return this.pv;
                        t = t ? t.toLowerCase() : "";
                        var n, r, s, a, o, h = this.comp.renderedFrame, l = this.keyframes, c = l[l.length - 1].t;
                        if (h <= c) return this.pv;
                        if (i ? r = c - (n = e ? Math.abs(c - this.elem.comp.globalData.frameRate * e) : Math.max(0, c - this.elem.data.ip)) : ((!e || e > l.length - 1) && (e = l.length - 1), n = c - (r = l[l.length - 1 - e].t)), "pingpong" === t) {
                            if (Math.floor((h - r) / n) % 2 != 0) return this.getValueAtTime((n - (h - r) % n + r) / this.comp.globalData.frameRate, 0)
                        } else {
                            if ("offset" === t) {
                                var u = this.getValueAtTime(r / this.comp.globalData.frameRate, 0),
                                    p = this.getValueAtTime(c / this.comp.globalData.frameRate, 0),
                                    d = this.getValueAtTime(((h - r) % n + r) / this.comp.globalData.frameRate, 0),
                                    f = Math.floor((h - r) / n);
                                if (this.pv.length) {
                                    for (a = (o = new Array(u.length)).length, s = 0; s < a; s += 1) o[s] = (p[s] - u[s]) * f + d[s];
                                    return o
                                }
                                return (p - u) * f + d
                            }
                            if ("continue" === t) {
                                var m = this.getValueAtTime(c / this.comp.globalData.frameRate, 0),
                                    g = this.getValueAtTime((c - .001) / this.comp.globalData.frameRate, 0);
                                if (this.pv.length) {
                                    for (a = (o = new Array(m.length)).length, s = 0; s < a; s += 1) o[s] = m[s] + (m[s] - g[s]) * ((h - c) / this.comp.globalData.frameRate) / 5e-4;
                                    return o
                                }
                                return m + (h - c) / .001 * (m - g)
                            }
                        }
                        return this.getValueAtTime(((h - r) % n + r) / this.comp.globalData.frameRate, 0)
                    }

                    function e(t, e, i) {
                        if (!this.k) return this.pv;
                        t = t ? t.toLowerCase() : "";
                        var n, r, s, a, o, h = this.comp.renderedFrame, l = this.keyframes, c = l[0].t;
                        if (h >= c) return this.pv;
                        if (i ? r = c + (n = e ? Math.abs(this.elem.comp.globalData.frameRate * e) : Math.max(0, this.elem.data.op - c)) : ((!e || e > l.length - 1) && (e = l.length - 1), n = (r = l[e].t) - c), "pingpong" === t) {
                            if (Math.floor((c - h) / n) % 2 == 0) return this.getValueAtTime(((c - h) % n + c) / this.comp.globalData.frameRate, 0)
                        } else {
                            if ("offset" === t) {
                                var u = this.getValueAtTime(c / this.comp.globalData.frameRate, 0),
                                    p = this.getValueAtTime(r / this.comp.globalData.frameRate, 0),
                                    d = this.getValueAtTime((n - (c - h) % n + c) / this.comp.globalData.frameRate, 0),
                                    f = Math.floor((c - h) / n) + 1;
                                if (this.pv.length) {
                                    for (a = (o = new Array(u.length)).length, s = 0; s < a; s += 1) o[s] = d[s] - (p[s] - u[s]) * f;
                                    return o
                                }
                                return d - (p - u) * f
                            }
                            if ("continue" === t) {
                                var m = this.getValueAtTime(c / this.comp.globalData.frameRate, 0),
                                    g = this.getValueAtTime((c + .001) / this.comp.globalData.frameRate, 0);
                                if (this.pv.length) {
                                    for (a = (o = new Array(m.length)).length, s = 0; s < a; s += 1) o[s] = m[s] + (m[s] - g[s]) * (c - h) / .001;
                                    return o
                                }
                                return m + (m - g) * (c - h) / .001
                            }
                        }
                        return this.getValueAtTime((n - ((c - h) % n + c)) / this.comp.globalData.frameRate, 0)
                    }

                    function i(t, e) {
                        if (!this.k) return this.pv;
                        if (t = .5 * (t || .4), (e = Math.floor(e || 5)) <= 1) return this.pv;
                        var i, n, r = this.comp.renderedFrame / this.comp.globalData.frameRate, s = r - t,
                            a = e > 1 ? (r + t - s) / (e - 1) : 1, o = 0, h = 0;
                        for (i = this.pv.length ? createTypedArray("float32", this.pv.length) : 0; o < e;) {
                            if (n = this.getValueAtTime(s + o * a), this.pv.length) for (h = 0; h < this.pv.length; h += 1) i[h] += n[h]; else i += n;
                            o += 1
                        }
                        if (this.pv.length) for (h = 0; h < this.pv.length; h += 1) i[h] /= e; else i /= e;
                        return i
                    }

                    function n(t) {
                        this._transformCachingAtTime || (this._transformCachingAtTime = {v: new Matrix});
                        var e = this._transformCachingAtTime.v;
                        if (e.cloneFromProps(this.pre.props), this.appliedTransformations < 1) {
                            var i = this.a.getValueAtTime(t);
                            e.translate(-i[0] * this.a.mult, -i[1] * this.a.mult, i[2] * this.a.mult)
                        }
                        if (this.appliedTransformations < 2) {
                            var n = this.s.getValueAtTime(t);
                            e.scale(n[0] * this.s.mult, n[1] * this.s.mult, n[2] * this.s.mult)
                        }
                        if (this.sk && this.appliedTransformations < 3) {
                            var r = this.sk.getValueAtTime(t), s = this.sa.getValueAtTime(t);
                            e.skewFromAxis(-r * this.sk.mult, s * this.sa.mult)
                        }
                        if (this.r && this.appliedTransformations < 4) {
                            var a = this.r.getValueAtTime(t);
                            e.rotate(-a * this.r.mult)
                        } else if (!this.r && this.appliedTransformations < 4) {
                            var o = this.rz.getValueAtTime(t), h = this.ry.getValueAtTime(t),
                                l = this.rx.getValueAtTime(t), c = this.or.getValueAtTime(t);
                            e.rotateZ(-o * this.rz.mult).rotateY(h * this.ry.mult).rotateX(l * this.rx.mult).rotateZ(-c[2] * this.or.mult).rotateY(c[1] * this.or.mult).rotateX(c[0] * this.or.mult)
                        }
                        if (this.data.p && this.data.p.s) {
                            var u = this.px.getValueAtTime(t), p = this.py.getValueAtTime(t);
                            if (this.data.p.z) {
                                var d = this.pz.getValueAtTime(t);
                                e.translate(u * this.px.mult, p * this.py.mult, -d * this.pz.mult)
                            } else e.translate(u * this.px.mult, p * this.py.mult, 0)
                        } else {
                            var f = this.p.getValueAtTime(t);
                            e.translate(f[0] * this.p.mult, f[1] * this.p.mult, -f[2] * this.p.mult)
                        }
                        return e
                    }

                    function r() {
                        return this.v.clone(new Matrix)
                    }

                    var s = TransformPropertyFactory.getTransformProperty;
                    TransformPropertyFactory.getTransformProperty = function (t, e, i) {
                        var a = s(t, e, i);
                        return a.dynamicProperties.length ? a.getValueAtTime = n.bind(a) : a.getValueAtTime = r.bind(a), a.setGroupProperty = expressionHelpers.setGroupProperty, a
                    };
                    var a = PropertyFactory.getProp;
                    PropertyFactory.getProp = function (n, r, s, o, h) {
                        var l = a(n, r, s, o, h);
                        l.kf ? l.getValueAtTime = expressionHelpers.getValueAtTime.bind(l) : l.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(l), l.setGroupProperty = expressionHelpers.setGroupProperty, l.loopOut = t, l.loopIn = e, l.smooth = i, l.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(l), l.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(l), l.numKeys = 1 === r.a ? r.k.length : 0, l.propertyIndex = r.ix;
                        var c = 0;
                        return 0 !== s && (c = createTypedArray("float32", 1 === r.a ? r.k[0].s.length : r.k.length)), l._cachingAtTime = {
                            lastFrame: initialDefaultFrame,
                            lastIndex: 0,
                            value: c
                        }, expressionHelpers.searchExpressions(n, r, l), l.k && h.addDynamicProperty(l), l
                    };
                    var o = ShapePropertyFactory.getConstructorFunction(),
                        h = ShapePropertyFactory.getKeyframedConstructorFunction();

                    function l() {
                    }

                    l.prototype = {
                        vertices: function (t, e) {
                            this.k && this.getValue();
                            var i, n = this.v;
                            void 0 !== e && (n = this.getValueAtTime(e, 0));
                            var r = n._length, s = n[t], a = n.v, o = createSizedArray(r);
                            for (i = 0; i < r; i += 1) o[i] = "i" === t || "o" === t ? [s[i][0] - a[i][0], s[i][1] - a[i][1]] : [s[i][0], s[i][1]];
                            return o
                        },
                        points: function (t) {
                            return this.vertices("v", t)
                        },
                        inTangents: function (t) {
                            return this.vertices("i", t)
                        },
                        outTangents: function (t) {
                            return this.vertices("o", t)
                        },
                        isClosed: function () {
                            return this.v.c
                        },
                        pointOnPath: function (t, e) {
                            var i = this.v;
                            void 0 !== e && (i = this.getValueAtTime(e, 0)), this._segmentsLength || (this._segmentsLength = bez.getSegmentsLength(i));
                            for (var n, r = this._segmentsLength, s = r.lengths, a = r.totalLength * t, o = 0, h = s.length, l = 0; o < h;) {
                                if (l + s[o].addedLength > a) {
                                    var c = o, u = i.c && o === h - 1 ? 0 : o + 1, p = (a - l) / s[o].addedLength;
                                    n = bez.getPointInSegment(i.v[c], i.v[u], i.o[c], i.i[u], p, s[o]);
                                    break
                                }
                                l += s[o].addedLength, o += 1
                            }
                            return n || (n = i.c ? [i.v[0][0], i.v[0][1]] : [i.v[i._length - 1][0], i.v[i._length - 1][1]]), n
                        },
                        vectorOnPath: function (t, e, i) {
                            1 == t ? t = this.v.c : 0 == t && (t = .999);
                            var n = this.pointOnPath(t, e), r = this.pointOnPath(t + .001, e), s = r[0] - n[0],
                                a = r[1] - n[1], o = Math.sqrt(Math.pow(s, 2) + Math.pow(a, 2));
                            return 0 === o ? [0, 0] : "tangent" === i ? [s / o, a / o] : [-a / o, s / o]
                        },
                        tangentOnPath: function (t, e) {
                            return this.vectorOnPath(t, e, "tangent")
                        },
                        normalOnPath: function (t, e) {
                            return this.vectorOnPath(t, e, "normal")
                        },
                        setGroupProperty: expressionHelpers.setGroupProperty,
                        getValueAtTime: expressionHelpers.getStaticValueAtTime
                    }, extendPrototype([l], o), extendPrototype([l], h), h.prototype.getValueAtTime = function (t) {
                        return this._cachingAtTime || (this._cachingAtTime = {
                            shapeValue: shapePool.clone(this.pv),
                            lastIndex: 0,
                            lastTime: initialDefaultFrame
                        }), t *= this.elem.globalData.frameRate, (t -= this.offsetTime) !== this._cachingAtTime.lastTime && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < t ? this._caching.lastIndex : 0, this._cachingAtTime.lastTime = t, this.interpolateShape(t, this._cachingAtTime.shapeValue, this._cachingAtTime)), this._cachingAtTime.shapeValue
                    }, h.prototype.initiateExpression = ExpressionManager.initiateExpression;
                    var c = ShapePropertyFactory.getShapeProp;
                    ShapePropertyFactory.getShapeProp = function (t, e, i, n, r) {
                        var s = c(t, e, i, n, r);
                        return s.propertyIndex = e.ix, s.lock = !1, 3 === i ? expressionHelpers.searchExpressions(t, e.pt, s) : 4 === i && expressionHelpers.searchExpressions(t, e.ks, s), s.k && t.addDynamicProperty(s), s
                    }
                }(), TextProperty.prototype.getExpressionValue = function (t, e) {
                    var i = this.calculateExpression(e);
                    if (t.t !== i) {
                        var n = {};
                        return this.copyData(n, t), n.t = i.toString(), n.__complete = !1, n
                    }
                    return t
                }, TextProperty.prototype.searchProperty = function () {
                    var t = this.searchKeyframes(), e = this.searchExpressions();
                    return this.kf = t || e, this.kf
                }, TextProperty.prototype.searchExpressions = function () {
                    return this.data.d.x ? (this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this), this.addEffect(this.getExpressionValue.bind(this)), !0) : null
                };
                var ShapePathInterface = function (t, e, i) {
                    var n = e.sh;

                    function r(t) {
                        return "Shape" === t || "shape" === t || "Path" === t || "path" === t || "ADBE Vector Shape" === t || 2 === t ? r.path : null
                    }

                    var s = propertyGroupFactory(r, i);
                    return n.setGroupProperty(PropertyInterface("Path", s)), Object.defineProperties(r, {
                        path: {
                            get: function () {
                                return n.k && n.getValue(), n
                            }
                        },
                        shape: {
                            get: function () {
                                return n.k && n.getValue(), n
                            }
                        },
                        _name: {value: t.nm},
                        ix: {value: t.ix},
                        propertyIndex: {value: t.ix},
                        mn: {value: t.mn},
                        propertyGroup: {value: i}
                    }), r
                }, propertyGroupFactory = function (t, e) {
                    return function (i) {
                        return (i = void 0 === i ? 1 : i) <= 0 ? t : e(i - 1)
                    }
                }, PropertyInterface = function (t, e) {
                    var i = {_name: t};
                    return function (t) {
                        return (t = void 0 === t ? 1 : t) <= 0 ? i : e(t - 1)
                    }
                }, ShapeExpressionInterface = function () {
                    function t(t, a, p) {
                        var d, f = [], m = t ? t.length : 0;
                        for (d = 0; d < m; d += 1) "gr" === t[d].ty ? f.push(e(t[d], a[d], p)) : "fl" === t[d].ty ? f.push(i(t[d], a[d], p)) : "st" === t[d].ty ? f.push(r(t[d], a[d], p)) : "tm" === t[d].ty ? f.push(s(t[d], a[d], p)) : "tr" === t[d].ty || ("el" === t[d].ty ? f.push(o(t[d], a[d], p)) : "sr" === t[d].ty ? f.push(h(t[d], a[d], p)) : "sh" === t[d].ty ? f.push(ShapePathInterface(t[d], a[d], p)) : "rc" === t[d].ty ? f.push(l(t[d], a[d], p)) : "rd" === t[d].ty ? f.push(c(t[d], a[d], p)) : "rp" === t[d].ty ? f.push(u(t[d], a[d], p)) : "gf" === t[d].ty ? f.push(n(t[d], a[d], p)) : f.push((t[d], a[d], function () {
                            return null
                        })));
                        return f
                    }

                    function e(e, i, n) {
                        var r = function (t) {
                            switch (t) {
                                case"ADBE Vectors Group":
                                case"Contents":
                                case 2:
                                    return r.content;
                                default:
                                    return r.transform
                            }
                        };
                        r.propertyGroup = propertyGroupFactory(r, n);
                        var s = function (e, i, n) {
                            var r, s = function (t) {
                                for (var e = 0, i = r.length; e < i;) {
                                    if (r[e]._name === t || r[e].mn === t || r[e].propertyIndex === t || r[e].ix === t || r[e].ind === t) return r[e];
                                    e += 1
                                }
                                return "number" == typeof t ? r[t - 1] : null
                            };
                            s.propertyGroup = propertyGroupFactory(s, n), r = t(e.it, i.it, s.propertyGroup), s.numProperties = r.length;
                            var o = a(e.it[e.it.length - 1], i.it[i.it.length - 1], s.propertyGroup);
                            return s.transform = o, s.propertyIndex = e.cix, s._name = e.nm, s
                        }(e, i, r.propertyGroup), o = a(e.it[e.it.length - 1], i.it[i.it.length - 1], r.propertyGroup);
                        return r.content = s, r.transform = o, Object.defineProperty(r, "_name", {
                            get: function () {
                                return e.nm
                            }
                        }), r.numProperties = e.np, r.propertyIndex = e.ix, r.nm = e.nm, r.mn = e.mn, r
                    }

                    function i(t, e, i) {
                        function n(t) {
                            return "Color" === t || "color" === t ? n.color : "Opacity" === t || "opacity" === t ? n.opacity : null
                        }

                        return Object.defineProperties(n, {
                            color: {get: ExpressionPropertyInterface(e.c)},
                            opacity: {get: ExpressionPropertyInterface(e.o)},
                            _name: {value: t.nm},
                            mn: {value: t.mn}
                        }), e.c.setGroupProperty(PropertyInterface("Color", i)), e.o.setGroupProperty(PropertyInterface("Opacity", i)), n
                    }

                    function n(t, e, i) {
                        function n(t) {
                            return "Start Point" === t || "start point" === t ? n.startPoint : "End Point" === t || "end point" === t ? n.endPoint : "Opacity" === t || "opacity" === t ? n.opacity : null
                        }

                        return Object.defineProperties(n, {
                            startPoint: {get: ExpressionPropertyInterface(e.s)},
                            endPoint: {get: ExpressionPropertyInterface(e.e)},
                            opacity: {get: ExpressionPropertyInterface(e.o)},
                            type: {
                                get: function () {
                                    return "a"
                                }
                            },
                            _name: {value: t.nm},
                            mn: {value: t.mn}
                        }), e.s.setGroupProperty(PropertyInterface("Start Point", i)), e.e.setGroupProperty(PropertyInterface("End Point", i)), e.o.setGroupProperty(PropertyInterface("Opacity", i)), n
                    }

                    function r(t, e, i) {
                        var n, r = propertyGroupFactory(l, i), s = propertyGroupFactory(h, r);

                        function a(i) {
                            Object.defineProperty(h, t.d[i].nm, {get: ExpressionPropertyInterface(e.d.dataProps[i].p)})
                        }

                        var o = t.d ? t.d.length : 0, h = {};
                        for (n = 0; n < o; n += 1) a(n), e.d.dataProps[n].p.setGroupProperty(s);

                        function l(t) {
                            return "Color" === t || "color" === t ? l.color : "Opacity" === t || "opacity" === t ? l.opacity : "Stroke Width" === t || "stroke width" === t ? l.strokeWidth : null
                        }

                        return Object.defineProperties(l, {
                            color: {get: ExpressionPropertyInterface(e.c)},
                            opacity: {get: ExpressionPropertyInterface(e.o)},
                            strokeWidth: {get: ExpressionPropertyInterface(e.w)},
                            dash: {
                                get: function () {
                                    return h
                                }
                            },
                            _name: {value: t.nm},
                            mn: {value: t.mn}
                        }), e.c.setGroupProperty(PropertyInterface("Color", r)), e.o.setGroupProperty(PropertyInterface("Opacity", r)), e.w.setGroupProperty(PropertyInterface("Stroke Width", r)), l
                    }

                    function s(t, e, i) {
                        function n(e) {
                            return e === t.e.ix || "End" === e || "end" === e ? n.end : e === t.s.ix ? n.start : e === t.o.ix ? n.offset : null
                        }

                        var r = propertyGroupFactory(n, i);
                        return n.propertyIndex = t.ix, e.s.setGroupProperty(PropertyInterface("Start", r)), e.e.setGroupProperty(PropertyInterface("End", r)), e.o.setGroupProperty(PropertyInterface("Offset", r)), n.propertyIndex = t.ix, n.propertyGroup = i, Object.defineProperties(n, {
                            start: {get: ExpressionPropertyInterface(e.s)},
                            end: {get: ExpressionPropertyInterface(e.e)},
                            offset: {get: ExpressionPropertyInterface(e.o)},
                            _name: {value: t.nm}
                        }), n.mn = t.mn, n
                    }

                    function a(t, e, i) {
                        function n(e) {
                            return t.a.ix === e || "Anchor Point" === e ? n.anchorPoint : t.o.ix === e || "Opacity" === e ? n.opacity : t.p.ix === e || "Position" === e ? n.position : t.r.ix === e || "Rotation" === e || "ADBE Vector Rotation" === e ? n.rotation : t.s.ix === e || "Scale" === e ? n.scale : t.sk && t.sk.ix === e || "Skew" === e ? n.skew : t.sa && t.sa.ix === e || "Skew Axis" === e ? n.skewAxis : null
                        }

                        var r = propertyGroupFactory(n, i);
                        return e.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", r)), e.transform.mProps.p.setGroupProperty(PropertyInterface("Position", r)), e.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", r)), e.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", r)), e.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", r)), e.transform.mProps.sk && (e.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", r)), e.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", r))), e.transform.op.setGroupProperty(PropertyInterface("Opacity", r)), Object.defineProperties(n, {
                            opacity: {get: ExpressionPropertyInterface(e.transform.mProps.o)},
                            position: {get: ExpressionPropertyInterface(e.transform.mProps.p)},
                            anchorPoint: {get: ExpressionPropertyInterface(e.transform.mProps.a)},
                            scale: {get: ExpressionPropertyInterface(e.transform.mProps.s)},
                            rotation: {get: ExpressionPropertyInterface(e.transform.mProps.r)},
                            skew: {get: ExpressionPropertyInterface(e.transform.mProps.sk)},
                            skewAxis: {get: ExpressionPropertyInterface(e.transform.mProps.sa)},
                            _name: {value: t.nm}
                        }), n.ty = "tr", n.mn = t.mn, n.propertyGroup = i, n
                    }

                    function o(t, e, i) {
                        function n(e) {
                            return t.p.ix === e ? n.position : t.s.ix === e ? n.size : null
                        }

                        var r = propertyGroupFactory(n, i);
                        n.propertyIndex = t.ix;
                        var s = "tm" === e.sh.ty ? e.sh.prop : e.sh;
                        return s.s.setGroupProperty(PropertyInterface("Size", r)), s.p.setGroupProperty(PropertyInterface("Position", r)), Object.defineProperties(n, {
                            size: {get: ExpressionPropertyInterface(s.s)},
                            position: {get: ExpressionPropertyInterface(s.p)},
                            _name: {value: t.nm}
                        }), n.mn = t.mn, n
                    }

                    function h(t, e, i) {
                        function n(e) {
                            return t.p.ix === e ? n.position : t.r.ix === e ? n.rotation : t.pt.ix === e ? n.points : t.or.ix === e || "ADBE Vector Star Outer Radius" === e ? n.outerRadius : t.os.ix === e ? n.outerRoundness : !t.ir || t.ir.ix !== e && "ADBE Vector Star Inner Radius" !== e ? t.is && t.is.ix === e ? n.innerRoundness : null : n.innerRadius
                        }

                        var r = propertyGroupFactory(n, i), s = "tm" === e.sh.ty ? e.sh.prop : e.sh;
                        return n.propertyIndex = t.ix, s.or.setGroupProperty(PropertyInterface("Outer Radius", r)), s.os.setGroupProperty(PropertyInterface("Outer Roundness", r)), s.pt.setGroupProperty(PropertyInterface("Points", r)), s.p.setGroupProperty(PropertyInterface("Position", r)), s.r.setGroupProperty(PropertyInterface("Rotation", r)), t.ir && (s.ir.setGroupProperty(PropertyInterface("Inner Radius", r)), s.is.setGroupProperty(PropertyInterface("Inner Roundness", r))), Object.defineProperties(n, {
                            position: {get: ExpressionPropertyInterface(s.p)},
                            rotation: {get: ExpressionPropertyInterface(s.r)},
                            points: {get: ExpressionPropertyInterface(s.pt)},
                            outerRadius: {get: ExpressionPropertyInterface(s.or)},
                            outerRoundness: {get: ExpressionPropertyInterface(s.os)},
                            innerRadius: {get: ExpressionPropertyInterface(s.ir)},
                            innerRoundness: {get: ExpressionPropertyInterface(s.is)},
                            _name: {value: t.nm}
                        }), n.mn = t.mn, n
                    }

                    function l(t, e, i) {
                        function n(e) {
                            return t.p.ix === e ? n.position : t.r.ix === e ? n.roundness : t.s.ix === e || "Size" === e || "ADBE Vector Rect Size" === e ? n.size : null
                        }

                        var r = propertyGroupFactory(n, i), s = "tm" === e.sh.ty ? e.sh.prop : e.sh;
                        return n.propertyIndex = t.ix, s.p.setGroupProperty(PropertyInterface("Position", r)), s.s.setGroupProperty(PropertyInterface("Size", r)), s.r.setGroupProperty(PropertyInterface("Rotation", r)), Object.defineProperties(n, {
                            position: {get: ExpressionPropertyInterface(s.p)},
                            roundness: {get: ExpressionPropertyInterface(s.r)},
                            size: {get: ExpressionPropertyInterface(s.s)},
                            _name: {value: t.nm}
                        }), n.mn = t.mn, n
                    }

                    function c(t, e, i) {
                        function n(e) {
                            return t.r.ix === e || "Round Corners 1" === e ? n.radius : null
                        }

                        var r = propertyGroupFactory(n, i), s = e;
                        return n.propertyIndex = t.ix, s.rd.setGroupProperty(PropertyInterface("Radius", r)), Object.defineProperties(n, {
                            radius: {get: ExpressionPropertyInterface(s.rd)},
                            _name: {value: t.nm}
                        }), n.mn = t.mn, n
                    }

                    function u(t, e, i) {
                        function n(e) {
                            return t.c.ix === e || "Copies" === e ? n.copies : t.o.ix === e || "Offset" === e ? n.offset : null
                        }

                        var r = propertyGroupFactory(n, i), s = e;
                        return n.propertyIndex = t.ix, s.c.setGroupProperty(PropertyInterface("Copies", r)), s.o.setGroupProperty(PropertyInterface("Offset", r)), Object.defineProperties(n, {
                            copies: {get: ExpressionPropertyInterface(s.c)},
                            offset: {get: ExpressionPropertyInterface(s.o)},
                            _name: {value: t.nm}
                        }), n.mn = t.mn, n
                    }

                    return function (e, i, n) {
                        var r;

                        function s(t) {
                            if ("number" == typeof t) return 0 === (t = void 0 === t ? 1 : t) ? n : r[t - 1];
                            for (var e = 0, i = r.length; e < i;) {
                                if (r[e]._name === t) return r[e];
                                e += 1
                            }
                            return null
                        }

                        return s.propertyGroup = propertyGroupFactory(s, (function () {
                            return n
                        })), r = t(e, i, s.propertyGroup), s.numProperties = r.length, s._name = "Contents", s
                    }
                }(), TextExpressionInterface = function (t) {
                    var e, i;

                    function n(t) {
                        return "ADBE Text Document" === t ? n.sourceText : null
                    }

                    return Object.defineProperty(n, "sourceText", {
                        get: function () {
                            t.textProperty.getValue();
                            var n = t.textProperty.currentData.t;
                            return n !== e && (t.textProperty.currentData.t = e, (i = new String(n)).value = n || new String(n)), i
                        }
                    }), n
                }, LayerExpressionInterface = function () {
                    function t(t) {
                        var e = new Matrix;
                        return void 0 !== t ? this._elem.finalTransform.mProp.getValueAtTime(t).clone(e) : this._elem.finalTransform.mProp.applyToMatrix(e), e
                    }

                    function e(t, e) {
                        var i = this.getMatrix(e);
                        return i.props[12] = 0, i.props[13] = 0, i.props[14] = 0, this.applyPoint(i, t)
                    }

                    function i(t, e) {
                        var i = this.getMatrix(e);
                        return this.applyPoint(i, t)
                    }

                    function n(t, e) {
                        var i = this.getMatrix(e);
                        return i.props[12] = 0, i.props[13] = 0, i.props[14] = 0, this.invertPoint(i, t)
                    }

                    function r(t, e) {
                        var i = this.getMatrix(e);
                        return this.invertPoint(i, t)
                    }

                    function s(t, e) {
                        if (this._elem.hierarchy && this._elem.hierarchy.length) {
                            var i, n = this._elem.hierarchy.length;
                            for (i = 0; i < n; i += 1) this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(t)
                        }
                        return t.applyToPointArray(e[0], e[1], e[2] || 0)
                    }

                    function a(t, e) {
                        if (this._elem.hierarchy && this._elem.hierarchy.length) {
                            var i, n = this._elem.hierarchy.length;
                            for (i = 0; i < n; i += 1) this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(t)
                        }
                        return t.inversePoint(e)
                    }

                    function o(t) {
                        var e = new Matrix;
                        if (e.reset(), this._elem.finalTransform.mProp.applyToMatrix(e), this._elem.hierarchy && this._elem.hierarchy.length) {
                            var i, n = this._elem.hierarchy.length;
                            for (i = 0; i < n; i += 1) this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(e);
                            return e.inversePoint(t)
                        }
                        return e.inversePoint(t)
                    }

                    function h() {
                        return [1, 1, 1, 1]
                    }

                    return function (l) {
                        var c;

                        function u(t) {
                            switch (t) {
                                case"ADBE Root Vectors Group":
                                case"Contents":
                                case 2:
                                    return u.shapeInterface;
                                case 1:
                                case 6:
                                case"Transform":
                                case"transform":
                                case"ADBE Transform Group":
                                    return c;
                                case 4:
                                case"ADBE Effect Parade":
                                case"effects":
                                case"Effects":
                                    return u.effect;
                                case"ADBE Text Properties":
                                    return u.textInterface;
                                default:
                                    return null
                            }
                        }

                        u.getMatrix = t, u.invertPoint = a, u.applyPoint = s, u.toWorld = i, u.toWorldVec = e, u.fromWorld = r, u.fromWorldVec = n, u.toComp = i, u.fromComp = o, u.sampleImage = h, u.sourceRectAtTime = l.sourceRectAtTime.bind(l), u._elem = l;
                        var p = getDescriptor(c = TransformExpressionInterface(l.finalTransform.mProp), "anchorPoint");
                        return Object.defineProperties(u, {
                            hasParent: {
                                get: function () {
                                    return l.hierarchy.length
                                }
                            },
                            parent: {
                                get: function () {
                                    return l.hierarchy[0].layerInterface
                                }
                            },
                            rotation: getDescriptor(c, "rotation"),
                            scale: getDescriptor(c, "scale"),
                            position: getDescriptor(c, "position"),
                            opacity: getDescriptor(c, "opacity"),
                            anchorPoint: p,
                            anchor_point: p,
                            transform: {
                                get: function () {
                                    return c
                                }
                            },
                            active: {
                                get: function () {
                                    return l.isInRange
                                }
                            }
                        }), u.startTime = l.data.st, u.index = l.data.ind, u.source = l.data.refId, u.height = 0 === l.data.ty ? l.data.h : 100, u.width = 0 === l.data.ty ? l.data.w : 100, u.inPoint = l.data.ip / l.comp.globalData.frameRate, u.outPoint = l.data.op / l.comp.globalData.frameRate, u._name = l.data.nm, u.registerMaskInterface = function (t) {
                            u.mask = new MaskManagerInterface(t, l)
                        }, u.registerEffectsInterface = function (t) {
                            u.effect = t
                        }, u
                    }
                }(), FootageInterface = (dataInterfaceFactory = function (t) {
                    function e(t) {
                        return "Outline" === t ? e.outlineInterface() : null
                    }

                    return e._name = "Outline", e.outlineInterface = function (t) {
                        var e = "", i = t.getFootageData();

                        function n(t) {
                            if (i[t]) return e = t, "object" == typeof (i = i[t]) ? n : i;
                            var r = t.indexOf(e);
                            if (-1 !== r) {
                                var s = parseInt(t.substr(r + e.length), 10);
                                return "object" == typeof (i = i[s]) ? n : i
                            }
                            return ""
                        }

                        return function () {
                            return e = "", i = t.getFootageData(), n
                        }
                    }(t), e
                }, function (t) {
                    function e(t) {
                        return "Data" === t ? e.dataInterface : null
                    }

                    return e._name = "Data", e.dataInterface = dataInterfaceFactory(t), e
                }), dataInterfaceFactory, CompExpressionInterface = function (t) {
                    function e(e) {
                        for (var i = 0, n = t.layers.length; i < n;) {
                            if (t.layers[i].nm === e || t.layers[i].ind === e) return t.elements[i].layerInterface;
                            i += 1
                        }
                        return null
                    }

                    return Object.defineProperty(e, "_name", {value: t.data.nm}), e.layer = e, e.pixelAspect = 1, e.height = t.data.h || t.globalData.compSize.h, e.width = t.data.w || t.globalData.compSize.w, e.pixelAspect = 1, e.frameDuration = 1 / t.globalData.frameRate, e.displayStartTime = 0, e.numLayers = t.layers.length, e
                }, TransformExpressionInterface = function (t) {
                    function e(t) {
                        switch (t) {
                            case"scale":
                            case"Scale":
                            case"ADBE Scale":
                            case 6:
                                return e.scale;
                            case"rotation":
                            case"Rotation":
                            case"ADBE Rotation":
                            case"ADBE Rotate Z":
                            case 10:
                                return e.rotation;
                            case"ADBE Rotate X":
                                return e.xRotation;
                            case"ADBE Rotate Y":
                                return e.yRotation;
                            case"position":
                            case"Position":
                            case"ADBE Position":
                            case 2:
                                return e.position;
                            case"ADBE Position_0":
                                return e.xPosition;
                            case"ADBE Position_1":
                                return e.yPosition;
                            case"ADBE Position_2":
                                return e.zPosition;
                            case"anchorPoint":
                            case"AnchorPoint":
                            case"Anchor Point":
                            case"ADBE AnchorPoint":
                            case 1:
                                return e.anchorPoint;
                            case"opacity":
                            case"Opacity":
                            case 11:
                                return e.opacity;
                            default:
                                return null
                        }
                    }

                    var i, n, r, s;
                    return Object.defineProperty(e, "rotation", {get: ExpressionPropertyInterface(t.r || t.rz)}), Object.defineProperty(e, "zRotation", {get: ExpressionPropertyInterface(t.rz || t.r)}), Object.defineProperty(e, "xRotation", {get: ExpressionPropertyInterface(t.rx)}), Object.defineProperty(e, "yRotation", {get: ExpressionPropertyInterface(t.ry)}), Object.defineProperty(e, "scale", {get: ExpressionPropertyInterface(t.s)}), t.p ? s = ExpressionPropertyInterface(t.p) : (i = ExpressionPropertyInterface(t.px), n = ExpressionPropertyInterface(t.py), t.pz && (r = ExpressionPropertyInterface(t.pz))), Object.defineProperty(e, "position", {
                        get: function () {
                            return t.p ? s() : [i(), n(), r ? r() : 0]
                        }
                    }), Object.defineProperty(e, "xPosition", {get: ExpressionPropertyInterface(t.px)}), Object.defineProperty(e, "yPosition", {get: ExpressionPropertyInterface(t.py)}), Object.defineProperty(e, "zPosition", {get: ExpressionPropertyInterface(t.pz)}), Object.defineProperty(e, "anchorPoint", {get: ExpressionPropertyInterface(t.a)}), Object.defineProperty(e, "opacity", {get: ExpressionPropertyInterface(t.o)}), Object.defineProperty(e, "skew", {get: ExpressionPropertyInterface(t.sk)}), Object.defineProperty(e, "skewAxis", {get: ExpressionPropertyInterface(t.sa)}), Object.defineProperty(e, "orientation", {get: ExpressionPropertyInterface(t.or)}), e
                }, ProjectInterface = function () {
                    function t(t) {
                        this.compositions.push(t)
                    }

                    return function () {
                        function e(t) {
                            for (var e = 0, i = this.compositions.length; e < i;) {
                                if (this.compositions[e].data && this.compositions[e].data.nm === t) return this.compositions[e].prepareFrame && this.compositions[e].data.xt && this.compositions[e].prepareFrame(this.currentFrame), this.compositions[e].compInterface;
                                e += 1
                            }
                            return null
                        }

                        return e.compositions = [], e.currentFrame = 0, e.registerComposition = t, e
                    }
                }(), EffectsExpressionInterface = function () {
                    function t(i, n, r, s) {
                        function a(t) {
                            for (var e = i.ef, n = 0, r = e.length; n < r;) {
                                if (t === e[n].nm || t === e[n].mn || t === e[n].ix) return 5 === e[n].ty ? l[n] : l[n]();
                                n += 1
                            }
                            throw new Error
                        }

                        var o, h = propertyGroupFactory(a, r), l = [], c = i.ef.length;
                        for (o = 0; o < c; o += 1) 5 === i.ef[o].ty ? l.push(t(i.ef[o], n.effectElements[o], n.effectElements[o].propertyGroup, s)) : l.push(e(n.effectElements[o], i.ef[o].ty, s, h));
                        return "ADBE Color Control" === i.mn && Object.defineProperty(a, "color", {
                            get: function () {
                                return l[0]()
                            }
                        }), Object.defineProperties(a, {
                            numProperties: {
                                get: function () {
                                    return i.np
                                }
                            }, _name: {value: i.nm}, propertyGroup: {value: h}
                        }), a.enabled = 0 !== i.en, a.active = a.enabled, a
                    }

                    function e(t, e, i, n) {
                        var r = ExpressionPropertyInterface(t.p);
                        return t.p.setGroupProperty && t.p.setGroupProperty(PropertyInterface("", n)), function () {
                            return 10 === e ? i.comp.compInterface(t.p.v) : r()
                        }
                    }

                    return {
                        createEffectsInterface: function (e, i) {
                            if (e.effectsManager) {
                                var n, r = [], s = e.data.ef, a = e.effectsManager.effectElements.length;
                                for (n = 0; n < a; n += 1) r.push(t(s[n], e.effectsManager.effectElements[n], i, e));
                                var o = e.data.ef || [], h = function (t) {
                                    for (n = 0, a = o.length; n < a;) {
                                        if (t === o[n].nm || t === o[n].mn || t === o[n].ix) return r[n];
                                        n += 1
                                    }
                                    return null
                                };
                                return Object.defineProperty(h, "numProperties", {
                                    get: function () {
                                        return o.length
                                    }
                                }), h
                            }
                            return null
                        }
                    }
                }(), MaskManagerInterface = function () {
                    function t(t, e) {
                        this._mask = t, this._data = e
                    }

                    return Object.defineProperty(t.prototype, "maskPath", {
                        get: function () {
                            return this._mask.prop.k && this._mask.prop.getValue(), this._mask.prop
                        }
                    }), Object.defineProperty(t.prototype, "maskOpacity", {
                        get: function () {
                            return this._mask.op.k && this._mask.op.getValue(), 100 * this._mask.op.v
                        }
                    }), function (e) {
                        var i, n = createSizedArray(e.viewData.length), r = e.viewData.length;
                        for (i = 0; i < r; i += 1) n[i] = new t(e.viewData[i], e.masksProperties[i]);
                        return function (t) {
                            for (i = 0; i < r;) {
                                if (e.masksProperties[i].nm === t) return n[i];
                                i += 1
                            }
                            return null
                        }
                    }
                }(), ExpressionPropertyInterface = function () {
                    var t = {pv: 0, v: 0, mult: 1}, e = {pv: [0, 0, 0], v: [0, 0, 0], mult: 1};

                    function i(t, e, i) {
                        Object.defineProperty(t, "velocity", {
                            get: function () {
                                return e.getVelocityAtTime(e.comp.currentFrame)
                            }
                        }), t.numKeys = e.keyframes ? e.keyframes.length : 0, t.key = function (n) {
                            if (!t.numKeys) return 0;
                            var r = "";
                            r = "s" in e.keyframes[n - 1] ? e.keyframes[n - 1].s : "e" in e.keyframes[n - 2] ? e.keyframes[n - 2].e : e.keyframes[n - 2].s;
                            var s = "unidimensional" === i ? new Number(r) : Object.assign({}, r);
                            return s.time = e.keyframes[n - 1].t / e.elem.comp.globalData.frameRate, s.value = "unidimensional" === i ? r[0] : r, s
                        }, t.valueAtTime = e.getValueAtTime, t.speedAtTime = e.getSpeedAtTime, t.velocityAtTime = e.getVelocityAtTime, t.propertyGroup = e.propertyGroup
                    }

                    function n() {
                        return t
                    }

                    return function (r) {
                        return r ? "unidimensional" === r.propType ? function (e) {
                            e && "pv" in e || (e = t);
                            var n = 1 / e.mult, r = e.pv * n, s = new Number(r);
                            return s.value = r, i(s, e, "unidimensional"), function () {
                                return e.k && e.getValue(), r = e.v * n, s.value !== r && ((s = new Number(r)).value = r, i(s, e, "unidimensional")), s
                            }
                        }(r) : function (t) {
                            t && "pv" in t || (t = e);
                            var n = 1 / t.mult, r = t.data && t.data.l || t.pv.length,
                                s = createTypedArray("float32", r), a = createTypedArray("float32", r);
                            return s.value = a, i(s, t, "multidimensional"), function () {
                                t.k && t.getValue();
                                for (var e = 0; e < r; e += 1) a[e] = t.v[e] * n, s[e] = a[e];
                                return s
                            }
                        }(r) : n
                    }
                }(), TextExpressionSelectorPropFactory = function () {
                    function t(t, e) {
                        return this.textIndex = t + 1, this.textTotal = e, this.v = this.getValue() * this.mult, this.v
                    }

                    return function (e, i) {
                        this.pv = 1, this.comp = e.comp, this.elem = e, this.mult = .01, this.propType = "textSelector", this.textTotal = i.totalChars, this.selectorValue = 100, this.lastValue = [1, 1, 1], this.k = !0, this.x = !0, this.getValue = ExpressionManager.initiateExpression.bind(this)(e, i, this), this.getMult = t, this.getVelocityAtTime = expressionHelpers.getVelocityAtTime, this.kf ? this.getValueAtTime = expressionHelpers.getValueAtTime.bind(this) : this.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(this), this.setGroupProperty = expressionHelpers.setGroupProperty
                    }
                }(), propertyGetTextProp = TextSelectorProp.getTextSelectorProp;

                function SliderEffect(t, e, i) {
                    this.p = PropertyFactory.getProp(e, t.v, 0, 0, i)
                }

                function AngleEffect(t, e, i) {
                    this.p = PropertyFactory.getProp(e, t.v, 0, 0, i)
                }

                function ColorEffect(t, e, i) {
                    this.p = PropertyFactory.getProp(e, t.v, 1, 0, i)
                }

                function PointEffect(t, e, i) {
                    this.p = PropertyFactory.getProp(e, t.v, 1, 0, i)
                }

                function LayerIndexEffect(t, e, i) {
                    this.p = PropertyFactory.getProp(e, t.v, 0, 0, i)
                }

                function MaskIndexEffect(t, e, i) {
                    this.p = PropertyFactory.getProp(e, t.v, 0, 0, i)
                }

                function CheckboxEffect(t, e, i) {
                    this.p = PropertyFactory.getProp(e, t.v, 0, 0, i)
                }

                function NoValueEffect() {
                    this.p = {}
                }

                function EffectsManager(t, e) {
                    var i, n = t.ef || [];
                    this.effectElements = [];
                    var r, s = n.length;
                    for (i = 0; i < s; i += 1) r = new GroupEffect(n[i], e), this.effectElements.push(r)
                }

                function GroupEffect(t, e) {
                    this.init(t, e)
                }

                TextSelectorProp.getTextSelectorProp = function (t, e, i) {
                    return 1 === e.t ? new TextExpressionSelectorPropFactory(t, e, i) : propertyGetTextProp(t, e, i)
                }, extendPrototype([DynamicPropertyContainer], GroupEffect), GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties, GroupEffect.prototype.init = function (t, e) {
                    var i;
                    this.data = t, this.effectElements = [], this.initDynamicPropertyContainer(e);
                    var n, r = this.data.ef.length, s = this.data.ef;
                    for (i = 0; i < r; i += 1) {
                        switch (n = null, s[i].ty) {
                            case 0:
                                n = new SliderEffect(s[i], e, this);
                                break;
                            case 1:
                                n = new AngleEffect(s[i], e, this);
                                break;
                            case 2:
                                n = new ColorEffect(s[i], e, this);
                                break;
                            case 3:
                                n = new PointEffect(s[i], e, this);
                                break;
                            case 4:
                            case 7:
                                n = new CheckboxEffect(s[i], e, this);
                                break;
                            case 10:
                                n = new LayerIndexEffect(s[i], e, this);
                                break;
                            case 11:
                                n = new MaskIndexEffect(s[i], e, this);
                                break;
                            case 5:
                                n = new EffectsManager(s[i], e, this);
                                break;
                            default:
                                n = new NoValueEffect(s[i], e, this)
                        }
                        n && this.effectElements.push(n)
                    }
                };
                var lottie = {};

                function setLocationHref(t) {
                    locationHref = t
                }

                function searchAnimations() {
                    !0 === standalone ? animationManager.searchAnimations(animationData, standalone, renderer) : animationManager.searchAnimations()
                }

                function setSubframeRendering(t) {
                    subframeEnabled = t
                }

                function setIDPrefix(t) {
                    idPrefix = t
                }

                function loadAnimation(t) {
                    return !0 === standalone && (t.animationData = JSON.parse(animationData)), animationManager.loadAnimation(t)
                }

                function setQuality(t) {
                    if ("string" == typeof t) switch (t) {
                        case"high":
                            defaultCurveSegments = 200;
                            break;
                        default:
                        case"medium":
                            defaultCurveSegments = 50;
                            break;
                        case"low":
                            defaultCurveSegments = 10
                    } else !isNaN(t) && t > 1 && (defaultCurveSegments = t);
                    roundValues(!(defaultCurveSegments >= 50))
                }

                function inBrowser() {
                    return "undefined" != typeof navigator
                }

                function installPlugin(t, e) {
                    "expressions" === t && (expressionsPlugin = e)
                }

                function getFactory(t) {
                    switch (t) {
                        case"propertyFactory":
                            return PropertyFactory;
                        case"shapePropertyFactory":
                            return ShapePropertyFactory;
                        case"matrix":
                            return Matrix;
                        default:
                            return null
                    }
                }

                function checkReady() {
                    "complete" === document.readyState && (clearInterval(readyStateCheckInterval), searchAnimations())
                }

                function getQueryVariable(t) {
                    for (var e = queryString.split("&"), i = 0; i < e.length; i += 1) {
                        var n = e[i].split("=");
                        if (decodeURIComponent(n[0]) == t) return decodeURIComponent(n[1])
                    }
                    return null
                }

                lottie.play = animationManager.play, lottie.pause = animationManager.pause, lottie.setLocationHref = setLocationHref, lottie.togglePause = animationManager.togglePause, lottie.setSpeed = animationManager.setSpeed, lottie.setDirection = animationManager.setDirection, lottie.stop = animationManager.stop, lottie.searchAnimations = searchAnimations, lottie.registerAnimation = animationManager.registerAnimation, lottie.loadAnimation = loadAnimation, lottie.setSubframeRendering = setSubframeRendering, lottie.resize = animationManager.resize, lottie.goToAndStop = animationManager.goToAndStop, lottie.destroy = animationManager.destroy, lottie.setQuality = setQuality, lottie.inBrowser = inBrowser, lottie.installPlugin = installPlugin, lottie.freeze = animationManager.freeze, lottie.unfreeze = animationManager.unfreeze, lottie.setVolume = animationManager.setVolume, lottie.mute = animationManager.mute, lottie.unmute = animationManager.unmute, lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations, lottie.useWebWorker = function (t) {
                    _useWebWorker = t
                }, lottie.setIDPrefix = setIDPrefix, lottie.__getFactory = getFactory, lottie.version = "5.8.1";
                var standalone = "__[STANDALONE]__", animationData = "__[ANIMATIONDATA]__", renderer = "", queryString;
                if (standalone) {
                    var scripts = document.getElementsByTagName("script"), index = scripts.length - 1,
                        myScript = scripts[index] || {src: ""};
                    queryString = myScript.src.replace(/^[^\?]+\??/, ""), renderer = getQueryVariable("renderer")
                }
                var readyStateCheckInterval = setInterval(checkReady, 100);
                return lottie
            }, void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = function () {
                return factory(root)
            }.call(exports, __webpack_require__, exports, module)) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        }, 835: (t, e, i) => {
            "use strict";
            var n = i(763);

            function r() {
                var t = navigator.userAgent.toLowerCase(), e = navigator.appVersion.toLowerCase(),
                    i = /windows phone|iemobile|wpdesktop/.test(t), n = !i && /android.*mobile/.test(t),
                    r = !i && !n && /android/i.test(t), s = n || r,
                    a = !i && /ip(hone|od|ad)/i.test(t) && !window.MSStream, o = !i && /ipad/i.test(t) && a, h = r || o,
                    l = n || a && !o || i, c = l || h, u = t.indexOf("firefox") > -1,
                    p = !!t.match(/version\/[\d\.]+.*safari/), d = t.indexOf("opr") > -1,
                    f = !window.ActiveXObject && "ActiveXObject" in window,
                    m = e.indexOf("msie") > -1 || f || e.indexOf("edge") > -1, g = t.indexOf("edge") > -1,
                    v = null !== window.chrome && void 0 !== window.chrome && "google inc." == navigator.vendor.toLowerCase() && !d && !g;
                this.infos = {
                    isDroid: s,
                    isDroidPhone: n,
                    isDroidTablet: r,
                    isWindowsPhone: i,
                    isIos: a,
                    isIpad: o,
                    isDevice: c,
                    isEdge: g,
                    isIE: m,
                    isIE11: f,
                    isPhone: l,
                    isTablet: h,
                    isFirefox: u,
                    isSafari: p,
                    isOpera: d,
                    isChrome: v,
                    isDesktop: !l && !h
                }, Object.keys(this.infos).forEach((function (t) {
                    Object.defineProperty(this, t, {
                        get: function () {
                            return this.infos[t]
                        }
                    })
                }), this), Object.freeze(this)
            }

            t.exports = new r, r.prototype.addClasses = function (t) {
                Object.keys(this.infos).forEach((function (e) {
                    this.infos[e] && function (t, e) {
                        t.addClass ? t.addClass(e) : t.classList ? t.classList.add(e) : t.className += " " + e
                    }(t, n(e))
                }), this)
            }, r.prototype.getInfos = function () {
                return t = this.infos, JSON.parse(JSON.stringify(t));
                var t
            }
        }
    }, __webpack_module_cache__ = {};

    function __webpack_require__(t) {
        var e = __webpack_module_cache__[t];
        if (void 0 !== e) return e.exports;
        var i = __webpack_module_cache__[t] = {exports: {}};
        return __webpack_modules__[t].call(i.exports, i, i.exports, __webpack_require__), i.exports
    }

    __webpack_require__.n = t => {
        var e = t && t.__esModule ? () => t.default : () => t;
        return __webpack_require__.d(e, {a: e}), e
    }, __webpack_require__.d = (t, e) => {
        for (var i in e) __webpack_require__.o(e, i) && !__webpack_require__.o(t, i) && Object.defineProperty(t, i, {
            enumerable: !0,
            get: e[i]
        })
    }, __webpack_require__.g = function () {
        if ("object" == typeof globalThis) return globalThis;
        try {
            return this || new Function("return this")()
        } catch (t) {
            if ("object" == typeof window) return window
        }
    }(), __webpack_require__.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e);
    var __webpack_exports__ = {};
    (() => {
        "use strict";
        __webpack_require__(827);
        var t = __webpack_require__(835), e = __webpack_require__.n(t), i = {
            body: document.body,
            height: window.innerHeight,
            width: window.innerWidth,
            scrollHeight: 0,
            scrollEl: document.querySelector(".js-smooth"),
            scrollP: document.querySelector(".js-scroll-proxy"),
            headerNormal: document.querySelector(".js-site-head--normal"),
            headerSticky: document.querySelector(".js-site-head--sticky"),
            isStickyMenu: !1,
            isTransiition: !1,
            isMenuOpen: !1,
            theme: document.querySelector("[data-theme]")
        };
        Object.assign(i, e().getInfos()), Object.assign(i, {isSmooth: i.isDesktop});
        const n = i;

        function r(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }

        function s(t, e) {
            t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
        }

        var a, o, h, l, c, u, p, d, f,
            m = {autoSleep: 120, force3D: "auto", nullTargetWarn: 1, units: {lineHeight: ""}},
            g = {duration: .5, overwrite: !1, delay: 0}, v = 1e8, y = 1e-8, b = 2 * Math.PI, x = b / 4, w = 0,
            _ = Math.sqrt, E = Math.cos, M = Math.sin, A = function (t) {
                return "string" == typeof t
            }, S = function (t) {
                return "function" == typeof t
            }, T = function (t) {
                return "number" == typeof t
            }, D = function (t) {
                return void 0 === t
            }, C = function (t) {
                return "object" == typeof t
            }, P = function (t) {
                return !1 !== t
            }, I = function () {
                return "undefined" != typeof window
            }, L = function (t) {
                return S(t) || A(t)
            }, R = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function () {
            }, F = Array.isArray, k = /(?:-?\.?\d|\.)+/gi, O = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
            z = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, B = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, N = /[+-]=-?[.\d]+/,
            j = /[^,'"\[\]\s]+/gi, V = /[\d.+\-=]+(?:e[-+]\d*)*/i, G = {}, U = {}, H = function (t) {
                return (U = gt(t, G)) && ni
            }, W = function (t, e) {
                return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()")
            }, q = function (t, e) {
                return !e && console.warn(t)
            }, X = function (t, e) {
                return t && (G[t] = e) && U && (U[t] = e) || G
            }, Y = function () {
                return 0
            }, Z = {}, J = [], Q = {}, K = {}, $ = {}, tt = 30, et = [], it = "", nt = function (t) {
                var e, i, n = t[0];
                if (C(n) || S(n) || (t = [t]), !(e = (n._gsap || {}).harness)) {
                    for (i = et.length; i-- && !et[i].targetTest(n);) ;
                    e = et[i]
                }
                for (i = t.length; i--;) t[i] && (t[i]._gsap || (t[i]._gsap = new De(t[i], e))) || t.splice(i, 1);
                return t
            }, rt = function (t) {
                return t._gsap || nt(Xt(t))[0]._gsap
            }, st = function (t, e, i) {
                return (i = t[e]) && S(i) ? t[e]() : D(i) && t.getAttribute && t.getAttribute(e) || i
            }, at = function (t, e) {
                return (t = t.split(",")).forEach(e) || t
            }, ot = function (t) {
                return Math.round(1e5 * t) / 1e5 || 0
            }, ht = function (t) {
                return Math.round(1e7 * t) / 1e7 || 0
            }, lt = function (t, e) {
                for (var i = e.length, n = 0; t.indexOf(e[n]) < 0 && ++n < i;) ;
                return n < i
            }, ct = function () {
                var t, e, i = J.length, n = J.slice(0);
                for (Q = {}, J.length = 0, t = 0; t < i; t++) (e = n[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0)
            }, ut = function (t, e, i, n) {
                J.length && ct(), t.render(e, i, n), J.length && ct()
            }, pt = function (t) {
                var e = parseFloat(t);
                return (e || 0 === e) && (t + "").match(j).length < 2 ? e : A(t) ? t.trim() : t
            }, dt = function (t) {
                return t
            }, ft = function (t, e) {
                for (var i in e) i in t || (t[i] = e[i]);
                return t
            }, mt = function (t, e) {
                for (var i in e) i in t || "duration" === i || "ease" === i || (t[i] = e[i])
            }, gt = function (t, e) {
                for (var i in e) t[i] = e[i];
                return t
            }, vt = function t(e, i) {
                for (var n in i) "__proto__" !== n && "constructor" !== n && "prototype" !== n && (e[n] = C(i[n]) ? t(e[n] || (e[n] = {}), i[n]) : i[n]);
                return e
            }, yt = function (t, e) {
                var i, n = {};
                for (i in t) i in e || (n[i] = t[i]);
                return n
            }, bt = function (t) {
                var e = t.parent || o, i = t.keyframes ? mt : ft;
                if (P(t.inherit)) for (; e;) i(t, e.vars.defaults), e = e.parent || e._dp;
                return t
            }, xt = function (t, e, i, n) {
                void 0 === i && (i = "_first"), void 0 === n && (n = "_last");
                var r = e._prev, s = e._next;
                r ? r._next = s : t[i] === e && (t[i] = s), s ? s._prev = r : t[n] === e && (t[n] = r), e._next = e._prev = e.parent = null
            }, wt = function (t, e) {
                t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove(t), t._act = 0
            }, _t = function (t, e) {
                if (t && (!e || e._end > t._dur || e._start < 0)) for (var i = t; i;) i._dirty = 1, i = i.parent;
                return t
            }, Et = function (t) {
                for (var e = t.parent; e && e.parent;) e._dirty = 1, e.totalDuration(), e = e.parent;
                return t
            }, Mt = function t(e) {
                return !e || e._ts && t(e.parent)
            }, At = function (t) {
                return t._repeat ? St(t._tTime, t = t.duration() + t._rDelay) * t : 0
            }, St = function (t, e) {
                var i = Math.floor(t /= e);
                return t && i === t ? i - 1 : i
            }, Tt = function (t, e) {
                return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
            }, Dt = function (t) {
                return t._end = ht(t._start + (t._tDur / Math.abs(t._ts || t._rts || y) || 0))
            }, Ct = function (t, e) {
                var i = t._dp;
                return i && i.smoothChildTiming && t._ts && (t._start = ht(i._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), Dt(t), i._dirty || _t(i, t)), t
            }, Pt = function (t, e) {
                var i;
                if ((e._time || e._initted && !e._dur) && (i = Tt(t.rawTime(), e), (!e._dur || Gt(0, e.totalDuration(), i) - e._tTime > y) && e.render(i, !0)), _t(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
                    if (t._dur < t.duration()) for (i = t; i._dp;) i.rawTime() >= 0 && i.totalTime(i._tTime), i = i._dp;
                    t._zTime = -1e-8
                }
            }, It = function (t, e, i, n) {
                return e.parent && wt(e), e._start = ht((T(i) ? i : i || t !== o ? Nt(t, i, e) : t._time) + e._delay), e._end = ht(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)), function (t, e, i, n, r) {
                    void 0 === i && (i = "_first"), void 0 === n && (n = "_last");
                    var s, a = t[n];
                    if (r) for (s = e[r]; a && a[r] > s;) a = a._prev;
                    a ? (e._next = a._next, a._next = e) : (e._next = t[i], t[i] = e), e._next ? e._next._prev = e : t[n] = e, e._prev = a, e.parent = e._dp = t
                }(t, e, "_first", "_last", t._sort ? "_start" : 0), kt(e) || (t._recent = e), n || Pt(t, e), t
            }, Lt = function (t, e) {
                return (G.ScrollTrigger || W("scrollTrigger", e)) && G.ScrollTrigger.create(e, t)
            }, Rt = function (t, e, i, n) {
                return ke(t, e), t._initted ? !i && t._pt && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && p !== me.frame ? (J.push(t), t._lazy = [e, n], 1) : void 0 : 1
            }, Ft = function t(e) {
                var i = e.parent;
                return i && i._ts && i._initted && !i._lock && (i.rawTime() < 0 || t(i))
            }, kt = function (t) {
                var e = t.data;
                return "isFromStart" === e || "isStart" === e
            }, Ot = function (t, e, i, n) {
                var r = t._repeat, s = ht(e) || 0, a = t._tTime / t._tDur;
                return a && !n && (t._time *= s / t._dur), t._dur = s, t._tDur = r ? r < 0 ? 1e10 : ht(s * (r + 1) + t._rDelay * r) : s, a && !n ? Ct(t, t._tTime = t._tDur * a) : t.parent && Dt(t), i || _t(t.parent, t), t
            }, zt = function (t) {
                return t instanceof Pe ? _t(t) : Ot(t, t._dur)
            }, Bt = {_start: 0, endTime: Y, totalDuration: Y}, Nt = function t(e, i, n) {
                var r, s, a, o = e.labels, h = e._recent || Bt, l = e.duration() >= v ? h.endTime(!1) : e._dur;
                return A(i) && (isNaN(i) || i in o) ? (s = i.charAt(0), a = "%" === i.substr(-1), r = i.indexOf("="), "<" === s || ">" === s ? (r >= 0 && (i = i.replace(/=/, "")), ("<" === s ? h._start : h.endTime(h._repeat >= 0)) + (parseFloat(i.substr(1)) || 0) * (a ? (r < 0 ? h : n).totalDuration() / 100 : 1)) : r < 0 ? (i in o || (o[i] = l), o[i]) : (s = parseFloat(i.charAt(r - 1) + i.substr(r + 1)), a && n && (s = s / 100 * (F(n) ? n[0] : n).totalDuration()), r > 1 ? t(e, i.substr(0, r - 1), n) + s : l + s)) : null == i ? l : +i
            }, jt = function (t, e, i) {
                var n, r, s = T(e[1]), a = (s ? 2 : 1) + (t < 2 ? 0 : 1), o = e[a];
                if (s && (o.duration = e[1]), o.parent = i, t) {
                    for (n = o, r = i; r && !("immediateRender" in n);) n = r.vars.defaults || {}, r = P(r.vars.inherit) && r.parent;
                    o.immediateRender = P(n.immediateRender), t < 2 ? o.runBackwards = 1 : o.startAt = e[a - 1]
                }
                return new Ne(e[0], o, e[a + 1])
            }, Vt = function (t, e) {
                return t || 0 === t ? e(t) : e
            }, Gt = function (t, e, i) {
                return i < t ? t : i > e ? e : i
            }, Ut = function (t) {
                if ("string" != typeof t) return "";
                var e = V.exec(t);
                return e ? t.substr(e.index + e[0].length) : ""
            }, Ht = [].slice, Wt = function (t, e) {
                return t && C(t) && "length" in t && (!e && !t.length || t.length - 1 in t && C(t[0])) && !t.nodeType && t !== h
            }, qt = function (t, e, i) {
                return void 0 === i && (i = []), t.forEach((function (t) {
                    var n;
                    return A(t) && !e || Wt(t, 1) ? (n = i).push.apply(n, Xt(t)) : i.push(t)
                })) || i
            }, Xt = function (t, e, i) {
                return !A(t) || i || !l && ge() ? F(t) ? qt(t, i) : Wt(t) ? Ht.call(t, 0) : t ? [t] : [] : Ht.call((e || c).querySelectorAll(t), 0)
            }, Yt = function (t) {
                return t.sort((function () {
                    return .5 - Math.random()
                }))
            }, Zt = function (t) {
                if (S(t)) return t;
                var e = C(t) ? t : {each: t}, i = Ee(e.ease), n = e.from || 0, r = parseFloat(e.base) || 0, s = {},
                    a = n > 0 && n < 1, o = isNaN(n) || a, h = e.axis, l = n, c = n;
                return A(n) ? l = c = {
                    center: .5,
                    edges: .5,
                    end: 1
                }[n] || 0 : !a && o && (l = n[0], c = n[1]), function (t, a, u) {
                    var p, d, f, m, g, y, b, x, w, E = (u || e).length, M = s[E];
                    if (!M) {
                        if (!(w = "auto" === e.grid ? 0 : (e.grid || [1, v])[1])) {
                            for (b = -v; b < (b = u[w++].getBoundingClientRect().left) && w < E;) ;
                            w--
                        }
                        for (M = s[E] = [], p = o ? Math.min(w, E) * l - .5 : n % w, d = o ? E * c / w - .5 : n / w | 0, b = 0, x = v, y = 0; y < E; y++) f = y % w - p, m = d - (y / w | 0), M[y] = g = h ? Math.abs("y" === h ? m : f) : _(f * f + m * m), g > b && (b = g), g < x && (x = g);
                        "random" === n && Yt(M), M.max = b - x, M.min = x, M.v = E = (parseFloat(e.amount) || parseFloat(e.each) * (w > E ? E - 1 : h ? "y" === h ? E / w : w : Math.max(w, E / w)) || 0) * ("edges" === n ? -1 : 1), M.b = E < 0 ? r - E : r, M.u = Ut(e.amount || e.each) || 0, i = i && E < 0 ? we(i) : i
                    }
                    return E = (M[t] - M.min) / M.max || 0, ht(M.b + (i ? i(E) : E) * M.v) + M.u
                }
            }, Jt = function (t) {
                var e = Math.pow(10, ((t + "").split(".")[1] || "").length);
                return function (i) {
                    var n = Math.round(parseFloat(i) / t) * t * e;
                    return (n - n % 1) / e + (T(i) ? 0 : Ut(i))
                }
            }, Qt = function (t, e) {
                var i, n, r = F(t);
                return !r && C(t) && (i = r = t.radius || v, t.values ? (t = Xt(t.values), (n = !T(t[0])) && (i *= i)) : t = Jt(t.increment)), Vt(e, r ? S(t) ? function (e) {
                    return n = t(e), Math.abs(n - e) <= i ? n : e
                } : function (e) {
                    for (var r, s, a = parseFloat(n ? e.x : e), o = parseFloat(n ? e.y : 0), h = v, l = 0, c = t.length; c--;) (r = n ? (r = t[c].x - a) * r + (s = t[c].y - o) * s : Math.abs(t[c] - a)) < h && (h = r, l = c);
                    return l = !i || h <= i ? t[l] : e, n || l === e || T(e) ? l : l + Ut(e)
                } : Jt(t))
            }, Kt = function (t, e, i, n) {
                return Vt(F(t) ? !e : !0 === i ? !!(i = 0) : !n, (function () {
                    return F(t) ? t[~~(Math.random() * t.length)] : (i = i || 1e-5) && (n = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) && Math.floor(Math.round((t - i / 2 + Math.random() * (e - t + .99 * i)) / i) * i * n) / n
                }))
            }, $t = function (t, e, i) {
                return Vt(i, (function (i) {
                    return t[~~e(i)]
                }))
            }, te = function (t) {
                for (var e, i, n, r, s = 0, a = ""; ~(e = t.indexOf("random(", s));) n = t.indexOf(")", e), r = "[" === t.charAt(e + 7), i = t.substr(e + 7, n - e - 7).match(r ? j : k), a += t.substr(s, e - s) + Kt(r ? i : +i[0], r ? 0 : +i[1], +i[2] || 1e-5), s = n + 1;
                return a + t.substr(s, t.length - s)
            }, ee = function (t, e, i, n, r) {
                var s = e - t, a = n - i;
                return Vt(r, (function (e) {
                    return i + ((e - t) / s * a || 0)
                }))
            }, ie = function (t, e, i) {
                var n, r, s, a = t.labels, o = v;
                for (n in a) (r = a[n] - e) < 0 == !!i && r && o > (r = Math.abs(r)) && (s = n, o = r);
                return s
            }, ne = function (t, e, i) {
                var n, r, s = t.vars, a = s[e];
                if (a) return n = s[e + "Params"], r = s.callbackScope || t, i && J.length && ct(), n ? a.apply(r, n) : a.call(r)
            }, re = function (t) {
                return wt(t), t.scrollTrigger && t.scrollTrigger.kill(!1), t.progress() < 1 && ne(t, "onInterrupt"), t
            }, se = function (t) {
                var e = (t = !t.name && t.default || t).name, i = S(t), n = e && !i && t.init ? function () {
                        this._props = []
                    } : t, r = {init: Y, render: Ye, add: Re, kill: Je, modifier: Ze, rawVars: 0},
                    s = {targetTest: 0, get: 0, getSetter: He, aliases: {}, register: 0};
                if (ge(), t !== n) {
                    if (K[e]) return;
                    ft(n, ft(yt(t, r), s)), gt(n.prototype, gt(r, yt(t, s))), K[n.prop = e] = n, t.targetTest && (et.push(n), Z[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
                }
                X(e, n), t.register && t.register(ni, n, $e)
            }, ae = 255, oe = {
                aqua: [0, ae, ae],
                lime: [0, ae, 0],
                silver: [192, 192, 192],
                black: [0, 0, 0],
                maroon: [128, 0, 0],
                teal: [0, 128, 128],
                blue: [0, 0, ae],
                navy: [0, 0, 128],
                white: [ae, ae, ae],
                olive: [128, 128, 0],
                yellow: [ae, ae, 0],
                orange: [ae, 165, 0],
                gray: [128, 128, 128],
                purple: [128, 0, 128],
                green: [0, 128, 0],
                red: [ae, 0, 0],
                pink: [ae, 192, 203],
                cyan: [0, ae, ae],
                transparent: [ae, ae, ae, 0]
            }, he = function (t, e, i) {
                return (6 * (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t) < 1 ? e + (i - e) * t * 6 : t < .5 ? i : 3 * t < 2 ? e + (i - e) * (2 / 3 - t) * 6 : e) * ae + .5 | 0
            }, le = function (t, e, i) {
                var n, r, s, a, o, h, l, c, u, p, d = t ? T(t) ? [t >> 16, t >> 8 & ae, t & ae] : 0 : oe.black;
                if (!d) {
                    if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), oe[t]) d = oe[t]; else if ("#" === t.charAt(0)) {
                        if (t.length < 6 && (n = t.charAt(1), r = t.charAt(2), s = t.charAt(3), t = "#" + n + n + r + r + s + s + (5 === t.length ? t.charAt(4) + t.charAt(4) : "")), 9 === t.length) return [(d = parseInt(t.substr(1, 6), 16)) >> 16, d >> 8 & ae, d & ae, parseInt(t.substr(7), 16) / 255];
                        d = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & ae, t & ae]
                    } else if ("hsl" === t.substr(0, 3)) if (d = p = t.match(k), e) {
                        if (~t.indexOf("=")) return d = t.match(O), i && d.length < 4 && (d[3] = 1), d
                    } else a = +d[0] % 360 / 360, o = +d[1] / 100, n = 2 * (h = +d[2] / 100) - (r = h <= .5 ? h * (o + 1) : h + o - h * o), d.length > 3 && (d[3] *= 1), d[0] = he(a + 1 / 3, n, r), d[1] = he(a, n, r), d[2] = he(a - 1 / 3, n, r); else d = t.match(k) || oe.transparent;
                    d = d.map(Number)
                }
                return e && !p && (n = d[0] / ae, r = d[1] / ae, s = d[2] / ae, h = ((l = Math.max(n, r, s)) + (c = Math.min(n, r, s))) / 2, l === c ? a = o = 0 : (u = l - c, o = h > .5 ? u / (2 - l - c) : u / (l + c), a = l === n ? (r - s) / u + (r < s ? 6 : 0) : l === r ? (s - n) / u + 2 : (n - r) / u + 4, a *= 60), d[0] = ~~(a + .5), d[1] = ~~(100 * o + .5), d[2] = ~~(100 * h + .5)), i && d.length < 4 && (d[3] = 1), d
            }, ce = function (t) {
                var e = [], i = [], n = -1;
                return t.split(pe).forEach((function (t) {
                    var r = t.match(z) || [];
                    e.push.apply(e, r), i.push(n += r.length + 1)
                })), e.c = i, e
            }, ue = function (t, e, i) {
                var n, r, s, a, o = "", h = (t + o).match(pe), l = e ? "hsla(" : "rgba(", c = 0;
                if (!h) return t;
                if (h = h.map((function (t) {
                    return (t = le(t, e, 1)) && l + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")"
                })), i && (s = ce(t), (n = i.c).join(o) !== s.c.join(o))) for (a = (r = t.replace(pe, "1").split(z)).length - 1; c < a; c++) o += r[c] + (~n.indexOf(c) ? h.shift() || l + "0,0,0,0)" : (s.length ? s : h.length ? h : i).shift());
                if (!r) for (a = (r = t.split(pe)).length - 1; c < a; c++) o += r[c] + h[c];
                return o + r[a]
            }, pe = function () {
                var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
                for (t in oe) e += "|" + t + "\\b";
                return new RegExp(e + ")", "gi")
            }(), de = /hsl[a]?\(/, fe = function (t) {
                var e, i = t.join(" ");
                if (pe.lastIndex = 0, pe.test(i)) return e = de.test(i), t[1] = ue(t[1], e), t[0] = ue(t[0], e, ce(t[1])), !0
            }, me = function () {
                var t, e, i, n, r, s, a = Date.now, o = 500, p = 33, d = a(), m = d, g = 1e3 / 240, v = g, y = [],
                    b = function i(h) {
                        var l, c, u, f, b = a() - m, x = !0 === h;
                        if (b > o && (d += b - p), ((l = (u = (m += b) - d) - v) > 0 || x) && (f = ++n.frame, r = u - 1e3 * n.time, n.time = u /= 1e3, v += l + (l >= g ? 4 : g - l), c = 1), x || (t = e(i)), c) for (s = 0; s < y.length; s++) y[s](u, r, f, h)
                    };
                return n = {
                    time: 0, frame: 0, tick: function () {
                        b(!0)
                    }, deltaRatio: function (t) {
                        return r / (1e3 / (t || 60))
                    }, wake: function () {
                        u && (!l && I() && (h = l = window, c = h.document || {}, G.gsap = ni, (h.gsapVersions || (h.gsapVersions = [])).push(ni.version), H(U || h.GreenSockGlobals || !h.gsap && h || {}), i = h.requestAnimationFrame), t && n.sleep(), e = i || function (t) {
                            return setTimeout(t, v - 1e3 * n.time + 1 | 0)
                        }, f = 1, b(2))
                    }, sleep: function () {
                        (i ? h.cancelAnimationFrame : clearTimeout)(t), f = 0, e = Y
                    }, lagSmoothing: function (t, e) {
                        o = t || 1e8, p = Math.min(e, o, 0)
                    }, fps: function (t) {
                        g = 1e3 / (t || 240), v = 1e3 * n.time + g
                    }, add: function (t) {
                        y.indexOf(t) < 0 && y.push(t), ge()
                    }, remove: function (t) {
                        var e;
                        ~(e = y.indexOf(t)) && y.splice(e, 1) && s >= e && s--
                    }, _listeners: y
                }, n
            }(), ge = function () {
                return !f && me.wake()
            }, ve = {}, ye = /^[\d.\-M][\d.\-,\s]/, be = /["']/g, xe = function (t) {
                for (var e, i, n, r = {}, s = t.substr(1, t.length - 3).split(":"), a = s[0], o = 1, h = s.length; o < h; o++) i = s[o], e = o !== h - 1 ? i.lastIndexOf(",") : i.length, n = i.substr(0, e), r[a] = isNaN(n) ? n.replace(be, "").trim() : +n, a = i.substr(e + 1).trim();
                return r
            }, we = function (t) {
                return function (e) {
                    return 1 - t(1 - e)
                }
            }, _e = function t(e, i) {
                for (var n, r = e._first; r;) r instanceof Pe ? t(r, i) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === i || (r.timeline ? t(r.timeline, i) : (n = r._ease, r._ease = r._yEase, r._yEase = n, r._yoyo = i)), r = r._next
            }, Ee = function (t, e) {
                return t && (S(t) ? t : ve[t] || function (t) {
                    var e, i, n, r, s = (t + "").split("("), a = ve[s[0]];
                    return a && s.length > 1 && a.config ? a.config.apply(null, ~t.indexOf("{") ? [xe(s[1])] : (e = t, i = e.indexOf("(") + 1, n = e.indexOf(")"), r = e.indexOf("(", i), e.substring(i, ~r && r < n ? e.indexOf(")", n + 1) : n)).split(",").map(pt)) : ve._CE && ye.test(t) ? ve._CE("", t) : a
                }(t)) || e
            }, Me = function (t, e, i, n) {
                void 0 === i && (i = function (t) {
                    return 1 - e(1 - t)
                }), void 0 === n && (n = function (t) {
                    return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2
                });
                var r, s = {easeIn: e, easeOut: i, easeInOut: n};
                return at(t, (function (t) {
                    for (var e in ve[t] = G[t] = s, ve[r = t.toLowerCase()] = i, s) ve[r + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = ve[t + "." + e] = s[e]
                })), s
            }, Ae = function (t) {
                return function (e) {
                    return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2
                }
            }, Se = function t(e, i, n) {
                var r = i >= 1 ? i : 1, s = (n || (e ? .3 : .45)) / (i < 1 ? i : 1), a = s / b * (Math.asin(1 / r) || 0),
                    o = function (t) {
                        return 1 === t ? 1 : r * Math.pow(2, -10 * t) * M((t - a) * s) + 1
                    }, h = "out" === e ? o : "in" === e ? function (t) {
                        return 1 - o(1 - t)
                    } : Ae(o);
                return s = b / s, h.config = function (i, n) {
                    return t(e, i, n)
                }, h
            }, Te = function t(e, i) {
                void 0 === i && (i = 1.70158);
                var n = function (t) {
                    return t ? --t * t * ((i + 1) * t + i) + 1 : 0
                }, r = "out" === e ? n : "in" === e ? function (t) {
                    return 1 - n(1 - t)
                } : Ae(n);
                return r.config = function (i) {
                    return t(e, i)
                }, r
            };
        at("Linear,Quad,Cubic,Quart,Quint,Strong", (function (t, e) {
            var i = e < 5 ? e + 1 : e;
            Me(t + ",Power" + (i - 1), e ? function (t) {
                return Math.pow(t, i)
            } : function (t) {
                return t
            }, (function (t) {
                return 1 - Math.pow(1 - t, i)
            }), (function (t) {
                return t < .5 ? Math.pow(2 * t, i) / 2 : 1 - Math.pow(2 * (1 - t), i) / 2
            }))
        })), ve.Linear.easeNone = ve.none = ve.Linear.easeIn, Me("Elastic", Se("in"), Se("out"), Se()), function (t, e) {
            var i = 1 / e, n = function (n) {
                return n < i ? t * n * n : n < .7272727272727273 ? t * Math.pow(n - 1.5 / e, 2) + .75 : n < .9090909090909092 ? t * (n -= 2.25 / e) * n + .9375 : t * Math.pow(n - 2.625 / e, 2) + .984375
            };
            Me("Bounce", (function (t) {
                return 1 - n(1 - t)
            }), n)
        }(7.5625, 2.75), Me("Expo", (function (t) {
            return t ? Math.pow(2, 10 * (t - 1)) : 0
        })), Me("Circ", (function (t) {
            return -(_(1 - t * t) - 1)
        })), Me("Sine", (function (t) {
            return 1 === t ? 1 : 1 - E(t * x)
        })), Me("Back", Te("in"), Te("out"), Te()), ve.SteppedEase = ve.steps = G.SteppedEase = {
            config: function (t, e) {
                void 0 === t && (t = 1);
                var i = 1 / t, n = t + (e ? 0 : 1), r = e ? 1 : 0;
                return function (t) {
                    return ((n * Gt(0, .99999999, t) | 0) + r) * i
                }
            }
        }, g.ease = ve["quad.out"], at("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function (t) {
            return it += t + "," + t + "Params,"
        }));
        var De = function (t, e) {
            this.id = w++, t._gsap = this, this.target = t, this.harness = e, this.get = e ? e.get : st, this.set = e ? e.getSetter : He
        }, Ce = function () {
            function t(t) {
                this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Ot(this, +t.duration, 1, 1), this.data = t.data, f || me.wake()
            }

            var e = t.prototype;
            return e.delay = function (t) {
                return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay
            }, e.duration = function (t) {
                return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
            }, e.totalDuration = function (t) {
                return arguments.length ? (this._dirty = 0, Ot(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
            }, e.totalTime = function (t, e) {
                if (ge(), !arguments.length) return this._tTime;
                var i = this._dp;
                if (i && i.smoothChildTiming && this._ts) {
                    for (Ct(this, t), !i._dp || i.parent || Pt(i, this); i && i.parent;) i.parent._time !== i._start + (i._ts >= 0 ? i._tTime / i._ts : (i.totalDuration() - i._tTime) / -i._ts) && i.totalTime(i._tTime, !0), i = i.parent;
                    !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && It(this._dp, this, this._start - this._delay)
                }
                return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === y || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), ut(this, t, e)), this
            }, e.time = function (t, e) {
                return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + At(this)) % (this._dur + this._rDelay) || (t ? this._dur : 0), e) : this._time
            }, e.totalProgress = function (t, e) {
                return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
            }, e.progress = function (t, e) {
                return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + At(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
            }, e.iteration = function (t, e) {
                var i = this.duration() + this._rDelay;
                return arguments.length ? this.totalTime(this._time + (t - 1) * i, e) : this._repeat ? St(this._tTime, i) + 1 : 1
            }, e.timeScale = function (t) {
                if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
                if (this._rts === t) return this;
                var e = this.parent && this._ts ? Tt(this.parent._time, this) : this._tTime;
                return this._rts = +t || 0, this._ts = this._ps || -1e-8 === t ? 0 : this._rts, Et(this.totalTime(Gt(-this._delay, this._tDur, e), !0)), Dt(this), this
            }, e.paused = function (t) {
                return arguments.length ? (this._ps !== t && (this._ps = t, t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (ge(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== y && (this._tTime -= y)))), this) : this._ps
            }, e.startTime = function (t) {
                if (arguments.length) {
                    this._start = t;
                    var e = this.parent || this._dp;
                    return e && (e._sort || !this.parent) && It(e, this, t - this._delay), this
                }
                return this._start
            }, e.endTime = function (t) {
                return this._start + (P(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
            }, e.rawTime = function (t) {
                var e = this.parent || this._dp;
                return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Tt(e.rawTime(t), this) : this._tTime : this._tTime
            }, e.globalTime = function (t) {
                for (var e = this, i = arguments.length ? t : e.rawTime(); e;) i = e._start + i / (e._ts || 1), e = e._dp;
                return i
            }, e.repeat = function (t) {
                return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t, zt(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
            }, e.repeatDelay = function (t) {
                if (arguments.length) {
                    var e = this._time;
                    return this._rDelay = t, zt(this), e ? this.time(e) : this
                }
                return this._rDelay
            }, e.yoyo = function (t) {
                return arguments.length ? (this._yoyo = t, this) : this._yoyo
            }, e.seek = function (t, e) {
                return this.totalTime(Nt(this, t), P(e))
            }, e.restart = function (t, e) {
                return this.play().totalTime(t ? -this._delay : 0, P(e))
            }, e.play = function (t, e) {
                return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
            }, e.reverse = function (t, e) {
                return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
            }, e.pause = function (t, e) {
                return null != t && this.seek(t, e), this.paused(!0)
            }, e.resume = function () {
                return this.paused(!1)
            }, e.reversed = function (t) {
                return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)), this) : this._rts < 0
            }, e.invalidate = function () {
                return this._initted = this._act = 0, this._zTime = -1e-8, this
            }, e.isActive = function () {
                var t, e = this.parent || this._dp, i = this._start;
                return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= i && t < this.endTime(!0) - y))
            }, e.eventCallback = function (t, e, i) {
                var n = this.vars;
                return arguments.length > 1 ? (e ? (n[t] = e, i && (n[t + "Params"] = i), "onUpdate" === t && (this._onUpdate = e)) : delete n[t], this) : n[t]
            }, e.then = function (t) {
                var e = this;
                return new Promise((function (i) {
                    var n = S(t) ? t : dt, r = function () {
                        var t = e.then;
                        e.then = null, S(n) && (n = n(e)) && (n.then || n === e) && (e.then = t), i(n), e.then = t
                    };
                    e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? r() : e._prom = r
                }))
            }, e.kill = function () {
                re(this)
            }, t
        }();
        ft(Ce.prototype, {
            _time: 0,
            _start: 0,
            _end: 0,
            _tTime: 0,
            _tDur: 0,
            _dirty: 0,
            _repeat: 0,
            _yoyo: !1,
            parent: null,
            _initted: !1,
            _rDelay: 0,
            _ts: 1,
            _dp: 0,
            ratio: 0,
            _zTime: -1e-8,
            _prom: 0,
            _ps: !1,
            _rts: 1
        });
        var Pe = function (t) {
            function e(e, i) {
                var n;
                return void 0 === e && (e = {}), (n = t.call(this, e) || this).labels = {}, n.smoothChildTiming = !!e.smoothChildTiming, n.autoRemoveChildren = !!e.autoRemoveChildren, n._sort = P(e.sortChildren), o && It(e.parent || o, r(n), i), e.reversed && n.reverse(), e.paused && n.paused(!0), e.scrollTrigger && Lt(r(n), e.scrollTrigger), n
            }

            s(e, t);
            var i = e.prototype;
            return i.to = function (t, e, i) {
                return jt(0, arguments, this), this
            }, i.from = function (t, e, i) {
                return jt(1, arguments, this), this
            }, i.fromTo = function (t, e, i, n) {
                return jt(2, arguments, this), this
            }, i.set = function (t, e, i) {
                return e.duration = 0, e.parent = this, bt(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new Ne(t, e, Nt(this, i), 1), this
            }, i.call = function (t, e, i) {
                return It(this, Ne.delayedCall(0, t, e), i)
            }, i.staggerTo = function (t, e, i, n, r, s, a) {
                return i.duration = e, i.stagger = i.stagger || n, i.onComplete = s, i.onCompleteParams = a, i.parent = this, new Ne(t, i, Nt(this, r)), this
            }, i.staggerFrom = function (t, e, i, n, r, s, a) {
                return i.runBackwards = 1, bt(i).immediateRender = P(i.immediateRender), this.staggerTo(t, e, i, n, r, s, a)
            }, i.staggerFromTo = function (t, e, i, n, r, s, a, o) {
                return n.startAt = i, bt(n).immediateRender = P(n.immediateRender), this.staggerTo(t, e, n, r, s, a, o)
            }, i.render = function (t, e, i) {
                var n, r, s, a, h, l, c, u, p, d, f, m, g = this._time,
                    v = this._dirty ? this.totalDuration() : this._tDur, b = this._dur, x = t <= 0 ? 0 : ht(t),
                    w = this._zTime < 0 != t < 0 && (this._initted || !b);
                if (this !== o && x > v && t >= 0 && (x = v), x !== this._tTime || i || w) {
                    if (g !== this._time && b && (x += this._time - g, t += this._time - g), n = x, p = this._start, l = !(u = this._ts), w && (b || (g = this._zTime), (t || !e) && (this._zTime = t)), this._repeat) {
                        if (f = this._yoyo, h = b + this._rDelay, this._repeat < -1 && t < 0) return this.totalTime(100 * h + t, e, i);
                        if (n = ht(x % h), x === v ? (a = this._repeat, n = b) : ((a = ~~(x / h)) && a === x / h && (n = b, a--), n > b && (n = b)), d = St(this._tTime, h), !g && this._tTime && d !== a && (d = a), f && 1 & a && (n = b - n, m = 1), a !== d && !this._lock) {
                            var _ = f && 1 & d, E = _ === (f && 1 & a);
                            if (a < d && (_ = !_), g = _ ? 0 : b, this._lock = 1, this.render(g || (m ? 0 : ht(a * h)), e, !b)._lock = 0, this._tTime = x, !e && this.parent && ne(this, "onRepeat"), this.vars.repeatRefresh && !m && (this.invalidate()._lock = 1), g && g !== this._time || l !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                            if (b = this._dur, v = this._tDur, E && (this._lock = 2, g = _ ? b : -1e-4, this.render(g, !0), this.vars.repeatRefresh && !m && this.invalidate()), this._lock = 0, !this._ts && !l) return this;
                            _e(this, m)
                        }
                    }
                    if (this._hasPause && !this._forcing && this._lock < 2 && (c = function (t, e, i) {
                        var n;
                        if (i > e) for (n = t._first; n && n._start <= i;) {
                            if (!n._dur && "isPause" === n.data && n._start > e) return n;
                            n = n._next
                        } else for (n = t._last; n && n._start >= i;) {
                            if (!n._dur && "isPause" === n.data && n._start < e) return n;
                            n = n._prev
                        }
                    }(this, ht(g), ht(n)), c && (x -= n - (n = c._start))), this._tTime = x, this._time = n, this._act = !u, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t, g = 0), !g && n && !e && (ne(this, "onStart"), this._tTime !== x)) return this;
                    if (n >= g && t >= 0) for (r = this._first; r;) {
                        if (s = r._next, (r._act || n >= r._start) && r._ts && c !== r) {
                            if (r.parent !== this) return this.render(t, e, i);
                            if (r.render(r._ts > 0 ? (n - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (n - r._start) * r._ts, e, i), n !== this._time || !this._ts && !l) {
                                c = 0, s && (x += this._zTime = -1e-8);
                                break
                            }
                        }
                        r = s
                    } else {
                        r = this._last;
                        for (var M = t < 0 ? t : n; r;) {
                            if (s = r._prev, (r._act || M <= r._end) && r._ts && c !== r) {
                                if (r.parent !== this) return this.render(t, e, i);
                                if (r.render(r._ts > 0 ? (M - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (M - r._start) * r._ts, e, i), n !== this._time || !this._ts && !l) {
                                    c = 0, s && (x += this._zTime = M ? -1e-8 : y);
                                    break
                                }
                            }
                            r = s
                        }
                    }
                    if (c && !e && (this.pause(), c.render(n >= g ? 0 : -1e-8)._zTime = n >= g ? 1 : -1, this._ts)) return this._start = p, Dt(this), this.render(t, e, i);
                    this._onUpdate && !e && ne(this, "onUpdate", !0), (x === v && v >= this.totalDuration() || !x && g) && (p !== this._start && Math.abs(u) === Math.abs(this._ts) || this._lock || ((t || !b) && (x === v && this._ts > 0 || !x && this._ts < 0) && wt(this, 1), e || t < 0 && !g || !x && !g && v || (ne(this, x === v && t >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(x < v && this.timeScale() > 0) && this._prom())))
                }
                return this
            }, i.add = function (t, e) {
                var i = this;
                if (T(e) || (e = Nt(this, e, t)), !(t instanceof Ce)) {
                    if (F(t)) return t.forEach((function (t) {
                        return i.add(t, e)
                    })), this;
                    if (A(t)) return this.addLabel(t, e);
                    if (!S(t)) return this;
                    t = Ne.delayedCall(0, t)
                }
                return this !== t ? It(this, t, e) : this
            }, i.getChildren = function (t, e, i, n) {
                void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i && (i = !0), void 0 === n && (n = -v);
                for (var r = [], s = this._first; s;) s._start >= n && (s instanceof Ne ? e && r.push(s) : (i && r.push(s), t && r.push.apply(r, s.getChildren(!0, e, i)))), s = s._next;
                return r
            }, i.getById = function (t) {
                for (var e = this.getChildren(1, 1, 1), i = e.length; i--;) if (e[i].vars.id === t) return e[i]
            }, i.remove = function (t) {
                return A(t) ? this.removeLabel(t) : S(t) ? this.killTweensOf(t) : (xt(this, t), t === this._recent && (this._recent = this._last), _t(this))
            }, i.totalTime = function (e, i) {
                return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = ht(me.time - (this._ts > 0 ? e / this._ts : (this.totalDuration() - e) / -this._ts))), t.prototype.totalTime.call(this, e, i), this._forcing = 0, this) : this._tTime
            }, i.addLabel = function (t, e) {
                return this.labels[t] = Nt(this, e), this
            }, i.removeLabel = function (t) {
                return delete this.labels[t], this
            }, i.addPause = function (t, e, i) {
                var n = Ne.delayedCall(0, e || Y, i);
                return n.data = "isPause", this._hasPause = 1, It(this, n, Nt(this, t))
            }, i.removePause = function (t) {
                var e = this._first;
                for (t = Nt(this, t); e;) e._start === t && "isPause" === e.data && wt(e), e = e._next
            }, i.killTweensOf = function (t, e, i) {
                for (var n = this.getTweensOf(t, i), r = n.length; r--;) Ie !== n[r] && n[r].kill(t, e);
                return this
            }, i.getTweensOf = function (t, e) {
                for (var i, n = [], r = Xt(t), s = this._first, a = T(e); s;) s instanceof Ne ? lt(s._targets, r) && (a ? (!Ie || s._initted && s._ts) && s.globalTime(0) <= e && s.globalTime(s.totalDuration()) > e : !e || s.isActive()) && n.push(s) : (i = s.getTweensOf(r, e)).length && n.push.apply(n, i), s = s._next;
                return n
            }, i.tweenTo = function (t, e) {
                e = e || {};
                var i, n = this, r = Nt(n, t), s = e, a = s.startAt, o = s.onStart, h = s.onStartParams,
                    l = s.immediateRender, c = Ne.to(n, ft({
                        ease: e.ease || "none",
                        lazy: !1,
                        immediateRender: !1,
                        time: r,
                        overwrite: "auto",
                        duration: e.duration || Math.abs((r - (a && "time" in a ? a.time : n._time)) / n.timeScale()) || y,
                        onStart: function () {
                            if (n.pause(), !i) {
                                var t = e.duration || Math.abs((r - (a && "time" in a ? a.time : n._time)) / n.timeScale());
                                c._dur !== t && Ot(c, t, 0, 1).render(c._time, !0, !0), i = 1
                            }
                            o && o.apply(c, h || [])
                        }
                    }, e));
                return l ? c.render(0) : c
            }, i.tweenFromTo = function (t, e, i) {
                return this.tweenTo(e, ft({startAt: {time: Nt(this, t)}}, i))
            }, i.recent = function () {
                return this._recent
            }, i.nextLabel = function (t) {
                return void 0 === t && (t = this._time), ie(this, Nt(this, t))
            }, i.previousLabel = function (t) {
                return void 0 === t && (t = this._time), ie(this, Nt(this, t), 1)
            }, i.currentLabel = function (t) {
                return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + y)
            }, i.shiftChildren = function (t, e, i) {
                void 0 === i && (i = 0);
                for (var n, r = this._first, s = this.labels; r;) r._start >= i && (r._start += t, r._end += t), r = r._next;
                if (e) for (n in s) s[n] >= i && (s[n] += t);
                return _t(this)
            }, i.invalidate = function () {
                var e = this._first;
                for (this._lock = 0; e;) e.invalidate(), e = e._next;
                return t.prototype.invalidate.call(this)
            }, i.clear = function (t) {
                void 0 === t && (t = !0);
                for (var e, i = this._first; i;) e = i._next, this.remove(i), i = e;
                return this._dp && (this._time = this._tTime = this._pTime = 0), t && (this.labels = {}), _t(this)
            }, i.totalDuration = function (t) {
                var e, i, n, r = 0, s = this, a = s._last, h = v;
                if (arguments.length) return s.timeScale((s._repeat < 0 ? s.duration() : s.totalDuration()) / (s.reversed() ? -t : t));
                if (s._dirty) {
                    for (n = s.parent; a;) e = a._prev, a._dirty && a.totalDuration(), (i = a._start) > h && s._sort && a._ts && !s._lock ? (s._lock = 1, It(s, a, i - a._delay, 1)._lock = 0) : h = i, i < 0 && a._ts && (r -= i, (!n && !s._dp || n && n.smoothChildTiming) && (s._start += i / s._ts, s._time -= i, s._tTime -= i), s.shiftChildren(-i, !1, -Infinity), h = 0), a._end > r && a._ts && (r = a._end), a = e;
                    Ot(s, s === o && s._time > r ? s._time : r, 1, 1), s._dirty = 0
                }
                return s._tDur
            }, e.updateRoot = function (t) {
                if (o._ts && (ut(o, Tt(t, o)), p = me.frame), me.frame >= tt) {
                    tt += m.autoSleep || 120;
                    var e = o._first;
                    if ((!e || !e._ts) && m.autoSleep && me._listeners.length < 2) {
                        for (; e && !e._ts;) e = e._next;
                        e || me.sleep()
                    }
                }
            }, e
        }(Ce);
        ft(Pe.prototype, {_lock: 0, _hasPause: 0, _forcing: 0});
        var Ie, Le = function (t, e, i, n, r, s, a) {
                var o, h, l, c, u, p, d, f, m = new $e(this._pt, t, e, 0, 1, Xe, null, r), g = 0, v = 0;
                for (m.b = i, m.e = n, i += "", (d = ~(n += "").indexOf("random(")) && (n = te(n)), s && (s(f = [i, n], t, e), i = f[0], n = f[1]), h = i.match(B) || []; o = B.exec(n);) c = o[0], u = n.substring(g, o.index), l ? l = (l + 1) % 5 : "rgba(" === u.substr(-5) && (l = 1), c !== h[v++] && (p = parseFloat(h[v - 1]) || 0, m._pt = {
                    _next: m._pt,
                    p: u || 1 === v ? u : ",",
                    s: p,
                    c: "=" === c.charAt(1) ? parseFloat(c.substr(2)) * ("-" === c.charAt(0) ? -1 : 1) : parseFloat(c) - p,
                    m: l && l < 4 ? Math.round : 0
                }, g = B.lastIndex);
                return m.c = g < n.length ? n.substring(g, n.length) : "", m.fp = a, (N.test(n) || d) && (m.e = 0), this._pt = m, m
            }, Re = function (t, e, i, n, r, s, a, o, h) {
                S(n) && (n = n(r || 0, t, s));
                var l, c = t[e],
                    u = "get" !== i ? i : S(c) ? h ? t[e.indexOf("set") || !S(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](h) : t[e]() : c,
                    p = S(c) ? h ? Ge : Ve : je;
                if (A(n) && (~n.indexOf("random(") && (n = te(n)), "=" === n.charAt(1) && ((l = parseFloat(u) + parseFloat(n.substr(2)) * ("-" === n.charAt(0) ? -1 : 1) + (Ut(u) || 0)) || 0 === l) && (n = l)), u !== n) return isNaN(u * n) || "" === n ? (!c && !(e in t) && W(e, n), Le.call(this, t, e, u, n, p, o || m.stringFilter, h)) : (l = new $e(this._pt, t, e, +u || 0, n - (u || 0), "boolean" == typeof c ? qe : We, 0, p), h && (l.fp = h), a && l.modifier(a, this, t), this._pt = l)
            }, Fe = function (t, e, i, n, r, s) {
                var a, o, h, l;
                if (K[t] && !1 !== (a = new K[t]).init(r, a.rawVars ? e[t] : function (t, e, i, n, r) {
                    if (S(t) && (t = Oe(t, r, e, i, n)), !C(t) || t.style && t.nodeType || F(t) || R(t)) return A(t) ? Oe(t, r, e, i, n) : t;
                    var s, a = {};
                    for (s in t) a[s] = Oe(t[s], r, e, i, n);
                    return a
                }(e[t], n, r, s, i), i, n, s) && (i._pt = o = new $e(i._pt, r, t, 0, 1, a.render, a, 0, a.priority), i !== d)) for (h = i._ptLookup[i._targets.indexOf(r)], l = a._props.length; l--;) h[a._props[l]] = o;
                return a
            }, ke = function t(e, i) {
                var n, r, s, h, l, c, u, p, d, f, m, v, b, x = e.vars, w = x.ease, _ = x.startAt, E = x.immediateRender,
                    M = x.lazy, A = x.onUpdate, S = x.onUpdateParams, T = x.callbackScope, D = x.runBackwards,
                    C = x.yoyoEase, I = x.keyframes, L = x.autoRevert, R = e._dur, F = e._startAt, k = e._targets,
                    O = e.parent, z = O && "nested" === O.data ? O.parent._targets : k, B = "auto" === e._overwrite && !a,
                    N = e.timeline;
                if (N && (!I || !w) && (w = "none"), e._ease = Ee(w, g.ease), e._yEase = C ? we(Ee(!0 === C ? w : C, g.ease)) : 0, C && e._yoyo && !e._repeat && (C = e._yEase, e._yEase = e._ease, e._ease = C), e._from = !N && !!x.runBackwards, !N) {
                    if (v = (p = k[0] ? rt(k[0]).harness : 0) && x[p.prop], n = yt(x, Z), F && F.render(-1, !0).kill(), _) if (wt(e._startAt = Ne.set(k, ft({
                        data: "isStart",
                        overwrite: !1,
                        parent: O,
                        immediateRender: !0,
                        lazy: P(M),
                        startAt: null,
                        delay: 0,
                        onUpdate: A,
                        onUpdateParams: S,
                        callbackScope: T,
                        stagger: 0
                    }, _))), i < 0 && !E && !L && e._startAt.render(-1, !0), E) {
                        if (i > 0 && !L && (e._startAt = 0), R && i <= 0) return void (i && (e._zTime = i))
                    } else !1 === L && (e._startAt = 0); else if (D && R) if (F) !L && (e._startAt = 0); else if (i && (E = !1), s = ft({
                        overwrite: !1,
                        data: "isFromStart",
                        lazy: E && P(M),
                        immediateRender: E,
                        stagger: 0,
                        parent: O
                    }, n), v && (s[p.prop] = v), wt(e._startAt = Ne.set(k, s)), i < 0 && e._startAt.render(-1, !0), E) {
                        if (!i) return
                    } else t(e._startAt, y);
                    for (e._pt = 0, M = R && P(M) || M && !R, r = 0; r < k.length; r++) {
                        if (u = (l = k[r])._gsap || nt(k)[r]._gsap, e._ptLookup[r] = f = {}, Q[u.id] && J.length && ct(), m = z === k ? r : z.indexOf(l), p && !1 !== (d = new p).init(l, v || n, e, m, z) && (e._pt = h = new $e(e._pt, l, d.name, 0, 1, d.render, d, 0, d.priority), d._props.forEach((function (t) {
                            f[t] = h
                        })), d.priority && (c = 1)), !p || v) for (s in n) K[s] && (d = Fe(s, n, e, m, l, z)) ? d.priority && (c = 1) : f[s] = h = Re.call(e, l, s, "get", n[s], m, z, 0, x.stringFilter);
                        e._op && e._op[r] && e.kill(l, e._op[r]), B && e._pt && (Ie = e, o.killTweensOf(l, f, e.globalTime(i)), b = !e.parent, Ie = 0), e._pt && M && (Q[u.id] = 1)
                    }
                    c && Ke(e), e._onInit && e._onInit(e)
                }
                e._onUpdate = A, e._initted = (!e._op || e._pt) && !b
            }, Oe = function (t, e, i, n, r) {
                return S(t) ? t.call(e, i, n, r) : A(t) && ~t.indexOf("random(") ? te(t) : t
            }, ze = it + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
            Be = (ze + ",id,stagger,delay,duration,paused,scrollTrigger").split(","), Ne = function (t) {
                function e(e, i, n, s) {
                    var h;
                    "number" == typeof i && (n.duration = i, i = n, n = null);
                    var l, c, u, p, d, f, g, v, y = (h = t.call(this, s ? i : bt(i)) || this).vars, b = y.duration,
                        x = y.delay, w = y.immediateRender, _ = y.stagger, E = y.overwrite, M = y.keyframes, A = y.defaults,
                        S = y.scrollTrigger, D = y.yoyoEase, I = i.parent || o,
                        k = (F(e) || R(e) ? T(e[0]) : "length" in i) ? [e] : Xt(e);
                    if (h._targets = k.length ? nt(k) : q("GSAP target " + e + " not found. https://greensock.com", !m.nullTargetWarn) || [], h._ptLookup = [], h._overwrite = E, M || _ || L(b) || L(x)) {
                        if (i = h.vars, (l = h.timeline = new Pe({
                            data: "nested",
                            defaults: A || {}
                        })).kill(), l.parent = l._dp = r(h), l._start = 0, M) bt(ft(l.vars.defaults, {ease: "none"})), _ ? k.forEach((function (t, e) {
                            return M.forEach((function (i, n) {
                                return l.to(t, i, n ? ">" : e * _)
                            }))
                        })) : M.forEach((function (t) {
                            return l.to(k, t, ">")
                        })); else {
                            if (p = k.length, g = _ ? Zt(_) : Y, C(_)) for (d in _) ~ze.indexOf(d) && (v || (v = {}), v[d] = _[d]);
                            for (c = 0; c < p; c++) {
                                for (d in u = {}, i) Be.indexOf(d) < 0 && (u[d] = i[d]);
                                u.stagger = 0, D && (u.yoyoEase = D), v && gt(u, v), f = k[c], u.duration = +Oe(b, r(h), c, f, k), u.delay = (+Oe(x, r(h), c, f, k) || 0) - h._delay, !_ && 1 === p && u.delay && (h._delay = x = u.delay, h._start += x, u.delay = 0), l.to(f, u, g(c, f, k))
                            }
                            l.duration() ? b = x = 0 : h.timeline = 0
                        }
                        b || h.duration(b = l.duration())
                    } else h.timeline = 0;
                    return !0 !== E || a || (Ie = r(h), o.killTweensOf(k), Ie = 0), It(I, r(h), n), i.reversed && h.reverse(), i.paused && h.paused(!0), (w || !b && !M && h._start === ht(I._time) && P(w) && Mt(r(h)) && "nested" !== I.data) && (h._tTime = -1e-8, h.render(Math.max(0, -x))), S && Lt(r(h), S), h
                }

                s(e, t);
                var i = e.prototype;
                return i.render = function (t, e, i) {
                    var n, r, s, a, o, h, l, c, u, p = this._time, d = this._tDur, f = this._dur,
                        m = t > d - y && t >= 0 ? d : t < y ? 0 : t;
                    if (f) {
                        if (m !== this._tTime || !t || i || !this._initted && this._tTime || this._startAt && this._zTime < 0 != t < 0) {
                            if (n = m, c = this.timeline, this._repeat) {
                                if (a = f + this._rDelay, this._repeat < -1 && t < 0) return this.totalTime(100 * a + t, e, i);
                                if (n = ht(m % a), m === d ? (s = this._repeat, n = f) : ((s = ~~(m / a)) && s === m / a && (n = f, s--), n > f && (n = f)), (h = this._yoyo && 1 & s) && (u = this._yEase, n = f - n), o = St(this._tTime, a), n === p && !i && this._initted) return this;
                                s !== o && (c && this._yEase && _e(c, h), !this.vars.repeatRefresh || h || this._lock || (this._lock = i = 1, this.render(ht(a * s), !0).invalidate()._lock = 0))
                            }
                            if (!this._initted) {
                                if (Rt(this, t < 0 ? t : n, i, e)) return this._tTime = 0, this;
                                if (f !== this._dur) return this.render(t, e, i)
                            }
                            if (this._tTime = m, this._time = n, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = l = (u || this._ease)(n / f), this._from && (this.ratio = l = 1 - l), n && !p && !e && (ne(this, "onStart"), this._tTime !== m)) return this;
                            for (r = this._pt; r;) r.r(l, r.d), r = r._next;
                            c && c.render(t < 0 ? t : !n && h ? -1e-8 : c._dur * l, e, i) || this._startAt && (this._zTime = t), this._onUpdate && !e && (t < 0 && this._startAt && this._startAt.render(t, !0, i), ne(this, "onUpdate")), this._repeat && s !== o && this.vars.onRepeat && !e && this.parent && ne(this, "onRepeat"), m !== this._tDur && m || this._tTime !== m || (t < 0 && this._startAt && !this._onUpdate && this._startAt.render(t, !0, !0), (t || !f) && (m === this._tDur && this._ts > 0 || !m && this._ts < 0) && wt(this, 1), e || t < 0 && !p || !m && !p || (ne(this, m === d ? "onComplete" : "onReverseComplete", !0), this._prom && !(m < d && this.timeScale() > 0) && this._prom()))
                        }
                    } else !function (t, e, i, n) {
                        var r, s, a, o = t.ratio,
                            h = e < 0 || !e && (!t._start && Ft(t) && (t._initted || !kt(t)) || (t._ts < 0 || t._dp._ts < 0) && !kt(t)) ? 0 : 1,
                            l = t._rDelay, c = 0;
                        if (l && t._repeat && (c = Gt(0, t._tDur, e), s = St(c, l), a = St(t._tTime, l), t._yoyo && 1 & s && (h = 1 - h), s !== a && (o = 1 - h, t.vars.repeatRefresh && t._initted && t.invalidate())), h !== o || n || t._zTime === y || !e && t._zTime) {
                            if (!t._initted && Rt(t, e, n, i)) return;
                            for (a = t._zTime, t._zTime = e || (i ? y : 0), i || (i = e && !a), t.ratio = h, t._from && (h = 1 - h), t._time = 0, t._tTime = c, r = t._pt; r;) r.r(h, r.d), r = r._next;
                            t._startAt && e < 0 && t._startAt.render(e, !0, !0), t._onUpdate && !i && ne(t, "onUpdate"), c && t._repeat && !i && t.parent && ne(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === h && (h && wt(t, 1), i || (ne(t, h ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()))
                        } else t._zTime || (t._zTime = e)
                    }(this, t, e, i);
                    return this
                }, i.targets = function () {
                    return this._targets
                }, i.invalidate = function () {
                    return this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), t.prototype.invalidate.call(this)
                }, i.kill = function (t, e) {
                    if (void 0 === e && (e = "all"), !(t || e && "all" !== e)) return this._lazy = this._pt = 0, this.parent ? re(this) : this;
                    if (this.timeline) {
                        var i = this.timeline.totalDuration();
                        return this.timeline.killTweensOf(t, e, Ie && !0 !== Ie.vars.overwrite)._first || re(this), this.parent && i !== this.timeline.totalDuration() && Ot(this, this._dur * this.timeline._tDur / i, 0, 1), this
                    }
                    var n, r, s, a, o, h, l, c = this._targets, u = t ? Xt(t) : c, p = this._ptLookup, d = this._pt;
                    if ((!e || "all" === e) && function (t, e) {
                        for (var i = t.length, n = i === e.length; n && i-- && t[i] === e[i];) ;
                        return i < 0
                    }(c, u)) return "all" === e && (this._pt = 0), re(this);
                    for (n = this._op = this._op || [], "all" !== e && (A(e) && (o = {}, at(e, (function (t) {
                        return o[t] = 1
                    })), e = o), e = function (t, e) {
                        var i, n, r, s, a = t[0] ? rt(t[0]).harness : 0, o = a && a.aliases;
                        if (!o) return e;
                        for (n in i = gt({}, e), o) if (n in i) for (r = (s = o[n].split(",")).length; r--;) i[s[r]] = i[n];
                        return i
                    }(c, e)), l = c.length; l--;) if (~u.indexOf(c[l])) for (o in r = p[l], "all" === e ? (n[l] = e, a = r, s = {}) : (s = n[l] = n[l] || {}, a = e), a) (h = r && r[o]) && ("kill" in h.d && !0 !== h.d.kill(o) || xt(this, h, "_pt"), delete r[o]), "all" !== s && (s[o] = 1);
                    return this._initted && !this._pt && d && re(this), this
                }, e.to = function (t, i) {
                    return new e(t, i, arguments[2])
                }, e.from = function (t, e) {
                    return jt(1, arguments)
                }, e.delayedCall = function (t, i, n, r) {
                    return new e(i, 0, {
                        immediateRender: !1,
                        lazy: !1,
                        overwrite: !1,
                        delay: t,
                        onComplete: i,
                        onReverseComplete: i,
                        onCompleteParams: n,
                        onReverseCompleteParams: n,
                        callbackScope: r
                    })
                }, e.fromTo = function (t, e, i) {
                    return jt(2, arguments)
                }, e.set = function (t, i) {
                    return i.duration = 0, i.repeatDelay || (i.repeat = 0), new e(t, i)
                }, e.killTweensOf = function (t, e, i) {
                    return o.killTweensOf(t, e, i)
                }, e
            }(Ce);
        ft(Ne.prototype, {
            _targets: [],
            _lazy: 0,
            _startAt: 0,
            _op: 0,
            _onInit: 0
        }), at("staggerTo,staggerFrom,staggerFromTo", (function (t) {
            Ne[t] = function () {
                var e = new Pe, i = Ht.call(arguments, 0);
                return i.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, i)
            }
        }));
        var je = function (t, e, i) {
            return t[e] = i
        }, Ve = function (t, e, i) {
            return t[e](i)
        }, Ge = function (t, e, i, n) {
            return t[e](n.fp, i)
        }, Ue = function (t, e, i) {
            return t.setAttribute(e, i)
        }, He = function (t, e) {
            return S(t[e]) ? Ve : D(t[e]) && t.setAttribute ? Ue : je
        }, We = function (t, e) {
            return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e)
        }, qe = function (t, e) {
            return e.set(e.t, e.p, !!(e.s + e.c * t), e)
        }, Xe = function (t, e) {
            var i = e._pt, n = "";
            if (!t && e.b) n = e.b; else if (1 === t && e.e) n = e.e; else {
                for (; i;) n = i.p + (i.m ? i.m(i.s + i.c * t) : Math.round(1e4 * (i.s + i.c * t)) / 1e4) + n, i = i._next;
                n += e.c
            }
            e.set(e.t, e.p, n, e)
        }, Ye = function (t, e) {
            for (var i = e._pt; i;) i.r(t, i.d), i = i._next
        }, Ze = function (t, e, i, n) {
            for (var r, s = this._pt; s;) r = s._next, s.p === n && s.modifier(t, e, i), s = r
        }, Je = function (t) {
            for (var e, i, n = this._pt; n;) i = n._next, n.p === t && !n.op || n.op === t ? xt(this, n, "_pt") : n.dep || (e = 1), n = i;
            return !e
        }, Qe = function (t, e, i, n) {
            n.mSet(t, e, n.m.call(n.tween, i, n.mt), n)
        }, Ke = function (t) {
            for (var e, i, n, r, s = t._pt; s;) {
                for (e = s._next, i = n; i && i.pr > s.pr;) i = i._next;
                (s._prev = i ? i._prev : r) ? s._prev._next = s : n = s, (s._next = i) ? i._prev = s : r = s, s = e
            }
            t._pt = n
        }, $e = function () {
            function t(t, e, i, n, r, s, a, o, h) {
                this.t = e, this.s = n, this.c = r, this.p = i, this.r = s || We, this.d = a || this, this.set = o || je, this.pr = h || 0, this._next = t, t && (t._prev = this)
            }

            return t.prototype.modifier = function (t, e, i) {
                this.mSet = this.mSet || this.set, this.set = Qe, this.m = t, this.mt = i, this.tween = e
            }, t
        }();
        at(it + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function (t) {
            return Z[t] = 1
        })), G.TweenMax = G.TweenLite = Ne, G.TimelineLite = G.TimelineMax = Pe, o = new Pe({
            sortChildren: !1,
            defaults: g,
            autoRemoveChildren: !0,
            id: "root",
            smoothChildTiming: !0
        }), m.stringFilter = fe;
        var ti = {
            registerPlugin: function () {
                for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                e.forEach((function (t) {
                    return se(t)
                }))
            },
            timeline: function (t) {
                return new Pe(t)
            },
            getTweensOf: function (t, e) {
                return o.getTweensOf(t, e)
            },
            getProperty: function (t, e, i, n) {
                A(t) && (t = Xt(t)[0]);
                var r = rt(t || {}).get, s = i ? dt : pt;
                return "native" === i && (i = ""), t ? e ? s((K[e] && K[e].get || r)(t, e, i, n)) : function (e, i, n) {
                    return s((K[e] && K[e].get || r)(t, e, i, n))
                } : t
            },
            quickSetter: function (t, e, i) {
                if ((t = Xt(t)).length > 1) {
                    var n = t.map((function (t) {
                        return ni.quickSetter(t, e, i)
                    })), r = n.length;
                    return function (t) {
                        for (var e = r; e--;) n[e](t)
                    }
                }
                t = t[0] || {};
                var s = K[e], a = rt(t), o = a.harness && (a.harness.aliases || {})[e] || e, h = s ? function (e) {
                    var n = new s;
                    d._pt = 0, n.init(t, i ? e + i : e, d, 0, [t]), n.render(1, n), d._pt && Ye(1, d)
                } : a.set(t, o);
                return s ? h : function (e) {
                    return h(t, o, i ? e + i : e, a, 1)
                }
            },
            isTweening: function (t) {
                return o.getTweensOf(t, !0).length > 0
            },
            defaults: function (t) {
                return t && t.ease && (t.ease = Ee(t.ease, g.ease)), vt(g, t || {})
            },
            config: function (t) {
                return vt(m, t || {})
            },
            registerEffect: function (t) {
                var e = t.name, i = t.effect, n = t.plugins, r = t.defaults, s = t.extendTimeline;
                (n || "").split(",").forEach((function (t) {
                    return t && !K[t] && !G[t] && q(e + " effect requires " + t + " plugin.")
                })), $[e] = function (t, e, n) {
                    return i(Xt(t), ft(e || {}, r), n)
                }, s && (Pe.prototype[e] = function (t, i, n) {
                    return this.add($[e](t, C(i) ? i : (n = i) && {}, this), n)
                })
            },
            registerEase: function (t, e) {
                ve[t] = Ee(e)
            },
            parseEase: function (t, e) {
                return arguments.length ? Ee(t, e) : ve
            },
            getById: function (t) {
                return o.getById(t)
            },
            exportRoot: function (t, e) {
                void 0 === t && (t = {});
                var i, n, r = new Pe(t);
                for (r.smoothChildTiming = P(t.smoothChildTiming), o.remove(r), r._dp = 0, r._time = r._tTime = o._time, i = o._first; i;) n = i._next, !e && !i._dur && i instanceof Ne && i.vars.onComplete === i._targets[0] || It(r, i, i._start - i._delay), i = n;
                return It(o, r, 0), r
            },
            utils: {
                wrap: function t(e, i, n) {
                    var r = i - e;
                    return F(e) ? $t(e, t(0, e.length), i) : Vt(n, (function (t) {
                        return (r + (t - e) % r) % r + e
                    }))
                }, wrapYoyo: function t(e, i, n) {
                    var r = i - e, s = 2 * r;
                    return F(e) ? $t(e, t(0, e.length - 1), i) : Vt(n, (function (t) {
                        return e + ((t = (s + (t - e) % s) % s || 0) > r ? s - t : t)
                    }))
                }, distribute: Zt, random: Kt, snap: Qt, normalize: function (t, e, i) {
                    return ee(t, e, 0, 1, i)
                }, getUnit: Ut, clamp: function (t, e, i) {
                    return Vt(i, (function (i) {
                        return Gt(t, e, i)
                    }))
                }, splitColor: le, toArray: Xt, selector: function (t) {
                    return t = Xt(t)[0] || q("Invalid scope") || {}, function (e) {
                        var i = t.current || t.nativeElement || t;
                        return Xt(e, i.querySelectorAll ? i : i === t ? q("Invalid scope") || c.createElement("div") : t)
                    }
                }, mapRange: ee, pipe: function () {
                    for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                    return function (t) {
                        return e.reduce((function (t, e) {
                            return e(t)
                        }), t)
                    }
                }, unitize: function (t, e) {
                    return function (i) {
                        return t(parseFloat(i)) + (e || Ut(i))
                    }
                }, interpolate: function t(e, i, n, r) {
                    var s = isNaN(e + i) ? 0 : function (t) {
                        return (1 - t) * e + t * i
                    };
                    if (!s) {
                        var a, o, h, l, c, u = A(e), p = {};
                        if (!0 === n && (r = 1) && (n = null), u) e = {p: e}, i = {p: i}; else if (F(e) && !F(i)) {
                            for (h = [], l = e.length, c = l - 2, o = 1; o < l; o++) h.push(t(e[o - 1], e[o]));
                            l--, s = function (t) {
                                t *= l;
                                var e = Math.min(c, ~~t);
                                return h[e](t - e)
                            }, n = i
                        } else r || (e = gt(F(e) ? [] : {}, e));
                        if (!h) {
                            for (a in i) Re.call(p, e, a, "get", i[a]);
                            s = function (t) {
                                return Ye(t, p) || (u ? e.p : e)
                            }
                        }
                    }
                    return Vt(n, s)
                }, shuffle: Yt
            },
            install: H,
            effects: $,
            ticker: me,
            updateRoot: Pe.updateRoot,
            plugins: K,
            globalTimeline: o,
            core: {
                PropTween: $e,
                globals: X,
                Tween: Ne,
                Timeline: Pe,
                Animation: Ce,
                getCache: rt,
                _removeLinkedListItem: xt,
                suppressOverwrites: function (t) {
                    return a = t
                }
            }
        };
        at("to,from,fromTo,delayedCall,set,killTweensOf", (function (t) {
            return ti[t] = Ne[t]
        })), me.add(Pe.updateRoot), d = ti.to({}, {duration: 0});
        var ei = function (t, e) {
            for (var i = t._pt; i && i.p !== e && i.op !== e && i.fp !== e;) i = i._next;
            return i
        }, ii = function (t, e) {
            return {
                name: t, rawVars: 1, init: function (t, i, n) {
                    n._onInit = function (t) {
                        var n, r;
                        if (A(i) && (n = {}, at(i, (function (t) {
                            return n[t] = 1
                        })), i = n), e) {
                            for (r in n = {}, i) n[r] = e(i[r]);
                            i = n
                        }
                        !function (t, e) {
                            var i, n, r, s = t._targets;
                            for (i in e) for (n = s.length; n--;) (r = t._ptLookup[n][i]) && (r = r.d) && (r._pt && (r = ei(r, i)), r && r.modifier && r.modifier(e[i], t, s[n], i))
                        }(t, i)
                    }
                }
            }
        }, ni = ti.registerPlugin({
            name: "attr", init: function (t, e, i, n, r) {
                var s, a;
                for (s in e) (a = this.add(t, "setAttribute", (t.getAttribute(s) || 0) + "", e[s], n, r, 0, 0, s)) && (a.op = s), this._props.push(s)
            }
        }, {
            name: "endArray", init: function (t, e) {
                for (var i = e.length; i--;) this.add(t, i, t[i] || 0, e[i])
            }
        }, ii("roundProps", Jt), ii("modifiers"), ii("snap", Qt)) || ti;
        Ne.version = Pe.version = ni.version = "3.8.0", u = 1, I() && ge();
        ve.Power0, ve.Power1, ve.Power2, ve.Power3, ve.Power4, ve.Linear, ve.Quad, ve.Cubic, ve.Quart, ve.Quint, ve.Strong, ve.Elastic, ve.Back, ve.SteppedEase, ve.Bounce, ve.Sine, ve.Expo, ve.Circ;
        var ri, si, ai, oi, hi, li, ci, ui = {}, pi = 180 / Math.PI, di = Math.PI / 180, fi = Math.atan2,
            mi = /([A-Z])/g, gi = /(?:left|right|width|margin|padding|x)/i, vi = /[\s,\(]\S/,
            yi = {autoAlpha: "opacity,visibility", scale: "scaleX,scaleY", alpha: "opacity"}, bi = function (t, e) {
                return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
            }, xi = function (t, e) {
                return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
            }, wi = function (t, e) {
                return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e)
            }, _i = function (t, e) {
                var i = e.s + e.c * t;
                e.set(e.t, e.p, ~~(i + (i < 0 ? -.5 : .5)) + e.u, e)
            }, Ei = function (t, e) {
                return e.set(e.t, e.p, t ? e.e : e.b, e)
            }, Mi = function (t, e) {
                return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e)
            }, Ai = function (t, e, i) {
                return t.style[e] = i
            }, Si = function (t, e, i) {
                return t.style.setProperty(e, i)
            }, Ti = function (t, e, i) {
                return t._gsap[e] = i
            }, Di = function (t, e, i) {
                return t._gsap.scaleX = t._gsap.scaleY = i
            }, Ci = function (t, e, i, n, r) {
                var s = t._gsap;
                s.scaleX = s.scaleY = i, s.renderTransform(r, s)
            }, Pi = function (t, e, i, n, r) {
                var s = t._gsap;
                s[e] = i, s.renderTransform(r, s)
            }, Ii = "transform", Li = Ii + "Origin", Ri = function (t, e) {
                var i = si.createElementNS ? si.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : si.createElement(t);
                return i.style ? i : si.createElement(t)
            }, Fi = function t(e, i, n) {
                var r = getComputedStyle(e);
                return r[i] || r.getPropertyValue(i.replace(mi, "-$1").toLowerCase()) || r.getPropertyValue(i) || !n && t(e, Oi(i) || i, 1) || ""
            }, ki = "O,Moz,ms,Ms,Webkit".split(","), Oi = function (t, e, i) {
                var n = (e || hi).style, r = 5;
                if (t in n && !i) return t;
                for (t = t.charAt(0).toUpperCase() + t.substr(1); r-- && !(ki[r] + t in n);) ;
                return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? ki[r] : "") + t
            }, zi = function () {
                "undefined" != typeof window && window.document && (ri = window, si = ri.document, ai = si.documentElement, hi = Ri("div") || {style: {}}, Ri("div"), Ii = Oi(Ii), Li = Ii + "Origin", hi.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", ci = !!Oi("perspective"), oi = 1)
            }, Bi = function t(e) {
                var i,
                    n = Ri("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                    r = this.parentNode, s = this.nextSibling, a = this.style.cssText;
                if (ai.appendChild(n), n.appendChild(this), this.style.display = "block", e) try {
                    i = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = t
                } catch (t) {
                } else this._gsapBBox && (i = this._gsapBBox());
                return r && (s ? r.insertBefore(this, s) : r.appendChild(this)), ai.removeChild(n), this.style.cssText = a, i
            }, Ni = function (t, e) {
                for (var i = e.length; i--;) if (t.hasAttribute(e[i])) return t.getAttribute(e[i])
            }, ji = function (t) {
                var e;
                try {
                    e = t.getBBox()
                } catch (i) {
                    e = Bi.call(t, !0)
                }
                return e && (e.width || e.height) || t.getBBox === Bi || (e = Bi.call(t, !0)), !e || e.width || e.x || e.y ? e : {
                    x: +Ni(t, ["x", "cx", "x1"]) || 0,
                    y: +Ni(t, ["y", "cy", "y1"]) || 0,
                    width: 0,
                    height: 0
                }
            }, Vi = function (t) {
                return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !ji(t))
            }, Gi = function (t, e) {
                if (e) {
                    var i = t.style;
                    e in ui && e !== Li && (e = Ii), i.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), i.removeProperty(e.replace(mi, "-$1").toLowerCase())) : i.removeAttribute(e)
                }
            }, Ui = function (t, e, i, n, r, s) {
                var a = new $e(t._pt, e, i, 0, 1, s ? Mi : Ei);
                return t._pt = a, a.b = n, a.e = r, t._props.push(i), a
            }, Hi = {deg: 1, rad: 1, turn: 1}, Wi = function t(e, i, n, r) {
                var s, a, o, h, l = parseFloat(n) || 0, c = (n + "").trim().substr((l + "").length) || "px", u = hi.style,
                    p = gi.test(i), d = "svg" === e.tagName.toLowerCase(),
                    f = (d ? "client" : "offset") + (p ? "Width" : "Height"), m = 100, g = "px" === r, v = "%" === r;
                return r === c || !l || Hi[r] || Hi[c] ? l : ("px" !== c && !g && (l = t(e, i, n, "px")), h = e.getCTM && Vi(e), !v && "%" !== c || !ui[i] && !~i.indexOf("adius") ? (u[p ? "width" : "height"] = m + (g ? c : r), a = ~i.indexOf("adius") || "em" === r && e.appendChild && !d ? e : e.parentNode, h && (a = (e.ownerSVGElement || {}).parentNode), a && a !== si && a.appendChild || (a = si.body), (o = a._gsap) && v && o.width && p && o.time === me.time ? ot(l / o.width * m) : ((v || "%" === c) && (u.position = Fi(e, "position")), a === e && (u.position = "static"), a.appendChild(hi), s = hi[f], a.removeChild(hi), u.position = "absolute", p && v && ((o = rt(a)).time = me.time, o.width = a[f]), ot(g ? s * l / m : s && l ? m / s * l : 0))) : (s = h ? e.getBBox()[p ? "width" : "height"] : e[f], ot(v ? l / s * m : l / 100 * s)))
            }, qi = function (t, e, i, n) {
                var r;
                return oi || zi(), e in yi && "transform" !== e && ~(e = yi[e]).indexOf(",") && (e = e.split(",")[0]), ui[e] && "transform" !== e ? (r = rn(t, n), r = "transformOrigin" !== e ? r[e] : r.svg ? r.origin : sn(Fi(t, Li)) + " " + r.zOrigin + "px") : (!(r = t.style[e]) || "auto" === r || n || ~(r + "").indexOf("calc(")) && (r = Ji[e] && Ji[e](t, e, i) || Fi(t, e) || st(t, e) || ("opacity" === e ? 1 : 0)), i && !~(r + "").trim().indexOf(" ") ? Wi(t, e, r, i) + i : r
            }, Xi = function (t, e, i, n) {
                if (!i || "none" === i) {
                    var r = Oi(e, t, 1), s = r && Fi(t, r, 1);
                    s && s !== i ? (e = r, i = s) : "borderColor" === e && (i = Fi(t, "borderTopColor"))
                }
                var a, o, h, l, c, u, p, d, f, g, v, y, b = new $e(this._pt, t.style, e, 0, 1, Xe), x = 0, w = 0;
                if (b.b = i, b.e = n, i += "", "auto" === (n += "") && (t.style[e] = n, n = Fi(t, e) || n, t.style[e] = i), fe(a = [i, n]), n = a[1], h = (i = a[0]).match(z) || [], (n.match(z) || []).length) {
                    for (; o = z.exec(n);) p = o[0], f = n.substring(x, o.index), c ? c = (c + 1) % 5 : "rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5) || (c = 1), p !== (u = h[w++] || "") && (l = parseFloat(u) || 0, v = u.substr((l + "").length), (y = "=" === p.charAt(1) ? +(p.charAt(0) + "1") : 0) && (p = p.substr(2)), d = parseFloat(p), g = p.substr((d + "").length), x = z.lastIndex - g.length, g || (g = g || m.units[e] || v, x === n.length && (n += g, b.e += g)), v !== g && (l = Wi(t, e, u, g) || 0), b._pt = {
                        _next: b._pt,
                        p: f || 1 === w ? f : ",",
                        s: l,
                        c: y ? y * d : d - l,
                        m: c && c < 4 || "zIndex" === e ? Math.round : 0
                    });
                    b.c = x < n.length ? n.substring(x, n.length) : ""
                } else b.r = "display" === e && "none" === n ? Mi : Ei;
                return N.test(n) && (b.e = 0), this._pt = b, b
            }, Yi = {top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%"}, Zi = function (t, e) {
                if (e.tween && e.tween._time === e.tween._dur) {
                    var i, n, r, s = e.t, a = s.style, o = e.u, h = s._gsap;
                    if ("all" === o || !0 === o) a.cssText = "", n = 1; else for (r = (o = o.split(",")).length; --r > -1;) i = o[r], ui[i] && (n = 1, i = "transformOrigin" === i ? Li : Ii), Gi(s, i);
                    n && (Gi(s, Ii), h && (h.svg && s.removeAttribute("transform"), rn(s, 1), h.uncache = 1))
                }
            }, Ji = {
                clearProps: function (t, e, i, n, r) {
                    if ("isFromStart" !== r.data) {
                        var s = t._pt = new $e(t._pt, e, i, 0, 0, Zi);
                        return s.u = n, s.pr = -10, s.tween = r, t._props.push(i), 1
                    }
                }
            }, Qi = [1, 0, 0, 1, 0, 0], Ki = {}, $i = function (t) {
                return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
            }, tn = function (t) {
                var e = Fi(t, Ii);
                return $i(e) ? Qi : e.substr(7).match(O).map(ot)
            }, en = function (t, e) {
                var i, n, r, s, a = t._gsap || rt(t), o = t.style, h = tn(t);
                return a.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (h = [(r = t.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? Qi : h : (h !== Qi || t.offsetParent || t === ai || a.svg || (r = o.display, o.display = "block", (i = t.parentNode) && t.offsetParent || (s = 1, n = t.nextSibling, ai.appendChild(t)), h = tn(t), r ? o.display = r : Gi(t, "display"), s && (n ? i.insertBefore(t, n) : i ? i.appendChild(t) : ai.removeChild(t))), e && h.length > 6 ? [h[0], h[1], h[4], h[5], h[12], h[13]] : h)
            }, nn = function (t, e, i, n, r, s) {
                var a, o, h, l = t._gsap, c = r || en(t, !0), u = l.xOrigin || 0, p = l.yOrigin || 0, d = l.xOffset || 0,
                    f = l.yOffset || 0, m = c[0], g = c[1], v = c[2], y = c[3], b = c[4], x = c[5], w = e.split(" "),
                    _ = parseFloat(w[0]) || 0, E = parseFloat(w[1]) || 0;
                i ? c !== Qi && (o = m * y - g * v) && (h = _ * (-g / o) + E * (m / o) - (m * x - g * b) / o, _ = _ * (y / o) + E * (-v / o) + (v * x - y * b) / o, E = h) : (_ = (a = ji(t)).x + (~w[0].indexOf("%") ? _ / 100 * a.width : _), E = a.y + (~(w[1] || w[0]).indexOf("%") ? E / 100 * a.height : E)), n || !1 !== n && l.smooth ? (b = _ - u, x = E - p, l.xOffset = d + (b * m + x * v) - b, l.yOffset = f + (b * g + x * y) - x) : l.xOffset = l.yOffset = 0, l.xOrigin = _, l.yOrigin = E, l.smooth = !!n, l.origin = e, l.originIsAbsolute = !!i, t.style[Li] = "0px 0px", s && (Ui(s, l, "xOrigin", u, _), Ui(s, l, "yOrigin", p, E), Ui(s, l, "xOffset", d, l.xOffset), Ui(s, l, "yOffset", f, l.yOffset)), t.setAttribute("data-svg-origin", _ + " " + E)
            }, rn = function (t, e) {
                var i = t._gsap || new De(t);
                if ("x" in i && !e && !i.uncache) return i;
                var n, r, s, a, o, h, l, c, u, p, d, f, g, v, y, b, x, w, _, E, M, A, S, T, D, C, P, I, L, R, F, k,
                    O = t.style, z = i.scaleX < 0, B = "px", N = "deg", j = Fi(t, Li) || "0";
                return n = r = s = h = l = c = u = p = d = 0, a = o = 1, i.svg = !(!t.getCTM || !Vi(t)), v = en(t, i.svg), i.svg && (T = (!i.uncache || "0px 0px" === j) && !e && t.getAttribute("data-svg-origin"), nn(t, T || j, !!T || i.originIsAbsolute, !1 !== i.smooth, v)), f = i.xOrigin || 0, g = i.yOrigin || 0, v !== Qi && (w = v[0], _ = v[1], E = v[2], M = v[3], n = A = v[4], r = S = v[5], 6 === v.length ? (a = Math.sqrt(w * w + _ * _), o = Math.sqrt(M * M + E * E), h = w || _ ? fi(_, w) * pi : 0, (u = E || M ? fi(E, M) * pi + h : 0) && (o *= Math.abs(Math.cos(u * di))), i.svg && (n -= f - (f * w + g * E), r -= g - (f * _ + g * M))) : (k = v[6], R = v[7], P = v[8], I = v[9], L = v[10], F = v[11], n = v[12], r = v[13], s = v[14], l = (y = fi(k, L)) * pi, y && (T = A * (b = Math.cos(-y)) + P * (x = Math.sin(-y)), D = S * b + I * x, C = k * b + L * x, P = A * -x + P * b, I = S * -x + I * b, L = k * -x + L * b, F = R * -x + F * b, A = T, S = D, k = C), c = (y = fi(-E, L)) * pi, y && (b = Math.cos(-y), F = M * (x = Math.sin(-y)) + F * b, w = T = w * b - P * x, _ = D = _ * b - I * x, E = C = E * b - L * x), h = (y = fi(_, w)) * pi, y && (T = w * (b = Math.cos(y)) + _ * (x = Math.sin(y)), D = A * b + S * x, _ = _ * b - w * x, S = S * b - A * x, w = T, A = D), l && Math.abs(l) + Math.abs(h) > 359.9 && (l = h = 0, c = 180 - c), a = ot(Math.sqrt(w * w + _ * _ + E * E)), o = ot(Math.sqrt(S * S + k * k)), y = fi(A, S), u = Math.abs(y) > 2e-4 ? y * pi : 0, d = F ? 1 / (F < 0 ? -F : F) : 0), i.svg && (T = t.getAttribute("transform"), i.forceCSS = t.setAttribute("transform", "") || !$i(Fi(t, Ii)), T && t.setAttribute("transform", T))), Math.abs(u) > 90 && Math.abs(u) < 270 && (z ? (a *= -1, u += h <= 0 ? 180 : -180, h += h <= 0 ? 180 : -180) : (o *= -1, u += u <= 0 ? 180 : -180)), i.x = n - ((i.xPercent = n && (i.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-n) ? -50 : 0))) ? t.offsetWidth * i.xPercent / 100 : 0) + B, i.y = r - ((i.yPercent = r && (i.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? t.offsetHeight * i.yPercent / 100 : 0) + B, i.z = s + B, i.scaleX = ot(a), i.scaleY = ot(o), i.rotation = ot(h) + N, i.rotationX = ot(l) + N, i.rotationY = ot(c) + N, i.skewX = u + N, i.skewY = p + N, i.transformPerspective = d + B, (i.zOrigin = parseFloat(j.split(" ")[2]) || 0) && (O[Li] = sn(j)), i.xOffset = i.yOffset = 0, i.force3D = m.force3D, i.renderTransform = i.svg ? pn : ci ? un : on, i.uncache = 0, i
            }, sn = function (t) {
                return (t = t.split(" "))[0] + " " + t[1]
            }, an = function (t, e, i) {
                var n = Ut(e);
                return ot(parseFloat(e) + parseFloat(Wi(t, "x", i + "px", n))) + n
            }, on = function (t, e) {
                e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, un(t, e)
            }, hn = "0deg", ln = "0px", cn = ") ", un = function (t, e) {
                var i = e || this, n = i.xPercent, r = i.yPercent, s = i.x, a = i.y, o = i.z, h = i.rotation,
                    l = i.rotationY, c = i.rotationX, u = i.skewX, p = i.skewY, d = i.scaleX, f = i.scaleY,
                    m = i.transformPerspective, g = i.force3D, v = i.target, y = i.zOrigin, b = "",
                    x = "auto" === g && t && 1 !== t || !0 === g;
                if (y && (c !== hn || l !== hn)) {
                    var w, _ = parseFloat(l) * di, E = Math.sin(_), M = Math.cos(_);
                    _ = parseFloat(c) * di, w = Math.cos(_), s = an(v, s, E * w * -y), a = an(v, a, -Math.sin(_) * -y), o = an(v, o, M * w * -y + y)
                }
                m !== ln && (b += "perspective(" + m + cn), (n || r) && (b += "translate(" + n + "%, " + r + "%) "), (x || s !== ln || a !== ln || o !== ln) && (b += o !== ln || x ? "translate3d(" + s + ", " + a + ", " + o + ") " : "translate(" + s + ", " + a + cn), h !== hn && (b += "rotate(" + h + cn), l !== hn && (b += "rotateY(" + l + cn), c !== hn && (b += "rotateX(" + c + cn), u === hn && p === hn || (b += "skew(" + u + ", " + p + cn), 1 === d && 1 === f || (b += "scale(" + d + ", " + f + cn), v.style[Ii] = b || "translate(0, 0)"
            }, pn = function (t, e) {
                var i, n, r, s, a, o = e || this, h = o.xPercent, l = o.yPercent, c = o.x, u = o.y, p = o.rotation,
                    d = o.skewX, f = o.skewY, m = o.scaleX, g = o.scaleY, v = o.target, y = o.xOrigin, b = o.yOrigin,
                    x = o.xOffset, w = o.yOffset, _ = o.forceCSS, E = parseFloat(c), M = parseFloat(u);
                p = parseFloat(p), d = parseFloat(d), (f = parseFloat(f)) && (d += f = parseFloat(f), p += f), p || d ? (p *= di, d *= di, i = Math.cos(p) * m, n = Math.sin(p) * m, r = Math.sin(p - d) * -g, s = Math.cos(p - d) * g, d && (f *= di, a = Math.tan(d - f), r *= a = Math.sqrt(1 + a * a), s *= a, f && (a = Math.tan(f), i *= a = Math.sqrt(1 + a * a), n *= a)), i = ot(i), n = ot(n), r = ot(r), s = ot(s)) : (i = m, s = g, n = r = 0), (E && !~(c + "").indexOf("px") || M && !~(u + "").indexOf("px")) && (E = Wi(v, "x", c, "px"), M = Wi(v, "y", u, "px")), (y || b || x || w) && (E = ot(E + y - (y * i + b * r) + x), M = ot(M + b - (y * n + b * s) + w)), (h || l) && (a = v.getBBox(), E = ot(E + h / 100 * a.width), M = ot(M + l / 100 * a.height)), a = "matrix(" + i + "," + n + "," + r + "," + s + "," + E + "," + M + ")", v.setAttribute("transform", a), _ && (v.style[Ii] = a)
            }, dn = function (t, e, i, n, r, s) {
                var a, o, h = 360, l = A(r), c = parseFloat(r) * (l && ~r.indexOf("rad") ? pi : 1), u = s ? c * s : c - n,
                    p = n + u + "deg";
                return l && ("short" === (a = r.split("_")[1]) && (u %= h) !== u % 180 && (u += u < 0 ? h : -360), "cw" === a && u < 0 ? u = (u + 36e9) % h - ~~(u / h) * h : "ccw" === a && u > 0 && (u = (u - 36e9) % h - ~~(u / h) * h)), t._pt = o = new $e(t._pt, e, i, n, u, xi), o.e = p, o.u = "deg", t._props.push(i), o
            }, fn = function (t, e) {
                for (var i in e) t[i] = e[i];
                return t
            }, mn = function (t, e, i) {
                var n, r, s, a, o, h, l, c = fn({}, i._gsap), u = i.style;
                for (r in c.svg ? (s = i.getAttribute("transform"), i.setAttribute("transform", ""), u[Ii] = e, n = rn(i, 1), Gi(i, Ii), i.setAttribute("transform", s)) : (s = getComputedStyle(i)[Ii], u[Ii] = e, n = rn(i, 1), u[Ii] = s), ui) (s = c[r]) !== (a = n[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (o = Ut(s) !== (l = Ut(a)) ? Wi(i, r, s, l) : parseFloat(s), h = parseFloat(a), t._pt = new $e(t._pt, n, r, o, h - o, bi), t._pt.u = l || 0, t._props.push(r));
                fn(n, c)
            };
        at("padding,margin,Width,Radius", (function (t, e) {
            var i = "Top", n = "Right", r = "Bottom", s = "Left",
                a = (e < 3 ? [i, n, r, s] : [i + s, i + n, r + n, r + s]).map((function (i) {
                    return e < 2 ? t + i : "border" + i + t
                }));
            Ji[e > 1 ? "border" + t : t] = function (t, e, i, n, r) {
                var s, o;
                if (arguments.length < 4) return s = a.map((function (e) {
                    return qi(t, e, i)
                })), 5 === (o = s.join(" ")).split(s[0]).length ? s[0] : o;
                s = (n + "").split(" "), o = {}, a.forEach((function (t, e) {
                    return o[t] = s[e] = s[e] || s[(e - 1) / 2 | 0]
                })), t.init(e, o, r)
            }
        }));
        var gn, vn, yn, bn = {
            name: "css", register: zi, targetTest: function (t) {
                return t.style && t.nodeType
            }, init: function (t, e, i, n, r) {
                var s, a, o, h, l, c, u, p, d, f, g, v, y, b, x, w, _, E, M, S = this._props, T = t.style,
                    D = i.vars.startAt;
                for (u in oi || zi(), e) if ("autoRound" !== u && (a = e[u], !K[u] || !Fe(u, e, i, n, t, r))) if (l = typeof a, c = Ji[u], "function" === l && (l = typeof (a = a.call(i, n, t, r))), "string" === l && ~a.indexOf("random(") && (a = te(a)), c) c(this, t, u, a, i) && (x = 1); else if ("--" === u.substr(0, 2)) s = (getComputedStyle(t).getPropertyValue(u) + "").trim(), a += "", pe.lastIndex = 0, pe.test(s) || (p = Ut(s), d = Ut(a)), d ? p !== d && (s = Wi(t, u, s, d) + d) : p && (a += p), this.add(T, "setProperty", s, a, n, r, 0, 0, u), S.push(u); else if ("undefined" !== l) {
                    if (D && u in D ? (s = "function" == typeof D[u] ? D[u].call(i, n, t, r) : D[u], u in m.units && !Ut(s) && (s += m.units[u]), A(s) && ~s.indexOf("random(") && (s = te(s)), "=" === (s + "").charAt(1) && (s = qi(t, u))) : s = qi(t, u), h = parseFloat(s), (f = "string" === l && "=" === a.charAt(1) ? +(a.charAt(0) + "1") : 0) && (a = a.substr(2)), o = parseFloat(a), u in yi && ("autoAlpha" === u && (1 === h && "hidden" === qi(t, "visibility") && o && (h = 0), Ui(this, T, "visibility", h ? "inherit" : "hidden", o ? "inherit" : "hidden", !o)), "scale" !== u && "transform" !== u && ~(u = yi[u]).indexOf(",") && (u = u.split(",")[0])), g = u in ui) if (v || ((y = t._gsap).renderTransform && !e.parseTransform || rn(t, e.parseTransform), b = !1 !== e.smoothOrigin && y.smooth, (v = this._pt = new $e(this._pt, T, Ii, 0, 1, y.renderTransform, y, 0, -1)).dep = 1), "scale" === u) this._pt = new $e(this._pt, y, "scaleY", y.scaleY, (f ? f * o : o - y.scaleY) || 0), S.push("scaleY", u), u += "X"; else {
                        if ("transformOrigin" === u) {
                            _ = void 0, E = void 0, M = void 0, _ = (w = a).split(" "), E = _[0], M = _[1] || "50%", "top" !== E && "bottom" !== E && "left" !== M && "right" !== M || (w = E, E = M, M = w), _[0] = Yi[E] || E, _[1] = Yi[M] || M, a = _.join(" "), y.svg ? nn(t, a, 0, b, 0, this) : ((d = parseFloat(a.split(" ")[2]) || 0) !== y.zOrigin && Ui(this, y, "zOrigin", y.zOrigin, d), Ui(this, T, u, sn(s), sn(a)));
                            continue
                        }
                        if ("svgOrigin" === u) {
                            nn(t, a, 1, b, 0, this);
                            continue
                        }
                        if (u in Ki) {
                            dn(this, y, u, h, a, f);
                            continue
                        }
                        if ("smoothOrigin" === u) {
                            Ui(this, y, "smooth", y.smooth, a);
                            continue
                        }
                        if ("force3D" === u) {
                            y[u] = a;
                            continue
                        }
                        if ("transform" === u) {
                            mn(this, a, t);
                            continue
                        }
                    } else u in T || (u = Oi(u) || u);
                    if (g || (o || 0 === o) && (h || 0 === h) && !vi.test(a) && u in T) o || (o = 0), (p = (s + "").substr((h + "").length)) !== (d = Ut(a) || (u in m.units ? m.units[u] : p)) && (h = Wi(t, u, s, d)), this._pt = new $e(this._pt, g ? y : T, u, h, f ? f * o : o - h, g || "px" !== d && "zIndex" !== u || !1 === e.autoRound ? bi : _i), this._pt.u = d || 0, p !== d && "%" !== d && (this._pt.b = s, this._pt.r = wi); else if (u in T) Xi.call(this, t, u, s, a); else {
                        if (!(u in t)) {
                            W(u, a);
                            continue
                        }
                        this.add(t, u, s || t[u], a, n, r)
                    }
                    S.push(u)
                }
                x && Ke(this)
            }, get: qi, aliases: yi, getSetter: function (t, e, i) {
                var n = yi[e];
                return n && n.indexOf(",") < 0 && (e = n), e in ui && e !== Li && (t._gsap.x || qi(t, "x")) ? i && li === i ? "scale" === e ? Di : Ti : (li = i || {}) && ("scale" === e ? Ci : Pi) : t.style && !D(t.style[e]) ? Ai : ~e.indexOf("-") ? Si : He(t, e)
            }, core: {_removeProperty: Gi, _getMatrix: en}
        };
        ni.utils.checkPrefix = Oi, yn = at((gn = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + (vn = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function (t) {
            ui[t] = 1
        })), at(vn, (function (t) {
            m.units[t] = "deg", Ki[t] = 1
        })), yi[yn[13]] = gn + "," + vn, at("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function (t) {
            var e = t.split(":");
            yi[e[1]] = yn[e[0]]
        })), at("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function (t) {
            m.units[t] = "px"
        })), ni.registerPlugin(bn);
        var xn = ni.registerPlugin(bn) || ni;
        xn.core.Tween;

        function wn() {
            if (!(this instanceof wn)) return new wn;
            this.size = 0, this.uid = 0, this.selectors = [], this.selectorObjects = {}, this.indexes = Object.create(this.indexes), this.activeIndexes = []
        }

        var _n = window.document.documentElement,
            En = _n.matches || _n.webkitMatchesSelector || _n.mozMatchesSelector || _n.oMatchesSelector || _n.msMatchesSelector;
        wn.prototype.matchesSelector = function (t, e) {
            return En.call(t, e)
        }, wn.prototype.querySelectorAll = function (t, e) {
            return e.querySelectorAll(t)
        }, wn.prototype.indexes = [];
        var Mn = /^#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
        wn.prototype.indexes.push({
            name: "ID", selector: function (t) {
                var e;
                if (e = t.match(Mn)) return e[0].slice(1)
            }, element: function (t) {
                if (t.id) return [t.id]
            }
        });
        var An = /^\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
        wn.prototype.indexes.push({
            name: "CLASS", selector: function (t) {
                var e;
                if (e = t.match(An)) return e[0].slice(1)
            }, element: function (t) {
                var e = t.className;
                if (e) {
                    if ("string" == typeof e) return e.split(/\s/);
                    if ("object" == typeof e && "baseVal" in e) return e.baseVal.split(/\s/)
                }
            }
        });
        var Sn, Tn = /^((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
        wn.prototype.indexes.push({
            name: "TAG", selector: function (t) {
                var e;
                if (e = t.match(Tn)) return e[0].toUpperCase()
            }, element: function (t) {
                return [t.nodeName.toUpperCase()]
            }
        }), wn.prototype.indexes.default = {
            name: "UNIVERSAL", selector: function () {
                return !0
            }, element: function () {
                return [!0]
            }
        }, Sn = "function" == typeof window.Map ? window.Map : function () {
            function t() {
                this.map = {}
            }

            return t.prototype.get = function (t) {
                return this.map[t + " "]
            }, t.prototype.set = function (t, e) {
                this.map[t + " "] = e
            }, t
        }();
        var Dn = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g;

        function Cn(t, e) {
            var i, n, r, s, a, o, h = (t = t.slice(0).concat(t.default)).length, l = e, c = [];
            do {
                if (Dn.exec(""), (r = Dn.exec(l)) && (l = r[3], r[2] || !l)) for (i = 0; i < h; i++) if (a = (o = t[i]).selector(r[1])) {
                    for (n = c.length, s = !1; n--;) if (c[n].index === o && c[n].key === a) {
                        s = !0;
                        break
                    }
                    s || c.push({index: o, key: a});
                    break
                }
            } while (r);
            return c
        }

        function Pn(t, e) {
            var i, n, r;
            for (i = 0, n = t.length; i < n; i++) if (r = t[i], e.isPrototypeOf(r)) return r
        }

        function In(t, e) {
            return t.id - e.id
        }

        wn.prototype.logDefaultIndexUsed = function () {
        }, wn.prototype.add = function (t, e) {
            var i, n, r, s, a, o, h, l, c = this.activeIndexes, u = this.selectors, p = this.selectorObjects;
            if ("string" == typeof t) {
                for (p[(i = {
                    id: this.uid++,
                    selector: t,
                    data: e
                }).id] = i, h = Cn(this.indexes, t), n = 0; n < h.length; n++) s = (l = h[n]).key, (a = Pn(c, r = l.index)) || ((a = Object.create(r)).map = new Sn, c.push(a)), r === this.indexes.default && this.logDefaultIndexUsed(i), (o = a.map.get(s)) || (o = [], a.map.set(s, o)), o.push(i);
                this.size++, u.push(t)
            }
        }, wn.prototype.remove = function (t, e) {
            if ("string" == typeof t) {
                var i, n, r, s, a, o, h, l, c = this.activeIndexes, u = this.selectors = [], p = this.selectorObjects,
                    d = {}, f = 1 === arguments.length;
                for (i = Cn(this.indexes, t), r = 0; r < i.length; r++) for (n = i[r], s = c.length; s--;) if (o = c[s], n.index.isPrototypeOf(o)) {
                    if (h = o.map.get(n.key)) for (a = h.length; a--;) (l = h[a]).selector !== t || !f && l.data !== e || (h.splice(a, 1), d[l.id] = !0);
                    break
                }
                for (r in d) delete p[r], this.size--;
                for (r in p) u.push(p[r].selector)
            }
        }, wn.prototype.queryAll = function (t) {
            if (!this.selectors.length) return [];
            var e, i, n, r, s, a, o, h, l = {}, c = [], u = this.querySelectorAll(this.selectors.join(", "), t);
            for (e = 0, n = u.length; e < n; e++) for (s = u[e], i = 0, r = (a = this.matches(s)).length; i < r; i++) l[(h = a[i]).id] ? o = l[h.id] : (o = {
                id: h.id,
                selector: h.selector,
                data: h.data,
                elements: []
            }, l[h.id] = o, c.push(o)), o.elements.push(s);
            return c.sort(In)
        }, wn.prototype.matches = function (t) {
            if (!t) return [];
            var e, i, n, r, s, a, o, h, l, c, u, p = this.activeIndexes, d = {}, f = [];
            for (e = 0, r = p.length; e < r; e++) if (h = (o = p[e]).element(t)) for (i = 0, s = h.length; i < s; i++) if (l = o.map.get(h[i])) for (n = 0, a = l.length; n < a; n++) !d[u = (c = l[n]).id] && this.matchesSelector(t, c.selector) && (d[u] = !0, f.push(c));
            return f.sort(In)
        };
        const Ln = {}, Rn = {}, Fn = ["mouseenter", "mouseleave", "pointerenter", "pointerleave"];

        function kn(t) {
            void 0 === Rn[t] && (Rn[t] = [])
        }

        function On(t) {
            return "string" == typeof t ? document.querySelectorAll(t) : t
        }

        function zn(t) {
            let e = function (t, e) {
                const i = [];
                let n = e;
                do {
                    if (1 !== n.nodeType) break;
                    const e = t.matches(n);
                    e.length && i.push({delegatedTarget: n, stack: e})
                } while (n = n.parentElement);
                return i
            }(Ln[t.type], t.target);
            if (e.length) for (let i = 0; i < e.length; i++) for (let n = 0; n < e[i].stack.length; n++) -1 !== Fn.indexOf(t.type) ? (Bn(t, e[i].delegatedTarget), t.target === e[i].delegatedTarget && e[i].stack[n].data(t)) : (Bn(t, e[i].delegatedTarget), e[i].stack[n].data(t))
        }

        function Bn(t, e) {
            Object.defineProperty(t, "currentTarget", {configurable: !0, enumerable: !0, get: () => e})
        }

        function Nn(t) {
            return JSON.parse(JSON.stringify(t))
        }

        var jn = new class {
            bindAll(t, e) {
                void 0 === e && (e = Object.getOwnPropertyNames(Object.getPrototypeOf(t)));
                for (let i = 0; i < e.length; i++) t[e[i]] = t[e[i]].bind(t)
            }

            on(t, e, i, n) {
                const r = t.split(" ");
                for (let t = 0; t < r.length; t++) if ("function" != typeof e || void 0 !== i) if (e.nodeType && 1 === e.nodeType || e === window || e === document) e.addEventListener(r[t], i, n); else {
                    e = On(e);
                    for (let s = 0; s < e.length; s++) e[s].addEventListener(r[t], i, n)
                } else kn(r[t]), Rn[r[t]].push(e)
            }

            delegate(t, e, i) {
                const n = t.split(" ");
                for (let t = 0; t < n.length; t++) {
                    let r = Ln[n[t]];
                    void 0 === r && (r = new wn, Ln[n[t]] = r, -1 !== Fn.indexOf(n[t]) ? document.addEventListener(n[t], zn, !0) : document.addEventListener(n[t], zn)), r.add(e, i)
                }
            }

            off(t, e, i, n) {
                const r = t.split(" ");
                for (let t = 0; t < r.length; t++) {
                    if (void 0 === e) {
                        Rn[r[t]] = [];
                        continue
                    }
                    if ("function" == typeof e) {
                        kn(r[t]);
                        for (let i = 0; i < Rn[r[t]].length; i++) Rn[r[t]][i] === e && Rn[r[t]].splice(i, 1);
                        continue
                    }
                    const s = Ln[r[t]];
                    if (void 0 === s || (s.remove(e, i), 0 !== s.size)) if (void 0 === e.removeEventListener) {
                        e = On(e);
                        for (let s = 0; s < e.length; s++) e[s].removeEventListener(r[t], i, n)
                    } else e.removeEventListener(r[t], i, n); else delete Ln[r[t]], -1 !== Fn.indexOf(r[t]) ? document.removeEventListener(r[t], zn, !0) : document.removeEventListener(r[t], zn)
                }
            }

            emit(t, ...e) {
                !function (t, e) {
                    if (Rn[t]) for (let i = 0; i < Rn[t].length; i++) Rn[t][i](...e)
                }(t, e)
            }

            debugDelegated() {
                return Nn(Ln)
            }

            debugBus() {
                return Nn(Rn)
            }
        };
        const Vn = jn;
        var Gn, Un, Hn, Wn, qn, Xn, Yn, Zn, Jn, Qn, Kn, $n, tr, er, ir, nr, rr, sr, ar, or, hr, lr, cr, ur, pr, dr, fr,
            mr, gr = 1, vr = [], yr = [], br = Date.now, xr = br(), wr = 0, _r = 1, Er = function (t) {
                return t
            }, Mr = function (t) {
                return Kn(t)[0] || (Fr(t) ? console.warn("Element not found:", t) : null)
            }, Ar = function (t) {
                return Math.round(1e5 * t) / 1e5 || 0
            }, Sr = function () {
                return "undefined" != typeof window
            }, Tr = function () {
                return Gn || Sr() && (Gn = window.gsap) && Gn.registerPlugin && Gn
            }, Dr = function (t) {
                return !!~Yn.indexOf(t)
            }, Cr = function (t, e) {
                return ~vr.indexOf(t) && vr[vr.indexOf(t) + 1][e]
            }, Pr = function (t, e) {
                var i = e.s, n = e.sc, r = yr.indexOf(t), s = n === os.sc ? 1 : 2;
                return !~r && (r = yr.push(t) - 1), yr[r + s] || (yr[r + s] = Cr(t, i) || (Dr(t) ? n : function (e) {
                    return arguments.length ? t[i] = e : t[i]
                }))
            }, Ir = function (t) {
                return Cr(t, "getBoundingClientRect") || (Dr(t) ? function () {
                    return Ys.width = Hn.innerWidth, Ys.height = Hn.innerHeight, Ys
                } : function () {
                    return cs(t)
                })
            }, Lr = function (t, e) {
                var i = e.s, n = e.d2, r = e.d, s = e.a;
                return (i = "scroll" + n) && (s = Cr(t, i)) ? s() - Ir(t)()[r] : Dr(t) ? (Xn[i] || qn[i]) - (Hn["inner" + n] || qn["client" + n] || Xn["client" + n]) : t[i] - t["offset" + n]
            }, Rr = function (t, e) {
                for (var i = 0; i < hr.length; i += 3) (!e || ~e.indexOf(hr[i + 1])) && t(hr[i], hr[i + 1], hr[i + 2])
            }, Fr = function (t) {
                return "string" == typeof t
            }, kr = function (t) {
                return "function" == typeof t
            }, Or = function (t) {
                return "number" == typeof t
            }, zr = function (t) {
                return "object" == typeof t
            }, Br = function (t) {
                return kr(t) && t()
            }, Nr = function (t, e) {
                return function () {
                    var i = Br(t), n = Br(e);
                    return function () {
                        Br(i), Br(n)
                    }
                }
            }, jr = function (t, e, i) {
                return t && t.progress(e ? 0 : 1) && i && t.pause()
            }, Vr = function (t, e) {
                var i = e(t);
                i && i.totalTime && (t.callbackAnimation = i)
            }, Gr = Math.abs, Ur = "scrollLeft", Hr = "scrollTop", Wr = "left", qr = "top", Xr = "right", Yr = "bottom",
            Zr = "width", Jr = "height", Qr = "Right", Kr = "Left", $r = "Top", ts = "Bottom", es = "padding",
            is = "margin", ns = "Width", rs = "Height", ss = "px", as = {
                s: Ur, p: Wr, p2: Kr, os: Xr, os2: Qr, d: Zr, d2: ns, a: "x", sc: function (t) {
                    return arguments.length ? Hn.scrollTo(t, os.sc()) : Hn.pageXOffset || Wn.scrollLeft || qn.scrollLeft || Xn.scrollLeft || 0
                }
            }, os = {
                s: Hr, p: qr, p2: $r, os: Yr, os2: ts, d: Jr, d2: rs, a: "y", op: as, sc: function (t) {
                    return arguments.length ? Hn.scrollTo(as.sc(), t) : Hn.pageYOffset || Wn.scrollTop || qn.scrollTop || Xn.scrollTop || 0
                }
            }, hs = function (t) {
                return Hn.getComputedStyle(t)
            }, ls = function (t, e) {
                for (var i in e) i in t || (t[i] = e[i]);
                return t
            }, cs = function (t, e) {
                var i = e && "matrix(1, 0, 0, 1, 0, 0)" !== hs(t)[rr] && Gn.to(t, {
                    x: 0,
                    y: 0,
                    xPercent: 0,
                    yPercent: 0,
                    rotation: 0,
                    rotationX: 0,
                    rotationY: 0,
                    scale: 1,
                    skewX: 0,
                    skewY: 0
                }).progress(1), n = t.getBoundingClientRect();
                return i && i.progress(0).kill(), n
            }, us = function (t, e) {
                var i = e.d2;
                return t["offset" + i] || t["client" + i] || 0
            }, ps = function (t) {
                var e, i = [], n = t.labels, r = t.duration();
                for (e in n) i.push(n[e] / r);
                return i
            }, ds = function (t) {
                var e = Gn.utils.snap(t), i = Array.isArray(t) && t.slice(0).sort((function (t, e) {
                    return t - e
                }));
                return i ? function (t, n) {
                    var r;
                    if (!n) return e(t);
                    if (n > 0) {
                        for (t -= 1e-4, r = 0; r < i.length; r++) if (i[r] >= t) return i[r];
                        return i[r - 1]
                    }
                    for (r = i.length, t += 1e-4; r--;) if (i[r] <= t) return i[r];
                    return i[0]
                } : function (i, n) {
                    var r = e(i);
                    return !n || Math.abs(r - i) < .001 || r - i < 0 == n < 0 ? r : e(n < 0 ? i - t : i + t)
                }
            }, fs = function (t, e, i, n) {
                return i.split(",").forEach((function (i) {
                    return t(e, i, n)
                }))
            }, ms = function (t, e, i) {
                return t.addEventListener(e, i, {passive: !0})
            }, gs = function (t, e, i) {
                return t.removeEventListener(e, i)
            }, vs = {startColor: "green", endColor: "red", indent: 0, fontSize: "16px", fontWeight: "normal"},
            ys = {toggleActions: "play", anticipatePin: 0}, bs = {top: 0, left: 0, center: .5, bottom: 1, right: 1},
            xs = function (t, e) {
                if (Fr(t)) {
                    var i = t.indexOf("="), n = ~i ? +(t.charAt(i - 1) + 1) * parseFloat(t.substr(i + 1)) : 0;
                    ~i && (t.indexOf("%") > i && (n *= e / 100), t = t.substr(0, i - 1)), t = n + (t in bs ? bs[t] * e : ~t.indexOf("%") ? parseFloat(t) * e / 100 : parseFloat(t) || 0)
                }
                return t
            }, ws = function (t, e, i, n, r, s, a, o) {
                var h = r.startColor, l = r.endColor, c = r.fontSize, u = r.indent, p = r.fontWeight,
                    d = Wn.createElement("div"), f = Dr(i) || "fixed" === Cr(i, "pinType"),
                    m = -1 !== t.indexOf("scroller"), g = f ? Xn : i, v = -1 !== t.indexOf("start"), y = v ? h : l,
                    b = "border-color:" + y + ";font-size:" + c + ";color:" + y + ";font-weight:" + p + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
                return b += "position:" + ((m || o) && f ? "fixed;" : "absolute;"), (m || o || !f) && (b += (n === os ? Xr : Yr) + ":" + (s + parseFloat(u)) + "px;"), a && (b += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"), d._isStart = v, d.setAttribute("class", "gsap-marker-" + t + (e ? " marker-" + e : "")), d.style.cssText = b, d.innerText = e || 0 === e ? t + "-" + e : t, g.children[0] ? g.insertBefore(d, g.children[0]) : g.appendChild(d), d._offset = d["offset" + n.op.d2], _s(d, 0, n, v), d
            }, _s = function (t, e, i, n) {
                var r = {display: "block"}, s = i[n ? "os2" : "p2"], a = i[n ? "p2" : "os2"];
                t._isFlipped = n, r[i.a + "Percent"] = n ? -100 : 0, r[i.a] = n ? "1px" : 0, r["border" + s + ns] = 1, r["border" + a + ns] = 0, r[i.p] = e + "px", Gn.set(t, r)
            }, Es = [], Ms = {}, As = function () {
                return br() - wr > 20 && Vs()
            }, Ss = function () {
                var t = br();
                wr !== t ? (Vs(), wr || Rs("scrollStart"), wr = t) : Qn || (Qn = Jn(Vs))
            }, Ts = function () {
                return !ir && !ur && !Wn.fullscreenElement && Zn.restart(!0)
            }, Ds = {}, Cs = [], Ps = [], Is = function (t) {
                var e, i = Gn.ticker.frame, n = [], r = 0;
                if (fr !== i || gr) {
                    for (Os(); r < Ps.length; r += 4) (e = Hn.matchMedia(Ps[r]).matches) !== Ps[r + 3] && (Ps[r + 3] = e, e ? n.push(r) : Os(1, Ps[r]) || kr(Ps[r + 2]) && Ps[r + 2]());
                    for (ks(), r = 0; r < n.length; r++) e = n[r], dr = Ps[e], Ps[e + 2] = Ps[e + 1](t);
                    dr = 0, Un && Bs(0, 1), fr = i, Rs("matchMedia")
                }
            }, Ls = function t() {
                return gs($s, "scrollEnd", t) || Bs(!0)
            }, Rs = function (t) {
                return Ds[t] && Ds[t].map((function (t) {
                    return t()
                })) || Cs
            }, Fs = [], ks = function (t) {
                for (var e = 0; e < Fs.length; e += 5) t && Fs[e + 4] !== t || (Fs[e].style.cssText = Fs[e + 1], Fs[e].getBBox && Fs[e].setAttribute("transform", Fs[e + 2] || ""), Fs[e + 3].uncache = 1)
            }, Os = function (t, e) {
                var i;
                for (sr = 0; sr < Es.length; sr++) i = Es[sr], e && i.media !== e || (t ? i.kill(1) : i.revert());
                e && ks(e), e || Rs("revert")
            }, zs = function () {
                return yr.forEach((function (t) {
                    return "function" == typeof t && (t.rec = 0)
                }))
            }, Bs = function (t, e) {
                if (!wr || t) {
                    mr = !0;
                    var i = Rs("refreshInit");
                    lr && $s.sort(), e || Os(), Es.forEach((function (t) {
                        return t.refresh()
                    })), i.forEach((function (t) {
                        return t && t.render && t.render(-1)
                    })), zs(), Zn.pause(), mr = !1, Rs("refresh")
                } else ms($s, "scrollEnd", Ls)
            }, Ns = 0, js = 1, Vs = function () {
                if (!mr) {
                    var t = Es.length, e = br(), i = e - xr >= 50, n = t && Es[0].scroll();
                    if (js = Ns > n ? -1 : 1, Ns = n, i && (wr && !nr && e - wr > 200 && (wr = 0, Rs("scrollEnd")), tr = xr, xr = e), js < 0) {
                        for (sr = t; sr-- > 0;) Es[sr] && Es[sr].update(0, i);
                        js = 1
                    } else for (sr = 0; sr < t; sr++) Es[sr] && Es[sr].update(0, i);
                    Qn = 0
                }
            },
            Gs = [Wr, qr, Yr, Xr, "marginBottom", "marginRight", "marginTop", "marginLeft", "display", "flexShrink", "float", "zIndex", "grid-column-start", "grid-column-end", "grid-row-start", "grid-row-end", "grid-area", "justify-self", "align-self", "place-self"],
            Us = Gs.concat([Zr, Jr, "boxSizing", "maxWidth", "maxHeight", "position", is, es, "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"]),
            Hs = function (t, e, i, n) {
                if (t.parentNode !== e) {
                    for (var r, s = Gs.length, a = e.style, o = t.style; s--;) a[r = Gs[s]] = i[r];
                    a.position = "absolute" === i.position ? "absolute" : "relative", "inline" === i.display && (a.display = "inline-block"), o.bottom = o.right = "auto", a.overflow = "visible", a.boxSizing = "border-box", a.width = us(t, as) + ss, a.height = us(t, os) + ss, a.padding = o.margin = o.top = o.left = "0", qs(n), o.width = o.maxWidth = i.width, o.height = o.maxHeight = i.height, o.padding = i.padding, t.parentNode.insertBefore(e, t), e.appendChild(t)
                }
            }, Ws = /([A-Z])/g, qs = function (t) {
                if (t) {
                    var e, i, n = t.t.style, r = t.length, s = 0;
                    for ((t.t._gsap || Gn.core.getCache(t.t)).uncache = 1; s < r; s += 2) i = t[s + 1], e = t[s], i ? n[e] = i : n[e] && n.removeProperty(e.replace(Ws, "-$1").toLowerCase())
                }
            }, Xs = function (t) {
                for (var e = Us.length, i = t.style, n = [], r = 0; r < e; r++) n.push(Us[r], i[Us[r]]);
                return n.t = t, n
            }, Ys = {left: 0, top: 0}, Zs = function (t, e, i, n, r, s, a, o, h, l, c, u, p) {
                kr(t) && (t = t(o)), Fr(t) && "max" === t.substr(0, 3) && (t = u + ("=" === t.charAt(4) ? xs("0" + t.substr(3), i) : 0));
                var d, f, m, g = p ? p.time() : 0;
                if (p && p.seek(0), Or(t)) a && _s(a, i, n, !0); else {
                    kr(e) && (e = e(o));
                    var v, y, b, x, w = t.split(" ");
                    m = Mr(e) || Xn, (v = cs(m) || {}) && (v.left || v.top) || "none" !== hs(m).display || (x = m.style.display, m.style.display = "block", v = cs(m), x ? m.style.display = x : m.style.removeProperty("display")), y = xs(w[0], v[n.d]), b = xs(w[1] || "0", i), t = v[n.p] - h[n.p] - l + y + r - b, a && _s(a, b, n, i - b < 20 || a._isStart && b > 20), i -= i - b
                }
                if (s) {
                    var _ = t + i, E = s._isStart;
                    d = "scroll" + n.d2, _s(s, _, n, E && _ > 20 || !E && (c ? Math.max(Xn[d], qn[d]) : s.parentNode[d]) <= _ + 1), c && (h = cs(a), c && (s.style[n.op.p] = h[n.op.p] - n.op.m - s._offset + ss))
                }
                return p && m && (d = cs(m), p.seek(u), f = cs(m), p._caScrollDist = d[n.p] - f[n.p], t = t / p._caScrollDist * u), p && p.seek(g), p ? t : Math.round(t)
            }, Js = /(?:webkit|moz|length|cssText|inset)/i, Qs = function (t, e, i, n) {
                if (t.parentNode !== e) {
                    var r, s, a = t.style;
                    if (e === Xn) {
                        for (r in t._stOrig = a.cssText, s = hs(t)) +r || Js.test(r) || !s[r] || "string" != typeof a[r] || "0" === r || (a[r] = s[r]);
                        a.top = i, a.left = n
                    } else a.cssText = t._stOrig;
                    Gn.core.getCache(t).uncache = 1, e.appendChild(t)
                }
            }, Ks = function (t, e) {
                var i, n, r = Pr(t, e), s = "_scroll" + e.p2, a = function e(a, o, h, l, c) {
                    var u = e.tween, p = o.onComplete, d = {};
                    return u && u.kill(), i = Math.round(h), o[s] = a, o.modifiers = d, d[s] = function (t) {
                        return (t = Ar(r())) !== i && t !== n && Math.abs(t - i) > 2 ? (u.kill(), e.tween = 0) : t = h + l * u.ratio + c * u.ratio * u.ratio, n = i, i = Ar(t)
                    }, o.onComplete = function () {
                        e.tween = 0, p && p.call(u)
                    }, u = e.tween = Gn.to(t, o)
                };
                return t[s] = r, t.addEventListener("wheel", (function () {
                    return a.tween && a.tween.kill() && (a.tween = 0)
                }), {passive: !0}), a
            };
        as.op = os;
        var $s = function () {
            function t(e, i) {
                Un || t.register(Gn) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), this.init(e, i)
            }

            return t.prototype.init = function (e, i) {
                if (this.progress = this.start = 0, this.vars && this.kill(1), _r) {
                    var n, r, s, a, o, h, l, c, u, p, d, f, m, g, v, y, b, x, w, _, E, M, A, S, T, D, C, P, I, L, R, F,
                        k, O, z, B, N, j, V, G, U = e = ls(Fr(e) || Or(e) || e.nodeType ? {trigger: e} : e, ys),
                        H = U.onUpdate, W = U.toggleClass, q = U.id, X = U.onToggle, Y = U.onRefresh, Z = U.scrub,
                        J = U.trigger, Q = U.pin, K = U.pinSpacing, $ = U.invalidateOnRefresh, tt = U.anticipatePin,
                        et = U.onScrubComplete, it = U.onSnapComplete, nt = U.once, rt = U.snap, st = U.pinReparent,
                        at = U.pinSpacer, ot = U.containerAnimation, ht = U.fastScrollEnd, lt = U.preventOverlaps,
                        ct = e.horizontal || e.containerAnimation && !1 !== e.horizontal ? as : os, ut = !Z && 0 !== Z,
                        pt = Mr(e.scroller || Hn), dt = Gn.core.getCache(pt), ft = Dr(pt),
                        mt = "fixed" === ("pinType" in e ? e.pinType : Cr(pt, "pinType") || ft && "fixed"),
                        gt = [e.onEnter, e.onLeave, e.onEnterBack, e.onLeaveBack],
                        vt = ut && e.toggleActions.split(" "), yt = "markers" in e ? e.markers : ys.markers,
                        bt = ft ? 0 : parseFloat(hs(pt)["border" + ct.p2 + ns]) || 0, xt = this,
                        wt = e.onRefreshInit && function () {
                            return e.onRefreshInit(xt)
                        }, _t = function (t, e, i) {
                            var n = i.d, r = i.d2, s = i.a;
                            return (s = Cr(t, "getBoundingClientRect")) ? function () {
                                return s()[n]
                            } : function () {
                                return (e ? Hn["inner" + r] : t["client" + r]) || 0
                            }
                        }(pt, ft, ct), Et = function (t, e) {
                            return !e || ~vr.indexOf(t) ? Ir(t) : function () {
                                return Ys
                            }
                        }(pt, ft), Mt = 0, At = Pr(pt, ct);
                    if (xt.media = dr, tt *= 45, xt.scroller = pt, xt.scroll = ot ? ot.time.bind(ot) : At, a = At(), xt.vars = e, i = i || e.animation, "refreshPriority" in e && (lr = 1), dt.tweenScroll = dt.tweenScroll || {
                        top: Ks(pt, os),
                        left: Ks(pt, as)
                    }, xt.tweenTo = n = dt.tweenScroll[ct.p], i && (i.vars.lazy = !1, i._initted || !1 !== i.vars.immediateRender && !1 !== e.immediateRender && i.render(0, !0, !0), xt.animation = i.pause(), i.scrollTrigger = xt, (R = Or(Z) && Z) && (L = Gn.to(i, {
                        ease: "power3",
                        duration: R,
                        onComplete: function () {
                            return et && et(xt)
                        }
                    })), P = 0, q || (q = i.vars.id)), Es.push(xt), rt && (zr(rt) && !rt.push || (rt = {snapTo: rt}), "scrollBehavior" in Xn.style && Gn.set(ft ? [Xn, qn] : pt, {scrollBehavior: "auto"}), s = kr(rt.snapTo) ? rt.snapTo : "labels" === rt.snapTo ? function (t) {
                        return function (e) {
                            return Gn.utils.snap(ps(t), e)
                        }
                    }(i) : "labelsDirectional" === rt.snapTo ? (j = i, function (t, e) {
                        return ds(ps(j))(t, e.direction)
                    }) : !1 !== rt.directional ? function (t, e) {
                        return ds(rt.snapTo)(t, e.direction)
                    } : Gn.utils.snap(rt.snapTo), F = rt.duration || {
                        min: .1,
                        max: 2
                    }, F = zr(F) ? $n(F.min, F.max) : $n(F, F), k = Gn.delayedCall(rt.delay || R / 2 || .1, (function () {
                        if (Math.abs(xt.getVelocity()) < 10 && !nr && Mt !== At()) {
                            var t = i && !ut ? i.totalProgress() : xt.progress, e = (t - I) / (br() - tr) * 1e3 || 0,
                                r = Gn.utils.clamp(-xt.progress, 1 - xt.progress, Gr(e / 2) * e / .185),
                                a = xt.progress + (!1 === rt.inertia ? 0 : r), o = $n(0, 1, s(a, xt)), c = At(),
                                u = Math.round(h + o * m), p = rt, d = p.onStart, f = p.onInterrupt, g = p.onComplete,
                                v = n.tween;
                            if (c <= l && c >= h && u !== c) {
                                if (v && !v._initted && v.data <= Gr(u - c)) return;
                                !1 === rt.inertia && (r = o - xt.progress), n(u, {
                                    duration: F(Gr(.185 * Math.max(Gr(a - t), Gr(o - t)) / e / .05 || 0)),
                                    ease: rt.ease || "power3",
                                    data: Gr(u - c),
                                    onInterrupt: function () {
                                        return k.restart(!0) && f && f(xt)
                                    },
                                    onComplete: function () {
                                        Mt = At(), P = I = i && !ut ? i.totalProgress() : xt.progress, it && it(xt), g && g(xt)
                                    }
                                }, c, r * m, u - c - r * m), d && d(xt, n.tween)
                            }
                        } else xt.isActive && k.restart(!0)
                    })).pause()), q && (Ms[q] = xt), J = xt.trigger = Mr(J || Q), Q = !0 === Q ? J : Mr(Q), Fr(W) && (W = {
                        targets: J,
                        className: W
                    }), Q && (!1 === K || K === is || (K = !(!K && "flex" === hs(Q.parentNode).display) && es), xt.pin = Q, !1 !== e.force3D && Gn.set(Q, {force3D: !0}), (r = Gn.core.getCache(Q)).spacer ? g = r.pinState : (at && ((at = Mr(at)) && !at.nodeType && (at = at.current || at.nativeElement), r.spacerIsNative = !!at, at && (r.spacerState = Xs(at))), r.spacer = b = at || Wn.createElement("div"), b.classList.add("pin-spacer"), q && b.classList.add("pin-spacer-" + q), r.pinState = g = Xs(Q)), xt.spacer = b = r.spacer, C = hs(Q), A = C[K + ct.os2], w = Gn.getProperty(Q), _ = Gn.quickSetter(Q, ct.a, ss), Hs(Q, b, C), y = Xs(Q)), yt && (f = zr(yt) ? ls(yt, vs) : vs, p = ws("scroller-start", q, pt, ct, f, 0), d = ws("scroller-end", q, pt, ct, f, 0, p), x = p["offset" + ct.op.d2], c = ws("start", q, pt, ct, f, x, 0, ot), u = ws("end", q, pt, ct, f, x, 0, ot), ot && (N = Gn.quickSetter([c, u], ct.a, ss)), mt || vr.length && !0 === Cr(pt, "fixedMarkers") || (G = hs(V = ft ? Xn : pt).position, V.style.position = "absolute" === G || "fixed" === G ? G : "relative", Gn.set([p, d], {force3D: !0}), T = Gn.quickSetter(p, ct.a, ss), D = Gn.quickSetter(d, ct.a, ss))), ot) {
                        var St = ot.vars.onUpdate, Tt = ot.vars.onUpdateParams;
                        ot.eventCallback("onUpdate", (function () {
                            xt.update(0, 0, 1), St && St.apply(Tt || [])
                        }))
                    }
                    xt.previous = function () {
                        return Es[Es.indexOf(xt) - 1]
                    }, xt.next = function () {
                        return Es[Es.indexOf(xt) + 1]
                    }, xt.revert = function (t) {
                        var e = !1 !== t || !xt.enabled, n = ir;
                        e !== xt.isReverted && (e && (xt.scroll.rec || (xt.scroll.rec = At()), z = Math.max(At(), xt.scroll.rec || 0), O = xt.progress, B = i && i.progress()), c && [c, u, p, d].forEach((function (t) {
                            return t.style.display = e ? "none" : "block"
                        })), e && (ir = 1), xt.update(e), ir = n, Q && (e ? function (t, e, i) {
                            qs(i);
                            var n = t._gsap;
                            if (n.spacerIsNative) qs(n.spacerState); else if (t.parentNode === e) {
                                var r = e.parentNode;
                                r && (r.insertBefore(t, e), r.removeChild(e))
                            }
                        }(Q, b, g) : (!st || !xt.isActive) && Hs(Q, b, hs(Q), S)), xt.isReverted = e)
                    }, xt.refresh = function (n, r) {
                        if (!ir && xt.enabled || r) if (Q && n && wr) ms(t, "scrollEnd", Ls); else {
                            ir = 1, L && L.pause(), $ && i && i.progress(0).invalidate(), xt.isReverted || xt.revert();
                            for (var s, f, x, _, A, T, D, C, P, I, R = _t(), F = Et(), k = ot ? ot.duration() : Lr(pt, ct), N = 0, j = 0, V = e.end, G = e.endTrigger || J, U = e.start || (0 !== e.start && J ? Q ? "0 0" : "0 100%" : 0), H = e.pinnedContainer && Mr(e.pinnedContainer), W = J && Math.max(0, Es.indexOf(xt)) || 0, q = W; q--;) (T = Es[q]).end || T.refresh(0, 1) || (ir = 1), !(D = T.pin) || D !== J && D !== Q || T.isReverted || (I || (I = []), I.unshift(T), T.revert());
                            for (kr(U) && (U = U(xt)), h = Zs(U, J, R, ct, At(), c, p, xt, F, bt, mt, k, ot) || (Q ? -.001 : 0), kr(V) && (V = V(xt)), Fr(V) && !V.indexOf("+=") && (~V.indexOf(" ") ? V = (Fr(U) ? U.split(" ")[0] : "") + V : (N = xs(V.substr(2), R), V = Fr(U) ? U : h + N, G = J)), l = Math.max(h, Zs(V || (G ? "100% 0" : k), G, R, ct, At() + N, u, d, xt, F, bt, mt, k, ot)) || -.001, m = l - h || (h -= .01) && .001, N = 0, q = W; q--;) (D = (T = Es[q]).pin) && T.start - T._pinPush < h && !ot && (s = T.end - T.start, (D === J || D === H) && !Or(U) && (N += s), D === Q && (j += s));
                            if (h += N, l += N, xt._pinPush = j, c && N && ((s = {})[ct.a] = "+=" + N, H && (s[ct.p] = "-=" + At()), Gn.set([c, u], s)), Q) s = hs(Q), _ = ct === os, x = At(), E = parseFloat(w(ct.a)) + j, !k && l > 1 && ((ft ? Xn : pt).style["overflow-" + ct.a] = "scroll"), Hs(Q, b, s), y = Xs(Q), f = cs(Q, !0), C = mt && Pr(pt, _ ? as : os)(), K && ((S = [K + ct.os2, m + j + ss]).t = b, (q = K === es ? us(Q, ct) + m + j : 0) && S.push(ct.d, q + ss), qs(S), mt && At(z)), mt && ((A = {
                                top: f.top + (_ ? x - h : C) + ss,
                                left: f.left + (_ ? C : x - h) + ss,
                                boxSizing: "border-box",
                                position: "fixed"
                            }).width = A.maxWidth = Math.ceil(f.width) + ss, A.height = A.maxHeight = Math.ceil(f.height) + ss, A.margin = A.marginTop = A.marginRight = A.marginBottom = A.marginLeft = "0", A.padding = s.padding, A.paddingTop = s.paddingTop, A.paddingRight = s.paddingRight, A.paddingBottom = s.paddingBottom, A.paddingLeft = s.paddingLeft, v = function (t, e, i) {
                                for (var n, r = [], s = t.length, a = i ? 8 : 0; a < s; a += 2) n = t[a], r.push(n, n in e ? e[n] : t[a + 1]);
                                return r.t = t.t, r
                            }(g, A, st)), i ? (P = i._initted, cr(1), i.render(i.duration(), !0, !0), M = w(ct.a) - E + m + j, m !== M && v.splice(v.length - 2, 2), i.render(0, !0, !0), P || i.invalidate(), cr(0)) : M = m; else if (J && At() && !ot) for (f = J.parentNode; f && f !== Xn;) f._pinOffset && (h -= f._pinOffset, l -= f._pinOffset), f = f.parentNode;
                            I && I.forEach((function (t) {
                                return t.revert(!1)
                            })), xt.start = h, xt.end = l, a = o = At(), ot || (a < z && At(z), xt.scroll.rec = 0), xt.revert(!1), ir = 0, i && ut && i._initted && i.progress() !== B && i.progress(B, !0).render(i.time(), !0, !0), O !== xt.progress && (i && !ut && i.totalProgress(O, !0), xt.progress = O, xt.update(0, 0, 1)), Q && K && (b._pinOffset = Math.round(xt.progress * M)), Y && Y(xt)
                        }
                    }, xt.getVelocity = function () {
                        return (At() - o) / (br() - tr) * 1e3 || 0
                    }, xt.endAnimation = function () {
                        jr(xt.callbackAnimation), i && (L ? L.progress(1) : i.paused() ? ut || jr(i, xt.direction < 0, 1) : jr(i, i.reversed()))
                    }, xt.getTrailing = function (t) {
                        var e = Es.indexOf(xt), i = xt.direction > 0 ? Es.slice(0, e).reverse() : Es.slice(e + 1);
                        return Fr(t) ? i.filter((function (e) {
                            return e.vars.preventOverlaps === t
                        })) : i
                    }, xt.update = function (t, e, r) {
                        if (!ot || r || t) {
                            var s, c, u, d, f, g, x, w = xt.scroll(), S = t ? 0 : (w - h) / m,
                                C = S < 0 ? 0 : S > 1 ? 1 : S || 0, R = xt.progress;
                            if (e && (o = a, a = ot ? At() : w, rt && (I = P, P = i && !ut ? i.totalProgress() : C)), tt && !C && Q && !ir && !gr && wr && h < w + (w - o) / (br() - tr) * tt && (C = 1e-4), C !== R && xt.enabled) {
                                if (d = (f = (s = xt.isActive = !!C && C < 1) !== (!!R && R < 1)) || !!C != !!R, xt.direction = C > R ? 1 : -1, xt.progress = C, d && !ir && (c = C && !R ? 0 : 1 === C ? 1 : 1 === R ? 2 : 3, ut && (u = !f && "none" !== vt[c + 1] && vt[c + 1] || vt[c], x = i && ("complete" === u || "reset" === u || u in i))), lt && f && (x || Z || !i) && (kr(lt) ? lt(xt) : xt.getTrailing(lt).forEach((function (t) {
                                    return t.endAnimation()
                                }))), ut || (!L || ir || gr ? i && i.totalProgress(C, !!ir) : (L.vars.totalProgress = C, L.invalidate().restart())), Q) if (t && K && (b.style[K + ct.os2] = A), mt) {
                                    if (d) {
                                        if (g = !t && C > R && l + 1 > w && w + 1 >= Lr(pt, ct), st) if (t || !s && !g) Qs(Q, b); else {
                                            var F = cs(Q, !0), O = w - h;
                                            Qs(Q, Xn, F.top + (ct === os ? O : 0) + ss, F.left + (ct === os ? 0 : O) + ss)
                                        }
                                        qs(s || g ? v : y), M !== m && C < 1 && s || _(E + (1 !== C || g ? 0 : M))
                                    }
                                } else _(E + M * C);
                                rt && !n.tween && !ir && !gr && k.restart(!0), W && (f || nt && C && (C < 1 || !pr)) && Kn(W.targets).forEach((function (t) {
                                    return t.classList[s || nt ? "add" : "remove"](W.className)
                                })), H && !ut && !t && H(xt), d && !ir ? (ut && (x && ("complete" === u ? i.pause().totalProgress(1) : "reset" === u ? i.restart(!0).pause() : "restart" === u ? i.restart(!0) : i[u]()), H && H(xt)), !f && pr || (X && f && Vr(xt, X), gt[c] && Vr(xt, gt[c]), nt && (1 === C ? xt.kill(!1, 1) : gt[c] = 0), f || gt[c = 1 === C ? 1 : 3] && Vr(xt, gt[c])), ht && !s && Math.abs(xt.getVelocity()) > (Or(ht) ? ht : 2500) && (jr(xt.callbackAnimation), L ? L.progress(1) : jr(i, !C, 1))) : ut && H && !ir && H(xt)
                            }
                            if (D) {
                                var z = ot ? w / ot.duration() * (ot._caScrollDist || 0) : w;
                                T(z + (p._isFlipped ? 1 : 0)), D(z)
                            }
                            N && N(-w / ot.duration() * (ot._caScrollDist || 0))
                        }
                    }, xt.enable = function (e, i) {
                        xt.enabled || (xt.enabled = !0, ms(pt, "resize", Ts), ms(pt, "scroll", Ss), wt && ms(t, "refreshInit", wt), !1 !== e && (xt.progress = O = 0, a = o = Mt = At()), !1 !== i && xt.refresh())
                    }, xt.getTween = function (t) {
                        return t && n ? n.tween : L
                    }, xt.disable = function (e, i) {
                        if (xt.enabled && (!1 !== e && xt.revert(), xt.enabled = xt.isActive = !1, i || L && L.pause(), z = 0, r && (r.uncache = 1), wt && gs(t, "refreshInit", wt), k && (k.pause(), n.tween && n.tween.kill() && (n.tween = 0)), !ft)) {
                            for (var s = Es.length; s--;) if (Es[s].scroller === pt && Es[s] !== xt) return;
                            gs(pt, "resize", Ts), gs(pt, "scroll", Ss)
                        }
                    }, xt.kill = function (t, e) {
                        xt.disable(t, e), L && L.kill(), q && delete Ms[q];
                        var n = Es.indexOf(xt);
                        Es.splice(n, 1), n === sr && js > 0 && sr--, n = 0, Es.forEach((function (t) {
                            return t.scroller === xt.scroller && (n = 1)
                        })), n || (xt.scroll.rec = 0), i && (i.scrollTrigger = null, t && i.render(-1), e || i.kill()), c && [c, u, p, d].forEach((function (t) {
                            return t.parentNode && t.parentNode.removeChild(t)
                        })), Q && (r && (r.uncache = 1), n = 0, Es.forEach((function (t) {
                            return t.pin === Q && n++
                        })), n || (r.spacer = 0))
                    }, xt.enable(!1, !1), i && i.add && !m ? Gn.delayedCall(.01, (function () {
                        return h || l || xt.refresh()
                    })) && (m = .01) && (h = l = 0) : xt.refresh()
                } else this.update = this.refresh = this.kill = Er
            }, t.register = function (e) {
                if (!Un && (Gn = e || Tr(), Sr() && window.document && (Hn = window, Wn = document, qn = Wn.documentElement, Xn = Wn.body), Gn && (Kn = Gn.utils.toArray, $n = Gn.utils.clamp, cr = Gn.core.suppressOverwrites || Er, Gn.core.globals("ScrollTrigger", t), Xn))) {
                    Jn = Hn.requestAnimationFrame || function (t) {
                        return setTimeout(t, 16)
                    }, ms(Hn, "wheel", Ss), Yn = [Hn, Wn, qn, Xn], ms(Wn, "scroll", Ss);
                    var i, n = Xn.style, r = n.borderTopStyle;
                    n.borderTopStyle = "solid", i = cs(Xn), os.m = Math.round(i.top + os.sc()) || 0, as.m = Math.round(i.left + as.sc()) || 0, r ? n.borderTopStyle = r : n.removeProperty("border-top-style"), er = setInterval(As, 200), Gn.delayedCall(.5, (function () {
                        return gr = 0
                    })), ms(Wn, "touchcancel", Er), ms(Xn, "touchstart", Er), fs(ms, Wn, "pointerdown,touchstart,mousedown", (function () {
                        return nr = 1
                    })), fs(ms, Wn, "pointerup,touchend,mouseup", (function () {
                        return nr = 0
                    })), rr = Gn.utils.checkPrefix("transform"), Us.push(rr), Un = br(), Zn = Gn.delayedCall(.2, Bs).pause(), hr = [Wn, "visibilitychange", function () {
                        var t = Hn.innerWidth, e = Hn.innerHeight;
                        Wn.hidden ? (ar = t, or = e) : ar === t && or === e || Ts()
                    }, Wn, "DOMContentLoaded", Bs, Hn, "load", function () {
                        return wr || Bs()
                    }, Hn, "resize", Ts], Rr(ms)
                }
                return Un
            }, t.defaults = function (t) {
                for (var e in t) ys[e] = t[e]
            }, t.kill = function () {
                _r = 0, Es.slice(0).forEach((function (t) {
                    return t.kill(1)
                }))
            }, t.config = function (t) {
                "limitCallbacks" in t && (pr = !!t.limitCallbacks);
                var e = t.syncInterval;
                e && clearInterval(er) || (er = e) && setInterval(As, e), "autoRefreshEvents" in t && (Rr(gs) || Rr(ms, t.autoRefreshEvents || "none"), ur = -1 === (t.autoRefreshEvents + "").indexOf("resize"))
            }, t.scrollerProxy = function (t, e) {
                var i = Mr(t), n = yr.indexOf(i), r = Dr(i);
                ~n && yr.splice(n, r ? 6 : 2), r ? vr.unshift(Hn, e, Xn, e, qn, e) : vr.unshift(i, e)
            }, t.matchMedia = function (t) {
                var e, i, n, r, s;
                for (i in t) n = Ps.indexOf(i), r = t[i], dr = i, "all" === i ? r() : (e = Hn.matchMedia(i)) && (e.matches && (s = r()), ~n ? (Ps[n + 1] = Nr(Ps[n + 1], r), Ps[n + 2] = Nr(Ps[n + 2], s)) : (n = Ps.length, Ps.push(i, r, s), e.addListener ? e.addListener(Is) : e.addEventListener("change", Is)), Ps[n + 3] = e.matches), dr = 0;
                return Ps
            }, t.clearMatchMedia = function (t) {
                t || (Ps.length = 0), (t = Ps.indexOf(t)) >= 0 && Ps.splice(t, 4)
            }, t.isInViewport = function (t, e, i) {
                var n = (Fr(t) ? Mr(t) : t).getBoundingClientRect(), r = n[i ? Zr : Jr] * e || 0;
                return i ? n.right - r > 0 && n.left + r < Hn.innerWidth : n.bottom - r > 0 && n.top + r < Hn.innerHeight
            }, t.positionInViewport = function (t, e, i) {
                Fr(t) && (t = Mr(t));
                var n = t.getBoundingClientRect(), r = n[i ? Zr : Jr],
                    s = null == e ? r / 2 : e in bs ? bs[e] * r : ~e.indexOf("%") ? parseFloat(e) * r / 100 : parseFloat(e) || 0;
                return i ? (n.left + s) / Hn.innerWidth : (n.top + s) / Hn.innerHeight
            }, t
        }();
        $s.version = "3.8.0", $s.saveStyles = function (t) {
            return t ? Kn(t).forEach((function (t) {
                if (t && t.style) {
                    var e = Fs.indexOf(t);
                    e >= 0 && Fs.splice(e, 5), Fs.push(t, t.style.cssText, t.getBBox && t.getAttribute("transform"), Gn.core.getCache(t), dr)
                }
            })) : Fs
        }, $s.revert = function (t, e) {
            return Os(!t, e)
        }, $s.create = function (t, e) {
            return new $s(t, e)
        }, $s.refresh = function (t) {
            return t ? Ts() : (Un || $s.register()) && Bs(!0)
        }, $s.update = Vs, $s.clearScrollMemory = zs, $s.maxScroll = function (t, e) {
            return Lr(t, e ? as : os)
        }, $s.getScrollFunc = function (t, e) {
            return Pr(Mr(t), e ? as : os)
        }, $s.getById = function (t) {
            return Ms[t]
        }, $s.getAll = function () {
            return Es.slice(0)
        }, $s.isScrolling = function () {
            return !!wr
        }, $s.snapDirectional = ds, $s.addEventListener = function (t, e) {
            var i = Ds[t] || (Ds[t] = []);
            ~i.indexOf(e) || i.push(e)
        }, $s.removeEventListener = function (t, e) {
            var i = Ds[t], n = i && i.indexOf(e);
            n >= 0 && i.splice(n, 1)
        }, $s.batch = function (t, e) {
            var i, n = [], r = {}, s = e.interval || .016, a = e.batchMax || 1e9, o = function (t, e) {
                var i = [], n = [], r = Gn.delayedCall(s, (function () {
                    e(i, n), i = [], n = []
                })).pause();
                return function (t) {
                    i.length || r.restart(!0), i.push(t.trigger), n.push(t), a <= i.length && r.progress(1)
                }
            };
            for (i in e) r[i] = "on" === i.substr(0, 2) && kr(e[i]) && "onRefreshInit" !== i ? o(0, e[i]) : e[i];
            return kr(a) && (a = a(), ms($s, "refresh", (function () {
                return a = e.batchMax()
            }))), Kn(t).forEach((function (t) {
                var e = {};
                for (i in r) e[i] = r[i];
                e.trigger = t, n.push($s.create(e))
            })), n
        }, $s.sort = function (t) {
            return Es.sort(t || function (t, e) {
                return -1e6 * (t.vars.refreshPriority || 0) + t.start - (e.start + -1e6 * (e.vars.refreshPriority || 0))
            })
        }, Tr() && Gn.registerPlugin($s);
        var ta, ea, ia, na, ra, sa, aa, oa = function () {
            return "undefined" != typeof window
        }, ha = function () {
            return ta || oa() && (ta = window.gsap) && ta.registerPlugin && ta
        }, la = function (t) {
            return "string" == typeof t
        }, ca = function (t) {
            return "function" == typeof t
        }, ua = function (t, e) {
            var i = "x" === e ? "Width" : "Height", n = "scroll" + i, r = "client" + i;
            return t === ia || t === na || t === ra ? Math.max(na[n], ra[n]) - (ia["inner" + i] || na[r] || ra[r]) : t[n] - t["offset" + i]
        }, pa = function (t, e) {
            var i = "scroll" + ("x" === e ? "Left" : "Top");
            return t === ia && (null != t.pageXOffset ? i = "page" + e.toUpperCase() + "Offset" : t = null != na[i] ? na : ra), function () {
                return t[i]
            }
        }, da = function (t, e) {
            if (!(t = sa(t)[0]) || !t.getBoundingClientRect) return console.warn("scrollTo target doesn't exist. Using 0") || {
                x: 0,
                y: 0
            };
            var i = t.getBoundingClientRect(), n = !e || e === ia || e === ra, r = n ? {
                top: na.clientTop - (ia.pageYOffset || na.scrollTop || ra.scrollTop || 0),
                left: na.clientLeft - (ia.pageXOffset || na.scrollLeft || ra.scrollLeft || 0)
            } : e.getBoundingClientRect(), s = {x: i.left - r.left, y: i.top - r.top};
            return !n && e && (s.x += pa(e, "x")(), s.y += pa(e, "y")()), s
        }, fa = function (t, e, i, n, r) {
            return isNaN(t) || "object" == typeof t ? la(t) && "=" === t.charAt(1) ? parseFloat(t.substr(2)) * ("-" === t.charAt(0) ? -1 : 1) + n - r : "max" === t ? ua(e, i) - r : Math.min(ua(e, i), da(t, e)[i] - r) : parseFloat(t) - r
        }, ma = function () {
            ta = ha(), oa() && ta && document.body && (ia = window, ra = document.body, na = document.documentElement, sa = ta.utils.toArray, ta.config({autoKillThreshold: 7}), aa = ta.config(), ea = 1)
        }, ga = {
            version: "3.8.0", name: "scrollTo", rawVars: 1, register: function (t) {
                ta = t, ma()
            }, init: function (t, e, i, n, r) {
                ea || ma();
                var s = this, a = ta.getProperty(t, "scrollSnapType");
                s.isWin = t === ia, s.target = t, s.tween = i, e = function (t, e, i, n) {
                    if (ca(t) && (t = t(e, i, n)), "object" != typeof t) return la(t) && "max" !== t && "=" !== t.charAt(1) ? {
                        x: t,
                        y: t
                    } : {y: t};
                    if (t.nodeType) return {y: t, x: t};
                    var r, s = {};
                    for (r in t) s[r] = "onAutoKill" !== r && ca(t[r]) ? t[r](e, i, n) : t[r];
                    return s
                }(e, n, t, r), s.vars = e, s.autoKill = !!e.autoKill, s.getX = pa(t, "x"), s.getY = pa(t, "y"), s.x = s.xPrev = s.getX(), s.y = s.yPrev = s.getY(), a && "none" !== a && (s.snap = 1, s.snapInline = t.style.scrollSnapType, t.style.scrollSnapType = "none"), null != e.x ? (s.add(s, "x", s.x, fa(e.x, t, "x", s.x, e.offsetX || 0), n, r), s._props.push("scrollTo_x")) : s.skipX = 1, null != e.y ? (s.add(s, "y", s.y, fa(e.y, t, "y", s.y, e.offsetY || 0), n, r), s._props.push("scrollTo_y")) : s.skipY = 1
            }, render: function (t, e) {
                for (var i, n, r, s, a, o = e._pt, h = e.target, l = e.tween, c = e.autoKill, u = e.xPrev, p = e.yPrev, d = e.isWin, f = e.snap, m = e.snapInline; o;) o.r(t, o.d), o = o._next;
                i = d || !e.skipX ? e.getX() : u, r = (n = d || !e.skipY ? e.getY() : p) - p, s = i - u, a = aa.autoKillThreshold, e.x < 0 && (e.x = 0), e.y < 0 && (e.y = 0), c && (!e.skipX && (s > a || s < -a) && i < ua(h, "x") && (e.skipX = 1), !e.skipY && (r > a || r < -a) && n < ua(h, "y") && (e.skipY = 1), e.skipX && e.skipY && (l.kill(), e.vars.onAutoKill && e.vars.onAutoKill.apply(l, e.vars.onAutoKillParams || []))), d ? ia.scrollTo(e.skipX ? i : e.x, e.skipY ? n : e.y) : (e.skipY || (h.scrollTop = e.y), e.skipX || (h.scrollLeft = e.x)), !f || 1 !== t && 0 !== t || (n = h.scrollTop, i = h.scrollLeft, m ? h.style.scrollSnapType = m : h.style.removeProperty("scroll-snap-type"), h.scrollTop = n + 1, h.scrollLeft = i + 1, h.scrollTop = n, h.scrollLeft = i), e.xPrev = e.x, e.yPrev = e.y
            }, kill: function (t) {
                var e = "scrollTo" === t;
                (e || "scrollTo_x" === t) && (this.skipX = 1), (e || "scrollTo_y" === t) && (this.skipY = 1)
            }
        };
        ga.max = ua, ga.getOffset = da, ga.buildGetter = pa, ha() && ta.registerPlugin(ga);
        new class {
            constructor() {
                this.isRunning = !1, this.el = document.querySelector(".js-pe")
            }

            run() {
                clearTimeout(this.timer), this.timer = setTimeout((() => {
                    this.isRunning = !1, this.togglePointers("none")
                }), 300), this.isRunning || (this.isRunning = !0, this.togglePointers("all"))
            }

            togglePointers(t) {
                this.el.style.pointerEvents = t
            }
        };
        var va = __webpack_require__(198), ya = __webpack_require__.n(va);

        function ba(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }

        class xa {
            constructor() {
                ba(this, "onResize", (() => {
                    var t = window.innerWidth;
                    n.isDevice && t === n.width || (Object.assign(n, {
                        width: t,
                        height: window.innerHeight
                    }), this.setAspect(), Vn.emit(xa.events.RESIZE))
                })), ba(this, "onOrientationChange", (() => {
                    n.body.classList.contains("is-orientation-changed") ? n.body.classList.remove("is-orientation-changed") : n.body.classList.add("is-orientation-changed")
                })), window.addEventListener("resize", ya()(this.onResize, 200)), window.addEventListener("orientationchange", this.onOrientationChange), this.setAspect()
            }

            setAspect() {
                n.height <= n.width ? (n.body.classList.remove("is-portrait"), n.body.classList.add("is-landscape"), Object.assign(n, {isLandscape: !0})) : (n.body.classList.remove("is-landscape"), n.body.classList.add("is-portrait"), Object.assign(n, {isLandscape: !1}))
            }
        }

        xa.events = {RESIZE: "GlobalResize.events.RESIZE"};
        new xa;
        var wa = xa.events;

        function _a(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }

        class Ea {
            constructor() {
                _a(this, "mouseMove", (t => {
                    var {x: e, y: i, target: n} = this.getPos(t);
                    Vn.emit(Ea.events.MOVE, {x: e, y: i, target: n, e: t})
                })), _a(this, "mouseDown", (t => {
                    var {x: e, y: i, target: n} = this.getPos(t);
                    this.on = e, Vn.emit(Ea.events.DOWN, {x: e, y: i, target: n})
                })), _a(this, "mouseUp", (t => {
                    var {x: e, target: i} = this.getPos(t);
                    this.off = e;
                    var n = Math.abs(this.on - this.off) < 10;
                    Vn.emit(Ea.events.UP, {x: e, target: i, isClick: n})
                })), this.on = 0, this.off = 0, this.events = {
                    move: n.isDevice ? "touchmove" : "mousemove",
                    down: n.isDevice ? "touchstart" : "mousedown",
                    up: n.isDevice ? "touchend" : "mouseup"
                }, this.addListeners()
            }

            addListeners() {
                var {move: t, down: e, up: i} = this.events;
                window.addEventListener(t, this.mouseMove, {passive: !1}), window.addEventListener(e, this.mouseDown, {passive: !1}), window.addEventListener(i, this.mouseUp, {passive: !1})
            }

            getPos(t) {
                var {changedTouches: e, clientX: i, clientY: n, target: r} = t;
                return {x: e ? e[0].clientX : i, y: e ? e[0].clientY : n, target: r}
            }
        }

        Ea.events = {
            MOVE: "GlobalMouse.events.MOVE",
            DOWN: "GlobalMouse.events.DOWN",
            UP: "GlobalMouse.events.UP",
            ENTER: "GlobalMouse.events.ENTER"
        };
        new Ea;
        var Ma = Ea.events;

        function Aa(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }

        xn.registerPlugin($s, ga);

        class Sa {
            constructor() {
                Aa(this, "tick", (() => {
                    n.isSmooth ? (this.current += (this.target - this.current) * this.ease, this.rounded = Math.round(100 * this.current) / 100) : this.rounded = window.scrollY, $s.update(), this.calcMouse(), Vn.emit(Sa.events.TICK, {
                        target: this.target,
                        current: this.rounded,
                        last: this.last,
                        mouse: this.mouse
                    }), this.last = this.rounded
                })), Aa(this, "onResize", (() => {
                    $s.refresh()
                })), Aa(this, "move", (t => {
                    var {y: e, x: i, target: n} = t;
                    this.mouse.x = i, this.mouse.y = e, this.mouse.target = n
                })), Aa(this, "update", (() => {
                    this.target = this.current = this.rounded = 0
                })), Aa(this, "onScroll", (t => {
                    var {y: e} = t;
                    this.target = e, this.clamp()
                })), Aa(this, "scrollDown", (() => {
                    var t = document.querySelector(".c-hero").getBoundingClientRect().height;
                    xn.to(window, {duration: 1, scrollTo: t, ease: "expo.inOut"})
                })), this.target = 0, this.current = 0, this.rounded = 0, this.ease = .115, this.mouse = {
                    x: n.width / 2,
                    y: n.height / 2,
                    target: null,
                    rounded: {x: 0, y: 0},
                    lerped: {x: n.width / 2, y: n.height / 2}
                }, this.scroll = 0, $s.defaults({scroller: "body"}), $s.scrollerProxy("body", {
                    scrollTop: () => this.rounded,
                    getBoundingClientRect: () => ({top: 0, left: 0, width: n.width, height: n.height})
                }), this.init()
            }

            clamp() {
                this.target = xn.utils.clamp(0, n.scrollP, this.target)
            }

            calcMouse() {
                var t = this.mouse, {x: e, y: i, lerped: n, rounded: r} = t;
                n.x += .15 * (e - n.x), r.x = Math.round(100 * n.x) / 100, n.y += .15 * (i - n.y), r.y = Math.round(100 * n.y) / 100
            }

            scrollTo(t) {
                xn.to(window, {duration: 1, scrollTo: t, ease: "expo.inOut"})
            }

            init() {
                xn.ticker.fps(-1), xn.ticker.add(this.tick), Vn.on("scroll", window, (() => {
                    Vn.emit("scroll", {y: window.scrollY})
                })), n.isDevice || Vn.on(Ma.MOVE, this.move), Vn.on("scroll", this.onScroll), Vn.on("resize", this.onResize)
            }
        }

        Sa.events = {TICK: "TICK", SCROLL: "SCROLL"};
        const Ta = new Sa;
        var Da = Sa.events;

        function Ca(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }

        const Pa = new class {
            constructor() {
                Ca(this, "compare", (t => {
                    var {y: e} = t;
                    this.state.last = this.state.current, this.state.current = e, this.state.isUp = this.state.last > this.state.current
                })), Ca(this, "hide", (() => {
                    xn.to(".js-site-head--normal", {duration: .5, autoAlpha: 0, ease: "power1"}), this.close()
                })), Ca(this, "unhide", (() => {
                    xn.to(".js-site-head--normal", {duration: .5, autoAlpha: 1, ease: "power1"})
                })), Ca(this, "run", (t => {
                    var {current: e} = t;
                    if (!(n.isTransition || n.isMenuOpen || n.isLightbox)) {
                        this.state.current = e;
                        var {triggerPoint: i, isHidden: r, isUp: s} = this.state, {bg: a} = this.ui;
                        e > i && !s && !r || e <= i && s && !r ? (xn.to([this.el, a], {
                            duration: 1,
                            yPercent: -100,
                            ease: "expo"
                        }), n.isStickyMenu = !1, this.state.isHidden = !0) : e > i && r && s && (xn.to([this.el, a], {
                            duration: 1,
                            yPercent: 0,
                            ease: "expo"
                        }), n.isStickyMenu = !0, this.state.isHidden = !1)
                    }
                })), this.el = n.headerSticky, this.ui = {bg: document.querySelector(".js-site-head-bg")}, this.state = {
                    last: 0,
                    current: 0,
                    isUp: !1,
                    isHidden: !1,
                    triggerPoint: .5 * n.height
                }
            }

            setStyles() {
                xn.set([this.el, this.ui.bg], {yPercent: -100})
            }

            close() {
                xn.to([this.el, this.ui.bg], {
                    duration: 1,
                    yPercent: -100,
                    ease: "expo.inOut"
                }), this.state.isUp = !1, this.state.isHidden = !1
            }

            open() {
                xn.to([this.el, this.ui.bg], {duration: 1, yPercent: 0, ease: "expo"})
            }

            addListeners() {
                Vn.on("scroll", this.compare), Vn.on(Da.TICK, this.run), Vn.on("header:hide", this.hide), Vn.on("header:unhide", this.unhide)
            }

            init() {
                this.setStyles(), this.addListeners()
            }
        };
        var Ia = __webpack_require__(973), La = __webpack_require__.n(Ia);

        function Ra(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }

        const Fa = class {
            constructor() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                Ra(this, "draw", (() => {
                    var {
                        x: t,
                        y: e,
                        radius: i,
                        width: n,
                        height: r,
                        lineWidth: s,
                        radiusOffset: a
                    } = this.size, {start: o, end: h} = this.angle;
                    this.ctx.clearRect(0, 0, n, r), this.ctx.beginPath(), this.ctx.arc(t, e, i - a, 0, 2 * Math.PI), this.ctx.lineWidth = s, this.ctx.strokeStyle = "rgba(255, 255, 255, 0.45)", this.ctx.stroke(), this.ctx.beginPath(), this.ctx.arc(t, e, i - a, o * Math.PI, h * Math.PI), this.ctx.lineWidth = s, this.ctx.strokeStyle = "#ffffff", this.ctx.stroke()
                })), Ra(this, "onEnter", (() => {
                    this.tl && this.tl.kill(), this.tl = xn.timeline().to(this.angle, {
                        duration: 2.25,
                        end: 3.5,
                        start: 1.5,
                        onUpdate: this.draw,
                        ease: "power3"
                    })
                })), Ra(this, "onLeave", (() => {
                    this.tl && this.tl.kill(), this.tl = xn.timeline().to(this.angle, {
                        duration: 1.75,
                        end: -.5,
                        start: -.5,
                        onUpdate: this.draw,
                        ease: "power3"
                    })
                })), Ra(this, "onResize", (() => {
                    this.setBounds(), this.draw()
                })), this.opts = t, this.el = this.opts.el, this.trigger = this.el.closest(".js-vimeo"), this.lineWidth = this.opts.lineWidth || 3, this.radiusOffset = 2 * this.lineWidth, this.size = {
                    x: 0,
                    y: 0,
                    radius: 0,
                    lineWidth: this.lineWidth,
                    radiusOffset: this.radiusOffset
                }, this.angle = {start: -.5, end: -.5}, this.tl = null, this.init()
            }

            createCanvas() {
                this.canvas = document.createElement("canvas"), this.el.appendChild(this.canvas), this.ctx = this.canvas.getContext("2d")
            }

            setBounds() {
                var {width: t, height: e} = this.el.getBoundingClientRect();
                Object.assign(this.canvas, {
                    style: {height: "".concat(e, "px"), width: "".concat(t, "px")},
                    height: 2 * e,
                    width: 2 * t
                }), Object.assign(this.size, {
                    x: this.canvas.width / 2,
                    y: this.canvas.height / 2,
                    radius: this.canvas.height / 2,
                    width: 2 * t,
                    height: 2 * e
                })
            }

            addListeners() {
                this.trigger && (this.trigger.addEventListener("mouseenter", this.onEnter), this.trigger.addEventListener("mouseleave", this.onLeave))
            }

            removeListeners() {
                this.trigger && (this.trigger.removeEventListener("mouseenter", this.onEnter), this.trigger.removeEventListener("mouseleave", this.onLeave))
            }

            destroy() {
                this.removeListeners(), this.tl && this.tl.kill(), this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height), this.ctx = null, this.trigger = null, this.size = null, this.angle = null
            }

            init() {
                this.addListeners(), this.createCanvas(), this.setBounds(), this.draw()
            }
        };
        const ka = class {
            constructor() {
                this.el = document.querySelector(".js-preloader"), this.ui = {circle: this.el.querySelector(".js-preloader__circle")}, this.isLoaded = !1, this.circle = new Fa({
                    el: this.ui.circle,
                    lineWidth: 2
                }), this.init()
            }

            createTl() {
                this.tl = xn.timeline({
                    delay: .1, onComplete: () => {
                        this.circle.destroy(), this.el.remove()
                    }
                });
                var t = document.querySelector(".js-hero__box"), e = document.querySelector(".js-transition-line"),
                    i = document.querySelector(".js-t-scale"), n = document.querySelector(".js-ski-wrapper");
                if (xn.to(this.ui.circle, .35, {
                    alpha: 1,
                    ease: "linear"
                }), this.tl.set(".js-preloader", {pointerEvents: "none"}).to(this.circle.angle, {
                    duration: 1.5,
                    end: 1.5,
                    onUpdate: this.circle.draw,
                    ease: "power3.inOut"
                }).to(this.circle.angle, {
                    duration: 1.5,
                    start: 1.5,
                    onUpdate: this.circle.draw,
                    ease: "power3.inOut"
                }).eventCallback("onComplete", (() => {
                    this.isLoaded || this.tl.progress(0, !0)
                })).to([".js-preloader", ".js-preloader__inner"], {
                    duration: .85,
                    yPercent: xn.utils.wrap([-100, 100]),
                    ease: "expo.inOut"
                }), i && this.tl.from(i, {
                    duration: 3,
                    scale: 1.25,
                    ease: "power3"
                }, "-=0.85"), n && this.tl.from(n, {
                    duration: 2,
                    ease: "expo",
                    xPercent: 100
                }, "-=2"), this.tl.from(".js-intro-item", {
                    duration: 1.5,
                    alpha: 0,
                    y: 30,
                    stagger: "0.1",
                    ease: "expo"
                }, 3.25), t) {
                    var r = t.querySelector(".js-hero__box-inner");
                    this.tl.set(t, {alpha: 0}, 0).to(t, {
                        duration: .5,
                        alpha: 1,
                        ease: "linear"
                    }, 3.25).from([t, r], {
                        duration: 1.5,
                        cycle: {xPercent: [-100, 100]},
                        stagger: 0,
                        ease: "power3.inOut"
                    }, 3.25).from(".js-hero__box-item", {
                        duration: 1.5,
                        x: -60,
                        alpha: 0,
                        stagger: .1,
                        ease: "expo"
                    }, 3.5)
                }
                if (e) {
                    var s = new (La())(e, {type: "lines, words"});
                    this.tl.set(s.lines, {overflow: "hidden"}, 0).from(s.words, {
                        duration: 1.5,
                        yPercent: 105,
                        ease: "expo",
                        stagger: .1
                    }, 3.5).set(s.lines, {clearProps: "overflow"})
                }
            }

            preload() {
                window.addEventListener("load", (() => {
                    this.isLoaded = !0
                }))
            }

            init() {
                this.createTl(), this.preload()
            }
        };

        function Oa() {
        }

        Oa.prototype = {
            on: function (t, e, i) {
                var n = this.e || (this.e = {});
                return (n[t] || (n[t] = [])).push({fn: e, ctx: i}), this
            }, once: function (t, e, i) {
                var n = this;

                function r() {
                    n.off(t, r), e.apply(i, arguments)
                }

                return r._ = e, this.on(t, r, i)
            }, emit: function (t) {
                for (var e = [].slice.call(arguments, 1), i = ((this.e || (this.e = {}))[t] || []).slice(), n = 0, r = i.length; n < r; n++) i[n].fn.apply(i[n].ctx, e);
                return this
            }, off: function (t, e) {
                var i = this.e || (this.e = {}), n = i[t], r = [];
                if (n && e) for (var s = 0, a = n.length; s < a; s++) n[s].fn !== e && n[s].fn._ !== e && r.push(n[s]);
                return r.length ? i[t] = r : delete i[t], this
            }
        };
        var za = Oa;
        za.TinyEmitter = Oa;
        var Ba = function (t) {
            this.wrap = document.querySelector("[data-router-wrapper]"), this.properties = t, this.Transition = t.transition ? new t.transition.class(this.wrap, t.transition.name) : null
        };
        Ba.prototype.setup = function () {
            this.onEnter && this.onEnter(), this.onEnterCompleted && this.onEnterCompleted()
        }, Ba.prototype.add = function () {
            this.wrap.insertAdjacentHTML("beforeend", this.properties.view.outerHTML)
        }, Ba.prototype.update = function () {
            document.title = this.properties.page.title
        }, Ba.prototype.show = function (t) {
            var e = this;
            return new Promise((function (i) {
                try {
                    function n(t) {
                        e.onEnterCompleted && e.onEnterCompleted(), i()
                    }

                    return e.update(), e.onEnter && e.onEnter(), Promise.resolve(e.Transition ? Promise.resolve(e.Transition.show(t)).then(n) : n())
                } catch (t) {
                    return Promise.reject(t)
                }
            }))
        }, Ba.prototype.hide = function (t) {
            var e = this;
            return new Promise((function (i) {
                try {
                    function n(t) {
                        e.onLeaveCompleted && e.onLeaveCompleted(), i()
                    }

                    return e.onLeave && e.onLeave(), Promise.resolve(e.Transition ? Promise.resolve(e.Transition.hide(t)).then(n) : n())
                } catch (t) {
                    return Promise.reject(t)
                }
            }))
        };
        var Na = new window.DOMParser, ja = function (t, e) {
            this.renderers = t, this.transitions = e
        };
        ja.prototype.getOrigin = function (t) {
            var e = t.match(/(https?:\/\/[\w\-.]+)/);
            return e ? e[1].replace(/https?:\/\//, "") : null
        }, ja.prototype.getPathname = function (t) {
            var e = t.match(/https?:\/\/.*?(\/[\w_\-./]+)/);
            return e ? e[1] : "/"
        }, ja.prototype.getAnchor = function (t) {
            var e = t.match(/(#.*)$/);
            return e ? e[1] : null
        }, ja.prototype.getParams = function (t) {
            var e = t.match(/\?([\w_\-.=&]+)/);
            if (!e) return null;
            for (var i = e[1].split("&"), n = {}, r = 0; r < i.length; r++) {
                var s = i[r].split("=");
                n[s[0]] = s[1]
            }
            return n
        }, ja.prototype.getDOM = function (t) {
            return "string" == typeof t ? Na.parseFromString(t, "text/html") : t
        }, ja.prototype.getView = function (t) {
            return t.querySelector("[data-router-view]")
        }, ja.prototype.getSlug = function (t) {
            return t.getAttribute("data-router-view")
        }, ja.prototype.getRenderer = function (t) {
            if (!this.renderers) return Promise.resolve(Ba);
            if (t in this.renderers) {
                var e = this.renderers[t];
                return "function" != typeof e || Ba.isPrototypeOf(e) ? "function" == typeof e.then ? Promise.resolve(e).then((function (t) {
                    return t.default
                })) : Promise.resolve(e) : Promise.resolve(e()).then((function (t) {
                    return t.default
                }))
            }
            return Promise.resolve(Ba)
        }, ja.prototype.getTransition = function (t) {
            return this.transitions ? t in this.transitions ? {
                class: this.transitions[t],
                name: t
            } : "default" in this.transitions ? {class: this.transitions.default, name: "default"} : null : null
        }, ja.prototype.getProperties = function (t) {
            var e = this.getDOM(t), i = this.getView(e), n = this.getSlug(i);
            return {
                page: e,
                view: i,
                slug: n,
                renderer: this.getRenderer(n, this.renderers),
                transition: this.getTransition(n, this.transitions)
            }
        }, ja.prototype.getLocation = function (t) {
            return {
                href: t,
                anchor: this.getAnchor(t),
                origin: this.getOrigin(t),
                params: this.getParams(t),
                pathname: this.getPathname(t)
            }
        };
        var Va = function (t) {
            function e(e) {
                var i = this;
                void 0 === e && (e = {});
                var n = e.renderers, r = e.transitions;
                t.call(this), this.Helpers = new ja(n, r), this.Transitions = r, this.Contextual = !1, this.location = this.Helpers.getLocation(window.location.href), this.properties = this.Helpers.getProperties(document.cloneNode(!0)), this.popping = !1, this.running = !1, this.trigger = null, this.cache = new Map, this.cache.set(this.location.href, this.properties), this.properties.renderer.then((function (t) {
                    i.From = new t(i.properties), i.From.setup()
                })), this._navigate = this.navigate.bind(this), window.addEventListener("popstate", this.popState.bind(this)), this.links = document.querySelectorAll("a:not([target]):not([data-router-disabled])"), this.attach(this.links)
            }

            return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.attach = function (t) {
                for (var e = 0, i = t; e < i.length; e += 1) i[e].addEventListener("click", this._navigate)
            }, e.prototype.detach = function (t) {
                for (var e = 0, i = t; e < i.length; e += 1) i[e].removeEventListener("click", this._navigate)
            }, e.prototype.navigate = function (t) {
                if (!t.metaKey && !t.ctrlKey) {
                    t.preventDefault();
                    var e = !!t.currentTarget.hasAttribute("data-transition") && t.currentTarget.dataset.transition;
                    this.redirect(t.currentTarget.href, e, t.currentTarget)
                }
            }, e.prototype.redirect = function (t, e, i) {
                if (void 0 === e && (e = !1), void 0 === i && (i = "script"), this.trigger = i, !this.running && t !== this.location.href) {
                    var n = this.Helpers.getLocation(t);
                    this.Contextual = !1, e && (this.Contextual = this.Transitions.contextual[e].prototype, this.Contextual.name = e), n.origin !== this.location.origin || n.anchor && n.pathname === this.location.pathname ? window.location.href = t : (this.location = n, this.beforeFetch())
                }
            }, e.prototype.popState = function () {
                this.trigger = "popstate", this.Contextual = !1;
                var t = this.Helpers.getLocation(window.location.href);
                this.location.pathname !== t.pathname || !this.location.anchor && !t.anchor ? (this.popping = !0, this.location = t, this.beforeFetch()) : this.location = t
            }, e.prototype.pushState = function () {
                this.popping || window.history.pushState(this.location, "", this.location.href)
            }, e.prototype.fetch = function () {
                try {
                    var t = this;
                    return Promise.resolve(fetch(t.location.href, {
                        mode: "same-origin",
                        method: "GET",
                        headers: {"X-Requested-With": "Highway"},
                        credentials: "same-origin"
                    })).then((function (e) {
                        if (e.status >= 200 && e.status < 300) return e.text();
                        window.location.href = t.location.href
                    }))
                } catch (t) {
                    return Promise.reject(t)
                }
            }, e.prototype.beforeFetch = function () {
                try {
                    var t = this;

                    function n() {
                        t.afterFetch()
                    }

                    t.pushState(), t.running = !0, t.emit("NAVIGATE_OUT", {
                        from: {
                            page: t.From.properties.page,
                            view: t.From.properties.view
                        }, trigger: t.trigger, location: t.location
                    });
                    var e = {trigger: t.trigger, contextual: t.Contextual},
                        i = t.cache.has(t.location.href) ? Promise.resolve(t.From.hide(e)).then((function () {
                            t.properties = t.cache.get(t.location.href)
                        })) : Promise.resolve(Promise.all([t.fetch(), t.From.hide(e)])).then((function (e) {
                            t.properties = t.Helpers.getProperties(e[0]), t.cache.set(t.location.href, t.properties)
                        }));
                    return Promise.resolve(i && i.then ? i.then(n) : n())
                } catch (t) {
                    return Promise.reject(t)
                }
            }, e.prototype.afterFetch = function () {
                try {
                    var t = this;
                    return Promise.resolve(t.properties.renderer).then((function (e) {
                        return t.To = new e(t.properties), t.To.add(), t.emit("NAVIGATE_IN", {
                            to: {
                                page: t.To.properties.page,
                                view: t.To.wrap.lastElementChild
                            }, trigger: t.trigger, location: t.location
                        }), Promise.resolve(t.To.show({
                            trigger: t.trigger,
                            contextual: t.Contextual
                        })).then((function () {
                            t.popping = !1, t.running = !1, t.detach(t.links), t.links = document.querySelectorAll("a:not([target]):not([data-router-disabled])"), t.attach(t.links), t.emit("NAVIGATE_END", {
                                to: {
                                    page: t.To.properties.page,
                                    view: t.To.wrap.lastElementChild
                                },
                                from: {page: t.From.properties.page, view: t.From.properties.view},
                                trigger: t.trigger,
                                location: t.location
                            }), t.From = t.To, t.trigger = null
                        }))
                    }))
                } catch (t) {
                    return Promise.reject(t)
                }
            }, e
        }(za), Ga = function (t, e) {
            this.wrap = t, this.name = e
        };
        Ga.prototype.show = function (t) {
            var e = this, i = t.trigger, n = t.contextual, r = this.wrap.lastElementChild,
                s = this.wrap.firstElementChild;
            return new Promise((function (t) {
                n ? (r.setAttribute("data-transition-in", n.name), r.removeAttribute("data-transition-out", n.name), n.in && n.in({
                    to: r,
                    from: s,
                    trigger: i,
                    done: t
                })) : (r.setAttribute("data-transition-in", e.name), r.removeAttribute("data-transition-out", e.name), e.in && e.in({
                    to: r,
                    from: s,
                    trigger: i,
                    done: t
                }))
            }))
        }, Ga.prototype.hide = function (t) {
            var e = this, i = t.trigger, n = t.contextual, r = this.wrap.firstElementChild;
            return new Promise((function (t) {
                n ? (r.setAttribute("data-transition-out", n.name), r.removeAttribute("data-transition-in", n.name), n.out && n.out({
                    from: r,
                    trigger: i,
                    done: t
                })) : (r.setAttribute("data-transition-out", e.name), r.removeAttribute("data-transition-in", e.name), e.out && e.out({
                    from: r,
                    trigger: i,
                    done: t
                }))
            }))
        }, console.log("Highway v2.2.0");
        const Ua = {Core: Va, Helpers: ja, Renderer: Ba, Transition: Ga};
        var Ha, Wa, qa, Xa, Ya, Za = __webpack_require__(809), Ja = __webpack_require__.n(Za),
            Qa = () => "undefined" != typeof window,
            Ka = () => Ha || Qa() && (Ha = window.gsap) && Ha.registerPlugin && Ha,
            $a = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi,
            to = {rect: ["width", "height"], circle: ["r", "r"], ellipse: ["rx", "ry"], line: ["x2", "y2"]},
            eo = t => Math.round(1e4 * t) / 1e4, io = t => parseFloat(t || 0), no = (t, e) => io(t.getAttribute(e)),
            ro = Math.sqrt, so = (t, e, i, n, r, s) => ro(((io(i) - io(t)) * r) ** 2 + ((io(n) - io(e)) * s) ** 2),
            ao = t => console.warn(t), oo = t => "non-scaling-stroke" === t.getAttribute("vector-effect"), ho = t => {
                if (!(t = Wa(t)[0])) return 0;
                var e, i, n, r, s, a, o, h = t.tagName.toLowerCase(), l = t.style, c = 1, u = 1;
                oo(t) && (u = t.getScreenCTM(), c = ro(u.a * u.a + u.b * u.b), u = ro(u.d * u.d + u.c * u.c));
                try {
                    i = t.getBBox()
                } catch (t) {
                    ao("Some browsers won't measure invisible elements (like display:none or masks inside defs).")
                }
                var {x: p, y: d, width: f, height: m} = i || {x: 0, y: 0, width: 0, height: 0};
                if (i && (f || m) || !to[h] || (f = no(t, to[h][0]), m = no(t, to[h][1]), "rect" !== h && "line" !== h && (f *= 2, m *= 2), "line" === h && (p = no(t, "x1"), d = no(t, "y1"), f = Math.abs(f - p), m = Math.abs(m - d))), "path" === h) r = l.strokeDasharray, l.strokeDasharray = "none", e = t.getTotalLength() || 0, c !== u && ao("Warning: <path> length cannot be measured when vector-effect is non-scaling-stroke and the element isn't proportionally scaled."), e *= (c + u) / 2, l.strokeDasharray = r; else if ("rect" === h) e = 2 * f * c + 2 * m * u; else if ("line" === h) e = so(p, d, p + f, d + m, c, u); else if ("polyline" === h || "polygon" === h) for (n = t.getAttribute("points").match($a) || [], "polygon" === h && n.push(n[0], n[1]), e = 0, s = 2; s < n.length; s += 2) e += so(n[s - 2], n[s - 1], n[s], n[s + 1], c, u) || 0; else "circle" !== h && "ellipse" !== h || (a = f / 2 * c, o = m / 2 * u, e = Math.PI * (3 * (a + o) - ro((3 * a + o) * (a + 3 * o))));
                return e || 0
            }, lo = (t, e) => {
                if (!(t = Wa(t)[0])) return [0, 0];
                e || (e = ho(t) + 1);
                var i = qa.getComputedStyle(t), n = i.strokeDasharray || "", r = io(i.strokeDashoffset), s = n.indexOf(",");
                return s < 0 && (s = n.indexOf(" ")), (n = s < 0 ? e : io(n.substr(0, s)) || 1e-5) > e && (n = e), [Math.max(0, -r), Math.max(0, n - r)]
            }, co = () => {
                Qa() && (document, qa = window, Ya = Ha = Ka(), Wa = Ha.utils.toArray, Xa = -1 !== ((qa.navigator || {}).userAgent || "").indexOf("Edge"))
            }, uo = {
                version: "3.2.6", name: "drawSVG", register(t) {
                    Ha = t, co()
                }, init(t, e, i, n, r) {
                    if (!t.getBBox) return !1;
                    Ya || co();
                    var s, a, o, h, l = ho(t) + 1;
                    return this._style = t.style, this._target = t, e + "" == "true" ? e = "0 100%" : e ? -1 === (e + "").indexOf(" ") && (e = "0 " + e) : e = "0 0", a = ((t, e, i) => {
                        var n, r, s = t.indexOf(" ");
                        return s < 0 ? (n = void 0 !== i ? i + "" : t, r = t) : (n = t.substr(0, s), r = t.substr(s + 1)), (n = ~n.indexOf("%") ? io(n) / 100 * e : io(n)) > (r = ~r.indexOf("%") ? io(r) / 100 * e : io(r)) ? [r, n] : [n, r]
                    })(e, l, (s = lo(t, l))[0]), this._length = eo(l + 10), 0 === s[0] && 0 === a[0] ? (o = Math.max(1e-5, a[1] - l), this._dash = eo(l + o), this._offset = eo(l - s[1] + o), this._offsetPT = this.add(this, "_offset", this._offset, eo(l - a[1] + o))) : (this._dash = eo(s[1] - s[0]) || 1e-6, this._offset = eo(-s[0]), this._dashPT = this.add(this, "_dash", this._dash, eo(a[1] - a[0]) || 1e-5), this._offsetPT = this.add(this, "_offset", this._offset, eo(-a[0]))), Xa && (h = qa.getComputedStyle(t)).strokeLinecap !== h.strokeLinejoin && (a = io(h.strokeMiterlimit), this.add(t.style, "strokeMiterlimit", a, a + .01)), this._live = oo(t) || ~(e + "").indexOf("live"), this._props.push("drawSVG"), 1
                }, render(t, e) {
                    var i, n, r, s, a = e._pt, o = e._style;
                    if (a) {
                        for (e._live && (i = ho(e._target) + 11) !== e._length && (n = i / e._length, e._length = i, e._offsetPT.s *= n, e._offsetPT.c *= n, e._dashPT ? (e._dashPT.s *= n, e._dashPT.c *= n) : e._dash *= n); a;) a.r(t, a.d), a = a._next;
                        r = e._dash, s = e._offset, i = e._length, o.strokeDashoffset = e._offset, 1 !== t && t ? o.strokeDasharray = r + "px," + i + "px" : (r - s < .001 && i - r <= 10 && (o.strokeDashoffset = s + 1), o.strokeDasharray = s < .001 && i - r <= 10 ? "none" : s === r ? "0px, 999999px" : r + "px," + i + "px")
                    }
                }, getLength: ho, getPosition: lo
            };
        Ka() && Ha.registerPlugin(uo);
        const po = class {
            constructor(t) {
                this.el = n.body, this.elems = t, this.cache = null, this.options = null, this.observer = null, this.initial = !1, this.init()
            }

            createObserver() {
                this.options = {
                    root: null,
                    rootMargin: "0px 0px 0px 0px",
                    threshold: [0, 0]
                }, this.observer = new IntersectionObserver(this.handler.bind(this), this.options)
            }

            fixArray() {
                this.elems = [];
                var t = [...this.el.querySelectorAll("[data-scroll]")];
                t && t.forEach((t => {
                    t.getBoundingClientRect().top >= n.height && this.elems.push(t)
                }))
            }

            getCache() {
                this.cache = [], this.animations = [], this.elems.forEach(((t, e) => {
                    var i = {
                        el: t,
                        animation: t.dataset.scroll,
                        isIntersected: !1,
                        elems: null,
                        split: null,
                        tl: null,
                        immediate: void 0 === t.dataset.tlImmediate
                    };
                    this.cache.push(i)
                }))
            }

            setAnimation(t) {
                var {el: e, animation: i, immediate: r} = t;
                if (t.tl = xn.timeline({paused: !0, defaults: {immediateRender: r}}), "titleLines" === i) {
                    var s = e.querySelectorAll(".js-line");
                    t.tl.from(s, {duration: 1.5, yPercent: 100, alpha: 0, rotation: 4, stagger: .1, ease: "expo"}, 0)
                } else if ("staggerWords" === i) {
                    var a = new (La())(e, {type: "lines, words"});
                    t.tl.set(a.lines, {overflow: "hidden"}).from(a.words, {
                        duration: 1.5,
                        yPercent: 100,
                        ease: "expo",
                        stagger: .075
                    }, 0)
                } else if ("staggerChars" === i) {
                    var o = new (La())(e, {type: "lines, words, chars"});
                    t.tl.set(o.lines, {overflow: "hidden"}).from(o.chars, {
                        duration: 1.5,
                        yPercent: 100,
                        ease: "expo",
                        stagger: .05
                    }, 0)
                } else if ("staggerLines" === i) {
                    var h = new (La())(e, {type: "lines"});
                    t.tl.from(h.lines, {
                        duration: 1.5,
                        yPercent: 125,
                        alpha: 0,
                        rotation: 4,
                        stagger: .1,
                        ease: "expo"
                    }, 0)
                } else if ("staggerLinesP" === i) {
                    var l = e.querySelectorAll("p"), c = new (La())(l, {type: "lines"});
                    t.tl.from(c.lines, {
                        duration: 1.5,
                        yPercent: 125,
                        alpha: 0,
                        rotation: 4,
                        stagger: .1,
                        ease: "expo"
                    }, 0)
                } else if ("quote" === i) {
                    var u = e.querySelector(".js-quote__border"), p = e.querySelector(".js-quote__text"),
                        d = new (La())(p, {type: "lines"});
                    t.tl.from(u, {duration: 1.5, scaleY: 0, ease: "expo"}).from(d.lines, {
                        duration: 1.5,
                        yPercent: 125,
                        alpha: 0,
                        rotation: 4,
                        stagger: .1,
                        ease: "expo"
                    }, 0)
                } else "slideRight" === i ? t.tl.from(e, {
                    duration: 2,
                    x: .15 * n.width,
                    ease: "power3"
                }, .5).from(e, {
                    duration: 1,
                    alpha: 0,
                    ease: "linear",
                    immediateRender: !0
                }, .5) : "scaleIn" === i ? t.tl.set(e.parentNode, {overflow: "hidden"}).set(e, {willChange: "transform"}).from(e, {
                    duration: 3,
                    scale: 1.25,
                    ease: "power3"
                }, .1).set(e, {clearProps: "all"}) : "scaleX" === i ? t.tl.from(e, {
                    duration: 2,
                    scaleX: 0,
                    ease: "power3"
                }, 0) : "logo" === i ? t.tl.add((() => container.play())) : "map" === i ? t.tl.fromTo([".js-map-map", ".js-map-map__inner"], {xPercent: xn.utils.wrap([100, -100])}, {
                    xPercent: 0,
                    duration: 1.5,
                    ease: "power3.inOut"
                }, 0).add((() => Vn.emit("map:animate")), 0) : t.tl.from(e, {
                    duration: 1.5,
                    y: 60,
                    alpha: 0,
                    ease: "expo"
                }, 0);
                t.tl.progress(1, !0).progress(0, !0)
            }

            handler(t) {
                t.forEach((t => {
                    if (t.isIntersecting) {
                        var e = this.elems.indexOf(t.target), i = this.cache[e];
                        i.isIntersected = !0, i.tl.play(), this.stillObserving() ? this.observer.unobserve(t.target) : this.observer.disconnect()
                    }
                }))
            }

            stillObserving() {
                return this.cache.some((t => !t.isIntersected))
            }

            destroy() {
                this.cache = null, this.observer.disconnect(), this.observer = null, this.elems = null
            }

            run() {
                this.cache.forEach((t => {
                    this.setAnimation(t), this.observer.observe(t.el)
                }))
            }

            init() {
                this.fixArray(), this.getCache(), this.createObserver(), this.run()
            }
        };
        var fo = function (t) {
            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : document;
            return e.querySelector(t)
        }, mo = function (t) {
            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : document;
            return e.querySelectorAll(t)
        };

        function go(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }

        function vo(t, e) {
            var i = Object.keys(t);
            if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(t);
                e && (n = n.filter((function (e) {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                }))), i.push.apply(i, n)
            }
            return i
        }

        function yo(t) {
            for (var e = 1; e < arguments.length; e++) {
                var i = null != arguments[e] ? arguments[e] : {};
                e % 2 ? vo(Object(i), !0).forEach((function (e) {
                    bo(t, e, i[e])
                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : vo(Object(i)).forEach((function (e) {
                    Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e))
                }))
            }
            return t
        }

        function bo(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }

        const xo = class {
            constructor(t) {
                bo(this, "run", (t => {
                    var {current: e} = t;
                    this.state.current = e, this.animateElems()
                })), bo(this, "intersectRatio", ((t, e, i, r, s, a) => ({progress: (this.state.current - e) / (2 * n.height) + .5}))), bo(this, "onResize", (() => {
                    this.state.isResizing = !0, this.updateCache(), this.state.isResizing = !1
                })), this.elems = t, this.cache = null, this.stickies = null, this.state = {isResizing: !1}, this.init()
            }

            animateElems() {
                for (var t = 0; t < this.cache.length; t++) {
                    var {
                        height: e,
                        top: i,
                        bottom: r,
                        tl: s,
                        duration: a,
                        isTop: o,
                        isBottom: h
                    } = this.cache[t], {isVisible: l, start: c, end: u} = this.isVisible(i, r);
                    if (l || this.state.isResizing) {
                        var {progress: p} = this.intersectRatio(e, i, r, a, o, h);
                        s.progress(p)
                    }
                }
                for (var d = 0; d < this.stickies.length; d++) {
                    var f = this.stickies[d], {
                        el: m,
                        video: g,
                        speed: v,
                        height: y,
                        top: b,
                        bottom: x,
                        hasScale: w
                    } = f, {isVisible: _} = this.isVisible(b, x);
                    if (_) {
                        var E = this.state.current - b + (n.height - y), M = Math.min(Math.max(E * v, -y), 0),
                            A = w ? "scale(".concat(1 + M / n.height * -.25, ")") : "";
                        m.style.transform = "translate3d(0, ".concat(M, "px, 0)") + A, m.style.willChange = "transform", g && !f.isPlaying && (g.play(), f.isPlaying = !0)
                    } else g && f.isPlaying && (g.pause(), f.isPlaying = !1)
                }
            }

            isVisible(t, e) {
                var {current: i} = this.state, r = t - i, s = e - i;
                return {isVisible: r < n.height && s > 0, start: r, end: s}
            }

            getCache() {
                this.elems && (this.cache = [], this.elems.forEach((t => {
                    if (void 0 !== t.dataset.animateMobile || !n.isDevice) {
                        var e = xn.timeline({paused: !0}), i = JSON.parse(t.dataset.from),
                            r = yo(yo({}, JSON.parse(t.dataset.to)), {ease: "linear", duration: 1});
                        e.fromTo(t, i, r), e.progress(1);
                        var s = {}, {top: a, bottom: o, height: h} = t.getBoundingClientRect();
                        e.progress(0);
                        s.isBottom = o >= n.scrollHeight, s.isTop = a < n.height, s.el = t, s.tl = e, s.duration = t.dataset.duration || 1, s.isTop ? s.top = n.height + 0 : s.top = a - 0, s.isTop ? s.bottom = o : s.isBottom && !s.isTop ? s.bottom = o - n.height : s.bottom = o + 0, s.isBottom ? s.height = 0 : s.height = h, this.cache.push(s)
                    }
                })))
            }

            getStickies() {
                this.stickies = [], document.querySelectorAll("[data-stick]").forEach((t => {
                    var e = t.dataset.stick || 1, i = t.querySelector("video"),
                        n = void 0 !== t.dataset.stickScale, {height: r, top: s, bottom: a} = t.getBoundingClientRect();
                    this.stickies.push({
                        el: t,
                        video: i,
                        height: r,
                        top: s,
                        bottom: a,
                        speed: e,
                        hasScale: n,
                        video: i,
                        isPlaying: !1
                    })
                }))
            }

            updateCache() {
                this.elems.forEach((t => {
                    var {top: e, bottom: i} = t.getBoundingClientRect();
                    Object.assign(t, {top: e > n.height ? e : n.height, bottom: i, height: i - e})
                }))
            }

            addListeners() {
                Vn.on(Da.TICK, this.run), Vn.on(wa.RESIZE, this.onResize)
            }

            removeListeners() {
                Vn.off(Da.TICK, this.run), Vn.off(wa.RESIZE, this.onResize)
            }

            destroy() {
                this.removeListeners(), this.cache = null, this.elems = null, this.state = null
            }

            init() {
                this.getCache(), this.getStickies(), this.addListeners()
            }
        };
        var wo = __webpack_require__(306), _o = __webpack_require__.n(wo);
        const Eo = function (t, e, i, n, r) {
            var s = !0 === r && {passive: !0};
            t[("a" === e ? "add" : "remove") + "EventListener"](i, n, s)
        };

        function Mo(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }

        const Ao = class {
            constructor() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                Mo(this, "run", (() => {
                    this.calc(), this.transformSlides(), this.transformProgress()
                })), Mo(this, "onDown", (t => {
                    var {x: e, y: i, target: n} = this.getPos(t);
                    if (this.dragArea.contains(n)) {
                        this.resetLoop(), this.state.isDragging = !0;
                        var {on: r} = this.state;
                        r.x = e, r.y = i, this.clampTarget()
                    }
                })), Mo(this, "onUp", (t => {
                    var {x: e} = this.getPos(t), i = this.state, n = Math.abs(i.on.x - e) < 10;
                    if (this.opts.isClick && n) {
                        var r = t.target, s = r.classList.contains(".js-drag-item") ? r : r.closest(".js-drag-item");
                        s && vM.redirect(s.dataset.url)
                    }
                    this.snap(), i.off = i.target, i.isDragging = !1
                })), Mo(this, "onMove", (t => {
                    var e = this.state;
                    if (e.isDragging) {
                        var {x: i, y: n} = this.getPos(t), {off: r, on: s} = e, a = i - s.x, o = n - s.y;
                        Math.abs(a) > Math.abs(o) && t.cancelable && (t.preventDefault(), t.stopPropagation()), e.target = r + a * this.opts.speed, this.clampTarget()
                    }
                })), Mo(this, "clickNext", (() => {
                    var {itemL: t, target: e, slide: i, max: n} = this.state;
                    i.last = i.current, i.current = i.current === t ? 0 : i.current + 1, this.onClick()
                })), Mo(this, "clickPrev", (() => {
                    var {target: t, slide: e, min: i} = this.state;
                    t < i && (e.last = e.current, e.current = e.current - 1, this.onClick())
                })), Mo(this, "onClickBullet", (t => {
                    var {target: e} = t;
                    this.resetLoop();
                    var i = [].slice.call(this.bullets).indexOf(e, 1);
                    i = -1 === i ? 0 : i;
                    var n = this.state.slide;
                    n.last = n.current, n.current = i, this.onClick()
                })), this.el = t.el, this.opts = Object.assign({
                    speed: 1.5,
                    threshold: 50,
                    autoPlay: this.el.dataset.autoplay
                }, t), this.dragArea = this.el.querySelector(".js-drag-area"), this.items = this.el.querySelectorAll(".js-drag-item"), this.delayedCall = null, this.bullets = this.opts.bullets ? this.el.querySelectorAll(".js-pip") : null, this.navigation = this.opts.navigation ? {
                    prev: this.el.querySelector(".js-prev"),
                    next: this.el.querySelector(".js-next")
                } : null, this.progressBar = this.el.querySelector(".js-progress-bar"), this.state = {
                    itemL: this.items.length - 1,
                    target: 0,
                    current: {a: 0, aRounded: 0},
                    ease: {a: .1},
                    on: {x: 0, y: 0},
                    off: 0,
                    slide: {last: 0, current: 0},
                    progress: 0,
                    snap: null,
                    snapOffset: 0,
                    isFired: !1,
                    isDragging: !1,
                    isResizing: !1
                }, this.events = {
                    move: n.isDevice ? "touchmove" : "mousemove",
                    up: n.isDevice ? "touchend" : "mouseup",
                    down: n.isDevice ? "touchstart" : "mousedown"
                }, this.cache = null, this.init()
            }

            getCache() {
                this.cache = [], this.items.forEach((t => {
                    t.style.transform = "translate3d(0, 0, 0)";
                    var {left: e, right: i, width: r} = t.getBoundingClientRect(), s = t.dataset.ease;
                    this.cache.push({el: t, left: e, right: i, width: r, ease: n.isPhone ? "a" : s || "a", out: !1})
                }))
            }

            setBounds() {
                var t = this.state,
                    e = this.slides ? this.slides : this.items, {width: i} = this.dragArea.getBoundingClientRect(), {left: n} = e[0].getBoundingClientRect(), {right: r} = e[e.length - 1].getBoundingClientRect();
                t.max = -(r - i - n), t.min = 0, t.snap = [], e.forEach((e => {
                    var {left: i} = e.getBoundingClientRect();
                    t.snap.push(-i + n)
                }))
            }

            calc() {
                var {current: t, target: e, ease: i} = this.state;
                t.a += (e - t.a) * i.a, t.aRounded = Math.round(100 * t.a) / 100
            }

            transformSlides() {
                for (var t = this.state, e = t.itemL, i = 0; i <= e; i++) {
                    var n = this.cache[i], r = t.current[n.ease + "Rounded"], {isVisible: s} = this.isVisible(n, r),
                        a = "translate3d(".concat(r, "px, 0, 0) rotate(0.001deg)");
                    n.out || (n.el.style.transform = a), s || t.isResizing ? n.out = !1 : n.out || (n.out = !0)
                }
            }

            transformProgress() {
                var t = this.state;
                t.progress = t.current.aRounded / t.max, t.progress = Math.min(Math.max(t.progress, 0), 1), this.progressBar && (this.progressBar.style.transform = "scaleX(".concat(t.progress, ")"))
            }

            isVisible(t, e) {
                var {left: i, right: r} = t, s = this.opts.threshold, a = r + e;
                return {isVisible: i + e < s + n.width && a > -s}
            }

            clampTarget() {
                var t = this.state;
                t.target = Math.max(Math.min(t.target, t.min), t.max)
            }

            getClosest() {
                var t = this.state, {target: e, slide: i, max: n, snap: r} = t;
                i.current = _o().number(e, r), t.snapOffset = e <= n ? n : r[i.current]
            }

            snap() {
                var t = this.state;
                t.slide.last = t.slide.current, this.getClosest(), t.target = t.snapOffset, this.clampTarget(), this.navigation && this.toggleClasses(), this.bullets && this.toggleBullets()
            }

            toggleClasses() {
                var {prev: t, next: e} = this.navigation, {target: i, min: n, max: r} = this.state;
                i >= n ? (t.classList.add("is-disabled"), e.classList.remove("is-disabled")) : i <= r ? (e.classList.add("is-disabled"), t.classList.remove("is-disabled")) : (e.classList.remove("is-disabled"), t.classList.remove("is-disabled"))
            }

            toggleBullets() {
                var t = this.bullets, {last: e, current: i} = this.state.slide;
                t[e].classList.remove("is-active"), t[i].classList.add("is-active")
            }

            getPos(t) {
                var {changedTouches: e, clientX: i, clientY: n, target: r} = t;
                return {x: e ? e[0].clientX : i, y: e ? e[0].clientY : n, target: r}
            }

            resetLoop() {
                this.state.isFired || (this.state.isFired = !0)
            }

            onSet(t) {
                var e = this.state.slide;
                e.last = e.current, e.current = t, this.onClick(!0)
            }

            onClick() {
                var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], e = this.state, {
                    min: i,
                    max: n,
                    slide: r,
                    snap: s
                } = e;
                e.snapOffset = Math.max(Math.min(s[r.current], i), n), e.target = e.snapOffset, t && (e.current.aRounded = e.current.a = e.target), e.off = e.target, this.clampTarget(), this.toggleClasses(), this.bullets && this.toggleBullets()
            }

            on() {
                var {move: t, up: e, down: i} = this.events;
                if (Vn.on(Da.TICK, this.run), Eo(this.el, "a", i, this.onDown, !0), Eo(window, "a", e, this.onUp, !0), Eo(this.el, "a", t, this.onMove, !1), this.navigation) {
                    var {prev: n, next: r} = this.navigation;
                    Eo(n, "a", "click", this.clickPrev), Eo(r, "a", "click", this.clickNext)
                }
                this.bullets && this.bullets.forEach((t => {
                    Eo(t, "a", "click", this.onClickBullet)
                })), 1 == this.opts.autoPlay && this.playSlide()
            }

            playSlide() {
                this.delayedCall = xn.delayedCall(6, (() => {
                    this.state.isFired ? this.delayedCall.kill() : (this.clickNext(), this.playSlide())
                }))
            }

            off() {
                var {move: t, up: e, down: i} = this.events;
                if (Vn.off(Da.TICK, this.run), Eo(this.el, "r", i, this.onDown, !0), Eo(window, "r", e, this.onUp, !0), Eo(this.el, "r", t, this.onMove, !1), this.navigation) {
                    var {prev: n, next: r} = this.navigation;
                    Eo(n, "r", "click", this.clickPrev), Eo(r, "r", "click", this.clickNext)
                }
                this.bullets && this.bullets.forEach((t => {
                    Eo(t, "r", "click", this.onClickBullet)
                })), this.delayedCall && this.delayedCall.kill()
            }

            destroy() {
                this.off(), this.opts = null, this.state = null, this.items = null, this.slides = null, this.navigation = null, this.cache = null
            }

            init() {
                this.getCache(), this.setBounds(), this.on()
            }
        }, So = class extends Ao {
            constructor(t) {
                super(t);
                var e = this.items.length, i = this.el.querySelector(".js-slider-full-texts");
                this.tl = xn.timeline({paused: !0}).fromTo(i, {yPercent: 0}, {
                    duration: 1,
                    yPercent: -(100 - 100 / e),
                    ease: "linear"
                })
            }

            transformProgress() {
                super.transformProgress(), !n.isPhone && this.tl.progress(this.state.progress)
            }
        };
        const To = class extends Ao {
            constructor(t) {
                super(t), this.contentCache = null, this.contentTl = null, this.getContentCache()
            }

            getContentCache() {
                var t = this.el.querySelectorAll(".js-slider-txt__content-item");
                this.contentCache = [], t.forEach((t => {
                    this.contentCache.push({el: t, elems: t.querySelectorAll(".js-slider-txt__stagger")})
                }))
            }

            shiftContent() {
                var {last: t, current: e} = this.state.slide;
                if (t !== e) {
                    var i = this.contentCache[this.state.slide.last], n = this.contentCache[this.state.slide.current];
                    this.contentTl && this.contentTl.kill(), this.contentTl = xn.timeline().set(n.el, {autoAlpha: 1}).to(i.el, {
                        duration: .35,
                        autoAlpha: 0,
                        ease: "power1"
                    }).fromTo(n.elems, {alpha: 0, y: 30}, {
                        alpha: 1,
                        y: 0,
                        duration: 1.1,
                        stagger: .1,
                        ease: "expo"
                    }, .15)
                }
            }

            onClick() {
                super.onClick(), this.shiftContent()
            }

            snap() {
                super.snap(), this.shiftContent()
            }
        };
        const Do = class extends Ao {
            constructor(t) {
                super(t), Object.assign(this.state.current, {
                    b: 0,
                    bRounded: 0,
                    c: 0,
                    cRounded: 0
                }), Object.assign(this.state.ease, {a: .1, b: .095, c: .085})
            }

            setBounds() {
                this.slides = this.el.querySelectorAll(".js-slide"), super.setBounds()
            }

            calc() {
                super.calc();
                var {current: t, target: e, ease: i} = this.state;
                t.b += (e - t.b) * i.b, t.bRounded = Math.round(100 * t.b) / 100, t.c += (e - t.c) * i.c, t.cRounded = Math.round(100 * t.c) / 100
            }
        };

        function Co(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }

        function Po(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }

        function Io(t, e) {
            for (var i = 0; i < e.length; i++) {
                var n = e[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
            }
        }

        var Lo = void 0 !== __webpack_require__.g && "[object global]" === {}.toString.call(__webpack_require__.g);

        function Ro(t, e) {
            return 0 === t.indexOf(e.toLowerCase()) ? t : "".concat(e.toLowerCase()).concat(t.substr(0, 1).toUpperCase()).concat(t.substr(1))
        }

        function Fo(t) {
            return Boolean(t && 1 === t.nodeType && "nodeName" in t && t.ownerDocument && t.ownerDocument.defaultView)
        }

        function ko(t) {
            return !isNaN(parseFloat(t)) && isFinite(t) && Math.floor(t) == t
        }

        function Oo(t) {
            return /^(https?:)?\/\/((player|www)\.)?vimeo\.com(?=$|\/)/.test(t)
        }

        function zo() {
            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e = t.id, i = t.url,
                n = e || i;
            if (!n) throw new Error("An id or url must be passed, either in an options object or as a data-vimeo-id or data-vimeo-url attribute.");
            if (ko(n)) return "https://vimeo.com/".concat(n);
            if (Oo(n)) return n.replace("http:", "https:");
            if (e) throw new TypeError("".concat(e, " is not a valid video id."));
            throw new TypeError("".concat(n, " is not a vimeo.com url."))
        }

        var Bo = void 0 !== Array.prototype.indexOf, No = "undefined" != typeof window && void 0 !== window.postMessage;
        if (!(Lo || Bo && No)) throw new Error("Sorry, the Vimeo Player API is not available in this browser.");
        var jo = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== __webpack_require__.g ? __webpack_require__.g : "undefined" != typeof self ? self : {};
        !function (t) {
            if (!t.WeakMap) {
                var e = Object.prototype.hasOwnProperty, i = Object.defineProperty && function () {
                    try {
                        return 1 === Object.defineProperty({}, "x", {value: 1}).x
                    } catch (t) {
                    }
                }(), n = function (t, e, n) {
                    i ? Object.defineProperty(t, e, {configurable: !0, writable: !0, value: n}) : t[e] = n
                };
                t.WeakMap = function () {
                    function t() {
                        if (void 0 === this) throw new TypeError("Constructor WeakMap requires 'new'");
                        if (n(this, "_id", s("_WeakMap")), arguments.length > 0) throw new TypeError("WeakMap iterable is not supported")
                    }

                    function i(t, i) {
                        if (!r(t) || !e.call(t, "_id")) throw new TypeError(i + " method called on incompatible receiver " + typeof t)
                    }

                    function s(t) {
                        return t + "_" + a() + "." + a()
                    }

                    function a() {
                        return Math.random().toString().substring(2)
                    }

                    return n(t.prototype, "delete", (function (t) {
                        if (i(this, "delete"), !r(t)) return !1;
                        var e = t[this._id];
                        return !(!e || e[0] !== t) && (delete t[this._id], !0)
                    })), n(t.prototype, "get", (function (t) {
                        if (i(this, "get"), r(t)) {
                            var e = t[this._id];
                            return e && e[0] === t ? e[1] : void 0
                        }
                    })), n(t.prototype, "has", (function (t) {
                        if (i(this, "has"), !r(t)) return !1;
                        var e = t[this._id];
                        return !(!e || e[0] !== t)
                    })), n(t.prototype, "set", (function (t, e) {
                        if (i(this, "set"), !r(t)) throw new TypeError("Invalid value used as weak map key");
                        var s = t[this._id];
                        return s && s[0] === t ? (s[1] = e, this) : (n(t, this._id, [t, e]), this)
                    })), n(t, "_polyfill", !0), t
                }()
            }

            function r(t) {
                return Object(t) === t
            }
        }("undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : jo);
        var Vo, Go, Uo = (Vo = function (t) {
            !function (e, i, n) {
                i[e] = i[e] || n(), t.exports && (t.exports = i[e])
            }("Promise", jo, (function () {
                var t, e, i, n = Object.prototype.toString, r = "undefined" != typeof setImmediate ? function (t) {
                    return setImmediate(t)
                } : setTimeout;
                try {
                    Object.defineProperty({}, "x", {}), t = function (t, e, i, n) {
                        return Object.defineProperty(t, e, {value: i, writable: !0, configurable: !1 !== n})
                    }
                } catch (e) {
                    t = function (t, e, i) {
                        return t[e] = i, t
                    }
                }

                function s(t, n) {
                    i.add(t, n), e || (e = r(i.drain))
                }

                function a(t) {
                    var e, i = typeof t;
                    return null == t || "object" != i && "function" != i || (e = t.then), "function" == typeof e && e
                }

                function o() {
                    for (var t = 0; t < this.chain.length; t++) h(this, 1 === this.state ? this.chain[t].success : this.chain[t].failure, this.chain[t]);
                    this.chain.length = 0
                }

                function h(t, e, i) {
                    var n, r;
                    try {
                        !1 === e ? i.reject(t.msg) : (n = !0 === e ? t.msg : e.call(void 0, t.msg)) === i.promise ? i.reject(TypeError("Promise-chain cycle")) : (r = a(n)) ? r.call(n, i.resolve, i.reject) : i.resolve(n)
                    } catch (t) {
                        i.reject(t)
                    }
                }

                function l(t) {
                    var e, i = this;
                    if (!i.triggered) {
                        i.triggered = !0, i.def && (i = i.def);
                        try {
                            (e = a(t)) ? s((function () {
                                var n = new p(i);
                                try {
                                    e.call(t, (function () {
                                        l.apply(n, arguments)
                                    }), (function () {
                                        c.apply(n, arguments)
                                    }))
                                } catch (t) {
                                    c.call(n, t)
                                }
                            })) : (i.msg = t, i.state = 1, i.chain.length > 0 && s(o, i))
                        } catch (t) {
                            c.call(new p(i), t)
                        }
                    }
                }

                function c(t) {
                    var e = this;
                    e.triggered || (e.triggered = !0, e.def && (e = e.def), e.msg = t, e.state = 2, e.chain.length > 0 && s(o, e))
                }

                function u(t, e, i, n) {
                    for (var r = 0; r < e.length; r++) !function (r) {
                        t.resolve(e[r]).then((function (t) {
                            i(r, t)
                        }), n)
                    }(r)
                }

                function p(t) {
                    this.def = t, this.triggered = !1
                }

                function d(t) {
                    this.promise = t, this.state = 0, this.triggered = !1, this.chain = [], this.msg = void 0
                }

                function f(t) {
                    if ("function" != typeof t) throw TypeError("Not a function");
                    if (0 !== this.__NPO__) throw TypeError("Not a promise");
                    this.__NPO__ = 1;
                    var e = new d(this);
                    this.then = function (t, i) {
                        var n = {success: "function" != typeof t || t, failure: "function" == typeof i && i};
                        return n.promise = new this.constructor((function (t, e) {
                            if ("function" != typeof t || "function" != typeof e) throw TypeError("Not a function");
                            n.resolve = t, n.reject = e
                        })), e.chain.push(n), 0 !== e.state && s(o, e), n.promise
                    }, this.catch = function (t) {
                        return this.then(void 0, t)
                    };
                    try {
                        t.call(void 0, (function (t) {
                            l.call(e, t)
                        }), (function (t) {
                            c.call(e, t)
                        }))
                    } catch (t) {
                        c.call(e, t)
                    }
                }

                i = function () {
                    var t, i, n;

                    function r(t, e) {
                        this.fn = t, this.self = e, this.next = void 0
                    }

                    return {
                        add: function (e, s) {
                            n = new r(e, s), i ? i.next = n : t = n, i = n, n = void 0
                        }, drain: function () {
                            var n = t;
                            for (t = i = e = void 0; n;) n.fn.call(n.self), n = n.next
                        }
                    }
                }();
                var m = t({}, "constructor", f, !1);
                return f.prototype = m, t(m, "__NPO__", 0, !1), t(f, "resolve", (function (t) {
                    return t && "object" == typeof t && 1 === t.__NPO__ ? t : new this((function (e, i) {
                        if ("function" != typeof e || "function" != typeof i) throw TypeError("Not a function");
                        e(t)
                    }))
                })), t(f, "reject", (function (t) {
                    return new this((function (e, i) {
                        if ("function" != typeof e || "function" != typeof i) throw TypeError("Not a function");
                        i(t)
                    }))
                })), t(f, "all", (function (t) {
                    var e = this;
                    return "[object Array]" != n.call(t) ? e.reject(TypeError("Not an array")) : 0 === t.length ? e.resolve([]) : new e((function (i, n) {
                        if ("function" != typeof i || "function" != typeof n) throw TypeError("Not a function");
                        var r = t.length, s = Array(r), a = 0;
                        u(e, t, (function (t, e) {
                            s[t] = e, ++a === r && i(s)
                        }), n)
                    }))
                })), t(f, "race", (function (t) {
                    var e = this;
                    return "[object Array]" != n.call(t) ? e.reject(TypeError("Not an array")) : new e((function (i, n) {
                        if ("function" != typeof i || "function" != typeof n) throw TypeError("Not a function");
                        u(e, t, (function (t, e) {
                            i(e)
                        }), n)
                    }))
                })), f
            }))
        }, Vo(Go = {exports: {}}, Go.exports), Go.exports), Ho = new WeakMap;

        function Wo(t, e, i) {
            var n = Ho.get(t.element) || {};
            e in n || (n[e] = []), n[e].push(i), Ho.set(t.element, n)
        }

        function qo(t, e) {
            return (Ho.get(t.element) || {})[e] || []
        }

        function Xo(t, e, i) {
            var n = Ho.get(t.element) || {};
            if (!n[e]) return !0;
            if (!i) return n[e] = [], Ho.set(t.element, n), !0;
            var r = n[e].indexOf(i);
            return -1 !== r && n[e].splice(r, 1), Ho.set(t.element, n), n[e] && 0 === n[e].length
        }

        function Yo(t, e) {
            var i = Ho.get(t);
            Ho.set(e, i), Ho.delete(t)
        }

        var Zo = ["autopause", "autoplay", "background", "byline", "color", "controls", "dnt", "height", "id", "keyboard", "loop", "maxheight", "maxwidth", "muted", "playsinline", "portrait", "responsive", "speed", "texttrack", "title", "transparent", "url", "width"];

        function Jo(t) {
            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return Zo.reduce((function (e, i) {
                var n = t.getAttribute("data-vimeo-".concat(i));
                return (n || "" === n) && (e[i] = "" === n ? 1 : n), e
            }), e)
        }

        function Qo(t, e) {
            var i = t.html;
            if (!e) throw new TypeError("An element must be provided");
            if (null !== e.getAttribute("data-vimeo-initialized")) return e.querySelector("iframe");
            var n = document.createElement("div");
            return n.innerHTML = i, e.appendChild(n.firstChild), e.setAttribute("data-vimeo-initialized", "true"), e.querySelector("iframe")
        }

        function Ko(t) {
            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                i = arguments.length > 2 ? arguments[2] : void 0;
            return new Promise((function (n, r) {
                if (!Oo(t)) throw new TypeError("".concat(t, " is not a vimeo.com url."));
                var s = "https://vimeo.com/api/oembed.json?url=".concat(encodeURIComponent(t));
                for (var a in e) e.hasOwnProperty(a) && (s += "&".concat(a, "=").concat(encodeURIComponent(e[a])));
                var o = "XDomainRequest" in window ? new XDomainRequest : new XMLHttpRequest;
                o.open("GET", s, !0), o.onload = function () {
                    if (404 !== o.status) if (403 !== o.status) try {
                        var e = JSON.parse(o.responseText);
                        if (403 === e.domain_status_code) return Qo(e, i), void r(new Error("".concat(t, " is not embeddable.")));
                        n(e)
                    } catch (t) {
                        r(t)
                    } else r(new Error("".concat(t, " is not embeddable."))); else r(new Error("".concat(t, " was not found.")))
                }, o.onerror = function () {
                    var t = o.status ? " (".concat(o.status, ")") : "";
                    r(new Error("There was an error fetching the embed code from Vimeo".concat(t, ".")))
                }, o.send()
            }))
        }

        function $o(t) {
            if ("string" == typeof t) try {
                t = JSON.parse(t)
            } catch (t) {
                return console.warn(t), {}
            }
            return t
        }

        function th(t, e, i) {
            if (t.element.contentWindow && t.element.contentWindow.postMessage) {
                var n = {method: e};
                void 0 !== i && (n.value = i);
                var r = parseFloat(navigator.userAgent.toLowerCase().replace(/^.*msie (\d+).*$/, "$1"));
                r >= 8 && r < 10 && (n = JSON.stringify(n)), t.element.contentWindow.postMessage(n, t.origin)
            }
        }

        function eh(t, e) {
            var i, n = [];
            if ((e = $o(e)).event) {
                if ("error" === e.event) qo(t, e.data.method).forEach((function (i) {
                    var n = new Error(e.data.message);
                    n.name = e.data.name, i.reject(n), Xo(t, e.data.method, i)
                }));
                n = qo(t, "event:".concat(e.event)), i = e.data
            } else if (e.method) {
                var r = function (t, e) {
                    var i = qo(t, e);
                    if (i.length < 1) return !1;
                    var n = i.shift();
                    return Xo(t, e, n), n
                }(t, e.method);
                r && (n.push(r), i = e.value)
            }
            n.forEach((function (e) {
                try {
                    if ("function" == typeof e) return void e.call(t, i);
                    e.resolve(i)
                } catch (t) {
                }
            }))
        }

        var ih = new WeakMap, nh = new WeakMap, rh = {}, sh = function () {
            function t(e) {
                var i = this, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (Po(this, t), window.jQuery && e instanceof jQuery && (e.length > 1 && window.console && console.warn && console.warn("A jQuery object with multiple elements was passed, using the first element."), e = e[0]), "undefined" != typeof document && "string" == typeof e && (e = document.getElementById(e)), !Fo(e)) throw new TypeError("You must pass either a valid element or a valid id.");
                if ("IFRAME" !== e.nodeName) {
                    var r = e.querySelector("iframe");
                    r && (e = r)
                }
                if ("IFRAME" === e.nodeName && !Oo(e.getAttribute("src") || "")) throw new Error("The player element passed isnt a Vimeo embed.");
                if (ih.has(e)) return ih.get(e);
                this._window = e.ownerDocument.defaultView, this.element = e, this.origin = "*";
                var s = new Uo((function (t, r) {
                    if (i._onMessage = function (e) {
                        if (Oo(e.origin) && i.element.contentWindow === e.source) {
                            "*" === i.origin && (i.origin = e.origin);
                            var n = $o(e.data);
                            if (n && "error" === n.event && n.data && "ready" === n.data.method) {
                                var s = new Error(n.data.message);
                                return s.name = n.data.name, void r(s)
                            }
                            var a = n && "ready" === n.event, o = n && "ping" === n.method;
                            if (a || o) return i.element.setAttribute("data-ready", "true"), void t();
                            eh(i, n)
                        }
                    }, i._window.addEventListener("message", i._onMessage), "IFRAME" !== i.element.nodeName) {
                        var s = Jo(e, n);
                        Ko(zo(s), s, e).then((function (t) {
                            var n = Qo(t, e);
                            return i.element = n, i._originalElement = e, Yo(e, n), ih.set(i.element, i), t
                        })).catch(r)
                    }
                }));
                if (nh.set(this, s), ih.set(this.element, this), "IFRAME" === this.element.nodeName && th(this, "ping"), rh.isEnabled) {
                    var a = function () {
                        return rh.exit()
                    };
                    this.fullscreenchangeHandler = function () {
                        rh.isFullscreen ? Wo(i, "event:exitFullscreen", a) : Xo(i, "event:exitFullscreen", a), i.ready().then((function () {
                            th(i, "fullscreenchange", rh.isFullscreen)
                        }))
                    }, rh.on("fullscreenchange", this.fullscreenchangeHandler)
                }
                return this
            }

            var e, i, n;
            return e = t, i = [{
                key: "callMethod", value: function (t) {
                    var e = this, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    return new Uo((function (n, r) {
                        return e.ready().then((function () {
                            Wo(e, t, {resolve: n, reject: r}), th(e, t, i)
                        })).catch(r)
                    }))
                }
            }, {
                key: "get", value: function (t) {
                    var e = this;
                    return new Uo((function (i, n) {
                        return t = Ro(t, "get"), e.ready().then((function () {
                            Wo(e, t, {resolve: i, reject: n}), th(e, t)
                        })).catch(n)
                    }))
                }
            }, {
                key: "set", value: function (t, e) {
                    var i = this;
                    return new Uo((function (n, r) {
                        if (t = Ro(t, "set"), null == e) throw new TypeError("There must be a value to set.");
                        return i.ready().then((function () {
                            Wo(i, t, {resolve: n, reject: r}), th(i, t, e)
                        })).catch(r)
                    }))
                }
            }, {
                key: "on", value: function (t, e) {
                    if (!t) throw new TypeError("You must pass an event name.");
                    if (!e) throw new TypeError("You must pass a callback function.");
                    if ("function" != typeof e) throw new TypeError("The callback must be a function.");
                    0 === qo(this, "event:".concat(t)).length && this.callMethod("addEventListener", t).catch((function () {
                    })), Wo(this, "event:".concat(t), e)
                }
            }, {
                key: "off", value: function (t, e) {
                    if (!t) throw new TypeError("You must pass an event name.");
                    if (e && "function" != typeof e) throw new TypeError("The callback must be a function.");
                    Xo(this, "event:".concat(t), e) && this.callMethod("removeEventListener", t).catch((function (t) {
                    }))
                }
            }, {
                key: "loadVideo", value: function (t) {
                    return this.callMethod("loadVideo", t)
                }
            }, {
                key: "ready", value: function () {
                    var t = nh.get(this) || new Uo((function (t, e) {
                        e(new Error("Unknown player. Probably unloaded."))
                    }));
                    return Uo.resolve(t)
                }
            }, {
                key: "addCuePoint", value: function (t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    return this.callMethod("addCuePoint", {time: t, data: e})
                }
            }, {
                key: "removeCuePoint", value: function (t) {
                    return this.callMethod("removeCuePoint", t)
                }
            }, {
                key: "enableTextTrack", value: function (t, e) {
                    if (!t) throw new TypeError("You must pass a language.");
                    return this.callMethod("enableTextTrack", {language: t, kind: e})
                }
            }, {
                key: "disableTextTrack", value: function () {
                    return this.callMethod("disableTextTrack")
                }
            }, {
                key: "pause", value: function () {
                    return this.callMethod("pause")
                }
            }, {
                key: "play", value: function () {
                    return this.callMethod("play")
                }
            }, {
                key: "requestFullscreen", value: function () {
                    return rh.isEnabled ? rh.request(this.element) : this.callMethod("requestFullscreen")
                }
            }, {
                key: "exitFullscreen", value: function () {
                    return rh.isEnabled ? rh.exit() : this.callMethod("exitFullscreen")
                }
            }, {
                key: "getFullscreen", value: function () {
                    return rh.isEnabled ? Uo.resolve(rh.isFullscreen) : this.get("fullscreen")
                }
            }, {
                key: "requestPictureInPicture", value: function () {
                    return this.callMethod("requestPictureInPicture")
                }
            }, {
                key: "exitPictureInPicture", value: function () {
                    return this.callMethod("exitPictureInPicture")
                }
            }, {
                key: "getPictureInPicture", value: function () {
                    return this.get("pictureInPicture")
                }
            }, {
                key: "unload", value: function () {
                    return this.callMethod("unload")
                }
            }, {
                key: "destroy", value: function () {
                    var t = this;
                    return new Uo((function (e) {
                        if (nh.delete(t), ih.delete(t.element), t._originalElement && (ih.delete(t._originalElement), t._originalElement.removeAttribute("data-vimeo-initialized")), t.element && "IFRAME" === t.element.nodeName && t.element.parentNode && (t.element.parentNode.parentNode && t._originalElement && t._originalElement !== t.element.parentNode ? t.element.parentNode.parentNode.removeChild(t.element.parentNode) : t.element.parentNode.removeChild(t.element)), t.element && "DIV" === t.element.nodeName && t.element.parentNode) {
                            t.element.removeAttribute("data-vimeo-initialized");
                            var i = t.element.querySelector("iframe");
                            i && i.parentNode && (i.parentNode.parentNode && t._originalElement && t._originalElement !== i.parentNode ? i.parentNode.parentNode.removeChild(i.parentNode) : i.parentNode.removeChild(i))
                        }
                        t._window.removeEventListener("message", t._onMessage), rh.isEnabled && rh.off("fullscreenchange", t.fullscreenchangeHandler), e()
                    }))
                }
            }, {
                key: "getAutopause", value: function () {
                    return this.get("autopause")
                }
            }, {
                key: "setAutopause", value: function (t) {
                    return this.set("autopause", t)
                }
            }, {
                key: "getBuffered", value: function () {
                    return this.get("buffered")
                }
            }, {
                key: "getCameraProps", value: function () {
                    return this.get("cameraProps")
                }
            }, {
                key: "setCameraProps", value: function (t) {
                    return this.set("cameraProps", t)
                }
            }, {
                key: "getChapters", value: function () {
                    return this.get("chapters")
                }
            }, {
                key: "getCurrentChapter", value: function () {
                    return this.get("currentChapter")
                }
            }, {
                key: "getColor", value: function () {
                    return this.get("color")
                }
            }, {
                key: "setColor", value: function (t) {
                    return this.set("color", t)
                }
            }, {
                key: "getCuePoints", value: function () {
                    return this.get("cuePoints")
                }
            }, {
                key: "getCurrentTime", value: function () {
                    return this.get("currentTime")
                }
            }, {
                key: "setCurrentTime", value: function (t) {
                    return this.set("currentTime", t)
                }
            }, {
                key: "getDuration", value: function () {
                    return this.get("duration")
                }
            }, {
                key: "getEnded", value: function () {
                    return this.get("ended")
                }
            }, {
                key: "getLoop", value: function () {
                    return this.get("loop")
                }
            }, {
                key: "setLoop", value: function (t) {
                    return this.set("loop", t)
                }
            }, {
                key: "setMuted", value: function (t) {
                    return this.set("muted", t)
                }
            }, {
                key: "getMuted", value: function () {
                    return this.get("muted")
                }
            }, {
                key: "getPaused", value: function () {
                    return this.get("paused")
                }
            }, {
                key: "getPlaybackRate", value: function () {
                    return this.get("playbackRate")
                }
            }, {
                key: "setPlaybackRate", value: function (t) {
                    return this.set("playbackRate", t)
                }
            }, {
                key: "getPlayed", value: function () {
                    return this.get("played")
                }
            }, {
                key: "getQualities", value: function () {
                    return this.get("qualities")
                }
            }, {
                key: "getQuality", value: function () {
                    return this.get("quality")
                }
            }, {
                key: "setQuality", value: function (t) {
                    return this.set("quality", t)
                }
            }, {
                key: "getSeekable", value: function () {
                    return this.get("seekable")
                }
            }, {
                key: "getSeeking", value: function () {
                    return this.get("seeking")
                }
            }, {
                key: "getTextTracks", value: function () {
                    return this.get("textTracks")
                }
            }, {
                key: "getVideoEmbedCode", value: function () {
                    return this.get("videoEmbedCode")
                }
            }, {
                key: "getVideoId", value: function () {
                    return this.get("videoId")
                }
            }, {
                key: "getVideoTitle", value: function () {
                    return this.get("videoTitle")
                }
            }, {
                key: "getVideoWidth", value: function () {
                    return this.get("videoWidth")
                }
            }, {
                key: "getVideoHeight", value: function () {
                    return this.get("videoHeight")
                }
            }, {
                key: "getVideoUrl", value: function () {
                    return this.get("videoUrl")
                }
            }, {
                key: "getVolume", value: function () {
                    return this.get("volume")
                }
            }, {
                key: "setVolume", value: function (t) {
                    return this.set("volume", t)
                }
            }], i && Io(e.prototype, i), n && Io(e, n), t
        }();
        Lo || (rh = function () {
            var t = function () {
                for (var t, e = [["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"], ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror"], ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitCurrentFullScreenElement", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitfullscreenerror"], ["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror"], ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError"]], i = 0, n = e.length, r = {}; i < n; i++) if ((t = e[i]) && t[1] in document) {
                    for (i = 0; i < t.length; i++) r[e[0][i]] = t[i];
                    return r
                }
                return !1
            }(), e = {fullscreenchange: t.fullscreenchange, fullscreenerror: t.fullscreenerror}, i = {
                request: function (e) {
                    return new Promise((function (n, r) {
                        var s = function t() {
                            i.off("fullscreenchange", t), n()
                        };
                        i.on("fullscreenchange", s);
                        var a = (e = e || document.documentElement)[t.requestFullscreen]();
                        a instanceof Promise && a.then(s).catch(r)
                    }))
                }, exit: function () {
                    return new Promise((function (e, n) {
                        if (i.isFullscreen) {
                            var r = function t() {
                                i.off("fullscreenchange", t), e()
                            };
                            i.on("fullscreenchange", r);
                            var s = document[t.exitFullscreen]();
                            s instanceof Promise && s.then(r).catch(n)
                        } else e()
                    }))
                }, on: function (t, i) {
                    var n = e[t];
                    n && document.addEventListener(n, i)
                }, off: function (t, i) {
                    var n = e[t];
                    n && document.removeEventListener(n, i)
                }
            };
            return Object.defineProperties(i, {
                isFullscreen: {
                    get: function () {
                        return Boolean(document[t.fullscreenElement])
                    }
                }, element: {
                    enumerable: !0, get: function () {
                        return document[t.fullscreenElement]
                    }
                }, isEnabled: {
                    enumerable: !0, get: function () {
                        return Boolean(document[t.fullscreenEnabled])
                    }
                }
            }), i
        }(), function () {
            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : document,
                e = [].slice.call(t.querySelectorAll("[data-vimeo-id], [data-vimeo-url]")), i = function (t) {
                    "console" in window && console.error && console.error("There was an error creating an embed: ".concat(t))
                };
            e.forEach((function (t) {
                try {
                    if (null !== t.getAttribute("data-vimeo-defer")) return;
                    var e = Jo(t);
                    Ko(zo(e), e, t).then((function (e) {
                        return Qo(e, t)
                    })).catch(i)
                } catch (t) {
                    i(t)
                }
            }))
        }(), function () {
            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : document;
            if (!window.VimeoPlayerResizeEmbeds_) {
                window.VimeoPlayerResizeEmbeds_ = !0;
                var e = function (e) {
                    if (Oo(e.origin) && e.data && "spacechange" === e.data.event) for (var i = t.querySelectorAll("iframe"), n = 0; n < i.length; n++) if (i[n].contentWindow === e.source) {
                        i[n].parentElement.style.paddingBottom = "".concat(e.data.data[0].bottom, "px");
                        break
                    }
                };
                window.addEventListener("message", e)
            }
        }());
        const ah = sh;

        function oh(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }

        const hh = class {
            constructor(t) {
                oh(this, "onEnter", (() => {
                    var {coverImg: t} = this.ui;
                    xn.to(t, {duration: 2.25, scale: 1.05, ease: "expo"})
                })), oh(this, "onLeave", (() => {
                    var {coverImg: t} = this.ui;
                    xn.to(t, {duration: 1.75, scale: 1, ease: "expo"})
                })), oh(this, "onClick", (() => {
                    var t, {id: e, isLoaded: i, isPlaying: r} = this.state;
                    i ? r ? (this.player.pause(), this.state.isPlaying = !1) : (this.player.play(), this.state.isPlaying = !0) : (t = n.isSmooth ? {
                        id: e,
                        background: !0,
                        muted: !1
                    } : {
                        id: e,
                        autoplay: !0
                    }, this.player = new ah(this.el, t), this.player.setVolume(.5), this.player.ready().then((() => {
                        this.player.play(), this.state.isPlaying = !0, this.animateIn()
                    })), this.state.isLoaded = !0)
                })), this.el = t, this.ui = {
                    circle: this.el.querySelector(".js-vimeo__icon"),
                    cover: this.el.querySelector(".js-vimeo__cover"),
                    coverImg: this.el.querySelector(".js-vimeo__img")
                }, this.state = {id: this.el.dataset.videoId, isLoaded: !1, isPlaying: !1}, this.tl = null, this.init()
            }

            animateIn() {
                var {cover: t} = this.ui;
                xn.to(t, {duration: .5, autoAlpha: 0, ease: "linear"})
            }

            addListeners() {
                n.isDevice || (Eo(this.el, "a", "mouseenter", this.onEnter), Eo(this.el, "a", "mouseleave", this.onLeave)), Eo(this.el, "a", "click", this.onClick)
            }

            removeListeners() {
                n.isDevice || (Eo(this.el, "r", "mouseenter", this.onEnter), Eo(this.el, "r", "mouseleave", this.onLeave)), Eo(this.el, "r", "click", this.onClick)
            }

            destroy() {
                this.removeListeners(), this.player && this.player.destroy(), this.circle && this.circle.destroy(), this.ui = null, this.state = null
            }

            init() {
                this.addListeners(), n.isDevice || (this.circle = new Fa({el: this.ui.circle}))
            }
        };

        function lh(t, e, i, n, r, s, a) {
            try {
                var o = t[s](a), h = o.value
            } catch (t) {
                return void i(t)
            }
            o.done ? e(h) : Promise.resolve(h).then(n, r)
        }

        function ch(t) {
            return function () {
                var e = this, i = arguments;
                return new Promise((function (n, r) {
                    var s = t.apply(e, i);

                    function a(t) {
                        lh(s, n, r, a, o, "next", t)
                    }

                    function o(t) {
                        lh(s, n, r, a, o, "throw", t)
                    }

                    a(void 0)
                }))
            }
        }

        function uh(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }

        function ph(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }

        const dh = class {
            constructor() {
                ph(this, "render", (() => {
                    if (!this.state.isResizing) {
                        var t = this.state, e = this.elm;
                        t.current.a += (t.target - t.current.a) * t.ease.a, t.current.aRounded = Math.round(100 * t.current.a) / 100, t.current.b += (t.target - t.current.b) * t.ease.b, t.current.bRounded = Math.round(100 * t.current.b) / 100, t.current.c += (t.target - t.current.c) * t.ease.c, t.current.cRounded = Math.round(100 * t.current.c) / 100, e.bg.style.transform = "translate3d(".concat(-t.current.aRounded, "px, 0, 0)"), e.scrollbarOuter.style.transform = "translate3d(".concat(-t.current.aRounded, "px, 0, 0)")
                    }
                })), ph(this, "onResize", (() => {
                    this.state.isResizing = !0, this.setCache(), Vn.emit("resize:on-reset"), this.transformSlides();
                    var t = this.elm.slides[0].clientWidth,
                        e = this.elm.slides[this.elm.slides.length - 1].getBoundingClientRect();
                    this.state.scrollMax = e.right - window.innerWidth, this.elm.bg.style.width = e.right + t + "px", this.elm.scrollbarOuter.style.width = e.right - t / 2 + "px", this.state.isResizing = !1
                })), ph(this, "renderLoop", (() => {
                    this.render(), this.transformSlides(), this.transformProgress(), this.toggleClasses()
                })), ph(this, "slideTo", (t => {
                    var {currentTarget: e} = t, i = e.dataset.target, n = parseInt(i),
                        r = this.snapTargets.find((t => t.el == n));
                    null != r && (this.state.target = r.bound), this.elm.buttons.forEach((t => {
                        t.classList.remove("is-active")
                    })), e.classList.add("is-active")
                })), ph(this, "onDown", (t => {
                    var {x: e, y: i, target: n} = t;
                    if (n.closest(".c-slider")) {
                        var r = this.state, s = this.elm;
                        r.isGrabbing = !0, r.cancel.x = e, r.cancel.y = i, r.on = r.target + e * r.speed, s.wrap.classList.add("is-grabbing")
                    }
                })), ph(this, "onMove", (t => {
                    var {x: e, y: i, e: n} = t, r = this.state;
                    if (r.isGrabbing) {
                        var {cancel: s} = this.state;
                        Math.abs(e - s.x) > Math.abs(i - s.y) && n.cancelable && (n.preventDefault(), n.stopPropagation()), r.target = r.on - e * r.speed, this.clampTarget()
                    }
                })), ph(this, "onUp", (() => {
                    this.state.isGrabbing = !1, this.elm.wrap.classList.remove("is-grabbing")
                })), this.el = document.querySelector(".js-slider"), this.el && (this.elm = {
                    wrap: this.el.querySelector(".c-slider"),
                    wrapIn: this.el.querySelector(".c-slider__wrap-in"),
                    items: [...this.el.querySelectorAll(".js-slide-item")],
                    slides: [...this.el.querySelectorAll(".c-slider-item")],
                    arrow: this.el.querySelector(".js-slider-arrow"),
                    buttons: [...this.el.querySelectorAll(".c-slider-item-btn")],
                    scrollbarOuter: this.el.querySelector(".c-slider__scroll-bar"),
                    scrollbarInner: this.el.querySelector(".c-slider__scroll-bar-in"),
                    bg: this.el.querySelector(".c-slider__bg")
                }, this.state = {
                    mouseDownX: 0,
                    mouseUpX: 0,
                    scrollMin: 0,
                    scrollMax: 0,
                    isGrabbing: !1,
                    speed: n.isDevice ? 4 : 2,
                    current: {a: 0, aRounded: 0, b: 0, bRounded: 0, c: 0, cRounded: 0},
                    target: 0,
                    ease: {a: .09, b: .08, c: .08},
                    cancel: {x: 0, y: 0},
                    on: 0,
                    progress: 0,
                    threshold: 200,
                    isResizing: !1,
                    length: this.elm.items.length - 1,
                    window: window.innerWidth
                }, this.events = {
                    move: n.isDevice ? "touchmove" : "mousemove",
                    up: n.isDevice ? "touchend" : "mouseup",
                    down: n.isDevice ? "touchstart" : "mousedown"
                }, this.init())
            }

            setProps() {
                var t = this.elm.slides[0].clientWidth,
                    e = this.elm.slides[this.elm.slides.length - 1].getBoundingClientRect();
                this.state.scrollMax = e.right - window.innerWidth, this.elm.bg.style.width = e.right + t + "px", this.elm.scrollbarOuter.style.width = e.right - t / 2 + "px", this.snapPoints = [], this.snapTargets = [];
                for (var i = 0; i < this.elm.items.length; i++) {
                    var n = this.elm.items[i].getBoundingClientRect().left;
                    this.snapPoints.push(n)
                }
                for (i = 0; i < this.elm.slides.length; i++) {
                    var r = this.elm.slides[i].getBoundingClientRect().left;
                    this.snapTargets.push({el: i, bound: r})
                }
            }

            init() {
                this.setProps(), this.on()
            }

            transformProgress() {
                var t = this.state;
                t.progress = t.current.aRounded / t.scrollMax, t.progress = Math.min(Math.max(t.progress, 0), 1), this.elm.scrollbarInner && (this.elm.scrollbarInner.style.transform = "scaleX(".concat(t.progress, ")"))
            }

            transformSlides() {
                for (var t = this.state, e = 0; e <= this.state.length; e++) {
                    var i = this.cache[e], n = t.current[i.ease + "Rounded"], r = this.isVisible(i, n),
                        s = "translate3d(".concat(-n, "px, 0, 0) rotate(0.001deg)");
                    r ? (i.out = !1, i.el.style.transform = s) : i.out || (i.out = !0, i.el.style.transform = s)
                }
            }

            isVisible(t, e) {
                var {start: i, end: n} = t;
                return e > i && e < n
            }

            setCache() {
                this.cache = [], this.elm.items.forEach(((t, e) => {
                    t.style.transform = "translate3d(0, 0, 0)";
                    var {left: i, right: r, width: s} = t.getBoundingClientRect(), a = t.dataset.ease,
                        o = i - window.innerWidth - 100, h = r + 100;
                    this.cache.push({el: t, start: o, end: h, ease: n.isPhone ? "a" : a || "a", out: !1})
                }))
            }

            clampTarget() {
                this.state.target = xn.utils.clamp(this.state.scrollMin, this.state.scrollMax, this.state.target)
            }

            toggleClasses() {
                var {scrollbarOuter: t, items: e} = this.elm, {current: i, scrollMin: n, scrollMax: r} = this.state;
                parseInt(i.aRounded) >= parseInt(r) ? t.classList.add("is-scrollMax") : t.classList.remove("is-scrollMax")
            }

            destroy() {
                Vn.off(Da.TICK, this.renderLoop), Vn.off(wa.RESIZE, this.onResize), Vn.off(Ma.DOWN, this.onDown), Vn.off(Ma.MOVE, this.onMove), Vn.off(Ma.UP, this.onUp)
            }

            addEvents() {
                Vn.on(Da.TICK, this.renderLoop), Vn.on(wa.RESIZE, this.onResize), Vn.on(Ma.DOWN, this.onDown), Vn.on(Ma.MOVE, this.onMove), Vn.on(Ma.UP, this.onUp), this.elm.buttons.forEach((t => Eo(t, "a", "click", this.slideTo))), Eo(this.elm.arrow, "a", "click", this.slideTo)
            }

            on() {
                this.setCache(), this.addEvents(), this.renderLoop()
            }
        };

        function fh(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }

        function mh(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }

        xn.registerPlugin($s, uo);

        function gh(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }

        function vh() {
            fetch("https://api.openweathermap.org/data/2.5/onecall?lat=45.28&lon=-111.37&units=imperial&appid=b64cbbf6a28594ead949ee0c80b314e0").then((t => t.json())).then((t => {
                !function (t) {
                    var e = t, i = e.current, n = e.daily.splice(1, 4), r = {
                        main: {
                            w: fo(".js-main-w span"),
                            ws: fo(".js-main-ws span"),
                            tmax: fo(".js-main-tmax span"),
                            tmin: fo(".js-main-tmin span"),
                            hum: fo(".js-main-hum span"),
                            ski: {
                                w: fo(".js-ski-main-w span"),
                                ws: fo(".js-ski-main-ws span"),
                                temp: fo(".js-ski-main-temp span"),
                                sub: {w: fo(".js-ski-sub-w span"), ws: fo(".js-ski-sub-ws span")}
                            }
                        }, week: fo(".js-week")
                    };

                    function s() {
                        var {w: t, ws: n, tmax: s, tmin: a, hum: h, ski: l} = r.main, c = i.weather[0];
                        t.textContent = c.description, fo(".js-icon", t.parentNode).innerHTML = o(c.main), n.textContent = "".concat(i.wind_speed, "mph"), s.textContent = "".concat(e.daily[0].temp.max, "F"), a.textContent = "".concat(e.daily[0].temp.min, "F"), h.textContent = "".concat(i.humidity, "%"), l.w.textContent = c.description, fo(".js-icon", l.w.parentNode).innerHTML = o(c.main), l.ws.textContent = "".concat(i.wind_speed, "mph"), l.temp.textContent = "".concat(parseInt(i.temp), "F"), l.sub.w.textContent = c.description, fo(".js-icon", l.sub.w.parentNode).innerHTML = o(c.main), l.sub.ws.textContent = "".concat(i.wind_speed, "mph")
                    }

                    function a() {
                        n.forEach((t => {
                            r.week.appendChild(h(t))
                        }))
                    }

                    function o() {
                        var t,
                            e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "sun").toLowerCase();
                        return t = e.includes("sun") && e.includes("cloud") ? "mixed" : e.includes("snow") ? "snow" : e.includes("sun") ? "sun" : e.includes("cloud") ? "cloud" : "mixed", '\n      <svg class="o-icon icon-'.concat(t, ' mr10">\n        <use xlink:href="#icon-').concat(t, '"></use>\n      </svg>  \n    ')
                    }

                    function h(t) {
                        var e = document.createElement("li");
                        return e.classList.add("day", "df"), e.innerHTML = '\n      <li class="day x df aic">\n        <span class="day__day db w25 nowrap">'.concat(l(t.dt), '</span>\n        <span class="day__icon df aic w20 tc nowrap">').concat(o(t.weather[0].main), '</span>\n        <span class="day__temp db nowrap">').concat(parseInt(t.temp.min), "/").concat(parseInt(t.temp.max), '</span>\n        <span class="day__temp db nowrap mla">WS ').concat(t.wind_speed, " mph</span>\n      </li>\n    "), e
                    }

                    function l(t) {
                        return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][new Date(1e3 * t).getDay()]
                    }

                    s(), a()
                }(t)
            }))
        }

        xn.registerPlugin($s);

        function yh(t, e, i, n, r, s, a) {
            try {
                var o = t[s](a), h = o.value
            } catch (t) {
                return void i(t)
            }
            o.done ? e(h) : Promise.resolve(h).then(n, r)
        }

        function bh(t) {
            return function () {
                var e = this, i = arguments;
                return new Promise((function (n, r) {
                    var s = t.apply(e, i);

                    function a(t) {
                        yh(s, n, r, a, o, "next", t)
                    }

                    function o(t) {
                        yh(s, n, r, a, o, "throw", t)
                    }

                    a(void 0)
                }))
            }
        }

        function xh(t) {
            return xh = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, xh(t)
        }

        function wh(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }

        function _h(t, e) {
            for (var i = 0; i < e.length; i++) {
                var n = e[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
            }
        }

        function Eh(t, e, i) {
            return e && _h(t.prototype, e), i && _h(t, i), t
        }

        function Mh(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }

        function Ah(t, e) {
            var i = Object.keys(t);
            if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(t);
                e && (n = n.filter((function (e) {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                }))), i.push.apply(i, n)
            }
            return i
        }

        function Sh(t) {
            for (var e = 1; e < arguments.length; e++) {
                var i = null != arguments[e] ? arguments[e] : {};
                e % 2 ? Ah(Object(i), !0).forEach((function (e) {
                    Mh(t, e, i[e])
                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : Ah(Object(i)).forEach((function (e) {
                    Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e))
                }))
            }
            return t
        }

        function Th(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), e && Ch(t, e)
        }

        function Dh(t) {
            return Dh = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            }, Dh(t)
        }

        function Ch(t, e) {
            return Ch = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            }, Ch(t, e)
        }

        function Ph(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }

        function Ih(t, e) {
            return !e || "object" != typeof e && "function" != typeof e ? Ph(t) : e
        }

        function Lh(t) {
            var e = function () {
                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                if (Reflect.construct.sham) return !1;
                if ("function" == typeof Proxy) return !0;
                try {
                    return Date.prototype.toString.call(Reflect.construct(Date, [], (function () {
                    }))), !0
                } catch (t) {
                    return !1
                }
            }();
            return function () {
                var i, n = Dh(t);
                if (e) {
                    var r = Dh(this).constructor;
                    i = Reflect.construct(n, arguments, r)
                } else i = n.apply(this, arguments);
                return Ih(this, i)
            }
        }

        function Rh(t, e, i) {
            return Rh = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, i) {
                var n = function (t, e) {
                    for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = Dh(t));) ;
                    return t
                }(t, e);
                if (n) {
                    var r = Object.getOwnPropertyDescriptor(n, e);
                    return r.get ? r.get.call(i) : r.value
                }
            }, Rh(t, e, i || t)
        }

        function Fh(t, e) {
            return function (t) {
                if (Array.isArray(t)) return t
            }(t) || function (t, e) {
                if ("undefined" == typeof Symbol || !(Symbol.iterator in Object(t))) return;
                var i = [], n = !0, r = !1, s = void 0;
                try {
                    for (var a, o = t[Symbol.iterator](); !(n = (a = o.next()).done) && (i.push(a.value), !e || i.length !== e); n = !0) ;
                } catch (t) {
                    r = !0, s = t
                } finally {
                    try {
                        n || null == o.return || o.return()
                    } finally {
                        if (r) throw s
                    }
                }
                return i
            }(t, e) || Oh(t, e) || function () {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function kh(t) {
            return function (t) {
                if (Array.isArray(t)) return zh(t)
            }(t) || function (t) {
                if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
            }(t) || Oh(t) || function () {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function Oh(t, e) {
            if (t) {
                if ("string" == typeof t) return zh(t, e);
                var i = Object.prototype.toString.call(t).slice(8, -1);
                return "Object" === i && t.constructor && (i = t.constructor.name), "Map" === i || "Set" === i ? Array.from(t) : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? zh(t, e) : void 0
            }
        }

        function zh(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];
            return n
        }

        var Bh = Float32Array;

        function Nh(t, e, i) {
            var n = new Bh(3);
            return t && (n[0] = t), e && (n[1] = e), i && (n[2] = i), n
        }

        function jh(t, e, i) {
            return (i = i || new Bh(3))[0] = t[0] + e[0], i[1] = t[1] + e[1], i[2] = t[2] + e[2], i
        }

        function Vh(t, e, i) {
            i = i || new Bh(3);
            var n = t[2] * e[0] - t[0] * e[2], r = t[0] * e[1] - t[1] * e[0];
            return i[0] = t[1] * e[2] - t[2] * e[1], i[1] = n, i[2] = r, i
        }

        function Gh(t, e) {
            e = e || new Bh(3);
            var i = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], n = Math.sqrt(i);
            return n > 1e-5 ? (e[0] = t[0] / n, e[1] = t[1] / n, e[2] = t[2] / n) : (e[0] = 0, e[1] = 0, e[2] = 0), e
        }

        var Uh, Hh, Wh, qh = Float32Array;

        function Xh(t, e) {
            return (e = e || new qh(16))[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e
        }

        function Yh(t) {
            return (t = t || new qh(16))[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
        }

        function Zh(t, e) {
            e = e || new qh(16);
            var i = t[0], n = t[1], r = t[2], s = t[3], a = t[4], o = t[5], h = t[6], l = t[7], c = t[8], u = t[9],
                p = t[10], d = t[11], f = t[12], m = t[13], g = t[14], v = t[15], y = p * v, b = g * d, x = h * v,
                w = g * l, _ = h * d, E = p * l, M = r * v, A = g * s, S = r * d, T = p * s, D = r * l, C = h * s,
                P = c * m, I = f * u, L = a * m, R = f * o, F = a * u, k = c * o, O = i * m, z = f * n, B = i * u,
                N = c * n, j = i * o, V = a * n, G = y * o + w * u + _ * m - (b * o + x * u + E * m),
                U = b * n + M * u + T * m - (y * n + A * u + S * m),
                H = x * n + A * o + D * m - (w * n + M * o + C * m),
                W = E * n + S * o + C * u - (_ * n + T * o + D * u), q = 1 / (i * G + a * U + c * H + f * W);
            return e[0] = q * G, e[1] = q * U, e[2] = q * H, e[3] = q * W, e[4] = q * (b * a + x * c + E * f - (y * a + w * c + _ * f)), e[5] = q * (y * i + A * c + S * f - (b * i + M * c + T * f)), e[6] = q * (w * i + M * a + C * f - (x * i + A * a + D * f)), e[7] = q * (_ * i + T * a + D * c - (E * i + S * a + C * c)), e[8] = q * (P * l + R * d + F * v - (I * l + L * d + k * v)), e[9] = q * (I * s + O * d + N * v - (P * s + z * d + B * v)), e[10] = q * (L * s + z * l + j * v - (R * s + O * l + V * v)), e[11] = q * (k * s + B * l + V * d - (F * s + N * l + j * d)), e[12] = q * (L * p + k * g + I * h - (F * g + P * h + R * p)), e[13] = q * (B * g + P * r + z * p - (O * p + N * g + I * r)), e[14] = q * (O * h + V * g + R * r - (j * g + L * r + z * h)), e[15] = q * (j * p + F * r + N * h - (B * h + V * p + k * r)), e
        }

        function Jh(t, e, i) {
            i = i || Nh();
            var n = e[0], r = e[1], s = e[2], a = n * t[3] + r * t[7] + s * t[11] + t[15];
            return i[0] = (n * t[0] + r * t[4] + s * t[8] + t[12]) / a, i[1] = (n * t[1] + r * t[5] + s * t[9] + t[13]) / a, i[2] = (n * t[2] + r * t[6] + s * t[10] + t[14]) / a, i
        }

        function Qh(t, e, i) {
            i = i || Nh();
            var n = e[0], r = e[1], s = e[2];
            return i[0] = n * t[0] + r * t[4] + s * t[8], i[1] = n * t[1] + r * t[5] + s * t[9], i[2] = n * t[2] + r * t[6] + s * t[10], i
        }

        var Kh = Object.freeze({
            __proto__: null, axisRotate: function (t, e, i, n) {
                n = n || new qh(16);
                var r = e[0], s = e[1], a = e[2], o = Math.sqrt(r * r + s * s + a * a), h = (r /= o) * r,
                    l = (s /= o) * s, c = (a /= o) * a, u = Math.cos(i), p = Math.sin(i), d = 1 - u,
                    f = h + (1 - h) * u, m = r * s * d + a * p, g = r * a * d - s * p, v = r * s * d - a * p,
                    y = l + (1 - l) * u, b = s * a * d + r * p, x = r * a * d + s * p, w = s * a * d - r * p,
                    _ = c + (1 - c) * u, E = t[0], M = t[1], A = t[2], S = t[3], T = t[4], D = t[5], C = t[6], P = t[7],
                    I = t[8], L = t[9], R = t[10], F = t[11];
                return n[0] = f * E + m * T + g * I, n[1] = f * M + m * D + g * L, n[2] = f * A + m * C + g * R, n[3] = f * S + m * P + g * F, n[4] = v * E + y * T + b * I, n[5] = v * M + y * D + b * L, n[6] = v * A + y * C + b * R, n[7] = v * S + y * P + b * F, n[8] = x * E + w * T + _ * I, n[9] = x * M + w * D + _ * L, n[10] = x * A + w * C + _ * R, n[11] = x * S + w * P + _ * F, t !== n && (n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15]), n
            }, axisRotation: function (t, e, i) {
                i = i || new qh(16);
                var n = t[0], r = t[1], s = t[2], a = Math.sqrt(n * n + r * r + s * s), o = (n /= a) * n,
                    h = (r /= a) * r, l = (s /= a) * s, c = Math.cos(e), u = Math.sin(e), p = 1 - c;
                return i[0] = o + (1 - o) * c, i[1] = n * r * p + s * u, i[2] = n * s * p - r * u, i[3] = 0, i[4] = n * r * p - s * u, i[5] = h + (1 - h) * c, i[6] = r * s * p + n * u, i[7] = 0, i[8] = n * s * p + r * u, i[9] = r * s * p - n * u, i[10] = l + (1 - l) * c, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i
            }, copy: Xh, frustum: function (t, e, i, n, r, s, a) {
                var o = e - t, h = n - i, l = r - s;
                return (a = a || new qh(16))[0] = 2 * r / o, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 2 * r / h, a[6] = 0, a[7] = 0, a[8] = (t + e) / o, a[9] = (n + i) / h, a[10] = s / l, a[11] = -1, a[12] = 0, a[13] = 0, a[14] = r * s / l, a[15] = 0, a
            }, getAxis: function (t, e, i) {
                var n = 4 * e;
                return (i = i || Nh())[0] = t[n + 0], i[1] = t[n + 1], i[2] = t[n + 2], i
            }, getTranslation: function (t, e) {
                return (e = e || Nh())[0] = t[12], e[1] = t[13], e[2] = t[14], e
            }, identity: Yh, inverse: Zh, lookAt: function (t, e, i, n) {
                return n = n || new qh(16), Uh = Uh || Nh(), Hh = Hh || Nh(), Gh(function (t, e, i) {
                    return (i = i || new Bh(3))[0] = t[0] - e[0], i[1] = t[1] - e[1], i[2] = t[2] - e[2], i
                }(t, e, Wh = Wh || Nh()), Wh), Gh(Vh(i, Wh, Uh), Uh), Gh(Vh(Wh, Uh, Hh), Hh), n[0] = Uh[0], n[1] = Uh[1], n[2] = Uh[2], n[3] = 0, n[4] = Hh[0], n[5] = Hh[1], n[6] = Hh[2], n[7] = 0, n[8] = Wh[0], n[9] = Wh[1], n[10] = Wh[2], n[11] = 0, n[12] = t[0], n[13] = t[1], n[14] = t[2], n[15] = 1, n
            }, multiply: function (t, e, i) {
                i = i || new qh(16);
                var n = t[0], r = t[1], s = t[2], a = t[3], o = t[4], h = t[5], l = t[6], c = t[7], u = t[8], p = t[9],
                    d = t[10], f = t[11], m = t[12], g = t[13], v = t[14], y = t[15], b = e[0], x = e[1], w = e[2],
                    _ = e[3], E = e[4], M = e[5], A = e[6], S = e[7], T = e[8], D = e[9], C = e[10], P = e[11],
                    I = e[12], L = e[13], R = e[14], F = e[15];
                return i[0] = n * b + o * x + u * w + m * _, i[1] = r * b + h * x + p * w + g * _, i[2] = s * b + l * x + d * w + v * _, i[3] = a * b + c * x + f * w + y * _, i[4] = n * E + o * M + u * A + m * S, i[5] = r * E + h * M + p * A + g * S, i[6] = s * E + l * M + d * A + v * S, i[7] = a * E + c * M + f * A + y * S, i[8] = n * T + o * D + u * C + m * P, i[9] = r * T + h * D + p * C + g * P, i[10] = s * T + l * D + d * C + v * P, i[11] = a * T + c * D + f * C + y * P, i[12] = n * I + o * L + u * R + m * F, i[13] = r * I + h * L + p * R + g * F, i[14] = s * I + l * L + d * R + v * F, i[15] = a * I + c * L + f * R + y * F, i
            }, negate: function (t, e) {
                return (e = e || new qh(16))[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = -t[3], e[4] = -t[4], e[5] = -t[5], e[6] = -t[6], e[7] = -t[7], e[8] = -t[8], e[9] = -t[9], e[10] = -t[10], e[11] = -t[11], e[12] = -t[12], e[13] = -t[13], e[14] = -t[14], e[15] = -t[15], e
            }, ortho: function (t, e, i, n, r, s, a) {
                return (a = a || new qh(16))[0] = 2 / (e - t), a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 2 / (n - i), a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 2 / (r - s), a[11] = 0, a[12] = (e + t) / (t - e), a[13] = (n + i) / (i - n), a[14] = (s + r) / (r - s), a[15] = 1, a
            }, perspective: function (t, e, i, n, r) {
                r = r || new qh(16);
                var s = Math.tan(.5 * Math.PI - .5 * t), a = 1 / (i - n);
                return r[0] = s / e, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = s, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = (i + n) * a, r[11] = -1, r[12] = 0, r[13] = 0, r[14] = i * n * a * 2, r[15] = 0, r
            }, rotateX: function (t, e, i) {
                i = i || new qh(16);
                var n = t[4], r = t[5], s = t[6], a = t[7], o = t[8], h = t[9], l = t[10], c = t[11], u = Math.cos(e),
                    p = Math.sin(e);
                return i[4] = u * n + p * o, i[5] = u * r + p * h, i[6] = u * s + p * l, i[7] = u * a + p * c, i[8] = u * o - p * n, i[9] = u * h - p * r, i[10] = u * l - p * s, i[11] = u * c - p * a, t !== i && (i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i
            }, rotateY: function (t, e, i) {
                i = i || new qh(16);
                var n = t[0], r = t[1], s = t[2], a = t[3], o = t[8], h = t[9], l = t[10], c = t[11], u = Math.cos(e),
                    p = Math.sin(e);
                return i[0] = u * n - p * o, i[1] = u * r - p * h, i[2] = u * s - p * l, i[3] = u * a - p * c, i[8] = u * o + p * n, i[9] = u * h + p * r, i[10] = u * l + p * s, i[11] = u * c + p * a, t !== i && (i[4] = t[4], i[5] = t[5], i[6] = t[6], i[7] = t[7], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i
            }, rotateZ: function (t, e, i) {
                i = i || new qh(16);
                var n = t[0], r = t[1], s = t[2], a = t[3], o = t[4], h = t[5], l = t[6], c = t[7], u = Math.cos(e),
                    p = Math.sin(e);
                return i[0] = u * n + p * o, i[1] = u * r + p * h, i[2] = u * s + p * l, i[3] = u * a + p * c, i[4] = u * o - p * n, i[5] = u * h - p * r, i[6] = u * l - p * s, i[7] = u * c - p * a, t !== i && (i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i
            }, rotationX: function (t, e) {
                e = e || new qh(16);
                var i = Math.cos(t), n = Math.sin(t);
                return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = i, e[6] = n, e[7] = 0, e[8] = 0, e[9] = -n, e[10] = i, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
            }, rotationY: function (t, e) {
                e = e || new qh(16);
                var i = Math.cos(t), n = Math.sin(t);
                return e[0] = i, e[1] = 0, e[2] = -n, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = n, e[9] = 0, e[10] = i, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
            }, rotationZ: function (t, e) {
                e = e || new qh(16);
                var i = Math.cos(t), n = Math.sin(t);
                return e[0] = i, e[1] = n, e[2] = 0, e[3] = 0, e[4] = -n, e[5] = i, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
            }, scale: function (t, e, i) {
                i = i || new qh(16);
                var n = e[0], r = e[1], s = e[2];
                return i[0] = n * t[0], i[1] = n * t[1], i[2] = n * t[2], i[3] = n * t[3], i[4] = r * t[4], i[5] = r * t[5], i[6] = r * t[6], i[7] = r * t[7], i[8] = s * t[8], i[9] = s * t[9], i[10] = s * t[10], i[11] = s * t[11], t !== i && (i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i
            }, scaling: function (t, e) {
                return (e = e || new qh(16))[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = t[1], e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = t[2], e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
            }, setAxis: function (t, e, i, n) {
                n !== t && (n = Xh(t, n));
                var r = 4 * i;
                return n[r + 0] = e[0], n[r + 1] = e[1], n[r + 2] = e[2], n
            }, setDefaultType: function (t) {
                var e = qh;
                return qh = t, e
            }, setTranslation: function (t, e, i) {
                return t !== (i = i || Yh()) && (i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[4] = t[4], i[5] = t[5], i[6] = t[6], i[7] = t[7], i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11]), i[12] = e[0], i[13] = e[1], i[14] = e[2], i[15] = 1, i
            }, transformDirection: Qh, transformNormal: function (t, e, i) {
                i = i || Nh();
                var n = Zh(t), r = e[0], s = e[1], a = e[2];
                return i[0] = r * n[0] + s * n[1] + a * n[2], i[1] = r * n[4] + s * n[5] + a * n[6], i[2] = r * n[8] + s * n[9] + a * n[10], i
            }, transformPoint: Jh, translate: function (t, e, i) {
                i = i || new qh(16);
                var n = e[0], r = e[1], s = e[2], a = t[0], o = t[1], h = t[2], l = t[3], c = t[4], u = t[5], p = t[6],
                    d = t[7], f = t[8], m = t[9], g = t[10], v = t[11], y = t[12], b = t[13], x = t[14], w = t[15];
                return t !== i && (i[0] = a, i[1] = o, i[2] = h, i[3] = l, i[4] = c, i[5] = u, i[6] = p, i[7] = d, i[8] = f, i[9] = m, i[10] = g, i[11] = v), i[12] = a * n + c * r + f * s + y, i[13] = o * n + u * r + m * s + b, i[14] = h * n + p * r + g * s + x, i[15] = l * n + d * r + v * s + w, i
            }, translation: function (t, e) {
                return (e = e || new qh(16))[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = t[0], e[13] = t[1], e[14] = t[2], e[15] = 1, e
            }, transpose: function (t, e) {
                var i;
                if ((e = e || new qh(16)) === t) return i = t[1], t[1] = t[4], t[4] = i, i = t[2], t[2] = t[8], t[8] = i, i = t[3], t[3] = t[12], t[12] = i, i = t[6], t[6] = t[9], t[9] = i, i = t[7], t[7] = t[13], t[13] = i, i = t[11], t[11] = t[14], t[14] = i, e;
                var n = t[0], r = t[1], s = t[2], a = t[3], o = t[4], h = t[5], l = t[6], c = t[7], u = t[8], p = t[9],
                    d = t[10], f = t[11], m = t[12], g = t[13], v = t[14], y = t[15];
                return e[0] = n, e[1] = o, e[2] = u, e[3] = m, e[4] = r, e[5] = h, e[6] = p, e[7] = g, e[8] = s, e[9] = l, e[10] = d, e[11] = v, e[12] = a, e[13] = c, e[14] = f, e[15] = y, e
            }
        }), $h = 5120, tl = 5121, el = 5122, il = 5123, nl = 5124, rl = 5125, sl = 5126, al = {}, ol = al;

        function hl(t) {
            if (t instanceof Int8Array) return $h;
            if (t instanceof Uint8Array) return tl;
            if (t instanceof Uint8ClampedArray) return tl;
            if (t instanceof Int16Array) return el;
            if (t instanceof Uint16Array) return il;
            if (t instanceof Int32Array) return nl;
            if (t instanceof Uint32Array) return rl;
            if (t instanceof Float32Array) return sl;
            throw new Error("unsupported typed array type")
        }

        ol[$h] = Int8Array, ol[5121] = Uint8Array, ol[5122] = Int16Array, ol[5123] = Uint16Array, ol[nl] = Int32Array, ol[5125] = Uint32Array, ol[5126] = Float32Array, ol[32819] = Uint16Array, ol[32820] = Uint16Array, ol[33635] = Uint16Array, ol[5131] = Uint16Array, ol[33640] = Uint32Array, ol[35899] = Uint32Array, ol[35902] = Uint32Array, ol[36269] = Uint32Array, ol[34042] = Uint32Array;
        var ll = "undefined" != typeof SharedArrayBuffer ? function (t) {
            return t && t.buffer && (t.buffer instanceof ArrayBuffer || t.buffer instanceof SharedArrayBuffer)
        } : function (t) {
            return t && t.buffer && t.buffer instanceof ArrayBuffer
        };

        function cl() {
            var t;
            (t = console).error.apply(t, arguments)
        }

        function ul() {
            var t;
            (t = console).warn.apply(t, arguments)
        }

        function pl(t, e) {
            return "undefined" != typeof WebGLShader && e instanceof WebGLShader
        }

        function dl(t, e) {
            return "undefined" != typeof WebGLTexture && e instanceof WebGLTexture
        }

        var fl = 34962, ml = "";

        function gl(t, e, i, n, r) {
            t.bindBuffer(e, i), t.bufferData(e, n, r || 35044)
        }

        function vl(t, e, i, n) {
            if (function (t, e) {
                return "undefined" != typeof WebGLBuffer && e instanceof WebGLBuffer
            }(0, e)) return e;
            i = i || fl;
            var r = t.createBuffer();
            return gl(t, i, r, e, n), r
        }

        function yl(t) {
            return "indices" === t
        }

        function bl(t) {
            return t.length ? t : t.data
        }

        var xl = /coord|texture/i, wl = /color|colour/i;

        function _l(t, e) {
            var i;
            if (e % (i = xl.test(t) ? 2 : wl.test(t) ? 4 : 3) > 0) throw new Error("Can not guess numComponents for attribute '".concat(t, "'. Tried ").concat(i, " but ").concat(e, " values is not evenly divisible by ").concat(i, ". You should specify it."));
            return i
        }

        function El(t, e) {
            return t.numComponents || t.size || _l(e, bl(t).length)
        }

        function Ml(t, e) {
            if (ll(t)) return t;
            if (ll(t.data)) return t.data;
            Array.isArray(t) && (t = {data: t});
            var i = t.type;
            return i || (i = yl(e) ? Uint16Array : Float32Array), new i(t.data)
        }

        function Al(t, e) {
            var i = {};
            return Object.keys(e).forEach((function (n) {
                if (!yl(n)) {
                    var r = e[n], s = r.attrib || r.name || r.attribName || ml + n;
                    if (r.value) {
                        if (!Array.isArray(r.value) && !ll(r.value)) throw new Error("array.value is not array or typedarray");
                        i[s] = {value: r.value}
                    } else {
                        var a, o, h, l;
                        if (r.buffer && r.buffer instanceof WebGLBuffer) a = r.buffer, l = r.numComponents || r.size, o = r.type, h = r.normalize; else if ("number" == typeof r || "number" == typeof r.data) {
                            var c = r.data || r, u = r.type || Float32Array, p = c * u.BYTES_PER_ELEMENT;
                            o = function (t) {
                                if (t === Int8Array) return $h;
                                if (t === Uint8Array) return tl;
                                if (t === Uint8ClampedArray) return tl;
                                if (t === Int16Array) return el;
                                if (t === Uint16Array) return il;
                                if (t === Int32Array) return nl;
                                if (t === Uint32Array) return rl;
                                if (t === Float32Array) return sl;
                                throw new Error("unsupported typed array type")
                            }(u), h = void 0 !== r.normalize ? r.normalize : (f = u) === Int8Array || f === Uint8Array, l = r.numComponents || r.size || _l(n, c), a = t.createBuffer(), t.bindBuffer(fl, a), t.bufferData(fl, p, r.drawType || 35044)
                        } else {
                            var d = Ml(r, n);
                            a = vl(t, d, void 0, r.drawType), o = hl(d), h = void 0 !== r.normalize ? r.normalize : function (t) {
                                return t instanceof Int8Array || t instanceof Uint8Array
                            }(d), l = El(r, n)
                        }
                        i[s] = {
                            buffer: a,
                            numComponents: l,
                            type: o,
                            normalize: h,
                            stride: r.stride || 0,
                            offset: r.offset || 0,
                            divisor: void 0 === r.divisor ? void 0 : r.divisor,
                            drawType: r.drawType
                        }
                    }
                }
                var f
            })), t.bindBuffer(fl, null), i
        }

        var Sl = ["position", "positions", "a_position"];

        function Tl(t, e, i) {
            var n = Al(t, e), r = Object.assign({}, i || {});
            r.attribs = Object.assign({}, i ? i.attribs : {}, n);
            var s = e.indices;
            if (s) {
                var a = Ml(s, "indices");
                r.indices = vl(t, a, 34963), r.numElements = a.length, r.elementType = hl(a)
            } else r.numElements || (r.numElements = function (t, e) {
                var i, n;
                for (n = 0; n < Sl.length && !((i = Sl[n]) in e) && !((i = ml + i) in e); ++n) ;
                n === Sl.length && (i = Object.keys(e)[0]);
                var r = e[i];
                t.bindBuffer(fl, r.buffer);
                var s = t.getBufferParameter(fl, 34660);
                t.bindBuffer(fl, null);
                var a,
                    o = s / (5120 === (a = r.type) || 5121 === a ? 1 : 5122 === a || 5123 === a ? 2 : 5124 === a || 5125 === a || 5126 === a ? 4 : 0),
                    h = r.numComponents || r.size, l = o / h;
                if (l % 1 != 0) throw new Error("numComponents ".concat(h, " not correct for length ").concat(length));
                return l
            }(t, r.attribs));
            return r
        }

        function Dl(t, e) {
            var i = {};
            return Object.keys(e).forEach((function (n) {
                i[n] = function (t, e, i) {
                    var n = "indices" === i ? 34963 : fl;
                    return vl(t, Ml(e, i), n)
                }(t, e[n], n)
            })), e.indices ? (i.numElements = e.indices.length, i.elementType = hl(Ml(e.indices))) : i.numElements = function (t) {
                var e, i;
                for (i = 0; i < Sl.length && !((e = Sl[i]) in t); ++i) ;
                i === Sl.length && (e = Object.keys(t)[0]);
                var n = t[e], r = bl(n).length, s = El(n, e), a = r / s;
                if (r % s > 0) throw new Error("numComponents ".concat(s, " not correct for length ").concat(r));
                return a
            }(e), i
        }

        var Cl = bl, Pl = El;

        function Il(t, e) {
            var i = 0;
            return t.push = function () {
                for (var e = 0; e < arguments.length; ++e) {
                    var n = arguments[e];
                    if (n instanceof Array || ll(n)) for (var r = 0; r < n.length; ++r) t[i++] = n[r]; else t[i++] = n
                }
            }, t.reset = function (t) {
                i = t || 0
            }, t.numComponents = e, Object.defineProperty(t, "numElements", {
                get: function () {
                    return this.length / this.numComponents | 0
                }
            }), t
        }

        function Ll(t, e, i) {
            return Il(new (i || Float32Array)(t * e), t)
        }

        function Rl(t) {
            return "indices" !== t
        }

        function Fl(t, e, i) {
            for (var n = t.length, r = new Float32Array(3), s = 0; s < n; s += 3) i(e, [t[s], t[s + 1], t[s + 2]], r), t[s] = r[0], t[s + 1] = r[1], t[s + 2] = r[2]
        }

        function kl(t, e, i) {
            i = i || Nh();
            var n = e[0], r = e[1], s = e[2];
            return i[0] = n * t[0] + r * t[1] + s * t[2], i[1] = n * t[4] + r * t[5] + s * t[6], i[2] = n * t[8] + r * t[9] + s * t[10], i
        }

        function Ol(t, e) {
            return Fl(t, e, Qh), t
        }

        function zl(t, e) {
            return Fl(t, Zh(e), kl), t
        }

        function Bl(t, e) {
            return Fl(t, e, Jh), t
        }

        function Nl(t, e) {
            return Object.keys(t).forEach((function (i) {
                var n = t[i];
                i.indexOf("pos") >= 0 ? Bl(n, e) : i.indexOf("tan") >= 0 || i.indexOf("binorm") >= 0 ? Ol(n, e) : i.indexOf("norm") >= 0 && zl(n, e)
            })), t
        }

        function jl(t, e, i) {
            return t = t || 2, {
                position: {
                    numComponents: 2,
                    data: [(e = e || 0) + -1 * (t *= .5), (i = i || 0) + -1 * t, e + 1 * t, i + -1 * t, e + -1 * t, i + 1 * t, e + 1 * t, i + 1 * t]
                },
                normal: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
                texcoord: [0, 0, 1, 0, 0, 1, 1, 1],
                indices: [0, 1, 2, 2, 1, 3]
            }
        }

        function Vl(t, e, i, n, r) {
            t = t || 1, e = e || 1, i = i || 1, n = n || 1, r = r || Yh();
            for (var s = (i + 1) * (n + 1), a = Ll(3, s), o = Ll(3, s), h = Ll(2, s), l = 0; l <= n; l++) for (var c = 0; c <= i; c++) {
                var u = c / i, p = l / n;
                a.push(t * u - .5 * t, 0, e * p - .5 * e), o.push(0, 1, 0), h.push(u, p)
            }
            for (var d = i + 1, f = Ll(3, i * n * 2, Uint16Array), m = 0; m < n; m++) for (var g = 0; g < i; g++) f.push((m + 0) * d + g, (m + 1) * d + g, (m + 0) * d + g + 1), f.push((m + 1) * d + g, (m + 1) * d + g + 1, (m + 0) * d + g + 1);
            return Nl({position: a, normal: o, texcoord: h, indices: f}, r)
        }

        function Gl(t, e, i, n, r, s, a) {
            if (e <= 0 || i <= 0) throw new Error("subdivisionAxis and subdivisionHeight must be > 0");
            n = n || 0, s = s || 0;
            for (var o = (r = r || Math.PI) - n, h = (a = a || 2 * Math.PI) - s, l = (e + 1) * (i + 1), c = Ll(3, l), u = Ll(3, l), p = Ll(2, l), d = Ll(3, l), f = Ll(3, l), m = 0; m <= i; m++) for (var g = 0; g <= e; g++) {
                var v = g / e, y = m / i, b = h * v + s, x = o * y + n, w = Math.sin(b), _ = Math.cos(b),
                    E = Math.sin(x), M = _ * E, A = Math.cos(x), S = w * E, T = h * ((g + 1) / e) + s,
                    D = o * (m / i) + n, C = Math.sin(T), P = Math.cos(T), I = Math.sin(D), L = Math.cos(D);
                d.push(P * I - M, L - A, C * I - S);
                var R = h * (g / e) + s, F = o * ((m + 1) / i) + n, k = Math.sin(R), O = Math.cos(R), z = Math.sin(F),
                    B = O * z - M, N = Math.cos(F) - A, j = k * z - S;
                c.push(t * M, t * A, t * S), u.push(M, A, S), p.push(1 - v, y), f.push(B, N, j)
            }
            for (var V = e + 1, G = Ll(3, e * i * 2, Uint16Array), U = 0; U < e; U++) for (var H = 0; H < i; H++) G.push((H + 0) * V + U, (H + 0) * V + U + 1, (H + 1) * V + U), G.push((H + 1) * V + U, (H + 0) * V + U + 1, (H + 1) * V + U + 1);
            return {position: c, normal: u, texcoord: p, indices: G, tangent: d, bitangent: f}
        }

        var Ul = [[3, 7, 5, 1], [6, 2, 0, 4], [6, 7, 3, 2], [0, 1, 5, 4], [7, 6, 4, 5], [2, 3, 1, 0]];

        function Hl(t) {
            for (var e = (t = t || 1) / 2, i = [[-e, -e, -e], [+e, -e, -e], [-e, +e, -e], [+e, +e, -e], [-e, -e, +e], [+e, -e, +e], [-e, +e, +e], [+e, +e, +e]], n = [[1, 0, 0], [-1, 0, 0], [0, 1, 0], [0, -1, 0], [0, 0, 1], [0, 0, -1]], r = [[1, 0], [0, 0], [0, 1], [1, 1]], s = Ll(3, 24), a = Ll(3, 24), o = Ll(2, 24), h = Ll(3, 12, Uint16Array), l = 0; l < 6; ++l) {
                for (var c = Ul[l], u = 0; u < 4; ++u) {
                    var p = i[c[u]], d = n[l], f = r[u];
                    s.push(p), a.push(d), o.push(f)
                }
                var m = 4 * l;
                h.push(m + 0, m + 1, m + 2), h.push(m + 0, m + 2, m + 3)
            }
            return {position: s, normal: a, texcoord: o, indices: h}
        }

        function Wl(t, e, i, n, r, s, a) {
            if (n < 3) throw new Error("radialSubdivisions must be 3 or greater");
            if (r < 1) throw new Error("verticalSubdivisions must be 1 or greater");
            for (var o = void 0 === s || s, h = void 0 === a || a, l = (o ? 2 : 0) + (h ? 2 : 0), c = (n + 1) * (r + 1 + l), u = Ll(3, c), p = Ll(3, c), d = Ll(2, c), f = Ll(3, n * (r + l / 2) * 2, Uint16Array), m = n + 1, g = Math.atan2(t - e, i), v = Math.cos(g), y = Math.sin(g), b = r + (h ? 2 : 0), x = o ? -2 : 0; x <= b; ++x) {
                var w = x / r, _ = i * w, E = void 0;
                x < 0 ? (_ = 0, w = 1, E = t) : x > r ? (_ = i, w = 1, E = e) : E = t + x / r * (e - t), -2 !== x && x !== r + 2 || (E = 0, w = 0), _ -= i / 2;
                for (var M = 0; M < m; ++M) {
                    var A = Math.sin(M * Math.PI * 2 / n), S = Math.cos(M * Math.PI * 2 / n);
                    u.push(A * E, _, S * E), x < 0 ? p.push(0, -1, 0) : x > r ? p.push(0, 1, 0) : 0 === E ? p.push(0, 0, 0) : p.push(A * v, y, S * v), d.push(M / n, 1 - w)
                }
            }
            for (var T = 0; T < r + l; ++T) if (!(1 === T && o || T === r + l - 2 && h)) for (var D = 0; D < n; ++D) f.push(m * (T + 0) + 0 + D, m * (T + 0) + 1 + D, m * (T + 1) + 1 + D), f.push(m * (T + 0) + 0 + D, m * (T + 1) + 1 + D, m * (T + 1) + 0 + D);
            return {position: u, normal: p, texcoord: d, indices: f}
        }

        function ql(t, e) {
            e = e || [];
            for (var i = [], n = 0; n < t.length; n += 4) {
                var r = t[n], s = t.slice(n + 1, n + 4);
                s.push.apply(s, e);
                for (var a = 0; a < r; ++a) i.push.apply(i, s)
            }
            return i
        }

        function Xl() {
            var t = [0, 0, 0, 0, 150, 0, 30, 0, 0, 0, 150, 0, 30, 150, 0, 30, 0, 0, 30, 0, 0, 30, 30, 0, 100, 0, 0, 30, 30, 0, 100, 30, 0, 100, 0, 0, 30, 60, 0, 30, 90, 0, 67, 60, 0, 30, 90, 0, 67, 90, 0, 67, 60, 0, 0, 0, 30, 30, 0, 30, 0, 150, 30, 0, 150, 30, 30, 0, 30, 30, 150, 30, 30, 0, 30, 100, 0, 30, 30, 30, 30, 30, 30, 30, 100, 0, 30, 100, 30, 30, 30, 60, 30, 67, 60, 30, 30, 90, 30, 30, 90, 30, 67, 60, 30, 67, 90, 30, 0, 0, 0, 100, 0, 0, 100, 0, 30, 0, 0, 0, 100, 0, 30, 0, 0, 30, 100, 0, 0, 100, 30, 0, 100, 30, 30, 100, 0, 0, 100, 30, 30, 100, 0, 30, 30, 30, 0, 30, 30, 30, 100, 30, 30, 30, 30, 0, 100, 30, 30, 100, 30, 0, 30, 30, 0, 30, 60, 30, 30, 30, 30, 30, 30, 0, 30, 60, 0, 30, 60, 30, 30, 60, 0, 67, 60, 30, 30, 60, 30, 30, 60, 0, 67, 60, 0, 67, 60, 30, 67, 60, 0, 67, 90, 30, 67, 60, 30, 67, 60, 0, 67, 90, 0, 67, 90, 30, 30, 90, 0, 30, 90, 30, 67, 90, 30, 30, 90, 0, 67, 90, 30, 67, 90, 0, 30, 90, 0, 30, 150, 30, 30, 90, 30, 30, 90, 0, 30, 150, 0, 30, 150, 30, 0, 150, 0, 0, 150, 30, 30, 150, 30, 0, 150, 0, 30, 150, 30, 30, 150, 0, 0, 0, 0, 0, 0, 30, 0, 150, 30, 0, 0, 0, 0, 150, 30, 0, 150, 0],
                e = ql([18, 0, 0, 1, 18, 0, 0, -1, 6, 0, 1, 0, 6, 1, 0, 0, 6, 0, -1, 0, 6, 1, 0, 0, 6, 0, 1, 0, 6, 1, 0, 0, 6, 0, -1, 0, 6, 1, 0, 0, 6, 0, -1, 0, 6, -1, 0, 0]),
                i = ql([18, 200, 70, 120, 18, 80, 70, 200, 6, 70, 200, 210, 6, 200, 200, 70, 6, 210, 100, 70, 6, 210, 160, 70, 6, 70, 180, 210, 6, 100, 70, 210, 6, 76, 210, 100, 6, 140, 210, 80, 6, 90, 130, 110, 6, 160, 160, 220], [255]),
                n = t.length / 3, r = {
                    position: Ll(3, n),
                    texcoord: Ll(2, n),
                    normal: Ll(3, n),
                    color: Ll(4, n, Uint8Array),
                    indices: Ll(3, n / 3, Uint16Array)
                };
            r.position.push(t), r.texcoord.push([.22, .19, .22, .79, .34, .19, .22, .79, .34, .79, .34, .19, .34, .19, .34, .31, .62, .19, .34, .31, .62, .31, .62, .19, .34, .43, .34, .55, .49, .43, .34, .55, .49, .55, .49, .43, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0]), r.normal.push(e), r.color.push(i);
            for (var s = 0; s < n; ++s) r.indices.push(s);
            return r
        }

        function Yl(t, e, i, n, r, s, a) {
            if (r <= 0) throw new Error("subdivisionDown must be > 0");
            var o = (a = a || 1) - (s = s || 0), h = 2 * (r + 1) * 4, l = Ll(3, h), c = Ll(3, h), u = Ll(2, h);

            function p(t, e, i) {
                return t + (e - t) * i
            }

            function d(e, i, a, h, d, f) {
                for (var m = 0; m <= r; m++) {
                    var g = i / 1, v = m / r, y = 2 * (g - .5), b = (s + v * o) * Math.PI, x = Math.sin(b),
                        w = Math.cos(b), _ = p(t, e, x), E = y * n, M = w * t, A = x * _;
                    l.push(E, M, A);
                    var S = jh((T = [0, x, w], D = a, (C = (C = void 0) || new Bh(3))[0] = T[0] * D[0], C[1] = T[1] * D[1], C[2] = T[2] * D[2], C), h);
                    c.push(S), u.push(g * d + f, v)
                }
                var T, D, C
            }

            for (var f = 0; f < 2; f++) {
                var m = 2 * (f / 1 - .5);
                d(e, f, [1, 1, 1], [0, 0, 0], 1, 0), d(e, f, [0, 0, 0], [m, 0, 0], 0, 0), d(i, f, [1, 1, 1], [0, 0, 0], 1, 0), d(i, f, [0, 0, 0], [m, 0, 0], 0, 1)
            }
            var g = Ll(3, 2 * r * 4, Uint16Array);

            function v(t, e) {
                for (var i = 0; i < r; ++i) g.push(t + i + 0, t + i + 1, e + i + 0), g.push(t + i + 1, e + i + 1, e + i + 0)
            }

            var y = r + 1;
            return v(0 * y, 4 * y), v(5 * y, 7 * y), v(6 * y, 2 * y), v(3 * y, 1 * y), {
                position: l,
                normal: c,
                texcoord: u,
                indices: g
            }
        }

        function Zl(t, e, i, n, r, s) {
            return Wl(t, t, e, i, n, r, s)
        }

        function Jl(t, e, i, n, r, s) {
            if (i < 3) throw new Error("radialSubdivisions must be 3 or greater");
            if (n < 3) throw new Error("verticalSubdivisions must be 3 or greater");
            r = r || 0;
            for (var a = (s = s || 2 * Math.PI) - r, o = i + 1, h = n + 1, l = o * h, c = Ll(3, l), u = Ll(3, l), p = Ll(2, l), d = Ll(3, i * n * 2, Uint16Array), f = 0; f < h; ++f) for (var m = f / n, g = m * Math.PI * 2, v = Math.sin(g), y = t + v * e, b = Math.cos(g), x = b * e, w = 0; w < o; ++w) {
                var _ = w / i, E = r + _ * a, M = Math.sin(E), A = Math.cos(E), S = M * y, T = A * y, D = M * v,
                    C = A * v;
                c.push(S, x, T), u.push(D, b, C), p.push(_, 1 - m)
            }
            for (var P = 0; P < n; ++P) for (var I = 0; I < i; ++I) {
                var L = 1 + I, R = 1 + P;
                d.push(o * P + I, o * R + I, o * P + L), d.push(o * R + I, o * R + L, o * P + L)
            }
            return {position: c, normal: u, texcoord: p, indices: d}
        }

        function Ql(t, e, i, n, r) {
            if (e < 3) throw new Error("divisions must be at least 3");
            r = r || 1, n = n || 0;
            for (var s = (e + 1) * ((i = i || 1) + 1), a = Ll(3, s), o = Ll(3, s), h = Ll(2, s), l = Ll(3, i * e * 2, Uint16Array), c = 0, u = t - n, p = e + 1, d = 0; d <= i; ++d) {
                for (var f = n + u * Math.pow(d / i, r), m = 0; m <= e; ++m) {
                    var g = 2 * Math.PI * m / e, v = f * Math.cos(g), y = f * Math.sin(g);
                    if (a.push(v, 0, y), o.push(0, 1, 0), h.push(1 - m / e, d / i), d > 0 && m !== e) {
                        var b = c + (m + 1), x = c + m, w = c + m - p, _ = c + (m + 1) - p;
                        l.push(b, x, w), l.push(b, w, _)
                    }
                }
                c += e + 1
            }
            return {position: a, normal: o, texcoord: h, indices: l}
        }

        function Kl(t) {
            return function (e) {
                var i = t.apply(this, Array.prototype.slice.call(arguments, 1));
                return Dl(e, i)
            }
        }

        function $l(t) {
            return function (e) {
                var i = t.apply(null, Array.prototype.slice.call(arguments, 1));
                return Tl(e, i)
            }
        }

        var tc = ["numComponents", "size", "type", "normalize", "stride", "offset", "attrib", "name", "attribName"];

        function ec(t, e, i, n) {
            n = n || 0;
            for (var r = t.length, s = 0; s < r; ++s) e[i + s] = t[s] + n
        }

        function ic(t, e) {
            var i, n, r = Cl(t), s = new r.constructor(e), a = s;
            return r.numComponents && r.numElements && Il(s, r.numComponents), t.data && (i = t, n = a = {data: s}, tc.forEach((function (t) {
                var e = i[t];
                void 0 !== e && (n[t] = e)
            }))), a
        }

        var nc = $l(Xl), rc = Kl(Xl), sc = $l(Hl), ac = Kl(Hl), oc = $l(Vl), hc = Kl(Vl), lc = $l(Gl), cc = Kl(Gl),
            uc = $l(Wl), pc = Kl(Wl), dc = $l(jl), fc = Kl(jl), mc = $l(Yl), gc = Kl(Yl), vc = $l(Zl), yc = Kl(Zl),
            bc = $l(Jl), xc = Kl(Jl), wc = $l(Ql), _c = Kl(Ql), Ec = mc, Mc = gc, Ac = Yl, Sc = Object.freeze({
                __proto__: null,
                create3DFBufferInfo: nc,
                create3DFBuffers: rc,
                create3DFVertices: Xl,
                createAugmentedTypedArray: Ll,
                createCubeBufferInfo: sc,
                createCubeBuffers: ac,
                createCubeVertices: Hl,
                createPlaneBufferInfo: oc,
                createPlaneBuffers: hc,
                createPlaneVertices: Vl,
                createSphereBufferInfo: lc,
                createSphereBuffers: cc,
                createSphereVertices: Gl,
                createTruncatedConeBufferInfo: uc,
                createTruncatedConeBuffers: pc,
                createTruncatedConeVertices: Wl,
                createXYQuadBufferInfo: dc,
                createXYQuadBuffers: fc,
                createXYQuadVertices: jl,
                createCresentBufferInfo: Ec,
                createCresentBuffers: Mc,
                createCresentVertices: Ac,
                createCrescentBufferInfo: mc,
                createCrescentBuffers: gc,
                createCrescentVertices: Yl,
                createCylinderBufferInfo: vc,
                createCylinderBuffers: yc,
                createCylinderVertices: Zl,
                createTorusBufferInfo: bc,
                createTorusBuffers: xc,
                createTorusVertices: Jl,
                createDiscBufferInfo: wc,
                createDiscBuffers: _c,
                createDiscVertices: Ql,
                deindexVertices: function (t) {
                    var e = t.indices, i = {}, n = e.length;
                    return Object.keys(t).filter(Rl).forEach((function (r) {
                        for (var s = t[r], a = s.numComponents, o = Ll(a, n, s.constructor), h = 0; h < n; ++h) for (var l = e[h] * a, c = 0; c < a; ++c) o.push(s[l + c]);
                        i[r] = o
                    })), i
                },
                flattenNormals: function (t) {
                    if (t.indices) throw new Error("can not flatten normals of indexed vertices. deindex them first");
                    for (var e = t.normal, i = e.length, n = 0; n < i; n += 9) {
                        var r = e[n + 0], s = e[n + 1], a = e[n + 2], o = e[n + 3], h = e[n + 4], l = e[n + 5],
                            c = r + o + e[n + 6], u = s + h + e[n + 7], p = a + l + e[n + 8],
                            d = Math.sqrt(c * c + u * u + p * p);
                        c /= d, u /= d, p /= d, e[n + 0] = c, e[n + 1] = u, e[n + 2] = p, e[n + 3] = c, e[n + 4] = u, e[n + 5] = p, e[n + 6] = c, e[n + 7] = u, e[n + 8] = p
                    }
                    return t
                },
                makeRandomVertexColors: function (t, e) {
                    e = e || {};
                    var i = t.position.numElements, n = Ll(4, i, Uint8Array), r = e.rand || function (t, e) {
                        return e < 3 ? (i = 256, Math.random() * i | 0) : 255;
                        var i
                    };
                    if (t.color = n, t.indices) for (var s = 0; s < i; ++s) n.push(r(s, 0), r(s, 1), r(s, 2), r(s, 3)); else for (var a = e.vertsPerColor || 3, o = i / a, h = 0; h < o; ++h) for (var l = [r(h, 0), r(h, 1), r(h, 2), r(h, 3)], c = 0; c < a; ++c) n.push(l);
                    return t
                },
                reorientDirections: Ol,
                reorientNormals: zl,
                reorientPositions: Bl,
                reorientVertices: Nl,
                concatVertices: function (t) {
                    for (var e, i = {}, n = function (n) {
                        var r = t[n];
                        Object.keys(r).forEach((function (t) {
                            i[t] || (i[t] = []), e || "indices" === t || (e = t);
                            var n = r[t], s = Pl(n, t), a = Cl(n).length / s;
                            i[t].push(a)
                        }))
                    }, r = 0; r < t.length; ++r) n(r);
                    var s = i[e], a = {};
                    return Object.keys(i).forEach((function (e) {
                        var i = function (e) {
                            for (var i, n = 0, r = 0; r < t.length; ++r) {
                                var s = t[r][e];
                                n += Cl(s).length, i && !s.data || (i = s)
                            }
                            return {length: n, spec: i}
                        }(e), n = ic(i.spec, i.length);
                        !function (e, i, n) {
                            for (var r = 0, s = 0, a = 0; a < t.length; ++a) {
                                var o = t[a][e], h = Cl(o);
                                "indices" === e ? (ec(h, n, s, r), r += i[a]) : ec(h, n, s), s += h.length
                            }
                        }(e, s, Cl(n)), a[e] = n
                    })), a
                },
                duplicateVertices: function (t) {
                    var e = {};
                    return Object.keys(t).forEach((function (i) {
                        var n = t[i], r = Cl(n), s = ic(n, r.length);
                        ec(r, Cl(s), 0), e[i] = s
                    })), e
                }
            });

        function Tc(t) {
            return !!t.texStorage2D
        }

        function Dc(t) {
            return !t.texStorage2D
        }

        var Cc, Pc, Ic, Lc = (Cc = {}, Pc = {}, function (t, e) {
            return function (t) {
                var e = t.constructor.name;
                if (!Cc[e]) {
                    for (var i in t) if ("number" == typeof t[i]) {
                        var n = Pc[t[i]];
                        Pc[t[i]] = n ? "".concat(n, " | ").concat(i) : i
                    }
                    Cc[e] = !0
                }
            }(t), Pc[e] || "0x" + e.toString(16)
        }), Rc = {textureColor: new Uint8Array([128, 192, 255, 255]), textureOptions: {}, crossOrigin: void 0}, Fc = ll;

        function kc() {
            return Ic = Ic || ("undefined" != typeof document && document.createElement ? document.createElement("canvas").getContext("2d") : null)
        }

        var Oc, zc = 6406, Bc = 6407, Nc = 6408, jc = 6409, Vc = 6410, Gc = 6402, Uc = 34041, Hc = 33071, Wc = 3553,
            qc = 34067, Xc = 32879, Yc = 35866, Zc = 34069, Jc = 10241, Qc = 10240, Kc = 10242, $c = 10243, tu = 3317,
            eu = 3314, iu = 32878, nu = 3316, ru = 3315, su = 32877, au = 37443, ou = 37441, hu = 37440, lu = 5120,
            cu = 5121, uu = 5122, pu = 5123, du = 5124, fu = 5125, mu = 5126, gu = 5131, vu = 36193, yu = 33640,
            bu = 33319, xu = 33320, wu = 6403, _u = 36244, Eu = 36248, Mu = 36249;

        function Au(t) {
            if (!Oc) {
                var e = {};
                e[6406] = {
                    textureFormat: zc,
                    colorRenderable: !0,
                    textureFilterable: !0,
                    bytesPerElement: [1, 2, 2, 4],
                    type: [cu, gu, vu, mu]
                }, e[6409] = {
                    textureFormat: jc,
                    colorRenderable: !0,
                    textureFilterable: !0,
                    bytesPerElement: [1, 2, 2, 4],
                    type: [cu, gu, vu, mu]
                }, e[6410] = {
                    textureFormat: Vc,
                    colorRenderable: !0,
                    textureFilterable: !0,
                    bytesPerElement: [2, 4, 4, 8],
                    type: [cu, gu, vu, mu]
                }, e[Bc] = {
                    textureFormat: Bc,
                    colorRenderable: !0,
                    textureFilterable: !0,
                    bytesPerElement: [3, 6, 6, 12, 2],
                    type: [cu, gu, vu, mu, 33635]
                }, e[Nc] = {
                    textureFormat: Nc,
                    colorRenderable: !0,
                    textureFilterable: !0,
                    bytesPerElement: [4, 8, 8, 16, 2, 2],
                    type: [cu, gu, vu, mu, 32819, 32820]
                }, e[33321] = {
                    textureFormat: wu,
                    colorRenderable: !0,
                    textureFilterable: !0,
                    bytesPerElement: [1],
                    type: [cu]
                }, e[36756] = {
                    textureFormat: wu,
                    colorRenderable: !1,
                    textureFilterable: !0,
                    bytesPerElement: [1],
                    type: [lu]
                }, e[33325] = {
                    textureFormat: wu,
                    colorRenderable: !1,
                    textureFilterable: !0,
                    bytesPerElement: [4, 2],
                    type: [mu, gu]
                }, e[33326] = {
                    textureFormat: wu,
                    colorRenderable: !1,
                    textureFilterable: !1,
                    bytesPerElement: [4],
                    type: [mu]
                }, e[33330] = {
                    textureFormat: _u,
                    colorRenderable: !0,
                    textureFilterable: !1,
                    bytesPerElement: [1],
                    type: [cu]
                }, e[33329] = {
                    textureFormat: _u,
                    colorRenderable: !0,
                    textureFilterable: !1,
                    bytesPerElement: [1],
                    type: [lu]
                }, e[33332] = {
                    textureFormat: _u,
                    colorRenderable: !0,
                    textureFilterable: !1,
                    bytesPerElement: [2],
                    type: [pu]
                }, e[33331] = {
                    textureFormat: _u,
                    colorRenderable: !0,
                    textureFilterable: !1,
                    bytesPerElement: [2],
                    type: [uu]
                }, e[33334] = {
                    textureFormat: _u,
                    colorRenderable: !0,
                    textureFilterable: !1,
                    bytesPerElement: [4],
                    type: [fu]
                }, e[33333] = {
                    textureFormat: _u,
                    colorRenderable: !0,
                    textureFilterable: !1,
                    bytesPerElement: [4],
                    type: [du]
                }, e[33323] = {
                    textureFormat: bu,
                    colorRenderable: !0,
                    textureFilterable: !0,
                    bytesPerElement: [2],
                    type: [cu]
                }, e[36757] = {
                    textureFormat: bu,
                    colorRenderable: !1,
                    textureFilterable: !0,
                    bytesPerElement: [2],
                    type: [lu]
                }, e[33327] = {
                    textureFormat: bu,
                    colorRenderable: !1,
                    textureFilterable: !0,
                    bytesPerElement: [8, 4],
                    type: [mu, gu]
                }, e[33328] = {
                    textureFormat: bu,
                    colorRenderable: !1,
                    textureFilterable: !1,
                    bytesPerElement: [8],
                    type: [mu]
                }, e[33336] = {
                    textureFormat: xu,
                    colorRenderable: !0,
                    textureFilterable: !1,
                    bytesPerElement: [2],
                    type: [cu]
                }, e[33335] = {
                    textureFormat: xu,
                    colorRenderable: !0,
                    textureFilterable: !1,
                    bytesPerElement: [2],
                    type: [lu]
                }, e[33338] = {
                    textureFormat: xu,
                    colorRenderable: !0,
                    textureFilterable: !1,
                    bytesPerElement: [4],
                    type: [pu]
                }, e[33337] = {
                    textureFormat: xu,
                    colorRenderable: !0,
                    textureFilterable: !1,
                    bytesPerElement: [4],
                    type: [uu]
                }, e[33340] = {
                    textureFormat: xu,
                    colorRenderable: !0,
                    textureFilterable: !1,
                    bytesPerElement: [8],
                    type: [fu]
                }, e[33339] = {
                    textureFormat: xu,
                    colorRenderable: !0,
                    textureFilterable: !1,
                    bytesPerElement: [8],
                    type: [du]
                }, e[32849] = {
                    textureFormat: Bc,
                    colorRenderable: !0,
                    textureFilterable: !0,
                    bytesPerElement: [3],
                    type: [cu]
                }, e[35905] = {
                    textureFormat: Bc,
                    colorRenderable: !1,
                    textureFilterable: !0,
                    bytesPerElement: [3],
                    type: [cu]
                }, e[36194] = {
                    textureFormat: Bc,
                    colorRenderable: !0,
                    textureFilterable: !0,
                    bytesPerElement: [3, 2],
                    type: [cu, 33635]
                }, e[36758] = {
                    textureFormat: Bc,
                    colorRenderable: !1,
                    textureFilterable: !0,
                    bytesPerElement: [3],
                    type: [lu]
                }, e[35898] = {
                    textureFormat: Bc,
                    colorRenderable: !1,
                    textureFilterable: !0,
                    bytesPerElement: [12, 6, 4],
                    type: [mu, gu, 35899]
                }, e[35901] = {
                    textureFormat: Bc,
                    colorRenderable: !1,
                    textureFilterable: !0,
                    bytesPerElement: [12, 6, 4],
                    type: [mu, gu, 35902]
                }, e[34843] = {
                    textureFormat: Bc,
                    colorRenderable: !1,
                    textureFilterable: !0,
                    bytesPerElement: [12, 6],
                    type: [mu, gu]
                }, e[34837] = {
                    textureFormat: Bc,
                    colorRenderable: !1,
                    textureFilterable: !1,
                    bytesPerElement: [12],
                    type: [mu]
                }, e[36221] = {
                    textureFormat: Eu,
                    colorRenderable: !1,
                    textureFilterable: !1,
                    bytesPerElement: [3],
                    type: [cu]
                }, e[36239] = {
                    textureFormat: Eu,
                    colorRenderable: !1,
                    textureFilterable: !1,
                    bytesPerElement: [3],
                    type: [lu]
                }, e[36215] = {
                    textureFormat: Eu,
                    colorRenderable: !1,
                    textureFilterable: !1,
                    bytesPerElement: [6],
                    type: [pu]
                }, e[36233] = {
                    textureFormat: Eu,
                    colorRenderable: !1,
                    textureFilterable: !1,
                    bytesPerElement: [6],
                    type: [uu]
                }, e[36209] = {
                    textureFormat: Eu,
                    colorRenderable: !1,
                    textureFilterable: !1,
                    bytesPerElement: [12],
                    type: [fu]
                }, e[36227] = {
                    textureFormat: Eu,
                    colorRenderable: !1,
                    textureFilterable: !1,
                    bytesPerElement: [12],
                    type: [du]
                }, e[32856] = {
                    textureFormat: Nc,
                    colorRenderable: !0,
                    textureFilterable: !0,
                    bytesPerElement: [4],
                    type: [cu]
                }, e[35907] = {
                    textureFormat: Nc,
                    colorRenderable: !0,
                    textureFilterable: !0,
                    bytesPerElement: [4],
                    type: [cu]
                }, e[36759] = {
                    textureFormat: Nc,
                    colorRenderable: !1,
                    textureFilterable: !0,
                    bytesPerElement: [4],
                    type: [lu]
                }, e[32855] = {
                    textureFormat: Nc,
                    colorRenderable: !0,
                    textureFilterable: !0,
                    bytesPerElement: [4, 2, 4],
                    type: [cu, 32820, yu]
                }, e[32854] = {
                    textureFormat: Nc,
                    colorRenderable: !0,
                    textureFilterable: !0,
                    bytesPerElement: [4, 2],
                    type: [cu, 32819]
                }, e[32857] = {
                    textureFormat: Nc,
                    colorRenderable: !0,
                    textureFilterable: !0,
                    bytesPerElement: [4],
                    type: [yu]
                }, e[34842] = {
                    textureFormat: Nc,
                    colorRenderable: !1,
                    textureFilterable: !0,
                    bytesPerElement: [16, 8],
                    type: [mu, gu]
                }, e[34836] = {
                    textureFormat: Nc,
                    colorRenderable: !1,
                    textureFilterable: !1,
                    bytesPerElement: [16],
                    type: [mu]
                }, e[36220] = {
                    textureFormat: Mu,
                    colorRenderable: !0,
                    textureFilterable: !1,
                    bytesPerElement: [4],
                    type: [cu]
                }, e[36238] = {
                    textureFormat: Mu,
                    colorRenderable: !0,
                    textureFilterable: !1,
                    bytesPerElement: [4],
                    type: [lu]
                }, e[36975] = {
                    textureFormat: Mu,
                    colorRenderable: !0,
                    textureFilterable: !1,
                    bytesPerElement: [4],
                    type: [yu]
                }, e[36214] = {
                    textureFormat: Mu,
                    colorRenderable: !0,
                    textureFilterable: !1,
                    bytesPerElement: [8],
                    type: [pu]
                }, e[36232] = {
                    textureFormat: Mu,
                    colorRenderable: !0,
                    textureFilterable: !1,
                    bytesPerElement: [8],
                    type: [uu]
                }, e[36226] = {
                    textureFormat: Mu,
                    colorRenderable: !0,
                    textureFilterable: !1,
                    bytesPerElement: [16],
                    type: [du]
                }, e[36208] = {
                    textureFormat: Mu,
                    colorRenderable: !0,
                    textureFilterable: !1,
                    bytesPerElement: [16],
                    type: [fu]
                }, e[33189] = {
                    textureFormat: Gc,
                    colorRenderable: !0,
                    textureFilterable: !1,
                    bytesPerElement: [2, 4],
                    type: [pu, fu]
                }, e[33190] = {
                    textureFormat: Gc,
                    colorRenderable: !0,
                    textureFilterable: !1,
                    bytesPerElement: [4],
                    type: [fu]
                }, e[36012] = {
                    textureFormat: Gc,
                    colorRenderable: !0,
                    textureFilterable: !1,
                    bytesPerElement: [4],
                    type: [mu]
                }, e[35056] = {
                    textureFormat: Uc,
                    colorRenderable: !0,
                    textureFilterable: !1,
                    bytesPerElement: [4],
                    type: [34042]
                }, e[36013] = {
                    textureFormat: Uc,
                    colorRenderable: !0,
                    textureFilterable: !1,
                    bytesPerElement: [4],
                    type: [36269]
                }, Object.keys(e).forEach((function (t) {
                    var i = e[t];
                    i.bytesPerElementMap = {}, i.bytesPerElement.forEach((function (t, e) {
                        var n = i.type[e];
                        i.bytesPerElementMap[n] = t
                    }))
                })), Oc = e
            }
            return Oc[t]
        }

        function Su(t) {
            var e = Au(t);
            if (!e) throw"unknown internal format";
            return {format: e.textureFormat, type: e.type[0]}
        }

        function Tu(t) {
            return 0 == (t & t - 1)
        }

        function Du(t, e, i, n, r) {
            if (r % 1 != 0) throw"can't guess dimensions";
            if (i || n) {
                if (n) {
                    if (!i && (i = r / n) % 1) throw"can't guess dimensions"
                } else if ((n = r / i) % 1) throw"can't guess dimensions"
            } else {
                var s = Math.sqrt(r / (e === qc ? 6 : 1));
                s % 1 == 0 ? (i = s, n = s) : (i = r, n = 1)
            }
            return {width: i, height: n}
        }

        var Cu = {};

        function Pu(t, e) {
            void 0 !== e.colorspaceConversion && (Cu.colorspaceConversion = t.getParameter(au), t.pixelStorei(au, e.colorspaceConversion)), void 0 !== e.premultiplyAlpha && (Cu.premultiplyAlpha = t.getParameter(ou), t.pixelStorei(ou, e.premultiplyAlpha)), void 0 !== e.flipY && (Cu.flipY = t.getParameter(hu), t.pixelStorei(hu, e.flipY))
        }

        function Iu(t, e) {
            void 0 !== e.colorspaceConversion && t.pixelStorei(au, Cu.colorspaceConversion), void 0 !== e.premultiplyAlpha && t.pixelStorei(ou, Cu.premultiplyAlpha), void 0 !== e.flipY && t.pixelStorei(hu, Cu.flipY)
        }

        function Lu(t) {
            Cu.unpackAlignment = t.getParameter(tu), Tc(t) && (Cu.unpackRowLength = t.getParameter(eu), Cu.unpackImageHeight = t.getParameter(iu), Cu.unpackSkipPixels = t.getParameter(nu), Cu.unpackSkipRows = t.getParameter(ru), Cu.unpackSkipImages = t.getParameter(su))
        }

        function Ru(t) {
            t.pixelStorei(tu, Cu.unpackAlignment), Tc(t) && (t.pixelStorei(eu, Cu.unpackRowLength), t.pixelStorei(iu, Cu.unpackImageHeight), t.pixelStorei(nu, Cu.unpackSkipPixels), t.pixelStorei(ru, Cu.unpackSkipRows), t.pixelStorei(su, Cu.unpackSkipImages))
        }

        function Fu(t, e, i, n) {
            n.minMag && (i.call(t, e, Jc, n.minMag), i.call(t, e, Qc, n.minMag)), n.min && i.call(t, e, Jc, n.min), n.mag && i.call(t, e, Qc, n.mag), n.wrap && (i.call(t, e, Kc, n.wrap), i.call(t, e, $c, n.wrap), (e === Xc || function (t, e) {
                return "undefined" != typeof WebGLSampler && e instanceof WebGLSampler
            }(0, e)) && i.call(t, e, 32882, n.wrap)), n.wrapR && i.call(t, e, 32882, n.wrapR), n.wrapS && i.call(t, e, Kc, n.wrapS), n.wrapT && i.call(t, e, $c, n.wrapT), n.minLod && i.call(t, e, 33082, n.minLod), n.maxLod && i.call(t, e, 33083, n.maxLod), n.baseLevel && i.call(t, e, 33084, n.baseLevel), n.maxLevel && i.call(t, e, 33085, n.maxLevel)
        }

        function ku(t, e, i) {
            var n = i.target || Wc;
            t.bindTexture(n, e), Fu(t, n, t.texParameteri, i)
        }

        function Ou(t, e, i, n, r, s) {
            s = s || Nc;
            var a = (i = i || Rc.textureOptions).target || Wc;
            if (n = n || i.width, r = r || i.height, t.bindTexture(a, e), function (t, e, i, n) {
                if (!Tc(t)) return Tu(e) && Tu(i);
                var r = Au(n);
                if (!r) throw"unknown internal format";
                return r.colorRenderable && r.textureFilterable
            }(t, n, r, s)) t.generateMipmap(a); else {
                var o = function (t) {
                    var e = Au(t);
                    if (!e) throw"unknown internal format";
                    return e.textureFilterable
                }(s) ? 9729 : 9728;
                t.texParameteri(a, Jc, o), t.texParameteri(a, Qc, o), t.texParameteri(a, Kc, Hc), t.texParameteri(a, $c, Hc)
            }
        }

        function zu(t) {
            return !0 === t.auto || void 0 === t.auto && void 0 === t.level
        }

        function Bu(t, e) {
            return (e = e || {}).cubeFaceOrder || [Zc, 34070, 34071, 34072, 34073, 34074]
        }

        function Nu(t, e) {
            var i = Bu(0, e).map((function (t, e) {
                return {face: t, ndx: e}
            }));
            return i.sort((function (t, e) {
                return t.face - e.face
            })), i
        }

        function ju(t, e, i, n) {
            var r = (n = n || Rc.textureOptions).target || Wc, s = n.level || 0, a = i.width, o = i.height,
                h = n.internalFormat || n.format || Nc, l = Su(h), c = n.format || l.format, u = n.type || l.type;
            if (Pu(t, n), t.bindTexture(r, e), r === qc) {
                var p, d, f = i.width, m = i.height;
                if (f / 6 === m) p = m, d = [0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0]; else if (m / 6 === f) p = f, d = [0, 0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5]; else if (f / 3 == m / 2) p = f / 3, d = [0, 0, 1, 0, 2, 0, 0, 1, 1, 1, 2, 1]; else {
                    if (f / 2 != m / 3) throw"can't figure out cube map from element: " + (i.src ? i.src : i.nodeName);
                    p = f / 2, d = [0, 0, 1, 0, 0, 1, 1, 1, 0, 2, 1, 2]
                }
                var g = kc();
                g ? (g.canvas.width = p, g.canvas.height = p, a = p, o = p, Nu(0, n).forEach((function (e) {
                    var n = d[2 * e.ndx + 0] * p, r = d[2 * e.ndx + 1] * p;
                    g.drawImage(i, n, r, p, p, 0, 0, p, p), t.texImage2D(e.face, s, h, c, u, g.canvas)
                })), g.canvas.width = 1, g.canvas.height = 1) : "undefined" != typeof createImageBitmap && (a = p, o = p, Nu(0, n).forEach((function (l) {
                    var f = d[2 * l.ndx + 0] * p, m = d[2 * l.ndx + 1] * p;
                    t.texImage2D(l.face, s, h, p, p, 0, c, u, null), createImageBitmap(i, f, m, p, p, {
                        premultiplyAlpha: "none",
                        colorSpaceConversion: "none"
                    }).then((function (i) {
                        Pu(t, n), t.bindTexture(r, e), t.texImage2D(l.face, s, h, c, u, i), Iu(t, n), zu(n) && Ou(t, e, n, a, o, h)
                    }))
                })))
            } else if (r === Xc || r === Yc) {
                var v = Math.min(i.width, i.height), y = Math.max(i.width, i.height), b = y / v;
                if (b % 1 != 0) throw"can not compute 3D dimensions of element";
                var x = i.width === y ? 1 : 0, w = i.height === y ? 1 : 0;
                Lu(t), t.pixelStorei(tu, 1), t.pixelStorei(eu, i.width), t.pixelStorei(iu, 0), t.pixelStorei(su, 0), t.texImage3D(r, s, h, v, v, v, 0, c, u, null);
                for (var _ = 0; _ < b; ++_) {
                    var E = _ * v * x, M = _ * v * w;
                    t.pixelStorei(nu, E), t.pixelStorei(ru, M), t.texSubImage3D(r, s, 0, 0, _, v, v, 1, c, u, i)
                }
                Ru(t)
            } else t.texImage2D(r, s, h, c, u, i);
            Iu(t, n), zu(n) && Ou(t, e, n, a, o, h), ku(t, e, n)
        }

        function Vu() {
        }

        function Gu(t, e) {
            return void 0 !== e || function (t) {
                if ("undefined" != typeof document) {
                    var e = document.createElement("a");
                    return e.href = t, e.hostname === location.hostname && e.port === location.port && e.protocol === location.protocol
                }
                var i = new URL(location.href).origin;
                return new URL(t, location.href).origin === i
            }(t) ? e : "anonymous"
        }

        function Uu(t) {
            return "undefined" != typeof ImageBitmap && t instanceof ImageBitmap || "undefined" != typeof ImageData && t instanceof ImageData || "undefined" != typeof HTMLElement && t instanceof HTMLElement
        }

        function Hu(t, e, i) {
            return Uu(t) ? (setTimeout((function () {
                i(null, t)
            })), t) : function (t, e, i) {
                var n;
                if (i = i || Vu, e = Gu(t, e = void 0 !== e ? e : Rc.crossOrigin), "undefined" != typeof Image) {
                    n = new Image, void 0 !== e && (n.crossOrigin = e);
                    var r = function () {
                        n.removeEventListener("error", s), n.removeEventListener("load", a), n = null
                    }, s = function () {
                        var e = "couldn't load image: " + t;
                        cl(e), i(e, n), r()
                    }, a = function () {
                        i(null, n), r()
                    };
                    return n.addEventListener("error", s), n.addEventListener("load", a), n.src = t, n
                }
                if ("undefined" != typeof ImageBitmap) {
                    var o, h, l = function () {
                        i(o, h)
                    }, c = {};
                    e && (c.mode = "cors"), fetch(t, c).then((function (t) {
                        if (!t.ok) throw t;
                        return t.blob()
                    })).then((function (t) {
                        return createImageBitmap(t, {premultiplyAlpha: "none", colorSpaceConversion: "none"})
                    })).then((function (t) {
                        h = t, setTimeout(l)
                    })).catch((function (t) {
                        o = t, setTimeout(l)
                    })), n = null
                }
                return n
            }(t, e, i)
        }

        function Wu(t, e, i) {
            var n = (i = i || Rc.textureOptions).target || Wc;
            if (t.bindTexture(n, e), !1 !== i.color) {
                var r = function (t) {
                    return Fc(t = t || Rc.textureColor) ? t : new Uint8Array([255 * t[0], 255 * t[1], 255 * t[2], 255 * t[3]])
                }(i.color);
                if (n === qc) for (var s = 0; s < 6; ++s) t.texImage2D(Zc + s, 0, Nc, 1, 1, 0, Nc, cu, r); else n === Xc || n === Yc ? t.texImage3D(n, 0, Nc, 1, 1, 1, 0, Nc, cu, r) : t.texImage2D(n, 0, Nc, 1, 1, 0, Nc, cu, r)
            }
        }

        function qu(t, e, i, n) {
            n = n || Vu;
            var r = i.src;
            if (6 !== r.length) throw"there must be 6 urls for a cubemap";
            var s = i.level || 0, a = i.internalFormat || i.format || Nc, o = Su(a), h = i.format || o.format,
                l = i.type || cu, c = i.target || Wc;
            if (c !== qc) throw"target must be TEXTURE_CUBE_MAP";
            Wu(t, e, i), i = Object.assign({}, i);
            var u, p = 6, d = [], f = Bu(0, i);
            u = r.map((function (r, o) {
                return Hu(r, i.crossOrigin, (m = f[o], function (r, o) {
                    --p, r ? d.push(r) : o.width !== o.height ? d.push("cubemap face img is not a square: " + o.src) : (Pu(t, i), t.bindTexture(c, e), 5 === p ? Bu().forEach((function (e) {
                        t.texImage2D(e, s, a, h, l, o)
                    })) : t.texImage2D(m, s, a, h, l, o), Iu(t, i), zu(i) && t.generateMipmap(c)), 0 === p && n(d.length ? d : void 0, e, u)
                }));
                var m
            }))
        }

        function Xu(t, e, i, n) {
            n = n || Vu;
            var r = i.src, s = i.internalFormat || i.format || Nc, a = Su(s), o = i.format || a.format,
                h = i.type || cu, l = i.target || Yc;
            if (l !== Xc && l !== Yc) throw"target must be TEXTURE_3D or TEXTURE_2D_ARRAY";
            Wu(t, e, i), i = Object.assign({}, i);
            var c, u = r.length, p = [], d = i.level || 0, f = i.width, m = i.height, g = r.length, v = !0;
            c = r.map((function (r, a) {
                return Hu(r, i.crossOrigin, (y = a, function (r, a) {
                    if (--u, r) p.push(r); else {
                        if (Pu(t, i), t.bindTexture(l, e), v) {
                            v = !1, f = i.width || a.width, m = i.height || a.height, t.texImage3D(l, d, s, f, m, g, 0, o, h, null);
                            for (var b = 0; b < g; ++b) t.texSubImage3D(l, d, 0, 0, b, f, m, 1, o, h, a)
                        } else {
                            var x, w = a;
                            a.width === f && a.height === m || (w = (x = kc()).canvas, x.canvas.width = f, x.canvas.height = m, x.drawImage(a, 0, 0, f, m)), t.texSubImage3D(l, d, 0, 0, y, f, m, 1, o, h, w), x && w === x.canvas && (x.canvas.width = 0, x.canvas.height = 0)
                        }
                        Iu(t, i), zu(i) && t.generateMipmap(l)
                    }
                    0 === u && n(p.length ? p : void 0, e, c)
                }));
                var y
            }))
        }

        function Yu(t, e, i, n) {
            var r = (n = n || Rc.textureOptions).target || Wc;
            t.bindTexture(r, e);
            var s = n.width, a = n.height, o = n.depth, h = n.level || 0, l = n.internalFormat || n.format || Nc,
                c = Su(l), u = n.format || c.format, p = n.type || function (t, e, i) {
                    return Fc(e) ? hl(e) : i || cu
                }(0, i, c.type);
            if (Fc(i)) i instanceof Uint8ClampedArray && (i = new Uint8Array(i.buffer)); else {
                var d = function (t) {
                    var e = al[t];
                    if (!e) throw new Error("unknown gl type");
                    return e
                }(p);
                i = new d(i)
            }
            var f, m = function (t, e) {
                var i = Au(t);
                if (!i) throw"unknown internal format";
                var n = i.bytesPerElementMap[e];
                if (void 0 === n) throw"unknown internal format";
                return n
            }(l, p), g = i.byteLength / m;
            if (g % 1) throw"length wrong size for format: " + Lc(t, u);
            if (r === Xc || r === Yc) if (s || a || o) !s || a && o ? !a || s && o ? (f = Du(0, r, s, a, g / o), s = f.width, a = f.height) : (f = Du(0, r, s, o, g / a), s = f.width, o = f.height) : (f = Du(0, r, a, o, g / s), a = f.width, o = f.height); else {
                var v = Math.cbrt(g);
                if (v % 1 != 0) throw"can't guess cube size of array of numElements: " + g;
                s = v, a = v, o = v
            } else f = Du(0, r, s, a, g), s = f.width, a = f.height;
            if (Lu(t), t.pixelStorei(tu, n.unpackAlignment || 1), Pu(t, n), r === qc) {
                var y = g / 6 * (m / i.BYTES_PER_ELEMENT);
                Nu(0, n).forEach((function (e) {
                    var n = y * e.ndx, r = i.subarray(n, n + y);
                    t.texImage2D(e.face, h, l, s, a, 0, u, p, r)
                }))
            } else r === Xc || r === Yc ? t.texImage3D(r, h, l, s, a, o, 0, u, p, i) : t.texImage2D(r, h, l, s, a, 0, u, p, i);
            return Iu(t, n), Ru(t), {width: s, height: a, depth: o, type: p}
        }

        function Zu(t, e, i) {
            i = i || Vu, e = e || Rc.textureOptions;
            var n = t.createTexture(), r = e.target || Wc, s = e.width || 1, a = e.height || 1,
                o = e.internalFormat || Nc;
            t.bindTexture(r, n), r === qc && (t.texParameteri(r, Kc, Hc), t.texParameteri(r, $c, Hc));
            var h = e.src;
            if (h) if ("function" == typeof h && (h = h(t, e)), "string" == typeof h) !function (t, e, i, n) {
                n = n || Vu, Wu(t, e, i = i || Rc.textureOptions), Hu((i = Object.assign({}, i)).src, i.crossOrigin, (function (r, s) {
                    r ? n(r, e, s) : (ju(t, e, s, i), n(null, e, s))
                }))
            }(t, n, e, i); else if (Fc(h) || Array.isArray(h) && ("number" == typeof h[0] || Array.isArray(h[0]) || Fc(h[0]))) {
                var l = Yu(t, n, h, e);
                s = l.width, a = l.height
            } else Array.isArray(h) && ("string" == typeof h[0] || Uu(h[0])) ? r === qc ? qu(t, n, e, i) : Xu(t, n, e, i) : (ju(t, n, h, e), s = h.width, a = h.height); else !function (t, e, i) {
                var n = i.target || Wc;
                t.bindTexture(n, e);
                var r = i.level || 0, s = i.internalFormat || i.format || Nc, a = Su(s), o = i.format || a.format,
                    h = i.type || a.type;
                if (Pu(t, i), n === qc) for (var l = 0; l < 6; ++l) t.texImage2D(Zc + l, r, s, i.width, i.height, 0, o, h, null); else n === Xc || n === Yc ? t.texImage3D(n, r, s, i.width, i.height, i.depth, 0, o, h, null) : t.texImage2D(n, r, s, i.width, i.height, 0, o, h, null);
                Iu(t, i)
            }(t, n, e);
            return zu(e) && Ou(t, n, e, s, a, o), ku(t, n, e), n
        }

        var Ju = cl;

        function Qu(t) {
            return "undefined" != typeof document && document.getElementById ? document.getElementById(t) : null
        }

        var Ku = 33984, $u = 34962, tp = 5126, ep = 5124, ip = 5125, np = 3553, rp = 34067, sp = 32879, ap = 35866,
            op = {};

        function hp(t, e) {
            return op[e].bindPoint
        }

        function lp(t, e) {
            return function (i) {
                t.uniform1i(e, i)
            }
        }

        function cp(t, e) {
            return function (i) {
                t.uniform1iv(e, i)
            }
        }

        function up(t, e) {
            return function (i) {
                t.uniform2iv(e, i)
            }
        }

        function pp(t, e) {
            return function (i) {
                t.uniform3iv(e, i)
            }
        }

        function dp(t, e) {
            return function (i) {
                t.uniform4iv(e, i)
            }
        }

        function fp(t, e, i, n) {
            var r = hp(0, e);
            return Tc(t) ? function (e) {
                var s, a;
                dl(0, e) ? (s = e, a = null) : (s = e.texture, a = e.sampler), t.uniform1i(n, i), t.activeTexture(Ku + i), t.bindTexture(r, s), t.bindSampler(i, a)
            } : function (e) {
                t.uniform1i(n, i), t.activeTexture(Ku + i), t.bindTexture(r, e)
            }
        }

        function mp(t, e, i, n, r) {
            for (var s = hp(0, e), a = new Int32Array(r), o = 0; o < r; ++o) a[o] = i + o;
            return Tc(t) ? function (e) {
                t.uniform1iv(n, a), e.forEach((function (e, n) {
                    var r, o;
                    t.activeTexture(Ku + a[n]), dl(0, e) ? (r = e, o = null) : (r = e.texture, o = e.sampler), t.bindSampler(i, o), t.bindTexture(s, r)
                }))
            } : function (e) {
                t.uniform1iv(n, a), e.forEach((function (e, i) {
                    t.activeTexture(Ku + a[i]), t.bindTexture(s, e)
                }))
            }
        }

        function gp(t, e) {
            return function (i) {
                if (i.value) switch (t.disableVertexAttribArray(e), i.value.length) {
                    case 4:
                        t.vertexAttrib4fv(e, i.value);
                        break;
                    case 3:
                        t.vertexAttrib3fv(e, i.value);
                        break;
                    case 2:
                        t.vertexAttrib2fv(e, i.value);
                        break;
                    case 1:
                        t.vertexAttrib1fv(e, i.value);
                        break;
                    default:
                        throw new Error("the length of a float constant value must be between 1 and 4!")
                } else t.bindBuffer($u, i.buffer), t.enableVertexAttribArray(e), t.vertexAttribPointer(e, i.numComponents || i.size, i.type || tp, i.normalize || !1, i.stride || 0, i.offset || 0), void 0 !== i.divisor && t.vertexAttribDivisor(e, i.divisor)
            }
        }

        function vp(t, e) {
            return function (i) {
                if (i.value) {
                    if (t.disableVertexAttribArray(e), 4 !== i.value.length) throw new Error("The length of an integer constant value must be 4!");
                    t.vertexAttrib4iv(e, i.value)
                } else t.bindBuffer($u, i.buffer), t.enableVertexAttribArray(e), t.vertexAttribIPointer(e, i.numComponents || i.size, i.type || ep, i.stride || 0, i.offset || 0), void 0 !== i.divisor && t.vertexAttribDivisor(e, i.divisor)
            }
        }

        function yp(t, e) {
            return function (i) {
                if (i.value) {
                    if (t.disableVertexAttribArray(e), 4 !== i.value.length) throw new Error("The length of an unsigned integer constant value must be 4!");
                    t.vertexAttrib4uiv(e, i.value)
                } else t.bindBuffer($u, i.buffer), t.enableVertexAttribArray(e), t.vertexAttribIPointer(e, i.numComponents || i.size, i.type || ip, i.stride || 0, i.offset || 0), void 0 !== i.divisor && t.vertexAttribDivisor(e, i.divisor)
            }
        }

        function bp(t, e, i) {
            var n = i.size, r = i.count;
            return function (i) {
                t.bindBuffer($u, i.buffer);
                for (var s = i.size || i.numComponents || n, a = s / r, o = i.type || tp, h = op[o].size * s, l = i.normalize || !1, c = i.offset || 0, u = h / r, p = 0; p < r; ++p) t.enableVertexAttribArray(e + p), t.vertexAttribPointer(e + p, a, o, l, h, c + u * p), void 0 !== i.divisor && t.vertexAttribDivisor(e + p, i.divisor)
            }
        }

        op[5126] = {
            Type: Float32Array, size: 4, setter: function (t, e) {
                return function (i) {
                    t.uniform1f(e, i)
                }
            }, arraySetter: function (t, e) {
                return function (i) {
                    t.uniform1fv(e, i)
                }
            }
        }, op[35664] = {
            Type: Float32Array, size: 8, setter: function (t, e) {
                return function (i) {
                    t.uniform2fv(e, i)
                }
            }
        }, op[35665] = {
            Type: Float32Array, size: 12, setter: function (t, e) {
                return function (i) {
                    t.uniform3fv(e, i)
                }
            }
        }, op[35666] = {
            Type: Float32Array, size: 16, setter: function (t, e) {
                return function (i) {
                    t.uniform4fv(e, i)
                }
            }
        }, op[5124] = {Type: Int32Array, size: 4, setter: lp, arraySetter: cp}, op[35667] = {
            Type: Int32Array,
            size: 8,
            setter: up
        }, op[35668] = {Type: Int32Array, size: 12, setter: pp}, op[35669] = {
            Type: Int32Array,
            size: 16,
            setter: dp
        }, op[5125] = {
            Type: Uint32Array, size: 4, setter: function (t, e) {
                return function (i) {
                    t.uniform1ui(e, i)
                }
            }, arraySetter: function (t, e) {
                return function (i) {
                    t.uniform1uiv(e, i)
                }
            }
        }, op[36294] = {
            Type: Uint32Array, size: 8, setter: function (t, e) {
                return function (i) {
                    t.uniform2uiv(e, i)
                }
            }
        }, op[36295] = {
            Type: Uint32Array, size: 12, setter: function (t, e) {
                return function (i) {
                    t.uniform3uiv(e, i)
                }
            }
        }, op[36296] = {
            Type: Uint32Array, size: 16, setter: function (t, e) {
                return function (i) {
                    t.uniform4uiv(e, i)
                }
            }
        }, op[35670] = {Type: Uint32Array, size: 4, setter: lp, arraySetter: cp}, op[35671] = {
            Type: Uint32Array,
            size: 8,
            setter: up
        }, op[35672] = {Type: Uint32Array, size: 12, setter: pp}, op[35673] = {
            Type: Uint32Array,
            size: 16,
            setter: dp
        }, op[35674] = {
            Type: Float32Array, size: 16, setter: function (t, e) {
                return function (i) {
                    t.uniformMatrix2fv(e, !1, i)
                }
            }
        }, op[35675] = {
            Type: Float32Array, size: 36, setter: function (t, e) {
                return function (i) {
                    t.uniformMatrix3fv(e, !1, i)
                }
            }
        }, op[35676] = {
            Type: Float32Array, size: 64, setter: function (t, e) {
                return function (i) {
                    t.uniformMatrix4fv(e, !1, i)
                }
            }
        }, op[35685] = {
            Type: Float32Array, size: 24, setter: function (t, e) {
                return function (i) {
                    t.uniformMatrix2x3fv(e, !1, i)
                }
            }
        }, op[35686] = {
            Type: Float32Array, size: 32, setter: function (t, e) {
                return function (i) {
                    t.uniformMatrix2x4fv(e, !1, i)
                }
            }
        }, op[35687] = {
            Type: Float32Array, size: 24, setter: function (t, e) {
                return function (i) {
                    t.uniformMatrix3x2fv(e, !1, i)
                }
            }
        }, op[35688] = {
            Type: Float32Array, size: 48, setter: function (t, e) {
                return function (i) {
                    t.uniformMatrix3x4fv(e, !1, i)
                }
            }
        }, op[35689] = {
            Type: Float32Array, size: 32, setter: function (t, e) {
                return function (i) {
                    t.uniformMatrix4x2fv(e, !1, i)
                }
            }
        }, op[35690] = {
            Type: Float32Array, size: 48, setter: function (t, e) {
                return function (i) {
                    t.uniformMatrix4x3fv(e, !1, i)
                }
            }
        }, op[35678] = {Type: null, size: 0, setter: fp, arraySetter: mp, bindPoint: np}, op[35680] = {
            Type: null,
            size: 0,
            setter: fp,
            arraySetter: mp,
            bindPoint: rp
        }, op[35679] = {Type: null, size: 0, setter: fp, arraySetter: mp, bindPoint: sp}, op[35682] = {
            Type: null,
            size: 0,
            setter: fp,
            arraySetter: mp,
            bindPoint: np
        }, op[36289] = {Type: null, size: 0, setter: fp, arraySetter: mp, bindPoint: ap}, op[36292] = {
            Type: null,
            size: 0,
            setter: fp,
            arraySetter: mp,
            bindPoint: ap
        }, op[36293] = {Type: null, size: 0, setter: fp, arraySetter: mp, bindPoint: rp}, op[36298] = {
            Type: null,
            size: 0,
            setter: fp,
            arraySetter: mp,
            bindPoint: np
        }, op[36299] = {Type: null, size: 0, setter: fp, arraySetter: mp, bindPoint: sp}, op[36300] = {
            Type: null,
            size: 0,
            setter: fp,
            arraySetter: mp,
            bindPoint: rp
        }, op[36303] = {Type: null, size: 0, setter: fp, arraySetter: mp, bindPoint: ap}, op[36306] = {
            Type: null,
            size: 0,
            setter: fp,
            arraySetter: mp,
            bindPoint: np
        }, op[36307] = {Type: null, size: 0, setter: fp, arraySetter: mp, bindPoint: sp}, op[36308] = {
            Type: null,
            size: 0,
            setter: fp,
            arraySetter: mp,
            bindPoint: rp
        }, op[36311] = {Type: null, size: 0, setter: fp, arraySetter: mp, bindPoint: ap};
        var xp = {};
        xp[5126] = {size: 4, setter: gp}, xp[35664] = {size: 8, setter: gp}, xp[35665] = {
            size: 12,
            setter: gp
        }, xp[35666] = {size: 16, setter: gp}, xp[5124] = {size: 4, setter: vp}, xp[35667] = {
            size: 8,
            setter: vp
        }, xp[35668] = {size: 12, setter: vp}, xp[35669] = {size: 16, setter: vp}, xp[5125] = {
            size: 4,
            setter: yp
        }, xp[36294] = {size: 8, setter: yp}, xp[36295] = {size: 12, setter: yp}, xp[36296] = {
            size: 16,
            setter: yp
        }, xp[35670] = {size: 4, setter: vp}, xp[35671] = {size: 8, setter: vp}, xp[35672] = {
            size: 12,
            setter: vp
        }, xp[35673] = {size: 16, setter: vp}, xp[35674] = {size: 4, setter: bp, count: 2}, xp[35675] = {
            size: 9,
            setter: bp,
            count: 3
        }, xp[35676] = {size: 16, setter: bp, count: 4};
        var wp = /^[ \t]*\n/;

        function _p(t, e, i, n) {
            var r = n || Ju, s = t.createShader(i), a = 0;
            if (wp.test(e) && (a = 1, e = e.replace(wp, "")), t.shaderSource(s, e), t.compileShader(s), !t.getShaderParameter(s, 35713)) {
                var o = t.getShaderInfoLog(s);
                return r(function (t, e) {
                    return e = e || 0, ++e, t.split("\n").map((function (t, i) {
                        return i + e + ": " + t
                    })).join("\n")
                }(e, a) + "\n*** Error compiling shader: " + o), t.deleteShader(s), null
            }
            return s
        }

        function Ep(t, e, i) {
            var n, r;
            if ("function" == typeof e && (i = e, e = void 0), "function" == typeof t) i = t, t = void 0; else if (t && !Array.isArray(t)) {
                if (t.errorCallback) return t;
                var s = t;
                i = s.errorCallback, t = s.attribLocations, n = s.transformFeedbackVaryings, r = s.transformFeedbackMode
            }
            var a = {errorCallback: i || Ju, transformFeedbackVaryings: n, transformFeedbackMode: r};
            if (t) {
                var o = {};
                Array.isArray(t) ? t.forEach((function (t, i) {
                    o[t] = e ? e[i] : i
                })) : o = t, a.attribLocations = o
            }
            return a
        }

        var Mp = ["VERTEX_SHADER", "FRAGMENT_SHADER"];

        function Ap(t, e) {
            e.forEach((function (e) {
                t.deleteShader(e)
            }))
        }

        function Sp(t, e, i, n, r) {
            for (var s = Ep(i, n, r), a = [], o = 0; o < e.length; ++o) {
                var h = _p(t, e[o], t[Mp[o]], s.errorCallback);
                if (!h) return null;
                a.push(h)
            }
            return function (t, e, i, n, r) {
                for (var s, a = Ep(i, n, r), o = [], h = [], l = 0; l < e.length; ++l) {
                    var c = e[l];
                    if ("string" == typeof c) {
                        var u = Qu(c), p = u ? u.text : c, d = t[Mp[l]];
                        u && u.type && (d = ((s = u.type).indexOf("frag") >= 0 ? 35632 : s.indexOf("vert") >= 0 ? 35633 : void 0) || d), c = _p(t, p, d, a.errorCallback), h.push(c)
                    }
                    pl(0, c) && o.push(c)
                }
                if (o.length !== e.length) return a.errorCallback("not enough shaders for program"), Ap(t, h), null;
                var f = t.createProgram();
                o.forEach((function (e) {
                    t.attachShader(f, e)
                })), a.attribLocations && Object.keys(a.attribLocations).forEach((function (e) {
                    t.bindAttribLocation(f, a.attribLocations[e], e)
                }));
                var m = a.transformFeedbackVaryings;
                if (m && (m.attribs && (m = m.attribs), Array.isArray(m) || (m = Object.keys(m)), t.transformFeedbackVaryings(f, m, a.transformFeedbackMode || 35981)), t.linkProgram(f), !t.getProgramParameter(f, 35714)) {
                    var g = t.getProgramInfoLog(f);
                    return a.errorCallback("Error in program linking:" + g), t.deleteProgram(f), Ap(t, h), null
                }
                return f
            }(t, a, s)
        }

        function Tp(t) {
            var e = t.name;
            return e.startsWith("gl_") || e.startsWith("webgl_")
        }

        function Dp(t, e) {
            for (var i = t.uniformSetters || t, n = arguments.length, r = 1; r < n; ++r) {
                var s = arguments[r];
                if (Array.isArray(s)) for (var a = s.length, o = 0; o < a; ++o) Dp(i, s[o]); else for (var h in s) {
                    var l = i[h];
                    l && l(s[h])
                }
            }
        }

        function Cp(t, e, i) {
            i.vertexArrayObject ? t.bindVertexArray(i.vertexArrayObject) : (!function (t, e) {
                for (var i in e) {
                    var n = t[i];
                    n && n(e[i])
                }
            }(e.attribSetters || e, i.attribs), i.indices && t.bindBuffer(34963, i.indices))
        }

        function Pp(t, e) {
            var i = function (t, e) {
                var i = 0;

                function n(e, n, r) {
                    var s, a = n.size > 1 && "[0]" === n.name.substr(-3), o = n.type, h = op[o];
                    if (!h) throw new Error("unknown type: 0x".concat(o.toString(16)));
                    if (h.bindPoint) {
                        var l = i;
                        i += n.size, s = a ? h.arraySetter(t, o, l, r, n.size) : h.setter(t, o, l, r, n.size)
                    } else s = h.arraySetter && a ? h.arraySetter(t, r) : h.setter(t, r);
                    return s.location = r, s
                }

                for (var r = {}, s = t.getProgramParameter(e, 35718), a = 0; a < s; ++a) {
                    var o = t.getActiveUniform(e, a);
                    if (!Tp(o)) {
                        var h = o.name;
                        "[0]" === h.substr(-3) && (h = h.substr(0, h.length - 3));
                        var l = t.getUniformLocation(e, o.name);
                        l && (r[h] = n(0, o, l))
                    }
                }
                return r
            }(t, e), n = function (t, e) {
                for (var i = {}, n = t.getProgramParameter(e, 35721), r = 0; r < n; ++r) {
                    var s = t.getActiveAttrib(e, r);
                    if (!Tp(s)) {
                        var a = t.getAttribLocation(e, s.name), o = xp[s.type], h = o.setter(t, a, o);
                        h.location = a, i[s.name] = h
                    }
                }
                return i
            }(t, e), r = {program: e, uniformSetters: i, attribSetters: n};
            return Tc(t) && (r.uniformBlockSpec = function (t, e) {
                for (var i = t.getProgramParameter(e, 35718), n = [], r = [], s = 0; s < i; ++s) {
                    r.push(s), n.push({});
                    var a = t.getActiveUniform(e, s);
                    if (Tp(a)) break;
                    n[s].name = a.name
                }
                [["UNIFORM_TYPE", "type"], ["UNIFORM_SIZE", "size"], ["UNIFORM_BLOCK_INDEX", "blockNdx"], ["UNIFORM_OFFSET", "offset"]].forEach((function (i) {
                    var s = i[0], a = i[1];
                    t.getActiveUniforms(e, r, t[s]).forEach((function (t, e) {
                        n[e][a] = t
                    }))
                }));
                for (var o = {}, h = t.getProgramParameter(e, 35382), l = 0; l < h; ++l) {
                    var c = t.getActiveUniformBlockName(e, l), u = {
                        index: t.getUniformBlockIndex(e, c),
                        usedByVertexShader: t.getActiveUniformBlockParameter(e, l, 35396),
                        usedByFragmentShader: t.getActiveUniformBlockParameter(e, l, 35398),
                        size: t.getActiveUniformBlockParameter(e, l, 35392),
                        uniformIndices: t.getActiveUniformBlockParameter(e, l, 35395)
                    };
                    u.used = u.usedByVertexShader || u.usedByFragmentShader, o[c] = u
                }
                return {blockSpecs: o, uniformData: n}
            }(t, e), r.transformFeedbackInfo = function (t, e) {
                for (var i = {}, n = t.getProgramParameter(e, 35971), r = 0; r < n; ++r) {
                    var s = t.getTransformFeedbackVarying(e, r);
                    i[s.name] = {index: r, type: s.type, size: s.size}
                }
                return i
            }(t, e)), r
        }

        var Ip = !0, Lp = /^(.*?)_/;

        function Rp(t, e) {
            Lc(t, 0);
            var i = t.getExtension(e);
            if (i) {
                var n = {}, r = Lp.exec(e)[1], s = "_" + r;
                for (var a in i) {
                    var o = i[a], h = "function" == typeof o, l = h ? r : s, c = a;
                    a.endsWith(l) && (c = a.substring(0, a.length - l.length)), void 0 !== t[c] ? h || t[c] === o || ul(c, t[c], o, a) : h ? t[c] = function (t) {
                        return function () {
                            return t.apply(i, arguments)
                        }
                    }(o) : (t[c] = o, n[c] = o)
                }
                n.constructor = {name: i.constructor.name}, Lc(n, 0)
            }
            return i
        }

        var Fp = ["ANGLE_instanced_arrays", "EXT_blend_minmax", "EXT_color_buffer_float", "EXT_color_buffer_half_float", "EXT_disjoint_timer_query", "EXT_disjoint_timer_query_webgl2", "EXT_frag_depth", "EXT_sRGB", "EXT_shader_texture_lod", "EXT_texture_filter_anisotropic", "OES_element_index_uint", "OES_standard_derivatives", "OES_texture_float", "OES_texture_float_linear", "OES_texture_half_float", "OES_texture_half_float_linear", "OES_vertex_array_object", "WEBGL_color_buffer_float", "WEBGL_compressed_texture_atc", "WEBGL_compressed_texture_etc1", "WEBGL_compressed_texture_pvrtc", "WEBGL_compressed_texture_s3tc", "WEBGL_compressed_texture_s3tc_srgb", "WEBGL_depth_texture", "WEBGL_draw_buffers"];

        function kp(t) {
            for (var e = 0; e < Fp.length; ++e) Rp(t, Fp[e])
        }

        function Op(t, e) {
            var i = function (t, e) {
                for (var i = ["webgl", "experimental-webgl"], n = null, r = 0; r < i.length; ++r) if (n = t.getContext(i[r], e)) {
                    Ip && kp(n);
                    break
                }
                return n
            }(t, e);
            return i
        }

        function zp(t, e) {
            e = e || 1, e = Math.max(0, e);
            var i = t.clientWidth * e | 0, n = t.clientHeight * e | 0;
            return (t.width !== i || t.height !== n) && (t.width = i, t.height = n, !0)
        }

        var Bp = function () {
            function t(e, i) {
                var n = this;
                wh(this, t), Mh(this, "gl", null), Mh(this, "isWebGL2", null), Mh(this, "instancedEnabled", !1), Mh(this, "init", (function () {
                    var t = n.gl;
                    t.viewport(0, 0, t.canvas.width, t.canvas.height), t.clearColor(0, 0, 0, 1), t.enable(t.DEPTH_TEST), t.enable(t.CULL_FACE), t.enable(t.BLEND), t.blendFunc(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA)
                })), Mh(this, "resize", (function (t, e) {
                    n.gl.viewport(0, 0, t, e)
                })), Mh(this, "prepareRenderFrame", (function () {
                    n.gl.clear(n.gl.COLOR_BUFFER_BIT | n.gl.DEPTH_BUFFER_BIT)
                })), this.gl = Op(e, i), this.isWebGL2 = Tc(this.gl) && Dc(this.gl), kp(this.gl), this.gl.drawArraysInstanced && this.gl.createVertexArray ? zp(e) : alert("need drawArraysInstanced and createVertexArray")
            }

            return Eh(t, [{
                key: "clearColor", set: function (t) {
                    this.gl.clearColor(t[0], t[1], t[2], t[3])
                }
            }]), t
        }(), Np = 1e-6, jp = "undefined" != typeof Float32Array ? Float32Array : Array;

        function Vp() {
            var t = new jp(16);
            return jp != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t
        }

        function Gp(t) {
            return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
        }

        function Up(t, e) {
            var i = e[0], n = e[1], r = e[2], s = e[3], a = e[4], o = e[5], h = e[6], l = e[7], c = e[8], u = e[9],
                p = e[10], d = e[11], f = e[12], m = e[13], g = e[14], v = e[15], y = i * o - n * a, b = i * h - r * a,
                x = i * l - s * a, w = n * h - r * o, _ = n * l - s * o, E = r * l - s * h, M = c * m - u * f,
                A = c * g - p * f, S = c * v - d * f, T = u * g - p * m, D = u * v - d * m, C = p * v - d * g,
                P = y * C - b * D + x * T + w * S - _ * A + E * M;
            return P ? (P = 1 / P, t[0] = (o * C - h * D + l * T) * P, t[1] = (r * D - n * C - s * T) * P, t[2] = (m * E - g * _ + v * w) * P, t[3] = (p * _ - u * E - d * w) * P, t[4] = (h * S - a * C - l * A) * P, t[5] = (i * C - r * S + s * A) * P, t[6] = (g * x - f * E - v * b) * P, t[7] = (c * E - p * x + d * b) * P, t[8] = (a * D - o * S + l * M) * P, t[9] = (n * S - i * D - s * M) * P, t[10] = (f * _ - m * x + v * y) * P, t[11] = (u * x - c * _ - d * y) * P, t[12] = (o * A - a * T - h * M) * P, t[13] = (i * T - n * A + r * M) * P, t[14] = (m * b - f * w - g * y) * P, t[15] = (c * w - u * b + p * y) * P, t) : null
        }

        function Hp(t, e, i) {
            var n = e[0], r = e[1], s = e[2], a = e[3], o = e[4], h = e[5], l = e[6], c = e[7], u = e[8], p = e[9],
                d = e[10], f = e[11], m = e[12], g = e[13], v = e[14], y = e[15], b = i[0], x = i[1], w = i[2],
                _ = i[3];
            return t[0] = b * n + x * o + w * u + _ * m, t[1] = b * r + x * h + w * p + _ * g, t[2] = b * s + x * l + w * d + _ * v, t[3] = b * a + x * c + w * f + _ * y, b = i[4], x = i[5], w = i[6], _ = i[7], t[4] = b * n + x * o + w * u + _ * m, t[5] = b * r + x * h + w * p + _ * g, t[6] = b * s + x * l + w * d + _ * v, t[7] = b * a + x * c + w * f + _ * y, b = i[8], x = i[9], w = i[10], _ = i[11], t[8] = b * n + x * o + w * u + _ * m, t[9] = b * r + x * h + w * p + _ * g, t[10] = b * s + x * l + w * d + _ * v, t[11] = b * a + x * c + w * f + _ * y, b = i[12], x = i[13], w = i[14], _ = i[15], t[12] = b * n + x * o + w * u + _ * m, t[13] = b * r + x * h + w * p + _ * g, t[14] = b * s + x * l + w * d + _ * v, t[15] = b * a + x * c + w * f + _ * y, t
        }

        function Wp(t, e, i, n, r) {
            var s, a = 1 / Math.tan(e / 2);
            return t[0] = a / i, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != r && r !== 1 / 0 ? (s = 1 / (n - r), t[10] = (r + n) * s, t[14] = 2 * r * n * s) : (t[10] = -1, t[14] = -2 * n), t
        }

        function qp(t, e, i, n) {
            var r, s, a, o, h, l, c, u, p, d, f = e[0], m = e[1], g = e[2], v = n[0], y = n[1], b = n[2], x = i[0],
                w = i[1], _ = i[2];
            return Math.abs(f - x) < Np && Math.abs(m - w) < Np && Math.abs(g - _) < Np ? Gp(t) : (c = f - x, u = m - w, p = g - _, r = y * (p *= d = 1 / Math.hypot(c, u, p)) - b * (u *= d), s = b * (c *= d) - v * p, a = v * u - y * c, (d = Math.hypot(r, s, a)) ? (r *= d = 1 / d, s *= d, a *= d) : (r = 0, s = 0, a = 0), o = u * a - p * s, h = p * r - c * a, l = c * s - u * r, (d = Math.hypot(o, h, l)) ? (o *= d = 1 / d, h *= d, l *= d) : (o = 0, h = 0, l = 0), t[0] = r, t[1] = o, t[2] = c, t[3] = 0, t[4] = s, t[5] = h, t[6] = u, t[7] = 0, t[8] = a, t[9] = l, t[10] = p, t[11] = 0, t[12] = -(r * f + s * m + a * g), t[13] = -(o * f + h * m + l * g), t[14] = -(c * f + u * m + p * g), t[15] = 1, t)
        }

        function Xp() {
            var t = new jp(3);
            return jp != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t
        }

        function Yp(t, e, i) {
            var n = new jp(3);
            return n[0] = t, n[1] = e, n[2] = i, n
        }

        function Zp(t, e, i) {
            return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t[2] = e[2] + i[2], t
        }

        function Jp(t, e, i) {
            return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t[2] = e[2] - i[2], t
        }

        function Qp(t, e, i) {
            return t[0] = e[0] * i, t[1] = e[1] * i, t[2] = e[2] * i, t
        }

        function Kp(t, e) {
            var i = e[0], n = e[1], r = e[2], s = i * i + n * n + r * r;
            return s > 0 && (s = 1 / Math.sqrt(s)), t[0] = e[0] * s, t[1] = e[1] * s, t[2] = e[2] * s, t
        }

        function $p(t, e) {
            return t[0] * e[0] + t[1] * e[1] + t[2] * e[2]
        }

        function td(t, e, i) {
            var n = e[0], r = e[1], s = e[2], a = i[0], o = i[1], h = i[2];
            return t[0] = r * h - s * o, t[1] = s * a - n * h, t[2] = n * o - r * a, t
        }

        function ed(t, e, i, n) {
            var r = e[0], s = e[1], a = e[2];
            return t[0] = r + n * (i[0] - r), t[1] = s + n * (i[1] - s), t[2] = a + n * (i[2] - a), t
        }

        function id(t, e, i) {
            var n = e[0], r = e[1], s = e[2], a = i[3] * n + i[7] * r + i[11] * s + i[15];
            return a = a || 1, t[0] = (i[0] * n + i[4] * r + i[8] * s + i[12]) / a, t[1] = (i[1] * n + i[5] * r + i[9] * s + i[13]) / a, t[2] = (i[2] * n + i[6] * r + i[10] * s + i[14]) / a, t
        }

        Math.hypot || (Math.hypot = function () {
            for (var t = 0, e = arguments.length; e--;) t += arguments[e] * arguments[e];
            return Math.sqrt(t)
        });
        var nd, rd = function (t) {
            var e = t[0], i = t[1], n = t[2];
            return Math.hypot(e, i, n)
        };
        nd = Xp();
        !function () {
            var t, e = (t = new jp(4), jp != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0), t)
        }();

        function sd() {
            var t = new jp(4);
            return jp != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t
        }

        function ad(t, e, i, n) {
            var r, s, a, o, h, l = e[0], c = e[1], u = e[2], p = e[3], d = i[0], f = i[1], m = i[2], g = i[3];
            return (s = l * d + c * f + u * m + p * g) < 0 && (s = -s, d = -d, f = -f, m = -m, g = -g), 1 - s > Np ? (r = Math.acos(s), a = Math.sin(r), o = Math.sin((1 - n) * r) / a, h = Math.sin(n * r) / a) : (o = 1 - n, h = n), t[0] = o * l + h * d, t[1] = o * c + h * f, t[2] = o * u + h * m, t[3] = o * p + h * g, t
        }

        var od, hd, ld, cd, ud, pd, dd, fd = function (t, e) {
            var i = e[0], n = e[1], r = e[2], s = e[3], a = i * i + n * n + r * r + s * s;
            return a > 0 && (a = 1 / Math.sqrt(a)), t[0] = i * a, t[1] = n * a, t[2] = r * a, t[3] = s * a, t
        };
        od = Xp(), hd = Yp(1, 0, 0), ld = Yp(0, 1, 0), cd = sd(), ud = sd(), pd = new jp(9), jp != Float32Array && (pd[1] = 0, pd[2] = 0, pd[3] = 0, pd[5] = 0, pd[6] = 0, pd[7] = 0), pd[0] = 1, pd[4] = 1, pd[8] = 1, dd = pd;
        !function () {
            var t = function () {
                var t = new jp(2);
                return jp != Float32Array && (t[0] = 0, t[1] = 0), t
            }()
        }();
        var md, gd = function t(e, i) {
            var n = this;
            wh(this, t), Mh(this, "fov", void 0), Mh(this, "width", void 0), Mh(this, "height", void 0), Mh(this, "aspect", void 0), Mh(this, "zNear", void 0), Mh(this, "zFar", void 0), Mh(this, "projection", void 0), Mh(this, "eye", void 0), Mh(this, "target", void 0), Mh(this, "up", void 0), Mh(this, "view", void 0), Mh(this, "viewProjection", void 0), Mh(this, "world", void 0), Mh(this, "resize", (function (t, e) {
                n.width = t, n.height = e, n.aspect = t / e, n.projection = Vp(), Wp(n.projection, n.fov, n.aspect, n.zNear, n.zFar)
            })), Mh(this, "update", (function () {
                qp(n.view, n.eye, n.target, n.up), Up(n.camera, n.view), Hp(n.viewProjection, n.projection, n.view)
            })), Mh(this, "setPosition", (function (t) {
                n.eye = t
            })), Mh(this, "getUniforms", (function () {
                var t = {};
                return t.u_viewInverse = n.camera, t.u_world = n.world, t.u_worldInverseTranspose = Vp(), t.u_view = n.view, t.u_resolution = [n.width, n.height], Up(t.u_worldInverseTranspose, n.world), function (t, e) {
                    if (t === e) {
                        var i = e[1], n = e[2], r = e[3], s = e[6], a = e[7], o = e[11];
                        t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = i, t[6] = e[9], t[7] = e[13], t[8] = n, t[9] = s, t[11] = e[14], t[12] = r, t[13] = a, t[14] = o
                    } else t[0] = e[0], t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = e[1], t[5] = e[5], t[6] = e[9], t[7] = e[13], t[8] = e[2], t[9] = e[6], t[10] = e[10], t[11] = e[14], t[12] = e[3], t[13] = e[7], t[14] = e[11], t[15] = e[15]
                }(t.u_worldInverseTranspose, t.u_worldInverseTranspose), t.u_worldViewProjection = Vp(), Hp(t.u_worldViewProjection, n.viewProjection, n.world), t.u_cameraPos = n.eye, t
            })), Mh(this, "getRayFromScreen", (function (t, e) {
                var i = 2 * t - 1, r = 2 * e - 1, s = n.unproject([i, r, -1]), a = n.unproject([i, r, 1]), o = Xp();
                return Jp(o, a, s), Kp(o, o), {origin: s, direction: o}
            })), Mh(this, "unproject", (function (t) {
                var e = Vp();
                Up(e, n.viewProjection);
                var i = Yp(t[0], t[1], t[2]);
                return id(i, i, e), i
            })), Mh(this, "project", (function (t) {
                var e = function (t) {
                    var e = new jp(3);
                    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e
                }(t);
                return id(e, e, n.viewProjection), [(e[0] + 1) / 2, (e[1] + 1) / 2]
            })), this.fov = Math.PI / 180 * 30, this.width = e, this.height = i, this.aspect = e / i, this.zNear = .01, this.zFar = 100, this.projection = Vp(), Wp(this.projection, this.fov, this.aspect, this.zNear, this.zFar), this.eye = [0, 0, 6], this.target = [0, 0, 0], this.up = [0, 1, 0], this.view = Vp(), qp(this.view, this.eye, this.target, this.up), this.camera = Vp(), Up(this.camera, this.view), this.viewProjection = Vp(), Hp(this.viewProjection, this.projection, this.view), this.world = Vp(), Gp(this.world)
        }, vd = function t(e, i) {
            var n = this;
            wh(this, t), Mh(this, "resize", (function (t, e) {
                n.camera.resize(t, e)
            })), Mh(this, "update", (function (t) {
                n.camera.update(t)
            })), Mh(this, "getUniforms", (function (t) {
                var e = n.camera.getUniforms(t);
                return e.time = t, e
            })), this.camera = new gd(e, i)
        }, yd = function () {
            function t(e) {
                var i = this;
                wh(this, t), Mh(this, "programInfo", null), Mh(this, "textures", {}), Mh(this, "uniforms", null), Mh(this, "shaderStrings", null), Mh(this, "isInit", !1), Mh(this, "texturesLoaded", !1), Mh(this, "init", (function (t) {
                    i.programInfo = function (t, e, i, n, r) {
                        var s = Ep(i, n, r), a = !0;
                        if (e = e.map((function (t) {
                            if (t.indexOf("\n") < 0) {
                                var e = Qu(t);
                                e ? t = e.text : (s.errorCallback("no element with id: " + t), a = !1)
                            }
                            return t
                        })), !a) return null;
                        var o = Sp(t, e, s);
                        return o ? Pp(t, o) : null
                    }(t, Object.values(i.shaderStrings)), i.isInit = !0
                })), Mh(this, "loadTextures", (function (t, e, n) {
                    if (e) {
                        var r = Object.keys(e).length, s = 0;
                        Object.entries(e).forEach((function (e) {
                            var a = Fh(e, 2), o = a[0], h = a[1];
                            i.textures[o] = Zu(t, h, (function () {
                                (s += 1) === r && (i.texturesLoaded = !0, n && n())
                            }))
                        }))
                    }
                })), Mh(this, "updateUniforms", (function (t) {
                    Object.entries(t).forEach((function (t) {
                        var e = Fh(t, 2), n = e[0], r = e[1];
                        i.uniforms[n] = r
                    }))
                })), this.shaderStrings = e
            }

            return Eh(t, [{
                key: "isReady", get: function () {
                    return this.isInit && this.texturesLoaded
                }
            }]), t
        }(), bd = new Array(32).fill(void 0);

        function xd(t) {
            return bd[t]
        }

        bd.push(void 0, null, !0, !1);
        var wd = 0, _d = null;

        function Ed() {
            return null !== _d && _d.buffer === md.memory.buffer || (_d = new Uint8Array(md.memory.buffer)), _d
        }

        var Md = new TextEncoder("utf-8"), Ad = "function" == typeof Md.encodeInto ? function (t, e) {
            return Md.encodeInto(t, e)
        } : function (t, e) {
            var i = Md.encode(t);
            return e.set(i), {read: t.length, written: i.length}
        };

        function Sd(t, e, i) {
            if (void 0 === i) {
                var n = Md.encode(t), r = e(n.length);
                return Ed().subarray(r, r + n.length).set(n), wd = n.length, r
            }
            for (var s = t.length, a = e(s), o = Ed(), h = 0; h < s; h++) {
                var l = t.charCodeAt(h);
                if (l > 127) break;
                o[a + h] = l
            }
            if (h !== s) {
                0 !== h && (t = t.slice(h)), a = i(a, s, s = h + 3 * t.length);
                var c = Ed().subarray(a + h, a + s);
                h += Ad(t, c).written
            }
            return wd = h, a
        }

        var Td = null;

        function Dd() {
            return null !== Td && Td.buffer === md.memory.buffer || (Td = new Int32Array(md.memory.buffer)), Td
        }

        var Cd = bd.length;

        function Pd(t) {
            var e = xd(t);
            return function (t) {
                t < 36 || (bd[t] = Cd, Cd = t)
            }(t), e
        }

        var Id = new TextDecoder("utf-8", {ignoreBOM: !0, fatal: !0});

        function Ld(t, e) {
            return Id.decode(Ed().subarray(t, t + e))
        }

        function Rd(t) {
            Cd === bd.length && bd.push(bd.length + 1);
            var e = Cd;
            return Cd = bd[e], bd[e] = t, e
        }

        Id.decode();
        var Fd = null;

        function kd(t, e) {
            var i = e(4 * t.length);
            return (null !== Fd && Fd.buffer === md.memory.buffer || (Fd = new Float32Array(md.memory.buffer)), Fd).set(t, i / 4), wd = t.length, i
        }

        var Od = null;

        function zd(t, e) {
            var i = e(4 * t.length);
            return (null !== Od && Od.buffer === md.memory.buffer || (Od = new Uint32Array(md.memory.buffer)), Od).set(t, i / 4), wd = t.length, i
        }

        class Bd {
            free() {
                var t = this.ptr;
                this.ptr = 0, md.__wbg_gkcollider_free(t)
            }

            static create_collision_geometry(t, e, i) {
                var n = kd(t, md.__wbindgen_malloc), r = wd, s = kd(e, md.__wbindgen_malloc), a = wd,
                    o = zd(i, md.__wbindgen_malloc), h = wd,
                    l = md.gkcollider_create_collision_geometry(n, r, s, a, o, h);
                return jd.__wrap(l)
            }
        }

        class Nd {
            free() {
                var t = this.ptr;
                this.ptr = 0, md.__wbg_gkcollision_free(t)
            }
        }

        class jd {
            static __wrap(t) {
                var e = Object.create(jd.prototype);
                return e.ptr = t, e
            }

            free() {
                var t = this.ptr;
                this.ptr = 0, md.__wbg_gkcollisiongeo_free(t)
            }

            raycast(t, e) {
                var i = kd(t, md.__wbindgen_malloc), n = wd, r = kd(e, md.__wbindgen_malloc), s = wd;
                return Pd(md.gkcollisiongeo_raycast(this.ptr, i, n, r, s))
            }

            hitTest(t, e) {
                var i = kd(t, md.__wbindgen_malloc), n = wd, r = kd(e, md.__wbindgen_malloc), s = wd;
                return 0 !== md.gkcollisiongeo_hitTest(this.ptr, i, n, r, s)
            }
        }

        function Vd(t, e) {
            return Gd.apply(this, arguments)
        }

        function Gd() {
            return Gd = bh((function* (t, e) {
                if ("function" == typeof Response && t instanceof Response) {
                    if ("function" == typeof WebAssembly.instantiateStreaming) try {
                        return yield WebAssembly.instantiateStreaming(t, e)
                    } catch (e) {
                        if ("application/wasm" == t.headers.get("Content-Type")) throw e;
                        console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e)
                    }
                    var i = yield t.arrayBuffer();
                    return yield WebAssembly.instantiate(i, e)
                }
                var n = yield WebAssembly.instantiate(t, e);
                return n instanceof WebAssembly.Instance ? {instance: n, module: t} : n
            })), Gd.apply(this, arguments)
        }

        function Ud(t) {
            return Hd.apply(this, arguments)
        }

        function Hd() {
            return Hd = bh((function* (t) {
                void 0 === t && console.log("You must specify wasm location");
                var e = {wbg: {}};
                e.wbg.__wbindgen_json_serialize = function (t, e) {
                    var i = xd(e),
                        n = Sd(JSON.stringify(void 0 === i ? null : i), md.__wbindgen_malloc, md.__wbindgen_realloc),
                        r = wd;
                    Dd()[t / 4 + 1] = r, Dd()[t / 4 + 0] = n
                }, e.wbg.__wbindgen_object_drop_ref = function (t) {
                    Pd(t)
                }, e.wbg.__wbindgen_json_parse = function (t, e) {
                    return Rd(JSON.parse(Ld(t, e)))
                }, e.wbg.__wbindgen_string_new = function (t, e) {
                    return Rd(Ld(t, e))
                }, e.wbg.__wbg_new_59cb74e423758ede = function () {
                    return Rd(new Error)
                }, e.wbg.__wbg_stack_558ba5917b466edd = function (t, e) {
                    var i = Sd(xd(e).stack, md.__wbindgen_malloc, md.__wbindgen_realloc), n = wd;
                    Dd()[t / 4 + 1] = n, Dd()[t / 4 + 0] = i
                }, e.wbg.__wbg_error_4bb6c2a97407129a = function (t, e) {
                    try {
                        console.error(Ld(t, e))
                    } finally {
                        md.__wbindgen_free(t, e)
                    }
                }, e.wbg.__wbg_debug_7020dcb48edf105b = function (t) {
                    console.debug(xd(t))
                }, e.wbg.__wbg_error_b23efba5bfb5cec5 = function (t) {
                    console.error(xd(t))
                }, e.wbg.__wbg_info_8ce99578d0b91a35 = function (t) {
                    console.info(xd(t))
                }, e.wbg.__wbg_log_c180b836187d3c94 = function (t) {
                    console.log(xd(t))
                }, e.wbg.__wbg_warn_942f927afebcc748 = function (t) {
                    console.warn(xd(t))
                }, e.wbg.__wbindgen_throw = function (t, e) {
                    throw new Error(Ld(t, e))
                }, ("string" == typeof t || "function" == typeof Request && t instanceof Request || "function" == typeof URL && t instanceof URL) && (t = fetch(t));
                var {instance: i, module: n} = yield Vd(yield t, e);
                return md = i.exports, Ud.__wbindgen_wasm_module = n, md
            })), Hd.apply(this, arguments)
        }

        var Wd = function () {
            function t() {
                var e = this;
                wh(this, t), Mh(this, "id", null), Mh(this, "geometry", null), Mh(this, "collisionGeometry", null), Mh(this, "material", null), Mh(this, "_translation", [0, 0, 0]), Mh(this, "_rotation", [0, 0, 0]), Mh(this, "_scale", [1, 1, 1]), Mh(this, "_modelMatrix", null), Mh(this, "_modelIsDirty", !0), Mh(this, "rayCast", !0), Mh(this, "isInteractive", !1), Mh(this, "isSelectable", !1), Mh(this, "isHoverable", !1), Mh(this, "shouldDraw", !0), Mh(this, "setInteractive", (function (t, i, n) {
                    e.isInteractive = "boolean" == typeof t && t, e.isSelectable = "boolean" == typeof i && i, e.isHoverable = "boolean" == typeof n && n
                })), this.id = "_" + Math.random().toString(36).substr(2, 9)
            }

            return Eh(t, [{
                key: "update", value: function (t) {
                    var e = this;
                    t && Object.entries(t).forEach((function (t) {
                        e.material.uniforms[t[0]] = t[1]
                    }))
                }
            }, {
                key: "isReady", get: function () {
                    return !(!this.geometry || !this.material) && (this.geometry.isReady && this.material.isReady)
                }
            }, {
                key: "translation", get: function () {
                    return this._translation
                }, set: function (t) {
                    this._translation = t, this._modelIsDirty = !0
                }
            }, {
                key: "rotation", get: function () {
                    return this._rotation
                }, set: function (t) {
                    this._rotation = t, this._modelIsDirty = !0
                }
            }, {
                key: "scale", get: function () {
                    return this._scale
                }, set: function (t) {
                    this._scale = t, this._modelIsDirty = !0
                }
            }, {
                key: "modelMatrix", get: function () {
                    if (this._modelIsDirty) {
                        var t = Kh.identity(), e = Kh.translation(this._translation, t), i = Kh.scaling(this._scale);
                        this._modelMatrix = e, Kh.rotateX(e, this._rotation[0], this._modelMatrix), Kh.rotateY(e, this._rotation[1], this._modelMatrix), Kh.rotateZ(e, this._rotation[2], this._modelMatrix), Kh.multiply(this._modelMatrix, i, this._modelMatrix), this._modelIsDirty = !1
                    }
                    return this._modelMatrix
                }
            }]), t
        }(), qd = function (t) {
            Th(i, t);
            var e = Lh(i);

            function i() {
                return wh(this, i), e.apply(this, arguments)
            }

            return i
        }(Wd), Xd = function () {
            function t(e) {
                var i = this;
                wh(this, t), Mh(this, "isInit", !1), Mh(this, "isDirty", !1), Mh(this, "needsResize", !1), Mh(this, "newGeometry", []), Mh(this, "bufferInfo", void 0), Mh(this, "vertices", void 0), Mh(this, "init", (function (t) {
                    0 === Object.keys(i.vertices).length && i.vertices.constructor === Object || (Object.keys(i.vertices).forEach((function (e) {
                        "DYNAMIC_DRAW" === i.vertices[e].drawType && (i.vertices[e].drawType = t.DYNAMIC_DRAW)
                    })), i.bufferInfo = Tl(t, i.vertices), i.isInit = !0, i.isDirty = !1)
                })), Mh(this, "resizeVertices", (function () {
                })), Mh(this, "updateGeometry", (function (t, e) {
                    void 0 !== e && "number" == typeof e || (e = 0), Object.keys(t).forEach((function (n) {
                        for (var r = i.vertices[n].perInstance * e, s = 0; s < t[n].data.length; s += 1) i.vertices[n].data[s + r] = t[n].data[s]
                    })), i.isDirty = !0
                })), Mh(this, "updateBuffers", (function (t) {
                    Object.keys(i.bufferInfo.attribs).forEach((function (e) {
                        !function (t, e, i, n) {
                            i = Ml(i), void 0 !== n ? (t.bindBuffer(fl, e.buffer), t.bufferSubData(fl, n, i)) : gl(t, fl, e.buffer, i, e.drawType)
                        }(t, i.bufferInfo.attribs[e], i.vertices[e])
                    })), i.isDirty = !1
                })), Mh(this, "reloadBuffers", (function (t) {
                    i.deleteBuffers(t), i.bufferInfo = Tl(t, i.vertices), i.isDirty = !1, i.needsResize = !1
                })), Mh(this, "deleteBuffers", (function (t) {
                    Object.keys(i.bufferInfo.attribs).forEach((function (e) {
                        t.deleteBuffer(e.buffer)
                    })), t.deleteBuffer(i.bufferInfo.indices), i.bufferInfo = {}
                })), this.vertices = "sphere" === e ? Sc.createSphereVertices(1, 128, 128) : {}
            }

            return Eh(t, [{
                key: "isReady", get: function () {
                    return this.isInit
                }
            }]), t
        }(), Yd = {
            vertex: "#define GLSLIFY 1\nattribute vec4 position;attribute vec3 normal;attribute vec2 texcoord;uniform mat4 u_worldViewProjection;uniform mat4 u_viewInverse;uniform mat4 u_model;uniform vec3 u_cameraPos;varying float vAlpha;varying vec2 vTexture;void main(){vec4 pos=u_worldViewProjection*u_model*position;vec4 transformedCamera=vec4(-0.5,1.0,-1.0,1.0)*u_worldViewProjection;vAlpha=pow((1.0+(dot(normal,normalize(transformedCamera.xyz))))/2.0,1.0);vTexture=texcoord;gl_Position=pos;}",
            fragment: "precision mediump float;\n#define GLSLIFY 1\nuniform sampler2D uTexture;varying float vAlpha;varying vec2 vTexture;vec3 yellow=vec3(255.0/255.0,210.0/255.0,28.0/255.0);void main(){vec4 textureColor=texture2D(uTexture,vec2(vTexture.x-0.25,vTexture.y));float alpha=vAlpha+(1.0-vAlpha)*0.05;alpha*=0.9;gl_FragColor=vec4(textureColor.rgb*vAlpha,1.0);}"
        }, Zd = {}, Jd = function (t) {
            Th(i, t);
            var e = Lh(i);

            function i(t) {
                var n, r;
                return wh(this, i), Mh(Ph(r = e.call(this)), "material", null), Mh(Ph(r), "init", (function (t, e) {
                    r.geometry = new Xd("sphere"), r.geometry.init(t);
                    var i = {surface: {src: r.textureSrc.surface, minMag: t.LINEAR}};
                    r.material.init(t), r.material.loadTextures(t, i, (function () {
                        r.material.uniforms.uTexture = r.material.textures.surface, e && e()
                    })), r.material.uniforms.uModelMatrix = r.modelMatrix
                })), Mh(Ph(r), "createCollisionGeo", (function () {
                    r.collisionGeometry && r.collisionGeometry instanceof Nd || (r.collisionGeometry = Bd.create_collision_geometry(r.geometry.vertices.position, r.geometry.vertices.texcoord, r.geometry.vertices.indices))
                })), Mh(Ph(r), "rayCastFrom", (function (t) {
                    return r.collisionGeometry.raycast(t.origin, t.direction)
                })), Mh(Ph(r), "hitTest", (function (t) {
                    return r.collisionGeometry.hitTest(t.origin, t.direction)
                })), Mh(Ph(r), "onSelection", (function () {
                })), Mh(Ph(r), "update", (function (t, e, s) {
                    Rh((n = Ph(r), Dh(i.prototype)), "update", n).call(n, e, s), r.material.uniforms.u_model = r.modelMatrix
                })), Mh(Ph(r), "draw", (function (t) {
                    r.isReady && r.shouldDraw && (t.useProgram(r.material.programInfo.program), Cp(t, r.material.programInfo, r.geometry.bufferInfo), Dp(r.material.programInfo, r.material.uniforms), t.drawElements(t.TRIANGLES, r.geometry.bufferInfo.numElements, t.UNSIGNED_SHORT, 0))
                })), r.material = new yd(Yd), r.material.uniforms = Zd, r.textureSrc = {surface: t}, r
            }

            return i
        }(qd), Qd = function () {
            function t() {
                wh(this, t)
            }

            return Eh(t, null, [{
                key: "radiansForPosition", value: function (t, e) {
                    return e > 0 ? t >= 0 ? Math.atan(t / e) : 2 * Math.PI + Math.atan(t / e) : e < 0 ? Math.PI + Math.atan(t / e) : t > 0 ? Math.PI / 2 : 3 * Math.PI / 2
                }
            }, {
                key: "latLonFromWorld", value: function (t) {
                    var e = Xp();
                    Kp(e, t);
                    for (var i = Math.asin(e[1]), n = this.radiansForPosition(e[0], e[2]), r = 180 * i / Math.PI, s = 180 * n / Math.PI; s > 180;) s -= 360;
                    return {lat: r, lon: s}
                }
            }, {
                key: "distanceBetweenPoints", value: function (t, e) {
                    var i = function (t) {
                            return t * (Math.PI / 180)
                        }, n = i(t.lat), r = i(e.lat), s = i(e.lat - t.lat), a = i(e.lon - t.lon),
                        o = Math.sin(s / 2) * Math.sin(s / 2) + Math.cos(n) * Math.cos(r) * Math.sin(a / 2) * Math.sin(a / 2);
                    return 6371 * (2 * Math.atan2(Math.sqrt(o), Math.sqrt(1 - o)))
                }
            }, {
                key: "worldFromLatLon", value: function (t, e, i) {
                    var n = i || 0, r = t * Math.PI / 180, s = e * Math.PI / 180, a = Math.cos(r), o = Math.sin(r),
                        h = Yp(Math.sin(s) * a, o, Math.cos(s) * a), l = Xp();
                    return Kp(l, h), Zp(h, h, Qp(l, l, n)), h
                }
            }, {
                key: "dotBetweenLatLon", value: function (e, i) {
                    return $p(t.worldFromLatLon(e[0], e[1]), t.worldFromLatLon(i[0], i[1]))
                }
            }, {
                key: "hexToRGB", value: function (t, e) {
                    var i = 0, n = 0, r = 0, s = !1 !== e;
                    return 4 === t.length ? (i = "0x".concat(t[1]).concat(t[1]), n = "0x".concat(t[2]).concat(t[2]), r = "0x".concat(t[3]).concat(t[3])) : 7 === t.length && (i = "0x".concat(t[1]).concat(t[2]), n = "0x".concat(t[3]).concat(t[4]), r = "0x".concat(t[5]).concat(t[6])), s ? (i /= 255, n /= 255, r /= 255) : (i = parseInt(i, 16), n = parseInt(n, 16), r = parseInt(r, 16)), [i, n, r]
                }
            }, {
                key: "hexToRGBA", value: function (t, e, i) {
                    var n = this.hexToRGB(t, i), r = !1 !== i ? e : 255 * e;
                    return [n[0], n[1], n[2], r]
                }
            }, {
                key: "isSubSet", value: function (t, e) {
                    return t.every((function (t) {
                        return void 0 !== e.find((function (e) {
                            return e === t
                        }))
                    }))
                }
            }, {
                key: "lerpColor", value: function (t, e, i) {
                    var n = parseInt(t.replace(/#/g, ""), 16), r = n >> 16, s = n >> 8 & 255, a = 255 & n,
                        o = parseInt(e.replace(/#/g, ""), 16);
                    return "#".concat(((1 << 24) + (r + i * ((o >> 16) - r) << 16) + (s + i * ((o >> 8 & 255) - s) << 8) + (a + i * ((255 & o) - a)) | 0).toString(16).slice(1))
                }
            }]), t
        }(), Kd = function () {
            function t(e, i, n, r) {
                var s = this;
                wh(this, t), Mh(this, "time", void 0), Mh(this, "delay", 0), Mh(this, "ease", (function (t) {
                    return t
                })), Mh(this, "onComplete", (function (t) {
                })), Mh(this, "onUpdate", (function (t) {
                })), Mh(this, "endAt", void 0), Mh(this, "isNumeric", !1), Mh(this, "toObj", null), Mh(this, "fromObj", null), Mh(this, "currentObj", null), Mh(this, "mechanism", (function () {
                    if (s.isRunning) {
                        if (s.stopped) return !1;
                        var t = s.endAt - (new Date).getTime();
                        t <= 0 ? (clearTimeout(s.playTimeout), s.stopped = !0, s.advanceFrame(1, 1), s.isNumeric ? s.onUpdate(s.currentObj.value) : s.onUpdate(s.currentObj), s.onComplete(!0), s.cleanup()) : (s.advanceFrame(s.time - t, s.time), s.isNumeric ? s.onUpdate(s.currentObj.value) : s.onUpdate(s.currentObj))
                    }
                })), r = r || {}, this.time = n, this.endAt = (new Date).getTime() + this.time, this.isNumeric = !isNaN(e), this.isNumeric ? (this.toObj = {value: i}, this.fromObj = {value: e}) : (this.toObj = Sh({}, i), this.fromObj = Sh({}, e)), this.currentObj = Sh({}, this.fromObj), this.id = t.getId(), t.tweens[this.id] = this, r.onComplete && (this.onComplete = r.onComplete, delete r.onComplete), r.onUpdate && (this.onUpdate = r.onUpdate, delete r.onUpdate), r.ease && (this.ease = r.ease, delete r.ease), r.delay && (this.endAt += r.delay, this.delay = r.delay, delete r.delay), this.playTimeout = setTimeout((function () {
                    s.play()
                }), this.delay)
            }

            return Eh(t, [{
                key: "play", value: function () {
                    this.endAt = (new Date).getTime() + this.time, this.isRunning = !0, t.isRunning || (t.isRunning = !0, requestAnimationFrame(t.mechanism))
                }
            }, {
                key: "stop", value: function () {
                    clearTimeout(this.playTimeout), this.stopped = !0, this.onComplete(!1), this.cleanup()
                }
            }, {
                key: "currentValue", value: function () {
                    return this.isNumeric ? this.currentObj.value : this.currentObj
                }
            }, {
                key: "cleanup", value: function () {
                    this.isRunning = !1, delete t.tweens[this.id], 0 === Object.keys(t.tweens).length && (t.isRunning = !1)
                }
            }, {
                key: "advanceFrame", value: function (t, e) {
                    var i = 0 !== e ? t / e : 1;
                    for (var n in i = this.ease(i), this.toObj) {
                        var r = this.fromObj[n], s = this.toObj[n] - r;
                        this.currentObj[n] = r + s * i
                    }
                }
            }]), t
        }();
        Kd.id = 0, Kd.tweens = {}, Kd.killTweensOf = function (t) {
            for (var e in Kd.tweens) {
                var i = Kd.tweens[e];
                i.obj === t && i.stop()
            }
        }, Kd.getId = function () {
            return ++Kd.id
        }, Kd.isRunning = !1, Kd.mechanism = function () {
            for (var t in Kd.tweens) Kd.tweens[t].mechanism();
            Kd.isRunning && requestAnimationFrame(Kd.mechanism)
        };
        "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== __webpack_require__.g ? __webpack_require__.g : "undefined" != typeof self && self;

        function $d(t, e) {
            return t(e = {exports: {}}, e.exports), e.exports
        }

        $d((function (t) {
            !function (e, i, n, r) {
                function s(t, e, i) {
                    return setTimeout(c(t, i), e)
                }

                function a(t, e, i) {
                    return !!Array.isArray(t) && (o(t, i[e], i), !0)
                }

                function o(t, e, i) {
                    var n;
                    if (t) if (t.forEach) t.forEach(e, i); else if (t.length !== r) for (n = 0; n < t.length;) e.call(i, t[n], n, t), n++; else for (n in t) t.hasOwnProperty(n) && e.call(i, t[n], n, t)
                }

                function h(t, i, n) {
                    var r = "DEPRECATED METHOD: " + i + "\n" + n + " AT \n";
                    return function () {
                        var i = new Error("get-stack-trace"),
                            n = i && i.stack ? i.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace",
                            s = e.console && (e.console.warn || e.console.log);
                        return s && s.call(e.console, r, n), t.apply(this, arguments)
                    }
                }

                function l(t, e, i) {
                    var n, r = e.prototype;
                    (n = t.prototype = Object.create(r)).constructor = t, n._super = r, i && rt(n, i)
                }

                function c(t, e) {
                    return function () {
                        return t.apply(e, arguments)
                    }
                }

                function u(t, e) {
                    return xh(t) == ot ? t.apply(e && e[0] || r, e) : t
                }

                function p(t, e) {
                    return t === r ? e : t
                }

                function d(t, e, i) {
                    o(v(e), (function (e) {
                        t.addEventListener(e, i, !1)
                    }))
                }

                function f(t, e, i) {
                    o(v(e), (function (e) {
                        t.removeEventListener(e, i, !1)
                    }))
                }

                function m(t, e) {
                    for (; t;) {
                        if (t == e) return !0;
                        t = t.parentNode
                    }
                    return !1
                }

                function g(t, e) {
                    return t.indexOf(e) > -1
                }

                function v(t) {
                    return t.trim().split(/\s+/g)
                }

                function y(t, e, i) {
                    if (t.indexOf && !i) return t.indexOf(e);
                    for (var n = 0; n < t.length;) {
                        if (i && t[n][i] == e || !i && t[n] === e) return n;
                        n++
                    }
                    return -1
                }

                function b(t) {
                    return Array.prototype.slice.call(t, 0)
                }

                function x(t, e, i) {
                    for (var n = [], r = [], s = 0; s < t.length;) {
                        var a = e ? t[s][e] : t[s];
                        y(r, a) < 0 && n.push(t[s]), r[s] = a, s++
                    }
                    return i && (n = e ? n.sort((function (t, i) {
                        return t[e] > i[e]
                    })) : n.sort()), n
                }

                function w(t, e) {
                    for (var i, n, s = e[0].toUpperCase() + e.slice(1), a = 0; a < st.length;) {
                        if ((n = (i = st[a]) ? i + s : e) in t) return n;
                        a++
                    }
                    return r
                }

                function _(t) {
                    var i = t.ownerDocument || t;
                    return i.defaultView || i.parentWindow || e
                }

                function E(t, e) {
                    var i = this;
                    this.manager = t, this.callback = e, this.element = t.element, this.target = t.options.inputTarget, this.domHandler = function (e) {
                        u(t.options.enable, [t]) && i.handler(e)
                    }, this.init()
                }

                function M(t, e, i) {
                    var n = i.pointers.length, r = i.changedPointers.length, s = e & xt && n - r == 0,
                        a = e & (_t | Et) && n - r == 0;
                    i.isFirst = !!s, i.isFinal = !!a, s && (t.session = {}), i.eventType = e, function (t, e) {
                        var i = t.session, n = e.pointers, r = n.length;
                        i.firstInput || (i.firstInput = S(e)), r > 1 && !i.firstMultiple ? i.firstMultiple = S(e) : 1 === r && (i.firstMultiple = !1);
                        var s = i.firstInput, a = i.firstMultiple, o = a ? a.center : s.center, h = e.center = T(n);
                        e.timeStamp = ct(), e.deltaTime = e.timeStamp - s.timeStamp, e.angle = I(o, h), e.distance = P(o, h), function (t, e) {
                            var i = e.center, n = t.offsetDelta || {}, r = t.prevDelta || {}, s = t.prevInput || {};
                            e.eventType !== xt && s.eventType !== _t || (r = t.prevDelta = {
                                x: s.deltaX || 0,
                                y: s.deltaY || 0
                            }, n = t.offsetDelta = {
                                x: i.x,
                                y: i.y
                            }), e.deltaX = r.x + (i.x - n.x), e.deltaY = r.y + (i.y - n.y)
                        }(i, e), e.offsetDirection = C(e.deltaX, e.deltaY);
                        var l = D(e.deltaTime, e.deltaX, e.deltaY);
                        e.overallVelocityX = l.x, e.overallVelocityY = l.y, e.overallVelocity = lt(l.x) > lt(l.y) ? l.x : l.y, e.scale = a ? function (t, e) {
                            return P(e[0], e[1], Rt) / P(t[0], t[1], Rt)
                        }(a.pointers, n) : 1, e.rotation = a ? function (t, e) {
                            return I(e[1], e[0], Rt) + I(t[1], t[0], Rt)
                        }(a.pointers, n) : 0, e.maxPointers = i.prevInput ? e.pointers.length > i.prevInput.maxPointers ? e.pointers.length : i.prevInput.maxPointers : e.pointers.length, A(i, e);
                        var c = t.element;
                        m(e.srcEvent.target, c) && (c = e.srcEvent.target), e.target = c
                    }(t, i), t.emit("hammer.input", i), t.recognize(i), t.session.prevInput = i
                }

                function A(t, e) {
                    var i, n, s, a, o = t.lastInterval || e, h = e.timeStamp - o.timeStamp;
                    if (e.eventType != Et && (h > bt || o.velocity === r)) {
                        var l = e.deltaX - o.deltaX, c = e.deltaY - o.deltaY, u = D(h, l, c);
                        n = u.x, s = u.y, i = lt(u.x) > lt(u.y) ? u.x : u.y, a = C(l, c), t.lastInterval = e
                    } else i = o.velocity, n = o.velocityX, s = o.velocityY, a = o.direction;
                    e.velocity = i, e.velocityX = n, e.velocityY = s, e.direction = a
                }

                function S(t) {
                    for (var e = [], i = 0; i < t.pointers.length;) e[i] = {
                        clientX: ht(t.pointers[i].clientX),
                        clientY: ht(t.pointers[i].clientY)
                    }, i++;
                    return {timeStamp: ct(), pointers: e, center: T(e), deltaX: t.deltaX, deltaY: t.deltaY}
                }

                function T(t) {
                    var e = t.length;
                    if (1 === e) return {x: ht(t[0].clientX), y: ht(t[0].clientY)};
                    for (var i = 0, n = 0, r = 0; e > r;) i += t[r].clientX, n += t[r].clientY, r++;
                    return {x: ht(i / e), y: ht(n / e)}
                }

                function D(t, e, i) {
                    return {x: e / t || 0, y: i / t || 0}
                }

                function C(t, e) {
                    return t === e ? Mt : lt(t) >= lt(e) ? 0 > t ? At : St : 0 > e ? Tt : Dt
                }

                function P(t, e, i) {
                    i || (i = Lt);
                    var n = e[i[0]] - t[i[0]], r = e[i[1]] - t[i[1]];
                    return Math.sqrt(n * n + r * r)
                }

                function I(t, e, i) {
                    i || (i = Lt);
                    var n = e[i[0]] - t[i[0]], r = e[i[1]] - t[i[1]];
                    return 180 * Math.atan2(r, n) / Math.PI
                }

                function L() {
                    this.evEl = kt, this.evWin = Ot, this.pressed = !1, E.apply(this, arguments)
                }

                function R() {
                    this.evEl = Nt, this.evWin = jt, E.apply(this, arguments), this.store = this.manager.session.pointerEvents = []
                }

                function F() {
                    this.evTarget = Gt, this.evWin = Ut, this.started = !1, E.apply(this, arguments)
                }

                function k(t, e) {
                    var i = b(t.touches), n = b(t.changedTouches);
                    return e & (_t | Et) && (i = x(i.concat(n), "identifier", !0)), [i, n]
                }

                function O() {
                    this.evTarget = Wt, this.targetIds = {}, E.apply(this, arguments)
                }

                function z(t, e) {
                    var i = b(t.touches), n = this.targetIds;
                    if (e & (xt | wt) && 1 === i.length) return n[i[0].identifier] = !0, [i, i];
                    var r, s, a = b(t.changedTouches), o = [], h = this.target;
                    if (s = i.filter((function (t) {
                        return m(t.target, h)
                    })), e === xt) for (r = 0; r < s.length;) n[s[r].identifier] = !0, r++;
                    for (r = 0; r < a.length;) n[a[r].identifier] && o.push(a[r]), e & (_t | Et) && delete n[a[r].identifier], r++;
                    return o.length ? [x(s.concat(o), "identifier", !0), o] : void 0
                }

                function B() {
                    E.apply(this, arguments);
                    var t = c(this.handler, this);
                    this.touch = new O(this.manager, t), this.mouse = new L(this.manager, t), this.primaryTouch = null, this.lastTouches = []
                }

                function N(t, e) {
                    t & xt ? (this.primaryTouch = e.changedPointers[0].identifier, j.call(this, e)) : t & (_t | Et) && j.call(this, e)
                }

                function j(t) {
                    var e = t.changedPointers[0];
                    if (e.identifier === this.primaryTouch) {
                        var i = {x: e.clientX, y: e.clientY};
                        this.lastTouches.push(i);
                        var n = this.lastTouches;
                        setTimeout((function () {
                            var t = n.indexOf(i);
                            t > -1 && n.splice(t, 1)
                        }), qt)
                    }
                }

                function V(t) {
                    for (var e = t.srcEvent.clientX, i = t.srcEvent.clientY, n = 0; n < this.lastTouches.length; n++) {
                        var r = this.lastTouches[n], s = Math.abs(e - r.x), a = Math.abs(i - r.y);
                        if (Xt >= s && Xt >= a) return !0
                    }
                    return !1
                }

                function G(t, e) {
                    this.manager = t, this.set(e)
                }

                function U(t) {
                    this.options = rt({}, this.defaults, t || {}), this.id = dt++, this.manager = null, this.options.enable = p(this.options.enable, !0), this.state = ne, this.simultaneous = {}, this.requireFail = []
                }

                function H(t) {
                    return t & he ? "cancel" : t & ae ? "end" : t & se ? "move" : t & re ? "start" : ""
                }

                function W(t) {
                    return t == Dt ? "down" : t == Tt ? "up" : t == At ? "left" : t == St ? "right" : ""
                }

                function q(t, e) {
                    var i = e.manager;
                    return i ? i.get(t) : t
                }

                function X() {
                    U.apply(this, arguments)
                }

                function Y() {
                    X.apply(this, arguments), this.pX = null, this.pY = null
                }

                function Z() {
                    X.apply(this, arguments)
                }

                function J() {
                    U.apply(this, arguments), this._timer = null, this._input = null
                }

                function Q() {
                    X.apply(this, arguments)
                }

                function K() {
                    X.apply(this, arguments)
                }

                function $() {
                    U.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0
                }

                function tt(t, e) {
                    return (e = e || {}).recognizers = p(e.recognizers, tt.defaults.preset), new et(t, e)
                }

                function et(t, e) {
                    this.options = rt({}, tt.defaults, e || {}), this.options.inputTarget = this.options.inputTarget || t, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = t, this.input = function (t) {
                        return new (t.options.inputClass || (mt ? R : gt ? O : ft ? B : L))(t, M)
                    }(this), this.touchAction = new G(this, this.options.touchAction), it(this, !0), o(this.options.recognizers, (function (t) {
                        var e = this.add(new t[0](t[1]));
                        t[2] && e.recognizeWith(t[2]), t[3] && e.requireFailure(t[3])
                    }), this)
                }

                function it(t, e) {
                    var i, n = t.element;
                    n.style && (o(t.options.cssProps, (function (r, s) {
                        i = w(n.style, s), e ? (t.oldCssProps[i] = n.style[i], n.style[i] = r) : n.style[i] = t.oldCssProps[i] || ""
                    })), e || (t.oldCssProps = {}))
                }

                function nt(t, e) {
                    var n = i.createEvent("Event");
                    n.initEvent(t, !0, !0), n.gesture = e, e.target.dispatchEvent(n)
                }

                var rt, st = ["", "webkit", "Moz", "MS", "ms", "o"], at = i.createElement("div"), ot = "function",
                    ht = Math.round, lt = Math.abs, ct = Date.now;
                rt = "function" != typeof Object.assign ? function (t) {
                    if (t === r || null === t) throw new TypeError("Cannot convert undefined or null to object");
                    for (var e = Object(t), i = 1; i < arguments.length; i++) {
                        var n = arguments[i];
                        if (n !== r && null !== n) for (var s in n) n.hasOwnProperty(s) && (e[s] = n[s])
                    }
                    return e
                } : Object.assign;
                var ut = h((function (t, e, i) {
                        for (var n = Object.keys(e), s = 0; s < n.length;) (!i || i && t[n[s]] === r) && (t[n[s]] = e[n[s]]), s++;
                        return t
                    }), "extend", "Use `assign`."), pt = h((function (t, e) {
                        return ut(t, e, !0)
                    }), "merge", "Use `assign`."), dt = 1, ft = "ontouchstart" in e, mt = w(e, "PointerEvent") !== r,
                    gt = ft && /mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent), vt = "touch",
                    yt = "mouse", bt = 25, xt = 1, wt = 2, _t = 4, Et = 8, Mt = 1, At = 2, St = 4, Tt = 8, Dt = 16,
                    Ct = At | St, Pt = Tt | Dt, It = Ct | Pt, Lt = ["x", "y"], Rt = ["clientX", "clientY"];
                E.prototype = {
                    handler: function () {
                    }, init: function () {
                        this.evEl && d(this.element, this.evEl, this.domHandler), this.evTarget && d(this.target, this.evTarget, this.domHandler), this.evWin && d(_(this.element), this.evWin, this.domHandler)
                    }, destroy: function () {
                        this.evEl && f(this.element, this.evEl, this.domHandler), this.evTarget && f(this.target, this.evTarget, this.domHandler), this.evWin && f(_(this.element), this.evWin, this.domHandler)
                    }
                };
                var Ft = {mousedown: xt, mousemove: wt, mouseup: _t}, kt = "mousedown", Ot = "mousemove mouseup";
                l(L, E, {
                    handler: function (t) {
                        var e = Ft[t.type];
                        e & xt && 0 === t.button && (this.pressed = !0), e & wt && 1 !== t.which && (e = _t), this.pressed && (e & _t && (this.pressed = !1), this.callback(this.manager, e, {
                            pointers: [t],
                            changedPointers: [t],
                            pointerType: yt,
                            srcEvent: t
                        }))
                    }
                });
                var zt = {pointerdown: xt, pointermove: wt, pointerup: _t, pointercancel: Et, pointerout: Et},
                    Bt = {2: vt, 3: "pen", 4: yt, 5: "kinect"}, Nt = "pointerdown",
                    jt = "pointermove pointerup pointercancel";
                e.MSPointerEvent && !e.PointerEvent && (Nt = "MSPointerDown", jt = "MSPointerMove MSPointerUp MSPointerCancel"), l(R, E, {
                    handler: function (t) {
                        var e = this.store, i = !1, n = t.type.toLowerCase().replace("ms", ""), r = zt[n],
                            s = Bt[t.pointerType] || t.pointerType, a = s == vt, o = y(e, t.pointerId, "pointerId");
                        r & xt && (0 === t.button || a) ? 0 > o && (e.push(t), o = e.length - 1) : r & (_t | Et) && (i = !0), 0 > o || (e[o] = t, this.callback(this.manager, r, {
                            pointers: e,
                            changedPointers: [t],
                            pointerType: s,
                            srcEvent: t
                        }), i && e.splice(o, 1))
                    }
                });
                var Vt = {touchstart: xt, touchmove: wt, touchend: _t, touchcancel: Et}, Gt = "touchstart",
                    Ut = "touchstart touchmove touchend touchcancel";
                l(F, E, {
                    handler: function (t) {
                        var e = Vt[t.type];
                        if (e === xt && (this.started = !0), this.started) {
                            var i = k.call(this, t, e);
                            e & (_t | Et) && i[0].length - i[1].length == 0 && (this.started = !1), this.callback(this.manager, e, {
                                pointers: i[0],
                                changedPointers: i[1],
                                pointerType: vt,
                                srcEvent: t
                            })
                        }
                    }
                });
                var Ht = {touchstart: xt, touchmove: wt, touchend: _t, touchcancel: Et},
                    Wt = "touchstart touchmove touchend touchcancel";
                l(O, E, {
                    handler: function (t) {
                        var e = Ht[t.type], i = z.call(this, t, e);
                        i && this.callback(this.manager, e, {
                            pointers: i[0],
                            changedPointers: i[1],
                            pointerType: vt,
                            srcEvent: t
                        })
                    }
                });
                var qt = 2500, Xt = 25;
                l(B, E, {
                    handler: function (t, e, i) {
                        var n = i.pointerType == vt, r = i.pointerType == yt;
                        if (!(r && i.sourceCapabilities && i.sourceCapabilities.firesTouchEvents)) {
                            if (n) N.call(this, e, i); else if (r && V.call(this, i)) return;
                            this.callback(t, e, i)
                        }
                    }, destroy: function () {
                        this.touch.destroy(), this.mouse.destroy()
                    }
                });
                var Yt = w(at.style, "touchAction"), Zt = Yt !== r, Jt = "compute", Qt = "auto", Kt = "manipulation",
                    $t = "none", te = "pan-x", ee = "pan-y", ie = function () {
                        if (!Zt) return !1;
                        var t = {}, i = e.CSS && e.CSS.supports;
                        return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach((function (n) {
                            t[n] = !i || e.CSS.supports("touch-action", n)
                        })), t
                    }();
                G.prototype = {
                    set: function (t) {
                        t == Jt && (t = this.compute()), Zt && this.manager.element.style && ie[t] && (this.manager.element.style[Yt] = t), this.actions = t.toLowerCase().trim()
                    }, update: function () {
                        this.set(this.manager.options.touchAction)
                    }, compute: function () {
                        var t = [];
                        return o(this.manager.recognizers, (function (e) {
                            u(e.options.enable, [e]) && (t = t.concat(e.getTouchAction()))
                        })), function (t) {
                            if (g(t, $t)) return $t;
                            var e = g(t, te), i = g(t, ee);
                            return e && i ? $t : e || i ? e ? te : ee : g(t, Kt) ? Kt : Qt
                        }(t.join(" "))
                    }, preventDefaults: function (t) {
                        var e = t.srcEvent, i = t.offsetDirection;
                        if (!this.manager.session.prevented) {
                            var n = this.actions, r = g(n, $t) && !ie[$t], s = g(n, ee) && !ie[ee],
                                a = g(n, te) && !ie[te];
                            if (r) {
                                var o = 1 === t.pointers.length, h = t.distance < 2, l = t.deltaTime < 250;
                                if (o && h && l) return
                            }
                            return a && s ? void 0 : r || s && i & Ct || a && i & Pt ? this.preventSrc(e) : void 0
                        }
                        e.preventDefault()
                    }, preventSrc: function (t) {
                        this.manager.session.prevented = !0, t.preventDefault()
                    }
                };
                var ne = 1, re = 2, se = 4, ae = 8, oe = ae, he = 16, le = 32;
                U.prototype = {
                    defaults: {}, set: function (t) {
                        return rt(this.options, t), this.manager && this.manager.touchAction.update(), this
                    }, recognizeWith: function (t) {
                        if (a(t, "recognizeWith", this)) return this;
                        var e = this.simultaneous;
                        return e[(t = q(t, this)).id] || (e[t.id] = t, t.recognizeWith(this)), this
                    }, dropRecognizeWith: function (t) {
                        return a(t, "dropRecognizeWith", this) || (t = q(t, this), delete this.simultaneous[t.id]), this
                    }, requireFailure: function (t) {
                        if (a(t, "requireFailure", this)) return this;
                        var e = this.requireFail;
                        return -1 === y(e, t = q(t, this)) && (e.push(t), t.requireFailure(this)), this
                    }, dropRequireFailure: function (t) {
                        if (a(t, "dropRequireFailure", this)) return this;
                        t = q(t, this);
                        var e = y(this.requireFail, t);
                        return e > -1 && this.requireFail.splice(e, 1), this
                    }, hasRequireFailures: function () {
                        return this.requireFail.length > 0
                    }, canRecognizeWith: function (t) {
                        return !!this.simultaneous[t.id]
                    }, emit: function (t) {
                        function e(e) {
                            i.manager.emit(e, t)
                        }

                        var i = this, n = this.state;
                        ae > n && e(i.options.event + H(n)), e(i.options.event), t.additionalEvent && e(t.additionalEvent), n >= ae && e(i.options.event + H(n))
                    }, tryEmit: function (t) {
                        return this.canEmit() ? this.emit(t) : void (this.state = le)
                    }, canEmit: function () {
                        for (var t = 0; t < this.requireFail.length;) {
                            if (!(this.requireFail[t].state & (le | ne))) return !1;
                            t++
                        }
                        return !0
                    }, recognize: function (t) {
                        var e = rt({}, t);
                        return u(this.options.enable, [this, e]) ? (this.state & (oe | he | le) && (this.state = ne), this.state = this.process(e), void (this.state & (re | se | ae | he) && this.tryEmit(e))) : (this.reset(), void (this.state = le))
                    }, process: function (t) {
                    }, getTouchAction: function () {
                    }, reset: function () {
                    }
                }, l(X, U, {
                    defaults: {pointers: 1}, attrTest: function (t) {
                        var e = this.options.pointers;
                        return 0 === e || t.pointers.length === e
                    }, process: function (t) {
                        var e = this.state, i = t.eventType, n = e & (re | se), r = this.attrTest(t);
                        return n && (i & Et || !r) ? e | he : n || r ? i & _t ? e | ae : e & re ? e | se : re : le
                    }
                }), l(Y, X, {
                    defaults: {event: "pan", threshold: 10, pointers: 1, direction: It},
                    getTouchAction: function () {
                        var t = this.options.direction, e = [];
                        return t & Ct && e.push(ee), t & Pt && e.push(te), e
                    },
                    directionTest: function (t) {
                        var e = this.options, i = !0, n = t.distance, r = t.direction, s = t.deltaX, a = t.deltaY;
                        return r & e.direction || (e.direction & Ct ? (r = 0 === s ? Mt : 0 > s ? At : St, i = s != this.pX, n = Math.abs(t.deltaX)) : (r = 0 === a ? Mt : 0 > a ? Tt : Dt, i = a != this.pY, n = Math.abs(t.deltaY))), t.direction = r, i && n > e.threshold && r & e.direction
                    },
                    attrTest: function (t) {
                        return X.prototype.attrTest.call(this, t) && (this.state & re || !(this.state & re) && this.directionTest(t))
                    },
                    emit: function (t) {
                        this.pX = t.deltaX, this.pY = t.deltaY;
                        var e = W(t.direction);
                        e && (t.additionalEvent = this.options.event + e), this._super.emit.call(this, t)
                    }
                }), l(Z, X, {
                    defaults: {event: "pinch", threshold: 0, pointers: 2}, getTouchAction: function () {
                        return [$t]
                    }, attrTest: function (t) {
                        return this._super.attrTest.call(this, t) && (Math.abs(t.scale - 1) > this.options.threshold || this.state & re)
                    }, emit: function (t) {
                        if (1 !== t.scale) {
                            var e = t.scale < 1 ? "in" : "out";
                            t.additionalEvent = this.options.event + e
                        }
                        this._super.emit.call(this, t)
                    }
                }), l(J, U, {
                    defaults: {event: "press", pointers: 1, time: 251, threshold: 9},
                    getTouchAction: function () {
                        return [Qt]
                    },
                    process: function (t) {
                        var e = this.options, i = t.pointers.length === e.pointers, n = t.distance < e.threshold,
                            r = t.deltaTime > e.time;
                        if (this._input = t, !n || !i || t.eventType & (_t | Et) && !r) this.reset(); else if (t.eventType & xt) this.reset(), this._timer = s((function () {
                            this.state = oe, this.tryEmit()
                        }), e.time, this); else if (t.eventType & _t) return oe;
                        return le
                    },
                    reset: function () {
                        clearTimeout(this._timer)
                    },
                    emit: function (t) {
                        this.state === oe && (t && t.eventType & _t ? this.manager.emit(this.options.event + "up", t) : (this._input.timeStamp = ct(), this.manager.emit(this.options.event, this._input)))
                    }
                }), l(Q, X, {
                    defaults: {event: "rotate", threshold: 0, pointers: 2}, getTouchAction: function () {
                        return [$t]
                    }, attrTest: function (t) {
                        return this._super.attrTest.call(this, t) && (Math.abs(t.rotation) > this.options.threshold || this.state & re)
                    }
                }), l(K, X, {
                    defaults: {event: "swipe", threshold: 10, velocity: .3, direction: Ct | Pt, pointers: 1},
                    getTouchAction: function () {
                        return Y.prototype.getTouchAction.call(this)
                    },
                    attrTest: function (t) {
                        var e, i = this.options.direction;
                        return i & (Ct | Pt) ? e = t.overallVelocity : i & Ct ? e = t.overallVelocityX : i & Pt && (e = t.overallVelocityY), this._super.attrTest.call(this, t) && i & t.offsetDirection && t.distance > this.options.threshold && t.maxPointers == this.options.pointers && lt(e) > this.options.velocity && t.eventType & _t
                    },
                    emit: function (t) {
                        var e = W(t.offsetDirection);
                        e && this.manager.emit(this.options.event + e, t), this.manager.emit(this.options.event, t)
                    }
                }), l($, U, {
                    defaults: {
                        event: "tap",
                        pointers: 1,
                        taps: 1,
                        interval: 300,
                        time: 250,
                        threshold: 9,
                        posThreshold: 10
                    }, getTouchAction: function () {
                        return [Kt]
                    }, process: function (t) {
                        var e = this.options, i = t.pointers.length === e.pointers, n = t.distance < e.threshold,
                            r = t.deltaTime < e.time;
                        if (this.reset(), t.eventType & xt && 0 === this.count) return this.failTimeout();
                        if (n && r && i) {
                            if (t.eventType != _t) return this.failTimeout();
                            var a = !this.pTime || t.timeStamp - this.pTime < e.interval,
                                o = !this.pCenter || P(this.pCenter, t.center) < e.posThreshold;
                            if (this.pTime = t.timeStamp, this.pCenter = t.center, o && a ? this.count += 1 : this.count = 1, this._input = t, 0 === this.count % e.taps) return this.hasRequireFailures() ? (this._timer = s((function () {
                                this.state = oe, this.tryEmit()
                            }), e.interval, this), re) : oe
                        }
                        return le
                    }, failTimeout: function () {
                        return this._timer = s((function () {
                            this.state = le
                        }), this.options.interval, this), le
                    }, reset: function () {
                        clearTimeout(this._timer)
                    }, emit: function () {
                        this.state == oe && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input))
                    }
                }), tt.VERSION = "2.0.8", tt.defaults = {
                    domEvents: !1,
                    touchAction: Jt,
                    enable: !0,
                    inputTarget: null,
                    inputClass: null,
                    preset: [[Q, {enable: !1}], [Z, {enable: !1}, ["rotate"]], [K, {direction: Ct}], [Y, {direction: Ct}, ["swipe"]], [$], [$, {
                        event: "doubletap",
                        taps: 2
                    }, ["tap"]], [J]],
                    cssProps: {
                        userSelect: "none",
                        touchSelect: "none",
                        touchCallout: "none",
                        contentZooming: "none",
                        userDrag: "none",
                        tapHighlightColor: "rgba(0,0,0,0)"
                    }
                };
                et.prototype = {
                    set: function (t) {
                        return rt(this.options, t), t.touchAction && this.touchAction.update(), t.inputTarget && (this.input.destroy(), this.input.target = t.inputTarget, this.input.init()), this
                    }, stop: function (t) {
                        this.session.stopped = t ? 2 : 1
                    }, recognize: function (t) {
                        var e = this.session;
                        if (!e.stopped) {
                            this.touchAction.preventDefaults(t);
                            var i, n = this.recognizers, r = e.curRecognizer;
                            (!r || r && r.state & oe) && (r = e.curRecognizer = null);
                            for (var s = 0; s < n.length;) i = n[s], 2 === e.stopped || r && i != r && !i.canRecognizeWith(r) ? i.reset() : i.recognize(t), !r && i.state & (re | se | ae) && (r = e.curRecognizer = i), s++
                        }
                    }, get: function (t) {
                        if (t instanceof U) return t;
                        for (var e = this.recognizers, i = 0; i < e.length; i++) if (e[i].options.event == t) return e[i];
                        return null
                    }, add: function (t) {
                        if (a(t, "add", this)) return this;
                        var e = this.get(t.options.event);
                        return e && this.remove(e), this.recognizers.push(t), t.manager = this, this.touchAction.update(), t
                    }, remove: function (t) {
                        if (a(t, "remove", this)) return this;
                        if (t = this.get(t)) {
                            var e = this.recognizers, i = y(e, t);
                            -1 !== i && (e.splice(i, 1), this.touchAction.update())
                        }
                        return this
                    }, on: function (t, e) {
                        if (t !== r && e !== r) {
                            var i = this.handlers;
                            return o(v(t), (function (t) {
                                i[t] = i[t] || [], i[t].push(e)
                            })), this
                        }
                    }, off: function (t, e) {
                        if (t !== r) {
                            var i = this.handlers;
                            return o(v(t), (function (t) {
                                e ? i[t] && i[t].splice(y(i[t], e), 1) : delete i[t]
                            })), this
                        }
                    }, emit: function (t, e) {
                        this.options.domEvents && nt(t, e);
                        var i = this.handlers[t] && this.handlers[t].slice();
                        if (i && i.length) {
                            e.type = t, e.preventDefault = function () {
                                e.srcEvent.preventDefault()
                            };
                            for (var n = 0; n < i.length;) i[n](e), n++
                        }
                    }, destroy: function () {
                        this.element && it(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null
                    }
                }, rt(tt, {
                    INPUT_START: xt,
                    INPUT_MOVE: wt,
                    INPUT_END: _t,
                    INPUT_CANCEL: Et,
                    STATE_POSSIBLE: ne,
                    STATE_BEGAN: re,
                    STATE_CHANGED: se,
                    STATE_ENDED: ae,
                    STATE_RECOGNIZED: oe,
                    STATE_CANCELLED: he,
                    STATE_FAILED: le,
                    DIRECTION_NONE: Mt,
                    DIRECTION_LEFT: At,
                    DIRECTION_RIGHT: St,
                    DIRECTION_UP: Tt,
                    DIRECTION_DOWN: Dt,
                    DIRECTION_HORIZONTAL: Ct,
                    DIRECTION_VERTICAL: Pt,
                    DIRECTION_ALL: It,
                    Manager: et,
                    Input: E,
                    TouchAction: G,
                    TouchInput: O,
                    MouseInput: L,
                    PointerEventInput: R,
                    TouchMouseInput: B,
                    SingleTouchInput: F,
                    Recognizer: U,
                    AttrRecognizer: X,
                    Tap: $,
                    Pan: Y,
                    Swipe: K,
                    Pinch: Z,
                    Rotate: Q,
                    Press: J,
                    on: d,
                    off: f,
                    each: o,
                    merge: pt,
                    extend: ut,
                    assign: rt,
                    inherit: l,
                    bindFn: c,
                    prefixed: w
                }), (void 0 !== e ? e : "undefined" != typeof self ? self : {}).Hammer = tt, t.exports ? t.exports = tt : e.Hammer = tt
            }(window, document)
        }));
        var tf = function () {
                function t() {
                    var e = this;
                    wh(this, t), Mh(this, "isInteractive", !0), Mh(this, "hasAmbient", !1), Mh(this, "init", (function (t, i, n, r) {
                        e.zStart = e._zBounded(e.settings.CAM_Z_INI), e.zCurrent = e.zStart, e.zTarget = e.zStart, e.rotStart = [0, 0], e.rotCurrent = e.rotStart, e.rotTarget = e.rotStart, e.rotVelocity = [0, 0], e.interacting = !1, e.lastGestureChange = 0, e.pointsPerRadian = Math.PI / (t / window.devicePixelRatio), e.zFullWidth = e.settings.CAM_Z_MAX, e.camFov = r, e.camAspect = n, e.zFullWidth = e._frustumDist(1 / e.camAspect * 2, e.camFov)
                    })), Mh(this, "resize", (function (t, i, n, r) {
                        e.pointsPerRadian = Math.PI / (t / window.devicePixelRatio), e.camFov = r, e.camAspect = n, e.zFullWidth = e._frustumDist(1 / e.camAspect * 2, e.camFov)
                    })), Mh(this, "activate", (function () {
                        e.hammertime.on("panstart", e._onPanStart.bind(e)), e.hammertime.on("pan", e._onPanContinue.bind(e)), e.hammertime.on("panend", e._onPanEnd.bind(e)), e.hammertime.on("tap", e._onTap.bind(e))
                    })), Mh(this, "deactivate", (function () {
                        e.hammertime.off("panstart", e._onPanStart.bind(e)), e.hammertime.off("pan", e._onPanContinue.bind(e)), e.hammertime.off("panend", e._onPanEnd.bind(e)), e.hammertime.off("tap", e._onTap.bind(e))
                    })), Mh(this, "_zForScale", (function (t) {
                        return t < 1 ? e.zStart * (1 / t) : e.zStart + (e.settings.CAM_Z_MIN - e.zStart) * (1 - 1 / t)
                    })), Mh(this, "_onWheel", (function (t) {
                        if (e.isInteractive) {
                            t.preventDefault();
                            var i = Math.pow((t.deltaY + 10) / 100, 3) / 250, n = t.deltaY > 0 ? i : 1 / i;
                            n = Math.max(.9, n), n = Math.min(1.2, n), e.zStart = e.zCurrent, e.rotVelocity = [0, 0], e.zTarget = e._zBounded(e._zForScale(n)), e.lastGestureChange = t.timeStamp
                        }
                    })), Mh(this, "_onPanContinue", (function (t) {
                        if (e.isInteractive && !0 === e.interacting) {
                            var i = [6 * t.deltaY, 6 * t.deltaX],
                                n = e._rotForDelta([e.panStart[0] - i[0], e.panStart[1] - i[1]]);
                            e.rotTarget = e._rotBounded([e.rotStart[0] + n[0], e.rotStart[1] + n[1]]), e.lastGestureChange = t.timeStamp
                        }
                    })), Mh(this, "_onPanEnd", (function (t) {
                        if (e.isInteractive) if (e.interacting = !1, t.timeStamp - e.lastGestureChange > .1) e.rotVelocity = [0, 0]; else {
                            var i = e._rotForDelta([t.overallVelocityX, t.overallVelocityY]);
                            e.rotVelocity = [.016 * i[0], .016 * i[1]], e.rotDir = i[0] > 0 ? 1 : -1;
                            var n = e.rotTarget[0] / (Math.PI / 2) / .5;
                            Math.abs(n) < 1 ? e.ambientPitchX = Math.asin(n) : e.ambientPitchX = Math.PI / 2 * (n / Math.abs(n)), e.ambientPitchDir = i[1] > 0 ? -1 : 1
                        }
                    })), Mh(this, "_updateRot", (function () {
                        if (e.interacting) e.ambientYaw = 0, e.ambientPitch = 0; else {
                            var t = 0;
                            e.hasAmbient ? (e.ambientPitch = Math.min(e.ambientPitch + 1 / 120, 1), t = Math.sin(e.ambientPitchX) * (Math.PI / 2) * .5, e.ambientPitchX += .001 * e.ambientPitchDir) : (e.ambientPitch = 0, e.ambientPitchX = 0, t = 0), e.rotTarget = [e.rotTarget[0] * (1 - e.ambientPitch) + t * e.ambientPitch, e.rotTarget[1]];
                            var i = [Math.max(Math.min(e.rotTarget[0], e.settings.CAM_PITCH_SPRING_MAX), e.settings.CAM_PITCH_SPRING_MIN), e.rotTarget[1]],
                                n = [e.rotTarget[0] - i[0] + e.rotVelocity[0], e.rotTarget[1] - i[1] + e.rotVelocity[1]];
                            e.rotTarget = [e.rotTarget[0] - n[0] * e.settings.SPRING_STR * 3, e.rotTarget[1] - n[1] * e.settings.SPRING_STR * 3], e.rotVelocity = [e.rotVelocity[0] * e.settings.FRICTION, e.rotVelocity[1] * e.settings.FRICTION];
                            var r = e.zCurrent / e.settings.CAM_Z_MAX;
                            e.hasAmbient && (e.ambientYaw = Math.min(e.ambientYaw + e.settings.YAW_MIN_VELOCITY / 120, e.settings.YAW_MIN_VELOCITY));
                            var s = e.ambientYaw * (r * r);
                            Math.abs(e.rotVelocity[1]) < s && (e.rotVelocity[1] = s * e.rotDir)
                        }
                        var a = [e.rotTarget[0] - e.rotCurrent[0], e.rotTarget[1] - e.rotCurrent[1]];
                        e.rotCurrent = [e.rotCurrent[0] + a[0] * e.settings.SPRING_STR, e.rotCurrent[1] + a[1] * e.settings.SPRING_STR]
                    })), Mh(this, "_updateZ", (function () {
                        if (!e.interacting) {
                            e.zBounded = Math.max(Math.min(e.zTarget, e.settings.CAM_Z_SPRING_MAX), e.settings.CAM_Z_SPRING_MIN);
                            var t = e.zTarget - e.zBounded;
                            e.zTarget -= t * e.settings.SPRING_STR * 3
                        }
                        var i = e.zTarget - e.zCurrent;
                        e.zCurrent += i * e.settings.SPRING_STR
                    })), Mh(this, "update", (function (t) {
                        e.fov = t, e._updateZ(), e._updateRot()
                    })), Mh(this, "setAltitude", (function (t) {
                        e.zTarget = 1 + t / e.settings.EARTH_RADIUS
                    })), Mh(this, "getAltitude", (function () {
                        return (e.zCurrent - 1) * e.settings.EARTH_RADIUS
                    })), Mh(this, "reset", (function () {
                        e.zStart = e.zBounded(e.settings.CAM_Z_INI), e.zCurrent = e.zStart, e.zTarget = e.zStart, e.rotStart = [0, 0], e.rotCurrent = e.rotStart, e.rotTarget = e.rotStart, e.rotVelocity = [0, 0], e.interacting = !1, e.lastGestureChange = 0
                    })), Mh(this, "_zBounded", (function (t) {
                        if (t > e.settings.CAM_Z_SPRING_MAX) {
                            var i = t - e.settings.CAM_Z_SPRING_MAX, n = e.settings.CAM_Z_MAX - e.settings.CAM_Z_SPRING_MAX,
                                r = e.easeOutSin(Math.min(i / n, 1));
                            return e.settings.CAM_Z_SPRING_MAX + n * r
                        }
                        if (t < e.settings.CAM_Z_SPRING_MIN) {
                            var s = t - e.settings.CAM_Z_SPRING_MIN, a = e.settings.CAM_Z_MIN - e.settings.CAM_Z_SPRING_MIN,
                                o = e.easeOutSin(Math.min(s / a, 1));
                            return e.settings.CAM_Z_SPRING_MIN + a * o
                        }
                        return t
                    })), Mh(this, "_rotBounded", (function (t) {
                        if (t[0] > e.settings.CAM_PITCH_SPRING_MAX) {
                            var i = t[0] - e.settings.CAM_PITCH_SPRING_MAX,
                                n = e.settings.CAM_PITCH_MAX - e.settings.CAM_PITCH_SPRING_MAX,
                                r = e.easeOutSin(Math.min(i / n, 1));
                            return [e.settings.CAM_PITCH_SPRING_MAX + n * r, t[1]]
                        }
                        if (t[0] < e.settings.CAM_PITCH_SPRING_MIN) {
                            var s = t[0] - e.settings.CAM_PITCH_SPRING_MIN,
                                a = e.settings.CAM_PITCH_MIN - e.settings.CAM_PITCH_SPRING_MIN,
                                o = e.easeOutSin(Math.min(s / a, 1));
                            return [e.settings.CAM_PITCH_SPRING_MIN + a * o, t[1]]
                        }
                        return t
                    })), Mh(this, "_frustumDist", (function (t, e) {
                        return .5 * t / Math.tan(.5 * e * (Math.PI / 180))
                    })), Mh(this, "_rotForDelta", (function (t) {
                        return [t[0] * (e.pointsPerRadian * (e.zCurrent / e.zFullWidth)), t[1] * (e.pointsPerRadian * (e.zCurrent / e.zFullWidth))]
                    })), Mh(this, "easeOutSin", (function (t) {
                        return Math.sin(t * Math.PI / 2)
                    })), this.settings = {}, this.settings.EARTH_RADIUS = 6378137, this.settings.CAM_Z_MIN = 1, this.settings.CAM_Z_MAX = 45, this.settings.CAM_Z_INI = .5 * (this.settings.CAM_Z_MIN + this.settings.CAM_Z_MAX), this.settings.CAM_Z_SPRING_BND = .8, this.settings.CAM_Z_SPRING_MAX = this.settings.CAM_Z_MAX * this.settings.CAM_Z_SPRING_BND, this.settings.CAM_Z_SPRING_MIN = this.settings.CAM_Z_MIN * (1 / this.settings.CAM_Z_SPRING_BND), this.settings.CAM_PITCH_MAX = .5 * Math.PI, this.settings.CAM_PITCH_MIN = .5 * -Math.PI, this.settings.CAM_PITCH_INI = 0, this.settings.CAM_PITCH_SPRING_BND = .8, this.settings.CAM_PITCH_SPRING_MAX = this.settings.CAM_PITCH_MAX * this.settings.CAM_PITCH_SPRING_BND, this.settings.CAM_PITCH_SPRING_MIN = this.settings.CAM_PITCH_MIN * this.settings.CAM_PITCH_SPRING_BND, this.settings.FRICTION = .1, this.settings.SPRING_STR = .16, this.settings.YAW_MIN_VELOCITY = .01, this.zStart = 0, this.zCurrent = 0, this.zTarget = 0, this.panStart = [0, 0], this.rotStart = [0, 0], this.rotCurrent = [0, 0], this.rotTarget = [0, 0], this.rotVelocity = [0, 0], this.rotDir = 1, this.ambientYaw = 0, this.ambientPitch = 0, this.ambientPitchX = 0, this.ambientPitchDir = -1, this.interacting = !1, this.getInteractionState = function () {
                        return e.interacting
                    }, this.lastGestureChange = 0, this.pointsPerRadian = 0, this.zFullWidth = 0, this.onTap = function (t) {
                    }, this.onPanCB = function (t) {
                    }
                }

                return Eh(t, [{
                    key: "_onTap", value: function (t) {
                        this.isInteractive && this.onTap(t)
                    }
                }, {
                    key: "_onPinch", value: function (t) {
                        this.isInteractive && (t.isFirst ? (this.zStart = this.zCurrent, this.rotVelocity = [0, 0]) : t.isFinal || (this.zTarget = this._zBounded(this._zForScale(t.scale)), this.lastGestureChange = t.timeStamp))
                    }
                }, {
                    key: "_onPanStart", value: function (t) {
                        this.interacting = !0, this.rotStart = this.rotCurrent, this.panStart = [t.deltaX, t.deltaY], this.rotVelocity = [0, 0]
                    }
                }, {
                    key: "camPos", get: function () {
                        return [0, 0, this.zCurrent]
                    }
                }, {
                    key: "camYaw", get: function () {
                        return this.rotCurrent[1]
                    }
                }, {
                    key: "camPitch", get: function () {
                        return this.rotCurrent[0]
                    }
                }]), t
            }(), ef = function () {
                function t(e, i, n) {
                    var r = this;
                    wh(this, t), Mh(this, "isInteractive", !1), Mh(this, "targetElement", window), Mh(this, "targetDrawable", null), Mh(this, "camera", null), Mh(this, "movementModel", null), Mh(this, "boundingRect", null), Mh(this, "onTapCB", null), Mh(this, "options", {
                        tap: !0,
                        pan: !0,
                        pinch: !0
                    }), Mh(this, "resize", (function () {
                        r.boundingRect = r.targetElement.getBoundingClientRect(), r.movementModel.resize(r.boundingRect.width, r.boundingRect.height, r.camera.aspect, r.camera.fov)
                    })), Mh(this, "update", (function () {
                        r.movementModel.update(r.camera.fov)
                    })), Mh(this, "isOverTarget", (function (t, e) {
                        var i = t - r.boundingRect.x, n = e - r.boundingRect.y, s = i / r.boundingRect.width,
                            a = (r.boundingRect.height - n) / r.boundingRect.height, o = r.camera.getRayFromScreen(s, a);
                        return r.targetDrawable.hitTest(o)
                    })), Mh(this, "onPanStart", (function (t) {
                        r.isOverTarget(t.center.x, t.center.y) && r.movementModel._onPanStart(t)
                    })), Mh(this, "onPanContinue", (function (t) {
                        r.movementModel._onPanContinue(t)
                    })), Mh(this, "onPanEnd", (function (t) {
                        r.movementModel._onPanEnd(t)
                    })), Mh(this, "onTap", (function (t) {
                        var e = t.center.x - r.boundingRect.x, i = t.center.y - r.boundingRect.y;
                        r.onTapCB && r.onTapCB(e, i)
                    })), e && (this.targetElement = e, this.boundingRect = this.targetElement.getBoundingClientRect()), this.camera = i, n && (n.tap && (this.options.tap = n.tap), n.pan && (this.options.pan = n.pan), n.pinch && (this.options.pinch = n.pinch)), this.movementModel = new tf, this.movementModel.init(this.boundingRect.width, this.boundingRect.height, this.camera.aspect, this.camera.fov), this.movementModel.isInteractive = !0, this.movementModel.hasAmbient = !1, this.hammer = window.Hammer(this.targetElement, null), this.hammer.set({touchAction: "none"}), this.options.tap && this.hammer.on("tap", this.onTap), this.options.pan && this.hammer.on("panstart", this.onPanStart), this.options.pan && this.hammer.on("pan", this.onPanContinue), this.options.pan && this.hammer.on("panend", this.onPanEnd), this.options.pinch && this.hammer.on("tap", this.onPinch), this.isInteractive = !0
                }

                return Eh(t, [{
                    key: "target", set: function (t) {
                        this.targetDrawable = t
                    }
                }]), t
            }(), nf = function () {
                function t(e) {
                    var i = this;
                    wh(this, t), Mh(this, "_container", null), Mh(this, "_callouts", {}), Mh(this, "_calloutDefinitions", []), Mh(this, "_currentlyRemoving", []), Mh(this, "onAutoRemove", null), Mh(this, "autoRemoveCallouts", !0), Mh(this, "autoRemoveThreshholdSimilarity", .5), Mh(this, "autoRemoveThreshholdMargins", {
                        top: 0,
                        right: 0,
                        left: 0,
                        bottom: 0
                    }), e && "DIV" === e.tagName ? (this._container = e, this._container.style.pointerEvents = "none", this.resizeObserver = new ResizeObserver((function (t) {
                        t.length && (i.bounds = t[0].contentRect)
                    })), this.resizeObserver.observe(this._container)) : console.warn("CalloutManager expects a DIV element as a container."), this._removeCalloutComplete = this._removeCalloutComplete.bind(this)
                }

                return Eh(t, [{
                    key: "release", value: function () {
                        this.resizeObserver.disconnect()
                    }
                }, {
                    key: "addCallout", value: function (t) {
                        this.replaceCallouts([].concat(kh(this._calloutDefinitions), [t]))
                    }
                }, {
                    key: "removeCallout", value: function (t) {
                        var e = this._calloutDefinitions.findIndex((function (e) {
                            return e.id === t.id
                        }));
                        -1 !== e && this.replaceCallouts([].concat(kh(this._calloutDefinitions.slice(0, e)), kh(this._calloutDefinitions.slice(e + 1))))
                    }
                }, {
                    key: "replaceCallouts", value: function (t) {
                        var e = this, i = t.filter((function (t) {
                            return !e._calloutDefinitions.includes(t)
                        })), n = this._calloutDefinitions.filter((function (e) {
                            return !t.includes(e)
                        })).filter((function (t) {
                            return !e._currentlyRemoving.includes(t)
                        }));
                        this._currentlyRemoving = [].concat(kh(this._currentlyRemoving), kh(n)), this._calloutDefinitions = [].concat(kh(this._calloutDefinitions), kh(i)), i.map((function (t) {
                            var e = t.calloutClass;
                            if (e) return new e(t)
                        })).filter((function (t) {
                            return t
                        })).forEach((function (t) {
                            e._callouts[t.definition.id] = t, e._container.appendChild(t.element), t.animateIn()
                        })), n.map((function (t) {
                            return e._callouts[t.id]
                        })).forEach((function (t) {
                            t.animateOut(e._removeCalloutComplete)
                        }))
                    }
                }, {
                    key: "removeAllCallouts", value: function () {
                        this.replaceCallouts([])
                    }
                }, {
                    key: "getCalloutForDefinition", value: function (t) {
                        return this._callouts[t.id]
                    }
                }, {
                    key: "update", value: function (t) {
                        var e = this;
                        if (this.positionProvider) {
                            var i = [], n = this.positionProvider(this._calloutDefinitions);
                            this._calloutDefinitions.forEach((function (r, s) {
                                var a = e._callouts[r.id], o = n[s];
                                if (a && (a.setPosition(o), a.update(t)), e.autoRemoveCallouts) {
                                    var h = e.autoRemoveThreshholdSimilarity, l = e.autoRemoveThreshholdMargins;
                                    (o.world.similarityToCameraVector < h || o.screen.x < l.left || o.screen.x > e.bounds.width - l.right || o.screen.y < l.top || o.screen.y > e.bounds.height - l.bottom) && i.push(r)
                                }
                            })), i.forEach((function (t) {
                                e.removeCallout(t), e.onAutoRemove && e.onAutoRemove(t)
                            }))
                        }
                    }
                }, {
                    key: "_removeCalloutComplete", value: function (t) {
                        var e = t.definition.id, i = this._calloutDefinitions.findIndex((function (t) {
                            return t.id === e
                        }));
                        -1 !== i && (this._calloutDefinitions = [].concat(kh(this._calloutDefinitions.slice(0, i)), kh(this._calloutDefinitions.slice(i + 1))), i = this._currentlyRemoving.findIndex((function (t) {
                            return t.id === e
                        })), this._currentlyRemoving = [].concat(kh(this._currentlyRemoving.slice(0, i)), kh(this._currentlyRemoving.slice(i + 1))), this._container.removeChild(this._callouts[e].element), this._callouts[e].release(), delete this._callouts[e])
                    }
                }, {
                    key: "drawables", get: function () {
                        var t = this;
                        return this._calloutDefinitions.map((function (e) {
                            return t._callouts[e.id].drawables
                        }))
                    }
                }]), t
            }(), rf = function () {
                function t(e, i, n) {
                    var r = this;
                    wh(this, t), Mh(this, "_wasmLoaded", !1), Mh(this, "isInit", !1), Mh(this, "shouldDraw", !1), Mh(this, "isInteractive", !1), Mh(this, "renderer", null), Mh(this, "scene", null), Mh(this, "_alt", 4), Mh(this, "tartgetDrawable", null), Mh(this, "calloutManager", null), Mh(this, "interactionController", null), Mh(this, "boundingRect", null), Mh(this, "_onWasmLoad", []), Mh(this, "drawqueue", []), Mh(this, "loadWasm", (function (t) {
                        Ud(void 0 === t ? "./gkweb_bg.wasm" : t).then((function () {
                            r._wasmLoaded = !0, md.init_gkweb(), r._onWasmLoad.forEach((function (t) {
                                t()
                            })), r._onInitCB()
                        }))
                    })), Mh(this, "init", (function (t) {
                        r.renderer = new Bp(t, r.gkOptions.attributes), r.renderer.init(), r.gkOptions.clearColor && (r.renderer.clearColor = r.gkOptions.clearColor), r.scene = new vd(t.width, t.height), r.interactionController = new ef(t, r.scene.camera), r.interactionController.onTapCB = r.onTapCB, window.onresize = r.onResizeCB, window.onscroll = r.onResizeCB, r.isInit = !0
                    })), Mh(this, "_onInitCB", (function () {
                        r.onInitCB(r), r.renderloop(0)
                    })), Mh(this, "onResizeCB", (function () {
                        r.boundingRect = r.renderer.gl.canvas.getBoundingClientRect(), zp(r.renderer.gl.canvas), r.scene.resize(r.boundingRect.width, r.boundingRect.height), r.renderer.resize(r.boundingRect.width, r.boundingRect.height), r.interactionController.resize()
                    })), Mh(this, "setCameratargetDrawable", (function (t) {
                        r.interactionController.hitTarget = t.hitTest
                    })), Mh(this, "setAbsMovementModelTo", (function (t, e, i) {
                        r.interactionController.movementModel.rotCurrent[0] = t * (-Math.PI / 180), r.interactionController.movementModel.rotCurrent[1] = e * (Math.PI / 180), r.interactionController.movementModel.rotTarget[0] = t * (-Math.PI / 180), r.interactionController.movementModel.rotTarget[1] = e * (Math.PI / 180), void 0 !== i && (r._alt = i)
                    })), Mh(this, "setMovementModelTo", (function (t, e, i) {
                        r.interactionController.movementModel.rotTarget[0] = t * (-Math.PI / 180), r.interactionController.movementModel.rotTarget[1] = e * (Math.PI / 180), void 0 !== i && (r._alt = i)
                    })), Mh(this, "moveCameraTo", (function (t, e, i) {
                        var n = Qd.worldFromLatLon(t, e, i);
                        r.scene.camera.setPosition(n)
                    })), Mh(this, "addDrawable", (function (t, e) {
                        return t instanceof Wd && (t instanceof qd && null === r.tartgetDrawable && (r.tartgetDrawable = t, r.interactionController.target = t), t.init(r.renderer.gl, e), r.drawqueue.push(t), r._wasmLoaded ? t.createCollisionGeo() : r._onWasmLoad.push(t.createCollisionGeo), !0)
                    })), Mh(this, "startDrawing", (function () {
                        r.shouldDraw = !0, r.renderloop(0)
                    })), Mh(this, "stopDrawing", (function () {
                        r.shouldDraw = !1
                    })), Mh(this, "renderloop", (function (t) {
                        var e = t / 1e4;
                        if (r.shouldDraw) {
                            r.interactionController.update();
                            var i = -r.interactionController.movementModel.camPitch * (180 / Math.PI),
                                n = r.interactionController.movementModel.camYaw * (180 / Math.PI);
                            r.updateCameraFunction(e), r.moveCameraTo(i, n, r._alt), r.renderer.prepareRenderFrame(), r.scene.update(e);
                            var s = r.scene.getUniforms(e);
                            r.drawqueue.forEach((function (t) {
                                t.update(r.renderer.gl, s, e)
                            })), r.calloutManager && r.calloutManager.update(e), r.drawqueue.forEach((function (t) {
                                t.draw(r.renderer.gl)
                            })), requestAnimationFrame(r.renderloop)
                        }
                    })), Mh(this, "onTapCB", (function (t, e) {
                        var i = t / r.boundingRect.width, n = (r.boundingRect.height - e) / r.boundingRect.height,
                            s = r.scene.camera.getRayFromScreen(i, n), a = r.targetLatLon(s), o = {drawables: []};
                        a && (o.lat = a.lat, o.lon = a.lon), r.drawqueue.forEach((function (t) {
                            if (t.isInteractive && t.isSelectable) {
                                var e = {};
                                e.obj = t;
                                var i = t.rayCastFrom(s);
                                i && t.isSelectable && (e.selection = t.onSelection(a.lat, a.lon, i)), o.drawables.push(e)
                            }
                        })), r.userDefinedSelection(o)
                    })), Mh(this, "targetLatLon", (function (t) {
                        var e, i = r.tartgetDrawable.rayCastFrom(t);
                        return !1 !== i && (e = Qd.latLonFromWorld(i.point)), e
                    })), Mh(this, "onMouseMoveCB", (function (t, e) {
                        var i = t / r.boundingRect.width, n = (r.boundingRect.height - e) / r.boundingRect.height,
                            s = r.scene.camera.getRayFromScreen(i, n);
                        r.drawqueue.forEach((function (t) {
                            if (t.isInteractive && t.isHoverable) {
                                var e = t.rayCastFrom(s);
                                e && t.isHoverable && t.onHover(e)
                            }
                        }))
                    })), Mh(this, "updateCameraFunction", (function () {
                    })), Mh(this, "getPosition", (function (t, e, i) {
                        i || (i = 0);
                        var n = Qd.worldFromLatLon(t, e, i), s = r.scene.camera.project(n);
                        s[0] *= r.boundingRect.width, s[1] *= r.boundingRect.height, s[1] = r.boundingRect.height - s[1];
                        var a = r.scene.camera.project(r.scene.camera.target);
                        a[0] *= r.boundingRect.width, a[1] *= r.boundingRect.height, a[1] = r.boundingRect.height - a[1];
                        var o = [];
                        o.push(s[0] - a[0]), o.push(s[1] - a[1]);
                        var h = Xp();
                        Kp(h, n);
                        var l = r.scene.camera.eye, c = Xp();
                        Kp(c, l);
                        var u = $p(h, c);
                        return {screen: {x: s[0], y: s[1]}, world: {x: o[0], y: o[1], similarityToCameraVector: u}}
                    })), Mh(this, "registerCalloutManager", (function (t) {
                        t && t instanceof nf ? (t.positionProvider = function (t) {
                            return t.map((function (t) {
                                return r.getPosition(t.latitude, t.longitude, t.altitude)
                            }))
                        }, r.calloutManager = t) : console.warn("registerCalloutManager must be passed an instance of CalloutManager")
                    })), Mh(this, "computeGlobeSize", (function () {
                        var t, e, i, n, s, a = r.scene.camera.fov,
                            o = (t = r.scene.camera.eye, e = r.tartgetDrawable.translation, i = e[0] - t[0], n = e[1] - t[1], s = e[2] - t[2], Math.hypot(i, n, s));
                        return 2 * Math.asin(1 / o) / a * r.boundingRect.height
                    })), Mh(this, "setGlobeSize", (function (t) {
                        var e = r.scene.camera.fov;
                        return 1 * Math.sin(t / r.boundingRect.height * e / 2)
                    })), Mh(this, "setAmbient", (function (t) {
                        r.interactionController.movementModel.hasAmbient = t
                    })), this.gkOptions = void 0 === i ? {} : i, n && (this.onInitCB = n), this.boundingRect = e.getBoundingClientRect(), this.init(e), this.loadWasm(this.gkOptions.wasmPath)
                }

                return Eh(t, [{
                    key: "isWebGL1", get: function () {
                        return !!this.gl && Dc(this.gl)
                    }
                }, {
                    key: "isWebGL2", get: function () {
                        return !!this.gl && Tc(this.gl)
                    }
                }]), t
            }(), sf = $d((function (t, e) {
                !function (t) {
                    function e(t, e, i) {
                        this.obj = t, this.left = null, this.right = null, this.parent = i, this.dimension = e
                    }

                    function i(t) {
                        this.content = [], this.scoreFunction = t
                    }

                    i.prototype = {
                        push: function (t) {
                            this.content.push(t), this.bubbleUp(this.content.length - 1)
                        }, pop: function () {
                            var t = this.content[0], e = this.content.pop();
                            return this.content.length > 0 && (this.content[0] = e, this.sinkDown(0)), t
                        }, peek: function () {
                            return this.content[0]
                        }, remove: function (t) {
                            for (var e = this.content.length, i = 0; i < e; i++) if (this.content[i] == t) {
                                var n = this.content.pop();
                                return void (i != e - 1 && (this.content[i] = n, this.scoreFunction(n) < this.scoreFunction(t) ? this.bubbleUp(i) : this.sinkDown(i)))
                            }
                            throw new Error("Node not found.")
                        }, size: function () {
                            return this.content.length
                        }, bubbleUp: function (t) {
                            for (var e = this.content[t]; t > 0;) {
                                var i = Math.floor((t + 1) / 2) - 1, n = this.content[i];
                                if (!(this.scoreFunction(e) < this.scoreFunction(n))) break;
                                this.content[i] = e, this.content[t] = n, t = i
                            }
                        }, sinkDown: function (t) {
                            for (var e = this.content.length, i = this.content[t], n = this.scoreFunction(i); ;) {
                                var r = 2 * (t + 1), s = r - 1, a = null;
                                if (s < e) {
                                    var o = this.content[s], h = this.scoreFunction(o);
                                    h < n && (a = s)
                                }
                                if (r < e) {
                                    var l = this.content[r];
                                    this.scoreFunction(l) < (null == a ? n : h) && (a = r)
                                }
                                if (null == a) break;
                                this.content[t] = this.content[a], this.content[a] = i, t = a
                            }
                        }
                    }, t.kdTree = function (t, n, r) {
                        function s(t, i, n) {
                            var a, o, h = i % r.length;
                            return 0 === t.length ? null : 1 === t.length ? new e(t[0], h, n) : (t.sort((function (t, e) {
                                return t[r[h]] - e[r[h]]
                            })), (o = new e(t[a = Math.floor(t.length / 2)], h, n)).left = s(t.slice(0, a), i + 1, o), o.right = s(t.slice(a + 1), i + 1, o), o)
                        }

                        var a = this;
                        Array.isArray(t) ? this.root = s(t, 0, null) : function (t) {
                            function e(t) {
                                t.left && (t.left.parent = t, e(t.left)), t.right && (t.right.parent = t, e(t.right))
                            }

                            a.root = t, e(a.root)
                        }(t), this.toJSON = function (t) {
                            t || (t = this.root);
                            var i = new e(t.obj, t.dimension, null);
                            return t.left && (i.left = a.toJSON(t.left)), t.right && (i.right = a.toJSON(t.right)), i
                        }, this.insert = function (t) {
                            function i(e, n) {
                                if (null === e) return n;
                                var s = r[e.dimension];
                                return t[s] < e.obj[s] ? i(e.left, e) : i(e.right, e)
                            }

                            var n, s, a = i(this.root, null);
                            null !== a ? (n = new e(t, (a.dimension + 1) % r.length, a), s = r[a.dimension], t[s] < a.obj[s] ? a.left = n : a.right = n) : this.root = new e(t, 0, null)
                        }, this.remove = function (t) {
                            function e(i) {
                                if (null === i) return null;
                                if (i.obj === t) return i;
                                var n = r[i.dimension];
                                return t[n] < i.obj[n] ? e(i.left) : e(i.right)
                            }

                            function i(t) {
                                function e(t, i) {
                                    var n, s, a, o, h;
                                    return null === t ? null : (n = r[i], t.dimension === i ? null !== t.left ? e(t.left, i) : t : (s = t.obj[n], a = e(t.left, i), o = e(t.right, i), h = t, null !== a && a.obj[n] < s && (h = a), null !== o && o.obj[n] < h.obj[n] && (h = o), h))
                                }

                                var n, s, o;
                                if (null === t.left && null === t.right) return null === t.parent ? void (a.root = null) : (o = r[t.parent.dimension], void (t.obj[o] < t.parent.obj[o] ? t.parent.left = null : t.parent.right = null));
                                null !== t.right ? (s = (n = e(t.right, t.dimension)).obj, i(n), t.obj = s) : (s = (n = e(t.left, t.dimension)).obj, i(n), t.right = t.left, t.left = null, t.obj = s)
                            }

                            var n;
                            null !== (n = e(a.root)) && i(n)
                        }, this.nearest = function (t, e, s) {
                            function o(i) {
                                function s(t, i) {
                                    c.push([t, i]), c.size() > e && c.pop()
                                }

                                var a, h, l, u, p = r[i.dimension], d = n(t, i.obj), f = {};
                                for (u = 0; u < r.length; u += 1) u === i.dimension ? f[r[u]] = t[r[u]] : f[r[u]] = i.obj[r[u]];
                                h = n(f, i.obj), null !== i.right || null !== i.left ? (o(a = null === i.right ? i.left : null === i.left ? i.right : t[p] < i.obj[p] ? i.left : i.right), (c.size() < e || d < c.peek()[1]) && s(i, d), (c.size() < e || Math.abs(h) < c.peek()[1]) && null !== (l = a === i.left ? i.right : i.left) && o(l)) : (c.size() < e || d < c.peek()[1]) && s(i, d)
                            }

                            var h, l, c;
                            if (c = new i((function (t) {
                                return -t[1]
                            })), s) for (h = 0; h < e; h += 1) c.push([null, s]);
                            for (a.root && o(a.root), l = [], h = 0; h < Math.min(e, c.content.length); h += 1) c.content[h][0] && l.push([c.content[h][0].obj, c.content[h][1]]);
                            return l
                        }, this.balanceFactor = function () {
                            function t(e) {
                                return null === e ? 0 : Math.max(t(e.left), t(e.right)) + 1
                            }

                            function e(t) {
                                return null === t ? 0 : e(t.left) + e(t.right) + 1
                            }

                            return t(a.root) / (Math.log(e(a.root)) / Math.log(2))
                        }
                    }, t.BinaryHeap = i
                }(e)
            })), af = function () {
                function t() {
                    var e = this;
                    wh(this, t), Mh(this, "data", []), Mh(this, "types", []), Mh(this, "kdtree", null), Mh(this, "isInit", !1), Mh(this, "init", (function () {
                        e.isInit || (e.kdtree = new sf.kdTree(e.data, Qd.distanceBetweenPoints, ["lat", "lon"]))
                    })), Mh(this, "addGeojson", (function (t) {
                        if ("FeatureCollection" === t.type && t.features instanceof Array) {
                            var i = [];
                            t.features.forEach((function (t) {
                                var n = {
                                    id: "_".concat(Math.random().toString(36).substr(2, 9)),
                                    lat: t.geometry.coordinates[1],
                                    lon: t.geometry.coordinates[0],
                                    properties: t.properties
                                };
                                e.data.push(n), i.push(i)
                            })), e.isInit ? e.kdtree.insert(i) : e.init()
                        }
                    })), Mh(this, "addGeojsonPoint", (function (t) {
                        var i = {
                            id: "_".concat(Math.random().toString(36).substr(2, 9)),
                            lat: t.geometry.coordinates[1],
                            lon: t.geometry.coordinates[0],
                            properties: t.properties
                        };
                        return e.data.push(i), e.isInit ? e.kdtree.insert(i) : e.init(), i
                    })), Mh(this, "addDataPoint", (function (t) {
                        var i = void 0 === t.length ? [t] : t, n = [];
                        i.forEach((function (t) {
                            var i = {
                                id: "_".concat(Math.random().toString(36).substr(2, 9)),
                                lat: t.coordinates[1],
                                lon: t.coordinates[0],
                                properties: t.properties
                            };
                            e.data.push(i), n.push(i)
                        })), e.isInit ? e.kdtree.insert(n) : e.init()
                    })), Mh(this, "updateDataset", (function (t) {
                        t.features.forEach((function (t) {
                            var i = e.data.find((function (e) {
                                var i = e.lat === t.geometry.coordinates[1], n = e.lon === t.geometry.coordinates[0];
                                return i && n
                            }));
                            void 0 === i ? e.addGeojsonPoint(t) : i.properties = t.properties
                        }))
                    })), Mh(this, "deleteDataset", (function () {
                        e.data = []
                    })), Mh(this, "getNearest", (function (t, i, n, r) {
                        e.isInit || e.init();
                        var s = e.kdtree.nearest({lat: t, lon: i}, r, n);
                        if (void 0 !== s[0]) return s
                    })), Mh(this, "getElementFromId", (function (t) {
                        return e.data.find((function (e) {
                            return e.id === t
                        }))
                    })), Mh(this, "getElementFromKey", (function (t, i) {
                        return e.data.find((function (e) {
                            return e.properties[t] === i
                        }))
                    })), Mh(this, "getTypeList", (function () {
                        var t = [];
                        return t.push([e.data[0]]), e.data.forEach((function (e) {
                            var i = Object.keys(e.properties), n = !1;
                            t.forEach((function (t) {
                                var r = Object.keys(t[0].properties), s = Qd.isSubSet(i, r), a = Qd.isSubSet(r, i);
                                s && a && (t.push(e), n = !0)
                            })), !1 === n && t.push([e])
                        })), t
                    })), Mh(this, "getMaxForKey", (function (t) {
                        var i, n = -1 / 0;
                        if ("number" == typeof e.data[0].properties[t]) return e.data.forEach((function (e) {
                            var r = e.properties[t];
                            r >= n && (n = r, i = e.id)
                        })), {max: n, id: i};
                        console.warn("Cannot compare non-numbers")
                    })), Mh(this, "getMinForKey", (function (t) {
                        var i, n = 1 / 0;
                        if ("number" == typeof e.data[0].properties[t]) return e.data.forEach((function (e) {
                            var r = e.properties[t];
                            r <= n && (n = r, i = e.id)
                        })), {min: n, id: i};
                        console.warn("Cannot compare non-numbers")
                    })), Mh(this, "getRangeForKey", (function (t) {
                        return {min: e.getMinForKey(t), max: e.getMaxForKey(t)}
                    })), Mh(this, "mapKeyToRange", (function (t, i, n) {
                        var r = e.getRangeForKey(t);
                        return e.data.map((function (e) {
                            var s = (e.properties[t] - r.min.min) / (r.max.max - r.min.min) * (n - i) + i;
                            return {id: e.properties.region_id, value: s}
                        }))
                    }))
                }

                return Eh(t, [{
                    key: "isHomogeneous", get: function () {
                        return 1 === this.getTypeList().length
                    }
                }]), t
            }(), of = function (t) {
                Th(i, t);
                var e = Lh(i);

                function i() {
                    return wh(this, i), e.apply(this, arguments)
                }

                return i
            }(Wd),
            hf = "precision mediump float;\n#define GLSLIFY 1\nuniform sampler2D u_texture;varying vec4 v_color;varying float v_alpha;void main(){vec4 surfaceColor=texture2D(u_texture,gl_PointCoord.xy);float d=(1.0+v_alpha)/2.0;float alpha=smoothstep(0.4,0.49,v_alpha);gl_FragColor=vec4(surfaceColor.rgb,surfaceColor.a*alpha);}",
            lf = {}, cf = function (t) {
                Th(i, t);
                var e = Lh(i);

                function i(t) {
                    var n, r;
                    wh(this, i), Mh(Ph(r = e.call(this, t)), "datastore", void 0), Mh(Ph(r), "maxSelectionDistance", 300), Mh(Ph(r), "maxSelectionCount", 1), Mh(Ph(r), "maxDataPoints", 50), Mh(Ph(r), "dataPointCount", 0), Mh(Ph(r), "_resourceLoaded", !1), Mh(Ph(r), "_isDirty", !0), Mh(Ph(r), "_hasGeometry", !1), Mh(Ph(r), "useTexture", !1), Mh(Ph(r), "createEmptyVertices", (function () {
                        r.geometry.vertices.position = {
                            numComponents: 3,
                            data: new Array(3 * r.maxDataPoints).fill(0),
                            perInstance: 1
                        }, r.geometry.vertices.color = {
                            numComponents: 4,
                            data: new Array(4 * r.maxDataPoints).fill(0),
                            perInstance: 1
                        }, r.geometry.vertices.size = {
                            numComponents: 1,
                            data: new Array(1 * r.maxDataPoints).fill(0),
                            perInstance: 1
                        }, r.geometry.vertices.indices = {
                            numComponents: 1,
                            data: Array.from(Array(1 * r.maxDataPoints).keys()),
                            perInstance: 1
                        }
                    })), Mh(Ph(r), "extendVerticesBy", (function (t) {
                        var e, i, n;
                        (e = r.geometry.vertices.position.data).push.apply(e, kh(Array(3 * t).fill(0))), (i = r.geometry.vertices.color.data).push.apply(i, kh(Array(4 * t).fill(0))), (n = r.geometry.vertices.size.data).push.apply(n, kh(Array(1 * t).fill(0)));
                        var s = r.geometry.vertices.indices.data.length;
                        r.geometry.vertices.indices.data = Array.from(Array(1 * (s + t)).keys()), r.geometry.needsResize = !0, r.maxDataPoints += t
                    })), Mh(Ph(r), "init", (function (t, e) {
                        if (r.geometry.init(t), r._hasGeometry = !0, r.material.init(t), r.useTexture) {
                            var i = {texture: {src: r.textureSrc.texture, minMag: t.LINEAR}};
                            r.material.loadTextures(t, i, (function () {
                                e && e(), r.material.uniforms.u_texture = r.material.textures.texture
                            }))
                        } else e && e()
                    })), Mh(Ph(r), "createCollisionGeo", (function () {
                    })), Mh(Ph(r), "update", (function (t, e, s) {
                        Rh((n = Ph(r), Dh(i.prototype)), "update", n).call(n, e, s), r.material.uniforms.u_model = r.modelMatrix, r.geometry.needsResize && r.geometry.reloadBuffers(t), r.geometry.isDirty && r.geometry.updateBuffers(t)
                    })), Mh(Ph(r), "draw", (function (t) {
                        (r.isReady || r._hasGeometry) && 0 !== !r.dataPointCount && (t.useProgram(r.material.programInfo.program), t.disable(t.DEPTH_TEST), Cp(t, r.material.programInfo, r.geometry.bufferInfo), Dp(r.material.programInfo, r.material.uniforms), t.drawElements(t.POINTS, r.dataPointCount, t.UNSIGNED_SHORT, 0), t.enable(t.DEPTH_TEST))
                    })), Mh(Ph(r), "rayCastFrom", (function () {
                        return !0
                    })), Mh(Ph(r), "hitTest", (function () {
                        return !0
                    })), Mh(Ph(r), "onSelectionCB", (function (t) {
                        return t
                    })), Mh(Ph(r), "onSelection", (function (t, e) {
                        var i = r.getNearest(t, e);
                        return i = r.onSelectionCB(i)
                    })), Mh(Ph(r), "transform", (function (t, e) {
                        return e.size = 24, e
                    })), Mh(Ph(r), "addGeojson", (function (t, e) {
                        if ("string" != typeof t) {
                            r.datastore.addGeojson(t);
                            var i = {
                                position: {numComponents: 3, data: []},
                                color: {numComponents: 4, data: []},
                                size: {numComponents: 1, data: []},
                                indices: {numComponents: 1, data: []}
                            };
                            r.datastore.data.forEach((function (t, e) {
                                var n, s, a = {lat: t.lat, lon: t.lon, color: [1, 1, 1, 1], size: 10};
                                (a = r.transform(t, a)).coords = Qd.worldFromLatLon(a.lat, a.lon, .01), (n = i.position.data).push.apply(n, kh(a.coords)), (s = i.color.data).push.apply(s, kh(a.color)), i.size.data.push(a.size), i.indices.data.push(e)
                            })), r.geometry.updateGeometry(i, r.dataPointCount), r.dataPointCount += t.features.length, void 0 !== e && e()
                        } else console.warn("This function needs a geojson object at this time")
                    })), Mh(Ph(r), "addDataPoint", (function (t) {
                        r.dataPointCount + 1 >= r.maxDataPoints && (console.warn("More than ".concat(r.maxDataPoints, " datapoints have been added, Increasing buffer size by: ").concat(r.maxDataPoints)), r.extendVerticesBy(r.maxDataPoints));
                        var e = [];
                        e.push(r.datastore.addGeojsonPoint(t));
                        var i = {
                            position: {numComponents: 3, data: []},
                            color: {numComponents: 4, data: []},
                            size: {numComponents: 1, data: []},
                            indices: {numComponents: 1, data: []}
                        };
                        e.forEach((function (t, e) {
                            var n, s, a = {lat: t.lat, lon: t.lon, color: [1, 1, 1, 1], size: 10};
                            (a = r.transform(t, a)).coords = Qd.worldFromLatLon(a.lat, a.lon, .01), (n = i.position.data).push.apply(n, kh(a.coords)), (s = i.color.data).push.apply(s, kh(a.color)), i.size.data.push(a.size), i.indices.data.push(e)
                        })), r.geometry.updateGeometry(i, r.dataPointCount), r.dataPointCount += 1
                    })), Mh(Ph(r), "getNearest", (function (t, e) {
                        return r.datastore.getNearest(t, e, r.maxSelectionDistance, r.maxSelectionCount)
                    }));
                    var s = {
                        vertex: "#define GLSLIFY 1\nattribute vec4 position;attribute vec4 color;attribute float size;uniform mat4 u_worldViewProjection;uniform mat4 u_viewInverse;uniform mat4 u_model;uniform vec3 u_cameraPos;varying vec4 v_color;varying float v_alpha;void main(){vec4 pos=u_worldViewProjection*u_model*position;gl_PointSize=size;gl_Position=pos;v_color=color;v_alpha=dot(position.xyz,normalize(u_cameraPos));}",
                        fragment: "precision mediump float;\n#define GLSLIFY 1\nvarying vec4 v_color;void main(){gl_FragColor=v_color;}"
                    };
                    return t && (t.maxSelectionCount && (r.maxSelectionCount = t.maxSelectionCount), t.maxSelectionDistance && (r.maxSelectionDistance = t.maxSelectionDistance), t.maxDataPoints && (r.maxDataPoints = t.maxDataPoints), !0 === t.useTexture && void 0 !== t.texture && (r.useTexture = !0, s.fragment = hf, r.textureSrc = {texture: t.texture})), r.material = new yd(s), r.datastore = new af, r.material.uniforms = lf, r.geometry = new Xd, r.createEmptyVertices(), r
                }

                return i
            }(of), uf = {
                vertex: "#define GLSLIFY 1\nattribute vec4 position;attribute vec2 texcoord;uniform mat4 u_worldViewProjection;uniform mat4 u_viewInverse;uniform mat4 u_model;uniform mat4 u_view;uniform float u_scale;uniform vec3 u_cameraPos;varying float vAlpha;varying vec2 vTexture;void main(){vec3 cameraRight=vec3(u_view[0][0],u_view[1][0],u_view[2][0]);vec3 cameraUp=vec3(u_view[0][1],u_view[1][1],u_view[2][1]);vec3 cameraForward=normalize(u_cameraPos);vec3 worldPos=cameraRight*position.x*u_scale+cameraUp*position.y*u_scale+cameraForward*1.1;vec4 pos=u_worldViewProjection*vec4(worldPos,1.0);gl_Position=pos;vTexture=texcoord;}",
                fragment: "precision mediump float;\n#define GLSLIFY 1\nuniform sampler2D u_background;varying float vAlpha;varying vec2 vTexture;void main(){gl_FragColor=vec4(1.0);}"
            }, pf = {u_scale: 1}, df = function (t) {
                Th(i, t);
                var e = Lh(i);

                function i(t) {
                    var n, r;
                    return wh(this, i), Mh(Ph(r = e.call(this)), "material", null), Mh(Ph(r), "useTexture", !1), Mh(Ph(r), "nScale", 1), Mh(Ph(r), "init", (function (t, e) {
                        if (r.geometry = new Xd, r.geometry.vertices.position = [-1, -1, 0, -1, 1, 0, 1, 1, 0, 1, -1, 0], r.geometry.vertices.texcoord = [0, 0, 0, 1, 1, 1, 1, 0], r.geometry.vertices.indices = [0, 2, 1, 0, 3, 2], r.geometry.init(t), r.material.init(t), r.useTexture) {
                            var i = {background: {src: r.textureSrc.texture, minMag: t.LINEAR, flipY: !0}};
                            r.material.loadTextures(t, i, (function () {
                                r.material.uniforms.u_background = r.material.textures.background, e && e()
                            }))
                        } else r.material.texturesLoaded = !0, e && e()
                    })), Mh(Ph(r), "createCollisionGeo", (function () {
                    })), Mh(Ph(r), "rayCastFrom", (function () {
                        return !1
                    })), Mh(Ph(r), "hitTest", (function () {
                        return !1
                    })), Mh(Ph(r), "onSelection", (function () {
                    })), Mh(Ph(r), "update", (function (t, e, s) {
                        Rh((n = Ph(r), Dh(i.prototype)), "update", n).call(n, e, s), r.material.uniforms.u_model = r.modelMatrix, r.material.uniforms.u_scale = r.nScale
                    })), Mh(Ph(r), "draw", (function (t) {
                        r.isReady && (t.disable(t.DEPTH_TEST), t.useProgram(r.material.programInfo.program), Cp(t, r.material.programInfo, r.geometry.bufferInfo), Dp(r.material.programInfo, r.material.uniforms), t.drawElements(t.TRIANGLES, r.geometry.bufferInfo.numElements, t.UNSIGNED_SHORT, 0), t.enable(t.DEPTH_TEST))
                    })), t.texture && (r.useTexture = !0, uf.fragment = "precision mediump float;\n#define GLSLIFY 1\nuniform sampler2D u_background;varying float vAlpha;varying vec2 vTexture;void main(){vec4 textureColor=texture2D(u_background,vTexture);gl_FragColor=textureColor;}", r.textureSrc = {texture: t.texture}), r.material = new yd(uf), r.material.uniforms = pf, r
                }

                return i
            }(Wd), ff = {
                vertex: "#define GLSLIFY 1\nattribute vec4 position;attribute vec2 texcoord;uniform mat4 u_worldViewProjection;uniform mat4 u_viewInverse;uniform mat4 u_model;uniform mat4 u_view;uniform float u_scale;uniform vec3 u_point;uniform vec2 u_resolution;uniform vec3 u_cameraPos;varying float vAlpha;varying vec2 vTexture;void main(){vec4 pos=u_worldViewProjection*vec4(u_point,1.0);float size=u_scale*16.0;pos.y+=(size*4.0/u_resolution.y);gl_PointSize=size;gl_Position=pos;vTexture=texcoord;float d=(1.0+dot(u_point,normalize(u_cameraPos)))/2.0;vAlpha=smoothstep(0.4,0.5,d);}",
                fragment: "precision mediump float;\n#define GLSLIFY 1\nuniform sampler2D u_background;varying float vAlpha;varying vec2 vTexture;void main(){vec4 textureColor=texture2D(u_background,gl_PointCoord);gl_FragColor=vec4(textureColor.rgb,vAlpha*textureColor.a);}"
            }, mf = {u_scale: 1, u_point: [0, 0, 1]}, gf = function (t) {
                Th(i, t);
                var e = Lh(i);

                function i(t) {
                    var n, r;
                    return wh(this, i), Mh(Ph(r = e.call(this)), "material", null), Mh(Ph(r), "useTexture", !1), Mh(Ph(r), "nScale", 1), Mh(Ph(r), "point", [0, 0, 1]), Mh(Ph(r), "init", (function (t, e) {
                        r.geometry = new Xd, r.geometry.vertices.position = [0, 0, 1], r.geometry.init(t), r.material.init(t);
                        var i = {background: {src: r.textureSrc.texture, minMag: t.LINEAR}};
                        r.material.loadTextures(t, i, (function () {
                            r.material.uniforms.u_background = r.material.textures.background, e && e()
                        }))
                    })), Mh(Ph(r), "createCollisionGeo", (function () {
                    })), Mh(Ph(r), "rayCastFrom", (function () {
                        return !1
                    })), Mh(Ph(r), "hitTest", (function () {
                        return !1
                    })), Mh(Ph(r), "onSelection", (function () {
                    })), Mh(Ph(r), "update", (function (t, e, s) {
                        Rh((n = Ph(r), Dh(i.prototype)), "update", n).call(n, e, s), r.material.uniforms.u_model = r.modelMatrix, r.material.uniforms.u_scale = r.nScale, r.material.uniforms.u_point = r.point
                    })), Mh(Ph(r), "draw", (function (t) {
                        r.isReady && (t.disable(t.DEPTH_TEST), t.useProgram(r.material.programInfo.program), Cp(t, r.material.programInfo, r.geometry.bufferInfo), Dp(r.material.programInfo, r.material.uniforms), t.drawArrays(t.POINTS, 0, r.geometry.bufferInfo.numElements), t.enable(t.DEPTH_TEST))
                    })), Mh(Ph(r), "setPoint", (function (t, e, i) {
                        var n = void 0 === i ? 0 : i;
                        r.point = Qd.worldFromLatLon(t, e, n)
                    })), r.textureSrc = {texture: t.texture}, r.material = new yd(ff), r.material.uniforms = mf, r
                }

                return i
            }(Wd), vf = function (t) {
                var e = {};

                function i(n) {
                    if (e[n]) return e[n].exports;
                    var r = e[n] = {exports: {}, id: n, loaded: !1};
                    return t[n].call(r.exports, r, r.exports, i), r.loaded = !0, r.exports
                }

                return i.m = t, i.c = e, i.p = "", i(0)
            }([function (t, e, i) {
                t.exports = i(1)
            }, function (t, e, i) {
                var n = "function" == typeof Symbol && "symbol" === xh(Symbol.iterator) ? function (t) {
                    return xh(t)
                } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : xh(t)
                };
                !function () {
                    var e = Math.abs, r = Math.min, s = Math.max, a = Math.cos, o = Math.sin, h = Math.acos, l = Math.sqrt,
                        c = Math.PI, u = {x: 0, y: 0, z: 0}, p = i(2), d = i(3), f = function (t) {
                            var i = t && t.forEach ? t : [].slice.call(arguments), r = !1;
                            if ("object" === n(i[0])) {
                                r = i.length;
                                var s = [];
                                i.forEach((function (t) {
                                    ["x", "y", "z"].forEach((function (e) {
                                        void 0 !== t[e] && s.push(t[e])
                                    }))
                                })), i = s
                            }
                            var a = !1, o = i.length;
                            if (r) {
                                if (r > 4) {
                                    if (1 !== arguments.length) throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");
                                    a = !0
                                }
                            } else if (6 !== o && 8 !== o && 9 !== o && 12 !== o && 1 !== arguments.length) throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");
                            var h = !a && (9 === o || 12 === o) || t && t[0] && void 0 !== t[0].z;
                            this._3d = h;
                            for (var l = [], c = 0, u = h ? 3 : 2; c < o; c += u) {
                                var d = {x: i[c], y: i[c + 1]};
                                h && (d.z = i[c + 2]), l.push(d)
                            }
                            this.order = l.length - 1, this.points = l;
                            var f = ["x", "y"];
                            h && f.push("z"), this.dims = f, this.dimlen = f.length, function (t) {
                                for (var i = t.order, n = t.points, r = p.align(n, {
                                    p1: n[0],
                                    p2: n[i]
                                }), s = 0; s < r.length; s++) if (e(r[s].y) > 1e-4) return void (t._linear = !1);
                                t._linear = !0
                            }(this), this._t1 = 0, this._t2 = 1, this.update()
                        }, m = i(4);

                    function g(t, e, i, n, r) {
                        void 0 === r && (r = .5);
                        var s = p.projectionratio(r, t), a = 1 - s, o = {x: s * e.x + a * n.x, y: s * e.y + a * n.y},
                            h = p.abcratio(r, t);
                        return {A: {x: i.x + (i.x - o.x) / h, y: i.y + (i.y - o.y) / h}, B: i, C: o}
                    }

                    f.SVGtoBeziers = function (t) {
                        return m(f, t)
                    }, f.quadraticFromPoints = function (t, e, i, n) {
                        if (void 0 === n && (n = .5), 0 === n) return new f(e, e, i);
                        if (1 === n) return new f(t, e, e);
                        var r = g(2, t, e, i, n);
                        return new f(t, r.A, i)
                    }, f.cubicFromPoints = function (t, e, i, n, r) {
                        void 0 === n && (n = .5);
                        var s = g(3, t, e, i, n);
                        void 0 === r && (r = p.dist(e, s.C));
                        var a = r * (1 - n) / n, o = p.dist(t, i), h = (i.x - t.x) / o, l = (i.y - t.y) / o, c = r * h,
                            u = r * l, d = a * h, m = a * l, v = e.x - c, y = e.y - u, b = e.x + d, x = e.y + m, w = s.A,
                            _ = w.x + (v - w.x) / (1 - n), E = w.y + (y - w.y) / (1 - n), M = w.x + (b - w.x) / n,
                            A = w.y + (x - w.y) / n, S = {x: t.x + (_ - t.x) / n, y: t.y + (E - t.y) / n},
                            T = {x: i.x + (M - i.x) / (1 - n), y: i.y + (A - i.y) / (1 - n)};
                        return new f(t, S, T, i)
                    };
                    var v = function () {
                        return p
                    };
                    f.getUtils = v, f.PolyBezier = d, f.prototype = {
                        getUtils: v, valueOf: function () {
                            return this.toString()
                        }, toString: function () {
                            return p.pointsToString(this.points)
                        }, toSVG: function (t) {
                            if (this._3d) return !1;
                            for (var e = this.points, i = ["M", e[0].x, e[0].y, 2 === this.order ? "Q" : "C"], n = 1, r = e.length; n < r; n++) i.push(e[n].x), i.push(e[n].y);
                            return i.join(" ")
                        }, setRatios: function (t) {
                            if (t.length !== this.points.length) throw new Error("incorrect number of ratio values");
                            this.ratios = t, this._lut = []
                        }, verify: function () {
                            var t = this.coordDigest();
                            t !== this._print && (this._print = t, this.update())
                        }, coordDigest: function () {
                            return this.points.map((function (t, e) {
                                return "" + e + t.x + t.y + (t.z ? t.z : 0)
                            })).join("")
                        }, update: function (t) {
                            this._lut = [], this.dpoints = p.derive(this.points, this._3d), this.computedirection()
                        }, computedirection: function () {
                            var t = this.points, e = p.angle(t[0], t[this.order], t[1]);
                            this.clockwise = e > 0
                        }, length: function () {
                            return p.length(this.derivative.bind(this))
                        }, _lut: [], getLUT: function (t) {
                            if (this.verify(), t = t || 100, this._lut.length === t) return this._lut;
                            this._lut = [], t--;
                            for (var e = 0; e <= t; e++) this._lut.push(this.compute(e / t));
                            return this._lut
                        }, on: function (t, e) {
                            e = e || 5;
                            for (var i, n = this.getLUT(), r = [], s = 0, a = 0; a < n.length; a++) i = n[a], p.dist(i, t) < e && (r.push(i), s += a / n.length);
                            return !!r.length && s / r.length
                        }, project: function (t) {
                            var e, i, n, r, s = this.getLUT(), a = s.length - 1, o = p.closest(s, t), h = o.mdist,
                                l = o.mpos, c = (l + 1) / a, u = .1 / a;
                            for (h += 1, e = i = (l - 1) / a; i < c + u; i += u) n = this.compute(i), (r = p.dist(t, n)) < h && (h = r, e = i);
                            return (n = this.compute(e)).t = e, n.d = h, n
                        }, get: function (t) {
                            return this.compute(t)
                        }, point: function (t) {
                            return this.points[t]
                        }, compute: function (t) {
                            return this.ratios ? p.computeWithRatios(t, this.points, this.ratios, this._3d) : p.compute(t, this.points, this._3d, this.ratios)
                        }, raise: function () {
                            for (var t, e, i = this.points, n = [i[0]], r = i.length, s = 1; s < r; s++) t = i[s], e = i[s - 1], n[s] = {
                                x: (r - s) / r * t.x + s / r * e.x,
                                y: (r - s) / r * t.y + s / r * e.y
                            };
                            return n[r] = i[r - 1], new f(n)
                        }, derivative: function (t) {
                            var e, i, n = 1 - t, r = 0, s = this.dpoints[0];
                            2 === this.order && (s = [s[0], s[1], u], e = n, i = t), 3 === this.order && (e = n * n, i = n * t * 2, r = t * t);
                            var a = {x: e * s[0].x + i * s[1].x + r * s[2].x, y: e * s[0].y + i * s[1].y + r * s[2].y};
                            return this._3d && (a.z = e * s[0].z + i * s[1].z + r * s[2].z), a
                        }, curvature: function (t) {
                            return p.curvature(t, this.points, this._3d)
                        }, inflections: function () {
                            return p.inflections(this.points)
                        }, normal: function (t) {
                            return this._3d ? this.__normal3(t) : this.__normal2(t)
                        }, __normal2: function (t) {
                            var e = this.derivative(t), i = l(e.x * e.x + e.y * e.y);
                            return {x: -e.y / i, y: e.x / i}
                        }, __normal3: function (t) {
                            var e = this.derivative(t), i = this.derivative(t + .01),
                                n = l(e.x * e.x + e.y * e.y + e.z * e.z), r = l(i.x * i.x + i.y * i.y + i.z * i.z);
                            e.x /= n, e.y /= n, e.z /= n, i.x /= r, i.y /= r, i.z /= r;
                            var s = {x: i.y * e.z - i.z * e.y, y: i.z * e.x - i.x * e.z, z: i.x * e.y - i.y * e.x},
                                a = l(s.x * s.x + s.y * s.y + s.z * s.z);
                            s.x /= a, s.y /= a, s.z /= a;
                            var o = [s.x * s.x, s.x * s.y - s.z, s.x * s.z + s.y, s.x * s.y + s.z, s.y * s.y, s.y * s.z - s.x, s.x * s.z - s.y, s.y * s.z + s.x, s.z * s.z];
                            return {
                                x: o[0] * e.x + o[1] * e.y + o[2] * e.z,
                                y: o[3] * e.x + o[4] * e.y + o[5] * e.z,
                                z: o[6] * e.x + o[7] * e.y + o[8] * e.z
                            }
                        }, hull: function (t) {
                            var e, i = this.points, n = [], r = [], s = 0, a = 0, o = 0;
                            for (r[s++] = i[0], r[s++] = i[1], r[s++] = i[2], 3 === this.order && (r[s++] = i[3]); i.length > 1;) {
                                for (n = [], a = 0, o = i.length - 1; a < o; a++) e = p.lerp(t, i[a], i[a + 1]), r[s++] = e, n.push(e);
                                i = n
                            }
                            return r
                        }, split: function (t, e) {
                            if (0 === t && e) return this.split(e).left;
                            if (1 === e) return this.split(t).right;
                            var i = this.hull(t), n = {
                                left: 2 === this.order ? new f([i[0], i[3], i[5]]) : new f([i[0], i[4], i[7], i[9]]),
                                right: 2 === this.order ? new f([i[5], i[4], i[2]]) : new f([i[9], i[8], i[6], i[3]]),
                                span: i
                            };
                            return n.left._t1 = p.map(0, 0, 1, this._t1, this._t2), n.left._t2 = p.map(t, 0, 1, this._t1, this._t2), n.right._t1 = p.map(t, 0, 1, this._t1, this._t2), n.right._t2 = p.map(1, 0, 1, this._t1, this._t2), e ? (e = p.map(e, t, 1, 0, 1), n.right.split(e).left) : n
                        }, extrema: function () {
                            var t, e, i = this.dims, n = {}, r = [];
                            return i.forEach(function (i) {
                                e = function (t) {
                                    return t[i]
                                }, t = this.dpoints[0].map(e), n[i] = p.droots(t), 3 === this.order && (t = this.dpoints[1].map(e), n[i] = n[i].concat(p.droots(t))), n[i] = n[i].filter((function (t) {
                                    return t >= 0 && t <= 1
                                })), r = r.concat(n[i].sort(p.numberSort))
                            }.bind(this)), r = r.sort(p.numberSort).filter((function (t, e) {
                                return r.indexOf(t) === e
                            })), n.values = r, n
                        }, bbox: function () {
                            var t = this.extrema(), e = {};
                            return this.dims.forEach(function (i) {
                                e[i] = p.getminmax(this, i, t[i])
                            }.bind(this)), e
                        }, overlaps: function (t) {
                            var e = this.bbox(), i = t.bbox();
                            return p.bboxoverlap(e, i)
                        }, offset: function (t, e) {
                            if (void 0 !== e) {
                                var i = this.get(t), n = this.normal(t), r = {c: i, n, x: i.x + n.x * e, y: i.y + n.y * e};
                                return this._3d && (r.z = i.z + n.z * e), r
                            }
                            if (this._linear) {
                                var s = this.normal(0), a = this.points.map((function (e) {
                                    var i = {x: e.x + t * s.x, y: e.y + t * s.y};
                                    return e.z && n.z && (i.z = e.z + t * s.z), i
                                }));
                                return [new f(a)]
                            }
                            return this.reduce().map((function (e) {
                                return e._linear ? e.offset(t)[0] : e.scale(t)
                            }))
                        }, simple: function () {
                            if (3 === this.order) {
                                var t = p.angle(this.points[0], this.points[3], this.points[1]),
                                    i = p.angle(this.points[0], this.points[3], this.points[2]);
                                if (t > 0 && i < 0 || t < 0 && i > 0) return !1
                            }
                            var n = this.normal(0), r = this.normal(1), s = n.x * r.x + n.y * r.y;
                            return this._3d && (s += n.z * r.z), e(h(s)) < c / 3
                        }, reduce: function () {
                            var t, i, n = 0, r = 0, s = .01, a = [], o = [], h = this.extrema().values;
                            for (-1 === h.indexOf(0) && (h = [0].concat(h)), -1 === h.indexOf(1) && h.push(1), n = h[0], t = 1; t < h.length; t++) r = h[t], (i = this.split(n, r))._t1 = n, i._t2 = r, a.push(i), n = r;
                            return a.forEach((function (t) {
                                for (n = 0, r = 0; r <= 1;) for (r = n + s; r <= 1.01; r += s) if (!(i = t.split(n, r)).simple()) {
                                    if (e(n - (r -= s)) < s) return [];
                                    (i = t.split(n, r))._t1 = p.map(n, 0, 1, t._t1, t._t2), i._t2 = p.map(r, 0, 1, t._t1, t._t2), o.push(i), n = r;
                                    break
                                }
                                n < 1 && ((i = t.split(n, 1))._t1 = p.map(n, 0, 1, t._t1, t._t2), i._t2 = t._t2, o.push(i))
                            })), o
                        }, scale: function (t) {
                            var e = this.order, i = !1;
                            if ("function" == typeof t && (i = t), i && 2 === e) return this.raise().scale(i);
                            var n = this.clockwise, r = i ? i(0) : t, s = i ? i(1) : t,
                                a = [this.offset(0, 10), this.offset(1, 10)], o = p.lli4(a[0], a[0].c, a[1], a[1].c);
                            if (!o) throw new Error("cannot scale this curve. Try reducing it first.");
                            var h = this.points, c = [];
                            return [0, 1].forEach(function (t) {
                                var i = c[t * e] = p.copy(h[t * e]);
                                i.x += (t ? s : r) * a[t].n.x, i.y += (t ? s : r) * a[t].n.y
                            }.bind(this)), i ? ([0, 1].forEach(function (r) {
                                if (2 !== this.order || !r) {
                                    var s = h[r + 1], a = {x: s.x - o.x, y: s.y - o.y}, u = i ? i((r + 1) / e) : t;
                                    i && !n && (u = -u);
                                    var p = l(a.x * a.x + a.y * a.y);
                                    a.x /= p, a.y /= p, c[r + 1] = {x: s.x + u * a.x, y: s.y + u * a.y}
                                }
                            }.bind(this)), new f(c)) : ([0, 1].forEach(function (t) {
                                if (2 !== this.order || !t) {
                                    var i = c[t * e], n = this.derivative(t), r = {x: i.x + n.x, y: i.y + n.y};
                                    c[t + 1] = p.lli4(i, r, o, h[t + 1])
                                }
                            }.bind(this)), new f(c))
                        }, outline: function (t, e, i, n) {
                            e = void 0 === e ? t : e;
                            var r, s = this.reduce(), a = s.length, o = [], h = [], l = 0, c = this.length(),
                                u = void 0 !== i && void 0 !== n;

                            function f(t, e, i, n, r) {
                                return function (s) {
                                    var a = n / i, o = (n + r) / i, h = e - t;
                                    return p.map(s, 0, 1, t + a * h, t + o * h)
                                }
                            }

                            s.forEach((function (r) {
                                _ = r.length(), u ? (o.push(r.scale(f(t, i, c, l, _))), h.push(r.scale(f(-e, -n, c, l, _)))) : (o.push(r.scale(t)), h.push(r.scale(-e))), l += _
                            })), h = h.map((function (t) {
                                return (r = t.points)[3] ? t.points = [r[3], r[2], r[1], r[0]] : t.points = [r[2], r[1], r[0]], t
                            })).reverse();
                            var m = o[0].points[0], g = o[a - 1].points[o[a - 1].points.length - 1],
                                v = h[a - 1].points[h[a - 1].points.length - 1], y = h[0].points[0], b = p.makeline(v, m),
                                x = p.makeline(g, y), w = [b].concat(o).concat([x]).concat(h), _ = w.length;
                            return new d(w)
                        }, outlineshapes: function (t, e, i) {
                            e = e || t;
                            for (var n = this.outline(t, e).curves, r = [], s = 1, a = n.length; s < a / 2; s++) {
                                var o = p.makeshape(n[s], n[a - s], i);
                                o.startcap.virtual = s > 1, o.endcap.virtual = s < a / 2 - 1, r.push(o)
                            }
                            return r
                        }, intersects: function (t, e) {
                            return t ? t.p1 && t.p2 ? this.lineIntersects(t) : (t instanceof f && (t = t.reduce()), this.curveintersects(this.reduce(), t, e)) : this.selfintersects(e)
                        }, lineIntersects: function (t) {
                            var e = r(t.p1.x, t.p2.x), i = r(t.p1.y, t.p2.y), n = s(t.p1.x, t.p2.x), a = s(t.p1.y, t.p2.y),
                                o = this;
                            return p.roots(this.points, t).filter((function (t) {
                                var r = o.get(t);
                                return p.between(r.x, e, n) && p.between(r.y, i, a)
                            }))
                        }, selfintersects: function (t) {
                            var e, i, n, r, s = this.reduce(), a = s.length - 2, o = [];
                            for (e = 0; e < a; e++) n = s.slice(e, e + 1), r = s.slice(e + 2), i = this.curveintersects(n, r, t), o = o.concat(i);
                            return o
                        }, curveintersects: function (t, e, i) {
                            var n = [];
                            t.forEach((function (t) {
                                e.forEach((function (e) {
                                    t.overlaps(e) && n.push({left: t, right: e})
                                }))
                            }));
                            var r = [];
                            return n.forEach((function (t) {
                                var e = p.pairiteration(t.left, t.right, i);
                                e.length > 0 && (r = r.concat(e))
                            })), r
                        }, arcs: function (t) {
                            t = t || .5;
                            return this._iterate(t, [])
                        }, _error: function (t, i, n, r) {
                            var s = (r - n) / 4, a = this.get(n + s), o = this.get(r - s), h = p.dist(t, i),
                                l = p.dist(t, a), c = p.dist(t, o);
                            return e(l - h) + e(c - h)
                        }, _iterate: function (t, e) {
                            var i, n = 0, r = 1;
                            do {
                                i = 0, r = 1;
                                var s, h, l, c, u, d = this.get(n), f = !1, m = !1, g = r, v = 1;
                                do {
                                    if (m = f, c = l, g = (n + r) / 2, s = this.get(g), h = this.get(r), (l = p.getccenter(d, s, h)).interval = {
                                        start: n,
                                        end: r
                                    }, f = this._error(l, d, n, r) <= t, (u = m && !f) || (v = r), f) {
                                        if (r >= 1) {
                                            if (l.interval.end = v = 1, c = l, r > 1) {
                                                var y = {x: l.x + l.r * a(l.e), y: l.y + l.r * o(l.e)};
                                                l.e += p.angle({x: l.x, y: l.y}, y, this.get(1))
                                            }
                                            break
                                        }
                                        r += (r - n) / 2
                                    } else r = g
                                } while (!u && i++ < 100);
                                if (i >= 100) break;
                                c = c || l, e.push(c), n = v
                            } while (r < 1);
                            return e
                        }
                    }, t.exports = f
                }()
            }, function (t, e, i) {
                var n, r, s, a, o, h, l, c, u, p, d, f, m, g, v;
                n = Math.abs, r = Math.cos, s = Math.sin, a = Math.acos, o = Math.atan2, h = Math.sqrt, l = Math.pow, c = function (t) {
                    return t < 0 ? -l(-t, 1 / 3) : l(t, 1 / 3)
                }, u = Math.PI, p = 2 * u, d = u / 2, f = Number.MAX_SAFE_INTEGER || 9007199254740991, m = Number.MIN_SAFE_INTEGER || -9007199254740991, g = {
                    x: 0,
                    y: 0,
                    z: 0
                }, v = {
                    Tvalues: [-.06405689286260563, .06405689286260563, -.1911188674736163, .1911188674736163, -.3150426796961634, .3150426796961634, -.4337935076260451, .4337935076260451, -.5454214713888396, .5454214713888396, -.6480936519369755, .6480936519369755, -.7401241915785544, .7401241915785544, -.820001985973903, .820001985973903, -.8864155270044011, .8864155270044011, -.9382745520027328, .9382745520027328, -.9747285559713095, .9747285559713095, -.9951872199970213, .9951872199970213],
                    Cvalues: [.12793819534675216, .12793819534675216, .1258374563468283, .1258374563468283, .12167047292780339, .12167047292780339, .1155056680537256, .1155056680537256, .10744427011596563, .10744427011596563, .09761865210411388, .09761865210411388, .08619016153195327, .08619016153195327, .0733464814110803, .0733464814110803, .05929858491543678, .05929858491543678, .04427743881741981, .04427743881741981, .028531388628933663, .028531388628933663, .0123412297999872, .0123412297999872],
                    arcfn: function (t, e) {
                        var i = e(t), n = i.x * i.x + i.y * i.y;
                        return void 0 !== i.z && (n += i.z * i.z), h(n)
                    },
                    compute: function (t, e, i) {
                        if (0 === t) return e[0];
                        var n = e.length - 1;
                        if (1 === t) return e[n];
                        var r = e, s = 1 - t;
                        if (0 === n) return e[0];
                        if (1 === n) return p = {
                            x: s * r[0].x + t * r[1].x,
                            y: s * r[0].y + t * r[1].y
                        }, i && (p.z = s * r[0].z + t * r[1].z), p;
                        if (n < 4) {
                            var a, o, h, l = s * s, c = t * t, u = 0;
                            2 === n ? (r = [r[0], r[1], r[2], g], a = l, o = s * t * 2, h = c) : 3 === n && (a = l * s, o = l * t * 3, h = s * c * 3, u = t * c);
                            var p = {
                                x: a * r[0].x + o * r[1].x + h * r[2].x + u * r[3].x,
                                y: a * r[0].y + o * r[1].y + h * r[2].y + u * r[3].y
                            };
                            return i && (p.z = a * r[0].z + o * r[1].z + h * r[2].z + u * r[3].z), p
                        }
                        for (var d = JSON.parse(JSON.stringify(e)); d.length > 1;) {
                            for (var f = 0; f < d.length - 1; f++) d[f] = {
                                x: d[f].x + (d[f + 1].x - d[f].x) * t,
                                y: d[f].y + (d[f + 1].y - d[f].y) * t
                            }, void 0 !== d[f].z && (d[f] = d[f].z + (d[f + 1].z - d[f].z) * t);
                            d.splice(d.length - 1, 1)
                        }
                        return d[0]
                    },
                    computeWithRatios: function (t, e, i, n) {
                        var r, s = 1 - t, a = i, o = e, h = a[0], l = a[1], c = a[2], u = a[3];
                        return h *= s, l *= t, 2 === o.length ? (r = h + l, {
                            x: (h * o[0].x + l * o[1].x) / r,
                            y: (h * o[0].y + l * o[1].y) / r,
                            z: !!n && (h * o[0].z + l * o[1].z) / r
                        }) : (h *= s, l *= 2 * s, c *= t * t, 3 === o.length ? (r = h + l + c, {
                            x: (h * o[0].x + l * o[1].x + c * o[2].x) / r,
                            y: (h * o[0].y + l * o[1].y + c * o[2].y) / r,
                            z: !!n && (h * o[0].z + l * o[1].z + c * o[2].z) / r
                        }) : (h *= s, l *= 1.5 * s, c *= 3 * s, u *= t * t * t, 4 === o.length ? (r = h + l + c + u, {
                            x: (h * o[0].x + l * o[1].x + c * o[2].x + u * o[3].x) / r,
                            y: (h * o[0].y + l * o[1].y + c * o[2].y + u * o[3].y) / r,
                            z: !!n && (h * o[0].z + l * o[1].z + c * o[2].z + u * o[3].z) / r
                        }) : void 0))
                    },
                    derive: function (t, e) {
                        for (var i = [], n = t, r = n.length, s = r - 1; r > 1; r--, s--) {
                            for (var a, o = [], h = 0; h < s; h++) a = {
                                x: s * (n[h + 1].x - n[h].x),
                                y: s * (n[h + 1].y - n[h].y)
                            }, e && (a.z = s * (n[h + 1].z - n[h].z)), o.push(a);
                            i.push(o), n = o
                        }
                        return i
                    },
                    between: function (t, e, i) {
                        return e <= t && t <= i || v.approximately(t, e) || v.approximately(t, i)
                    },
                    approximately: function (t, e, i) {
                        return n(t - e) <= (i || 1e-6)
                    },
                    length: function (t) {
                        var e, i, n = 0, r = v.Tvalues.length;
                        for (e = 0; e < r; e++) i = .5 * v.Tvalues[e] + .5, n += v.Cvalues[e] * v.arcfn(i, t);
                        return .5 * n
                    },
                    map: function (t, e, i, n, r) {
                        return n + (t - e) / (i - e) * (r - n)
                    },
                    lerp: function (t, e, i) {
                        var n = {x: e.x + t * (i.x - e.x), y: e.y + t * (i.y - e.y)};
                        return e.z && i.z && (n.z = e.z + t * (i.z - e.z)), n
                    },
                    pointToString: function (t) {
                        var e = t.x + "/" + t.y;
                        return void 0 !== t.z && (e += "/" + t.z), e
                    },
                    pointsToString: function (t) {
                        return "[" + t.map(v.pointToString).join(", ") + "]"
                    },
                    copy: function (t) {
                        return JSON.parse(JSON.stringify(t))
                    },
                    angle: function (t, e, i) {
                        var n = e.x - t.x, r = e.y - t.y, s = i.x - t.x, a = i.y - t.y;
                        return o(n * a - r * s, n * s + r * a)
                    },
                    round: function (t, e) {
                        var i = "" + t, n = i.indexOf(".");
                        return parseFloat(i.substring(0, n + 1 + e))
                    },
                    dist: function (t, e) {
                        var i = t.x - e.x, n = t.y - e.y;
                        return h(i * i + n * n)
                    },
                    closest: function (t, e) {
                        var i, n, r = l(2, 63);
                        return t.forEach((function (t, s) {
                            (n = v.dist(e, t)) < r && (r = n, i = s)
                        })), {mdist: r, mpos: i}
                    },
                    abcratio: function (t, e) {
                        if (2 !== e && 3 !== e) return !1;
                        if (void 0 === t) t = .5; else if (0 === t || 1 === t) return t;
                        var i = l(t, e) + l(1 - t, e);
                        return n((i - 1) / i)
                    },
                    projectionratio: function (t, e) {
                        if (2 !== e && 3 !== e) return !1;
                        if (void 0 === t) t = .5; else if (0 === t || 1 === t) return t;
                        var i = l(1 - t, e);
                        return i / (l(t, e) + i)
                    },
                    lli8: function (t, e, i, n, r, s, a, o) {
                        var h = (t - i) * (s - o) - (e - n) * (r - a);
                        return 0 != h && {
                            x: ((t * n - e * i) * (r - a) - (t - i) * (r * o - s * a)) / h,
                            y: ((t * n - e * i) * (s - o) - (e - n) * (r * o - s * a)) / h
                        }
                    },
                    lli4: function (t, e, i, n) {
                        var r = t.x, s = t.y, a = e.x, o = e.y, h = i.x, l = i.y, c = n.x, u = n.y;
                        return v.lli8(r, s, a, o, h, l, c, u)
                    },
                    lli: function (t, e) {
                        return v.lli4(t, t.c, e, e.c)
                    },
                    makeline: function (t, e) {
                        var n = i(1), r = t.x, s = t.y, a = e.x, o = e.y, h = (a - r) / 3, l = (o - s) / 3;
                        return new n(r, s, r + h, s + l, r + 2 * h, s + 2 * l, a, o)
                    },
                    findbbox: function (t) {
                        var e = f, i = f, n = m, r = m;
                        return t.forEach((function (t) {
                            var s = t.bbox();
                            e > s.x.min && (e = s.x.min), i > s.y.min && (i = s.y.min), n < s.x.max && (n = s.x.max), r < s.y.max && (r = s.y.max)
                        })), {
                            x: {min: e, mid: (e + n) / 2, max: n, size: n - e},
                            y: {min: i, mid: (i + r) / 2, max: r, size: r - i}
                        }
                    },
                    shapeintersections: function (t, e, i, n, r) {
                        if (!v.bboxoverlap(e, n)) return [];
                        var s = [], a = [t.startcap, t.forward, t.back, t.endcap],
                            o = [i.startcap, i.forward, i.back, i.endcap];
                        return a.forEach((function (e) {
                            e.virtual || o.forEach((function (n) {
                                if (!n.virtual) {
                                    var a = e.intersects(n, r);
                                    a.length > 0 && (a.c1 = e, a.c2 = n, a.s1 = t, a.s2 = i, s.push(a))
                                }
                            }))
                        })), s
                    },
                    makeshape: function (t, e, i) {
                        var n = e.points.length, r = t.points.length, s = v.makeline(e.points[n - 1], t.points[0]),
                            a = v.makeline(t.points[r - 1], e.points[0]),
                            o = {startcap: s, forward: t, back: e, endcap: a, bbox: v.findbbox([s, t, e, a])}, h = v;
                        return o.intersections = function (t) {
                            return h.shapeintersections(o, o.bbox, t, t.bbox, i)
                        }, o
                    },
                    getminmax: function (t, e, i) {
                        if (!i) return {min: 0, max: 0};
                        var n, r, s = f, a = m;
                        -1 === i.indexOf(0) && (i = [0].concat(i)), -1 === i.indexOf(1) && i.push(1);
                        for (var o = 0, h = i.length; o < h; o++) n = i[o], (r = t.get(n))[e] < s && (s = r[e]), r[e] > a && (a = r[e]);
                        return {min: s, mid: (s + a) / 2, max: a, size: a - s}
                    },
                    align: function (t, e) {
                        var i = e.p1.x, n = e.p1.y, a = -o(e.p2.y - n, e.p2.x - i);
                        return t.map((function (t) {
                            return {x: (t.x - i) * r(a) - (t.y - n) * s(a), y: (t.x - i) * s(a) + (t.y - n) * r(a)}
                        }))
                    },
                    roots: function (t, e) {
                        e = e || {p1: {x: 0, y: 0}, p2: {x: 1, y: 0}};
                        var i = t.length - 1, n = v.align(t, e), s = function (t) {
                            return 0 <= t && t <= 1
                        };
                        if (2 === i) {
                            if (0 !== (m = (g = n[0].y) - 2 * (y = n[1].y) + (b = n[2].y))) {
                                var o = -h(y * y - g * b), l = -g + y;
                                return [-(o + l) / m, -(-o + l) / m].filter(s)
                            }
                            return y !== b && 0 === m ? [(2 * y - b) / (2 * y - 2 * b)].filter(s) : []
                        }
                        var u = n[0].y, d = n[1].y, f = n[2].y, m = 3 * d - u - 3 * f + n[3].y, g = 3 * u - 6 * d + 3 * f,
                            y = -3 * u + 3 * d, b = u;
                        if (v.approximately(m, 0)) {
                            if (v.approximately(g, 0)) return v.approximately(y, 0) ? [] : [-b / y].filter(s);
                            var x = 2 * g;
                            return [((w = h(y * y - 4 * g * b)) - y) / x, (-y - w) / x].filter(s)
                        }
                        var w, _, E = (n = (3 * (y /= m) - (g /= m) * g) / 3) / 3,
                            M = (w = (2 * g * g * g - 9 * g * y + 27 * (b /= m)) / 27) / 2, A = M * M + E * E * E;
                        if (A < 0) {
                            var S = -n / 3, T = h(S * S * S), D = -w / (2 * T), C = a(D < -1 ? -1 : D > 1 ? 1 : D),
                                P = 2 * c(T);
                            return [P * r(C / 3) - g / 3, P * r((C + p) / 3) - g / 3, P * r((C + 2 * p) / 3) - g / 3].filter(s)
                        }
                        if (0 === A) return [2 * (_ = M < 0 ? c(-M) : -c(M)) - g / 3, -_ - g / 3].filter(s);
                        var I = h(A);
                        return [(_ = c(-M + I)) - c(M + I) - g / 3].filter(s)
                    },
                    droots: function (t) {
                        if (3 === t.length) {
                            var e = t[0], i = t[1], n = t[2], r = e - 2 * i + n;
                            if (0 !== r) {
                                var s = -h(i * i - e * n), a = -e + i;
                                return [-(s + a) / r, -(-s + a) / r]
                            }
                            return i !== n && 0 === r ? [(2 * i - n) / (2 * (i - n))] : []
                        }
                        if (2 === t.length) return (e = t[0]) !== (i = t[1]) ? [e / (e - i)] : []
                    },
                    curvature: function (t, e, i, r) {
                        var s, a, o, c, u, p, d = v.derive(e), f = d[0], m = d[1], g = v.compute(t, f), y = v.compute(t, m),
                            b = g.x * g.x + g.y * g.y;
                        if (i ? (s = h(l(g.y * y.z - y.y * g.z, 2) + l(g.z * y.x - y.z * g.x, 2) + l(g.x * y.y - y.x * g.y, 2)), a = l(b + g.z * g.z, 1.5)) : (s = g.x * y.y - g.y * y.x, a = l(b, 1.5)), 0 === s || 0 === a) return {
                            k: 0,
                            r: 0
                        };
                        if (u = s / a, p = a / s, !r) {
                            var x = v.curvature(t - .001, e, i, !0).k, w = v.curvature(t + .001, e, i, !0).k;
                            c = (w - u + (u - x)) / 2, o = (n(w - u) + n(u - x)) / 2
                        }
                        return {k: u, r: p, dk: c, adk: o}
                    },
                    inflections: function (t) {
                        if (t.length < 4) return [];
                        var e = v.align(t, {p1: t[0], p2: t.slice(-1)[0]}), i = e[2].x * e[1].y, n = e[3].x * e[1].y,
                            r = e[1].x * e[2].y, s = 18 * (-3 * i + 2 * n + 3 * r - (u = e[3].x * e[2].y)),
                            a = 18 * (3 * i - n - 3 * r), o = 18 * (r - i);
                        if (v.approximately(s, 0)) {
                            if (!v.approximately(a, 0)) {
                                var h = -o / a;
                                if (0 <= h && h <= 1) return [h]
                            }
                            return []
                        }
                        var l = a * a - 4 * s * o, c = Math.sqrt(l), u = 2 * s;
                        return v.approximately(u, 0) ? [] : [(c - a) / u, -(a + c) / u].filter((function (t) {
                            return 0 <= t && t <= 1
                        }))
                    },
                    bboxoverlap: function (t, e) {
                        var i, r, s, a, o, h = ["x", "y"], l = h.length;
                        for (i = 0; i < l; i++) if (s = t[r = h[i]].mid, a = e[r].mid, o = (t[r].size + e[r].size) / 2, n(s - a) >= o) return !1;
                        return !0
                    },
                    expandbox: function (t, e) {
                        e.x.min < t.x.min && (t.x.min = e.x.min), e.y.min < t.y.min && (t.y.min = e.y.min), e.z && e.z.min < t.z.min && (t.z.min = e.z.min), e.x.max > t.x.max && (t.x.max = e.x.max), e.y.max > t.y.max && (t.y.max = e.y.max), e.z && e.z.max > t.z.max && (t.z.max = e.z.max), t.x.mid = (t.x.min + t.x.max) / 2, t.y.mid = (t.y.min + t.y.max) / 2, t.z && (t.z.mid = (t.z.min + t.z.max) / 2), t.x.size = t.x.max - t.x.min, t.y.size = t.y.max - t.y.min, t.z && (t.z.size = t.z.max - t.z.min)
                    },
                    pairiteration: function (t, e, i) {
                        var n = t.bbox(), r = e.bbox(), s = 1e5, a = i || .5;
                        if (n.x.size + n.y.size < a && r.x.size + r.y.size < a) return [(s * (t._t1 + t._t2) / 2 | 0) / s + "/" + (s * (e._t1 + e._t2) / 2 | 0) / s];
                        var o = t.split(.5), h = e.split(.5),
                            l = [{left: o.left, right: h.left}, {left: o.left, right: h.right}, {
                                left: o.right,
                                right: h.right
                            }, {left: o.right, right: h.left}];
                        l = l.filter((function (t) {
                            return v.bboxoverlap(t.left.bbox(), t.right.bbox())
                        }));
                        var c = [];
                        return 0 === l.length || (l.forEach((function (t) {
                            c = c.concat(v.pairiteration(t.left, t.right, a))
                        })), c = c.filter((function (t, e) {
                            return c.indexOf(t) === e
                        }))), c
                    },
                    getccenter: function (t, e, i) {
                        var n, a = e.x - t.x, h = e.y - t.y, l = i.x - e.x, c = i.y - e.y, u = a * r(d) - h * s(d),
                            f = a * s(d) + h * r(d), m = l * r(d) - c * s(d), g = l * s(d) + c * r(d), y = (t.x + e.x) / 2,
                            b = (t.y + e.y) / 2, x = (e.x + i.x) / 2, w = (e.y + i.y) / 2, _ = y + u, E = b + f, M = x + m,
                            A = w + g, S = v.lli8(y, b, _, E, x, w, M, A), T = v.dist(S, t), D = o(t.y - S.y, t.x - S.x),
                            C = o(e.y - S.y, e.x - S.x), P = o(i.y - S.y, i.x - S.x);
                        return D < P ? ((D > C || C > P) && (D += p), D > P && (n = P, P = D, D = n)) : P < C && C < D ? (n = P, P = D, D = n) : P += p, S.s = D, S.e = P, S.r = T, S
                    },
                    numberSort: function (t, e) {
                        return t - e
                    }
                }, t.exports = v
            }, function (t, e, i) {
                var n, r;
                n = i(2), (r = function (t) {
                    this.curves = [], this._3d = !1, t && (this.curves = t, this._3d = this.curves[0]._3d)
                }).prototype = {
                    valueOf: function () {
                        return this.toString()
                    }, toString: function () {
                        return "[" + this.curves.map((function (t) {
                            return n.pointsToString(t.points)
                        })).join(", ") + "]"
                    }, addCurve: function (t) {
                        this.curves.push(t), this._3d = this._3d || t._3d
                    }, length: function () {
                        return this.curves.map((function (t) {
                            return t.length()
                        })).reduce((function (t, e) {
                            return t + e
                        }))
                    }, curve: function (t) {
                        return this.curves[t]
                    }, bbox: function () {
                        for (var t = this.curves, e = t[0].bbox(), i = 1; i < t.length; i++) n.expandbox(e, t[i].bbox());
                        return e
                    }, offset: function (t) {
                        var e = [];
                        return this.curves.forEach((function (i) {
                            e = e.concat(i.offset(t))
                        })), new r(e)
                    }
                }, t.exports = r
            }, function (t, e, i) {
                var n = i(5), r = {x: !1, y: !1};

                function s(t, e, i) {
                    if ("Z" !== e) {
                        if ("M" !== e) {
                            var n = [!1, r.x, r.y].concat(i), s = new (t.bind.apply(t, n)), a = i.slice(-2);
                            return r = {x: a[0], y: a[1]}, s
                        }
                        r = {x: i[0], y: i[1]}
                    }
                }

                t.exports = function (t, e) {
                    for (var i, r, a = n(e).split(" "), o = new RegExp("[MLCQZ]", ""), h = [], l = {
                        C: 6,
                        Q: 4,
                        L: 2,
                        M: 2
                    }; a.length;) i = a.splice(0, 1)[0], o.test(i) && (r = s(t, i, a.splice(0, l[i]).map(parseFloat))) && h.push(r);
                    return new t.PolyBezier(h)
                }
            }, function (t, e) {
                t.exports = function (t) {
                    var e, i, n, r, s, a,
                        o = (t = t.replace(/,/g, " ").replace(/-/g, " - ").replace(/-\s+/g, "-").replace(/([a-zA-Z])/g, " $1 ")).replace(/([a-zA-Z])\s?/g, "|$1").split("|"),
                        h = o.length, l = [], c = 0, u = 0, p = 0, d = 0, f = 0, m = 0, g = 0, v = 0, y = "";
                    for (e = 1; e < h; e++) if (r = (n = (i = o[e]).substring(0, 1)).toLowerCase(), s = (l = (l = i.replace(n, "").trim().split(" ")).filter((function (t) {
                        return "" !== t
                    })).map(parseFloat)).length, "m" === r) {
                        if (y += "M ", "m" === n ? (p += l[0], d += l[1]) : (p = l[0], d = l[1]), c = p, u = d, y += p + " " + d + " ", s > 2) for (a = 0; a < s; a += 2) "m" === n ? (p += l[a], d += l[a + 1]) : (p = l[a], d = l[a + 1]), y += ["L", p, d, ""].join(" ")
                    } else if ("l" === r) for (a = 0; a < s; a += 2) "l" === n ? (p += l[a], d += l[a + 1]) : (p = l[a], d = l[a + 1]), y += ["L", p, d, ""].join(" "); else if ("h" === r) for (a = 0; a < s; a++) "h" === n ? p += l[a] : p = l[a], y += ["L", p, d, ""].join(" "); else if ("v" === r) for (a = 0; a < s; a++) "v" === n ? d += l[a] : d = l[a], y += ["L", p, d, ""].join(" "); else if ("q" === r) for (a = 0; a < s; a += 4) "q" === n ? (f = p + l[a], m = d + l[a + 1], p += l[a + 2], d += l[a + 3]) : (f = l[a], m = l[a + 1], p = l[a + 2], d = l[a + 3]), y += ["Q", f, m, p, d, ""].join(" "); else if ("t" === r) for (a = 0; a < s; a += 2) f = p + (p - f), m = d + (d - m), "t" === n ? (p += l[a], d += l[a + 1]) : (p = l[a], d = l[a + 1]), y += ["Q", f, m, p, d, ""].join(" "); else if ("c" === r) for (a = 0; a < s; a += 6) "c" === n ? (f = p + l[a], m = d + l[a + 1], g = p + l[a + 2], v = d + l[a + 3], p += l[a + 4], d += l[a + 5]) : (f = l[a], m = l[a + 1], g = l[a + 2], v = l[a + 3], p = l[a + 4], d = l[a + 5]), y += ["C", f, m, g, v, p, d, ""].join(" "); else if ("s" === r) for (a = 0; a < s; a += 4) f = p + (p - g), m = d + (d - v), "s" === n ? (g = p + l[a], v = d + l[a + 1], p += l[a + 2], d += l[a + 3]) : (g = l[a], v = l[a + 1], p = l[a + 2], d = l[a + 3]), y += ["C", f, m, g, v, p, d, ""].join(" "); else "z" === r && (y += "Z ", p = c, d = u);
                    return y.trim()
                }
            }]), yf = {u_animation: 1}, bf = function (t) {
                Th(i, t);
                var e = Lh(i);

                function i(t) {
                    var n, r;
                    wh(this, i), Mh(Ph(r = e.call(this, t)), "datastore", void 0), Mh(Ph(r), "maxSelectionDistance", 300), Mh(Ph(r), "maxSelectionCount", 1), Mh(Ph(r), "maxDataPoints", 10), Mh(Ph(r), "segments", 600), Mh(Ph(r), "_pointsPerArcHalf", 300), Mh(Ph(r), "_tweens", []), Mh(Ph(r), "dataPointCount", 0), Mh(Ph(r), "_resourceLoaded", !1), Mh(Ph(r), "_isDirty", !0), Mh(Ph(r), "_hasGeometry", !1), Mh(Ph(r), "useTexture", !1), Mh(Ph(r), "createEmptyVertices", (function () {
                        r.geometry.vertices.position = {
                            numComponents: 3,
                            data: new Array(r.segments).fill(0),
                            perInstance: 3
                        }, r.geometry.vertices.size = {
                            numComponents: 1,
                            data: new Array(r.segments).fill(0),
                            perInstance: 1
                        }, r.geometry.vertices.inst = {
                            numComponents: 1,
                            data: new Array(r.segments).fill(0),
                            perInstance: 1
                        }, r.geometry.vertices.indices = {
                            numComponents: 1,
                            data: Array.from(Array(r.segments).keys()),
                            perInstance: 1
                        }
                    })), Mh(Ph(r), "addArc", (function (t, e, i) {
                        var n = [], s = {
                            from: t.from,
                            to: t.to,
                            normalFactor: t.normalFactor || .5,
                            alt: t.alt || .3,
                            startColor: t.startColor || "#ffffff",
                            endColor: t.endColor || "#ffffff",
                            startWidth: t.startWidth || 4,
                            midWidth: t.midWidth || 4,
                            endWidth: t.endWidth || 4
                        }, a = (Qd.dotBetweenLatLon(t.from, t.to) + 1) / 2;
                        void 0 !== r.transform && (s = r.transform(t, s)), s.alt = .1 + (1 - a) * s.alt, n.push.apply(n, kh(r._createArcFrom(s)));
                        var o = Array.from(Array(r.segments).keys());
                        if (void 0 !== e) {
                            r.material.uniforms.u_animation = 0;
                            var h = new Kd(0, 1, e, {
                                onUpdate: function (t) {
                                    r.material.uniforms.u_animation = t
                                }, onComplete: function () {
                                    i && i()
                                }
                            });
                            r._tweens.push(h)
                        }
                        var l = {position: {data: new Float32Array(n)}, inst: {data: o}};
                        r.geometry.updateGeometry(l, 0), r.shouldDraw = !0
                    })), Mh(Ph(r), "_createArcFrom", (function (t) {
                        var e = r._computeControlPoints(t), i = new vf(e.cp0), n = new vf(e.cp1),
                            s = i.getLUT(r._pointsPerArcHalf), a = n.getLUT(r._pointsPerArcHalf), o = [];
                        s.reverse().forEach((function (t) {
                            o.push(t)
                        })), a.forEach((function (t) {
                            o.push(t)
                        })), o.splice(r._pointsPerArcHalf, 1);
                        var h = [];
                        return o.forEach((function (t) {
                            h.push.apply(h, kh(Object.values(t)))
                        })), h
                    })), Mh(Ph(r), "_computeControlPoints", (function (t) {
                        var e = Qd.worldFromLatLon(t.from[0], t.from[1], .005),
                            i = Qd.worldFromLatLon(t.to[0], t.to[1], .005), n = Xp();
                        ed(n, e, i, .5);
                        var r = Qd.latLonFromWorld(n), s = Qd.worldFromLatLon(r.lat, r.lon, t.alt), a = Xp();
                        Jp(a, e, n), Qp(a, a, t.normalFactor);
                        var o = Xp();
                        Zp(o, s, a);
                        var h = Xp();
                        Jp(h, s, a);
                        var l = [];
                        l.push.apply(l, kh(s)), l.push.apply(l, kh(o)), l.push.apply(l, kh(e));
                        var c = [];
                        return c.push.apply(c, kh(s)), c.push.apply(c, kh(h)), c.push.apply(c, kh(i)), {cp0: l, cp1: c}
                    })), Mh(Ph(r), "_createInstArray", (function (t) {
                        for (var e = Array.from(Array(r.segments + 1).keys()), i = [], n = 0; n < t; n += 1) e.forEach((function (t) {
                            i.push(t)
                        }));
                        return i
                    })), Mh(Ph(r), "removeAllArcs", (function () {
                        r.shouldDraw = !1
                    })), Mh(Ph(r), "init", (function (t, e) {
                        if (r.geometry.init(t), r._hasGeometry = !0, r.material.init(t), r.useTexture) {
                            var i = {texture: {src: r.textureSrc.texture, minMag: t.LINEAR}};
                            r.material.loadTextures(t, i, (function () {
                                e && e(), r.material.uniforms.u_texture = r.material.textures.texture
                            }))
                        } else e && e()
                    })), Mh(Ph(r), "createCollisionGeo", (function () {
                    })), Mh(Ph(r), "update", (function (t, e, s) {
                        Rh((n = Ph(r), Dh(i.prototype)), "update", n).call(n, e, s), r.material.uniforms.u_model = r.modelMatrix, r.geometry.needsResize && r.geometry.reloadBuffers(t), r.geometry.isDirty && r.geometry.updateBuffers(t)
                    })), Mh(Ph(r), "draw", (function (t) {
                        (r.isReady || r._hasGeometry) && r.shouldDraw && (t.useProgram(r.material.programInfo.program), t.disable(t.DEPTH_TEST), Cp(t, r.material.programInfo, r.geometry.bufferInfo), Dp(r.material.programInfo, r.material.uniforms), t.drawArrays(t.POINTS, 0, r.segments - 1), t.enable(t.DEPTH_TEST))
                    })), Mh(Ph(r), "rayCastFrom", (function () {
                        return !0
                    })), Mh(Ph(r), "hitTest", (function () {
                        return !0
                    })), Mh(Ph(r), "onSelectionCB", (function (t) {
                        return t
                    })), Mh(Ph(r), "onSelection", (function (t, e) {
                    }));
                    var s = {
                        vertex: "#define GLSLIFY 1\nattribute vec4 position;attribute float inst;uniform mat4 u_worldViewProjection;uniform mat4 u_viewInverse;uniform mat4 u_model;uniform vec3 u_cameraPos;varying vec4 v_color;varying float v_tex;varying float v_alpha;float when_gt(float x,float y){return max(sign(x-y),0.0);}float when_lt(float x,float y){return max(sign(y-x),0.0);}float getV(vec3 x){return x.x*x.x+x.y*x.y+x.z*x.z;}void main(){vec4 pos=u_worldViewProjection*u_model*position;v_tex=inst/600.0;gl_PointSize=(0.5-abs(0.5-v_tex))*(8.0/0.5)+4.0;gl_Position=pos;v_color=vec4(1.0,0.0,0.0,1.0);v_alpha=step(0.3,(1.0+dot(normalize(u_cameraPos),normalize(position.xyz)))/2.0);}",
                        fragment: "precision mediump float;\n#define GLSLIFY 1\nuniform float u_time;uniform float u_animation;varying vec4 v_color;varying float v_tex;varying float v_alpha;void main(){float d=distance(vec2(0.5),gl_PointCoord.xy);float c=1.0-smoothstep(0.0,0.5,d);float alpha=step(1.0-u_animation,1.0-v_tex)*(0.5-abs(0.5-v_tex));gl_FragColor=vec4(1.0,1.0,1.0,c*v_alpha*alpha);}"
                    };
                    return t && (t.maxSelectionCount && (r.maxSelectionCount = t.maxSelectionCount), t.maxSelectionDistance && (r.maxSelectionDistance = t.maxSelectionDistance), t.maxDataPoints && (r.maxDataPoints = t.maxDataPoints), !0 === t.useTexture && void 0 !== t.texture && (r.useTexture = !0, s.fragment = hf, r.textureSrc = {texture: t.texture})), r.material = new yd(s), r.datastore = new af, r.material.uniforms = yf, r.geometry = new Xd, r.shouldDraw = !1, r.createEmptyVertices(), r
                }

                return i
            }(of), xf = function t(e, i, n, r) {
                wh(this, t), Mh(this, "id", Math.random().toFixed(16).substr(2)), Mh(this, "latitude", 0), Mh(this, "longitude", 0), Mh(this, "altitude", 0), Mh(this, "calloutClass", void 0), Mh(this, "data", void 0), this.latitude = e, this.longitude = i, this.calloutClass = n, this.data = r
            }, wf = function () {
                function t(e) {
                    var i = this;
                    wh(this, t), Mh(this, "drawables", []), Mh(this, "element", void 0), Mh(this, "definition", void 0), Mh(this, "size", {
                        width: 0,
                        height: 0
                    }), this.definition = e, this.element = this.createElement(), this.resizeObserver = new ResizeObserver((function (t) {
                        t.length && (i.size = t[0].contentRect)
                    })), this.resizeObserver.observe(this.element)
                }

                return Eh(t, [{
                    key: "release", value: function () {
                        this.resizeObserver.disconnect()
                    }
                }, {
                    key: "createElement", value: function () {
                        return document.createElement("div")
                    }
                }, {
                    key: "animateIn", value: function () {
                    }
                }, {
                    key: "animateOut", value: function (t) {
                        t(this)
                    }
                }, {
                    key: "update", value: function (t) {
                        this.drawables.forEach((function (e) {
                            return e.update(t)
                        }))
                    }
                }, {
                    key: "setPosition", value: function (t) {
                        this.element.style.transform = "translate(".concat(t.screen.x, "px, ").concat(t.screen.y, "px)")
                    }
                }]), t
            }();

        function _f(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }

        class Ef extends wf {
            createElement() {
                var t = document.createElement("div");
                return t.className = "airport-callout", t.innerHTML = '<div class="callout-container">\n      <h3>'.concat(this.definition.data.name, "</h3>\n      <table>\n        <tbody>\n          <tr>\n            <td>Flight time:</td>\n            <td>").concat(this.definition.data.flight_time, "</td>\n          </tr>\n        </tbody>\n      </table>\n    </div>"), t
            }

            setPosition(t) {
                var e = t.screen.x - 29, i = t.screen.y - 123;
                this.element.style.transform = "translate(".concat(e.toFixed(1), "px, ").concat(i.toFixed(0), "px)")
            }

            animateIn() {
                var t = this.element.querySelector(".callout-container");
                xn.fromTo(this.element, {alpha: 0}, {
                    alpha: 1,
                    duration: .5,
                    ease: "power1"
                }), xn.fromTo(t, {scale: .75}, {scale: 1, duration: .5, ease: "expo"})
            }

            animateOut(t) {
                xn.to(this.element, {
                    alpha: 0, duration: .5, ease: "power1", onComplete: () => {
                        t(this)
                    }
                })
            }
        }

        const Mf = class {
            constructor(t) {
                _f(this, "onInitCB", (() => {
                })), _f(this, "toPrevious", (() => {
                    this.last = this.current, this.current = 0 === this.current ? this.points.datastore.data.length - 1 : this.current - 1, this.onClick()
                })), _f(this, "toNext", (() => {
                    this.last = this.current, this.current = this.current === this.points.datastore.data.length - 1 ? 0 : this.current + 1, this.onClick()
                })), _f(this, "resize", (() => {
                    this.gkview.boundingRect = this.canvas.getBoundingClientRect()
                })), _f(this, "update", (t => {
                    var {current: e, last: i} = t;
                    e !== i && (this.gkview.boundingRect = this.canvas.getBoundingClientRect(), this.gkview.onResizeCB())
                })), this.canvas = t, this.gkOptions = {
                    wasmPath: "/static/globe/gkweb_bg.wasm",
                    clearColor: [0, 0, 0, 0],
                    attributes: {alpha: !0}
                }, this.gkview = new rf(t, this.gkOptions, this.onInitCB), this.gkview._alt = 4.5, this.gkview.setAbsMovementModelTo(7.13087, -55.997978), this.calloutManager = new nf(document.getElementById("callout-manager")), this.gkview.registerCalloutManager(this.calloutManager), this.calloutManager.onAutoRemove = t => {
                    this.arcs.removeAllArcs()
                }, this.icosphere = new Jd("/static/globe/icosphere_surface.jpg"), this.icosphere.setInteractive(!0, !0, !1), this.icosphere.shouldDraw = !0, this.gkview.addDrawable(this.icosphere, (() => {
                    this.gkview.startDrawing()
                })), this.atmosphere = new df({texture: "/static/globe/atmosphere.png"}), this.atmosphere.shouldDraw = !0, this.atmosphere.nScale = .85, this.gkview.addDrawable(this.atmosphere), this.points = new cf({
                    useTexture: !0,
                    texture: "/static/globe/target.png"
                }), this.points.setInteractive(!0, !0, !1), this.points.maxSelectionDistance = n.isSmooth ? 200 : 400, this.points.applyTransform = (t, e) => e, fetch("/static/globe/data/points.json").then((t => t.json())).then((t => {
                    this.points.addGeojson(t)
                })), this.gkview.addDrawable(this.points), this.gkview.userDefinedSelection = t => {
                    console.log(t), t.drawables.forEach((t => {
                        if (t.obj.id === this.points.id) if (void 0 !== t.selection) {
                            var e = t.selection[0][0];
                            this.calloutManager.removeAllCallouts(), this.arcs.removeAllArcs(), this.calloutManager.addCallout(new xf(e.lat, e.lon, Ef, e.properties));
                            var i = {from: [e.lat, e.lon], to: [19.67753, -70.011568]};
                            this.arcs.addArc(i, 2e3)
                        } else this.arcs.removeAllArcs(), this.calloutManager.removeAllCallouts()
                    }))
                }, this.pin = new gf({texture: "/static/globe/pin.png"}), this.pin.shouldDraw = !0, this.pin.nScale = 2, this.pin.setPoint(19.67753, -70.011568), this.gkview.addDrawable(this.pin), this.arcs = new bf, this.gkview.addDrawable(this.arcs), Vn.on("resize", this.resize), Vn.on(Da.TICK, this.update), this.previous = document.querySelector(".js-globe-prev"), this.next = document.querySelector(".js-globe-next"), this.previous.addEventListener("click", this.toPrevious), this.next.addEventListener("click", this.toNext), this.gkview.interactionController.movementModel.isInteractive = !1, setTimeout((() => {
                    this.gkview.interactionController.movementModel.isInteractive = !0
                }), 2e3), this.last = 0, this.current = 0
            }

            onClick() {
                var t = this.points.datastore.data[this.current];
                this.calloutManager.removeAllCallouts(), this.arcs.removeAllArcs(), this.calloutManager.addCallout(new xf(t.lat, t.lon, Ef, t.properties));
                var e = {from: [t.lat, t.lon], to: [19.67753, -70.011568]};
                this.arcs.addArc(e, 2e3)
            }

            destroy() {
                Vn.off("resize", this.resize), Vn.off(Da.TICK, this.update)
            }
        };

        function Af(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }

        function Sf(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }

        const Tf = class {
            constructor(t) {
                Sf(this, "changeSlide", (t => {
                    if (!this._state.isAnimating) {
                        var {next: e, total: i} = this._state;
                        this._state.direction = t, this._state.current = e, "next" === this._state.direction ? this._state.next = e === i ? 0 : e + 1 : "previous" === this._state.direction ? this._state.next = 0 === e ? i : e - 1 : this._state.next = this._state.direction, this._bullets && (this._bullets[this._state.current].classList.remove("is-active"), this._bullets[this._state.next].classList.add("is-active")), this._pagination && (xn.to(this._pagination[this._state.current], {
                            duration: .35,
                            y: -5,
                            alpha: 0,
                            ease: "power2.inOut"
                        }), xn.fromTo(this._pagination[this._state.next], {y: 10, alpha: 0}, {
                            duration: 1.1,
                            y: 0,
                            alpha: 1,
                            ease: "expo",
                            delay: .5
                        })), this.animate()
                    }
                })), Sf(this, "onUp", (t => {
                    var {x: e} = t, {on: i, isSwiping: n} = this._state;
                    n && (i >= e + 50 ? this.changeSlide("next") : i <= e - 50 && this.changeSlide("previous"), this._state.isSwiping = !1)
                })), Sf(this, "onDown", (t => {
                    var {x: e, target: i} = t;
                    this._swipearea.contains(i) && (this._state.isSwiping = !0, this._state.on = e)
                })), Sf(this, "onResize", (() => {
                }));
                var {el: e, slides: i = ".js-slide", navigation: n, bullets: r, pagination: s} = t;
                e && (this._el = "string" == typeof e ? document.querySelector("".concat(e)) : e, this._swipearea = this._el.querySelector(".js-slider-swipearea"), this._slides = "string" == typeof i ? this._el.querySelectorAll("".concat(i)) : i, this._state = {
                    total: this._slides.length - 1,
                    current: 0,
                    next: 0,
                    on: 0,
                    off: 0,
                    direction: null,
                    isAnimating: !1,
                    isSwiping: !1
                }, this._navigation = {
                    previous: n ? this._el.querySelectorAll(".js-slider--previous") : null,
                    next: n ? this._el.querySelectorAll(".js-slider--next") : null
                }, this._bullets = r ? this._el.querySelectorAll(".js-bullet") : null, this._pagination = s ? this._el.querySelectorAll(".js-pagination__item") : null, this._paginationTotals = this._el.querySelectorAll(".js-pagination__total"), this._paginationTotals && this._paginationTotals.forEach((t => {
                    t.textContent = this._state.total + 1
                })), this._tl = null, this.init())
            }

            animate() {
                this._tl && this._tl.kill()
            }

            addListeners() {
                if (Vn.on(wa.RESIZE, this.onResize), this._swipearea && (Vn.on(Ma.DOWN, this.onDown), Vn.on(Ma.UP, this.onUp)), this._navigation) {
                    var {previous: t, next: e} = this._navigation;
                    t && t.forEach((t => {
                        t.addEventListener("click", (() => this.changeSlide("previous")))
                    })), e && e.forEach((t => {
                        t.addEventListener("click", (() => this.changeSlide("next")))
                    }))
                }
                this._bullets && this._bullets.forEach(((t, e) => {
                    t.addEventListener("click", (() => this.changeSlide(e)))
                }))
            }

            removeListeners() {
                Vn.off(wa.RESIZE, this.onResize), this._swipearea && (Vn.off(Ma.DOWN, this.onDown), Vn.off(Ma.UP, this.onUp))
            }

            destroy() {
                this.removeListeners(), this._el = null, this._slides = null, this._navigation = null, this._pagination = null, this._bullets = null, this._state = null
            }

            init() {
                this.addListeners()
            }
        };
        const Df = class extends Tf {
            constructor(t) {
                super(t), this._tl = null
            }

            animate() {
                super.animate(), this._state.isAnimating = !0;
                var t, {current: e, next: i, direction: n} = this._state, r = this._slides[e], s = this._slides[i],
                    a = s.querySelector("img");
                this._tl && this._tl.kill(), t = "next" === n ? [[100, -100], -25] : "previous" === n ? [[-100, 100], 25] : i > e ? [[100, -100], -25] : [[-100, 100], 25], this._tl = xn.timeline({
                    force3D: !0,
                    onComplete: () => {
                        this._state.isAnimating = !1
                    }
                }), this._tl.set(s, {
                    autoAlpha: 1,
                    zIndex: 2
                }).fromTo([s, a], {xPercent: xn.utils.wrap(t[0])}, {
                    duration: 1.1,
                    xPercent: 0,
                    ease: "expo.inOut",
                    stagger: 0
                }, 0).fromTo(r, {xPercent: 0}, {
                    duration: 1.1,
                    xPercent: t[1],
                    ease: "expo.inOut"
                }, 0).set(r, {autoAlpha: 0, clearProps: "zIndex, xPercent"}).set(s, {clearProps: "zIndex"})
            }
        };

        function Cf(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }

        const Pf = function (t) {
            return new Promise(((e, i) => {
                var n = new Image;
                n.addEventListener("load", (i => e(t))), n.addEventListener("error", (e => i(t))), n.src = t
            }))
        };
        const If = class {
            constructor(t) {
                var e, i, n, {el: r, elems: s} = t;
                n = (t, e) => {
                    t.forEach((t => {
                        t.intersectionRatio > 0 && (this.loadImage(t.target), this.observer.unobserve(t.target))
                    }))
                }, (i = "handle") in (e = this) ? Object.defineProperty(e, i, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[i] = n, this.images = s, this.options = {
                    root: null,
                    rootMargin: "0px 50% 0px 50%",
                    threshold: [0, 0]
                }, this.observer = new IntersectionObserver(this.handle, this.options), this.init()
            }

            observe() {
                this.images.forEach((t => {
                    this.observer.observe(t)
                }))
            }

            loadImage(t) {
                var e = t.dataset.lazySrc;
                Pf(e).then((() => {
                    t.src = e, xn.fromTo(t, {alpha: 0}, {duration: .25, alpha: 1, ease: "power1"})
                }))
            }

            destroy() {
                this.observer.disconnect(), this.observer = null, this.images = null
            }

            init() {
                this.observe()
            }
        };
        xn.registerPlugin($s);

        class Lf extends Ua.Renderer {
            initial() {
                this.onEnter(), window.onload = () => this.onEnterCompleted()
            }

            onEnter() {
                Ta.update(), this.el = this.wrap.lastElementChild, n.body.classList.add(this.el.dataset.theme), n.isDevice && this.heroHeightMobile()
            }

            onLeave() {
            }

            onEnterCompleted() {
                setTimeout((() => {
                    n.body.classList.add(this.el.dataset.theme)
                })), this.init()
            }

            onLeaveCompleted() {
                this.destroy(), $s.getAll().forEach((t => t.kill()))
            }

            init() {
                if (this.initScrollDown(), this.initParallaxSlider(), this.initDraggable(), this.initGalleries(), this.initVimeo(), this.initScrollAnimations(), n.isSmooth && this.initParallax(), this.initDraggableSlider(), this.initSkiReport(), this.initFlight(), this.initMap(), this.initReports(), this.initDisclaimer(), this.initBtns(), this.initGallery(), this.handleLazy(), this.initGM(), window.location.hash) {
                    var t = document.querySelector(window.location.hash);
                    t && Ta.scrollTo(t.offsetTop)
                } else Ta.scrollTo(0);
                n.isSmooth && this.initSmooth(), this.initGlobe(), document.querySelectorAll("a").forEach((t => {
                    t.addEventListener("click", (() => {
                        if (t.hash) {
                            var e = document.querySelector(t.hash);
                            e && Ta.scrollTo(e.offsetTop)
                        }
                    }))
                })), this.triggered = new class {
                    constructor(t) {
                        this.el = t, this.tweens()
                    }

                    tweens() {
                        var t = fo(".js-s-slide", this.el);
                        t && xn.timeline({scrollTrigger: {trigger: t}}).from(t, {
                            duration: 2,
                            x: .15 * n.width,
                            ease: "power3",
                            immediateRender: !1
                        }).from(t, {duration: 1, alpha: 0, ease: "linear", immediateRender: !0}, .5);
                        var e = mo(".js-s-upscale", this.el);
                        e.length && e.forEach((t => {
                            var e = fo(".js-s-downscale", t), i = n.width / t.getBoundingClientRect().width;
                            xn.timeline({
                                scrollTrigger: {
                                    trigger: t.parentNode,
                                    start: "top center",
                                    end: "top top",
                                    scrub: !0
                                }, defaults: {ease: "linear", force3D: !0}
                            }).to(t, {scale: i}).from(e, {scale: 1.25 * i}, 0)
                        }));
                        var i = mo(".js-s-mask", this.el);
                        i.length && i.forEach((t => {
                            var e = fo(".js-s-mask__img", t), i = fo(".js-s-mask__mask", t),
                                n = fo(".js-s-mask__gradient", t);
                            xn.set(e, {alpha: 0}), xn.timeline({scrollTrigger: {trigger: t}}).from(i, {
                                xPercent: -100,
                                duration: .65,
                                ease: "power3.in"
                            }).set(e, {alpha: 1}).addLabel("in").to(i, {
                                xPercent: 100,
                                duration: 1.25,
                                ease: "power3.out"
                            }, "in").from(e, {scale: 1.5, duration: 2, ease: "power3.out"}, "in").from(n, {
                                alpha: 0,
                                duration: 1.25,
                                ease: "power1"
                            }, "in")
                        }))
                    }

                    destroy() {
                    }
                }(this.el)
            }

            handleLazy() {
                var t = this.el.querySelectorAll("[data-lazy-src]");
                t.length && (this.lazy = new If({el: this.el, elems: t}))
            }

            initGallery() {
                var t = this.el.querySelector(".js-gallery");
                t && (this.gallerySlider = new Df({el: t, slides: ".js-gallery-slide", navigation: !0, bullets: !0}))
            }

            initGM() {
                var t = this.el.querySelector(".js-gm");
                t && (this.gm = new class {
                    constructor(t) {
                        Cf(this, "toggleVid", (t => {
                            var {currentTarget: e} = t, i = e.parentNode.querySelector("video"),
                                n = e.parentNode.querySelector("img");
                            i.play(), xn.to(i, {duration: .5, autoAlpha: 1, ease: "power1"}), xn.to(n, {
                                duration: .5,
                                autoAlpha: 0,
                                ease: "power1"
                            })
                        })), Cf(this, "close", (() => {
                            var t = this.cache[this.current];
                            t && t.vid && t.vid.pause(), xn.to(this.el, {
                                duration: .5,
                                autoAlpha: 0,
                                ease: "power1"
                            }), n.isModal = !1, Vn.emit("header:unhide")
                        })), Cf(this, "open", (t => {
                            var {currentTarget: e} = t;
                            n.isModal = !0, Vn.emit("header:hide"), this.last = this.current, this.current = this.triggers.indexOf(e), xn.set(this.slides, {x: -this.points[this.current]}), xn.to(this.el, {
                                duration: .5,
                                autoAlpha: 1,
                                ease: "power1"
                            }), this.last > -1 && xn.set(this.texts[this.last], {autoAlpha: 0}), xn.set(this.texts[this.current], {autoAlpha: 1}), this.togglebullets()
                        })), Cf(this, "next", (() => {
                            this.last = this.current, this.current = this.current === this.total ? 0 : this.current + 1, this.direction = !0, this.animate()
                        })), Cf(this, "prev", (() => {
                            this.last = this.current, this.current = 0 === this.current ? this.total : this.current - 1, this.direction = !1, this.animate()
                        })), Cf(this, "key", (t => {
                            n.isModal && (37 === t.keyCode ? this.prev() : 39 === t.keyCode && this.next())
                        })), this.el = t, this.slides = this.el.querySelector(".js-gm-inner"), this.items = [...this.el.querySelectorAll(".js-gm-item")], this.texts = [...this.el.querySelectorAll(".js-gm-text")], this.triggers = [...document.querySelectorAll(".js-gm-trigger")], this.bullets = [...this.el.querySelectorAll(".js-gm-index")], this.btns = {
                            close: this.el.querySelector(".js-close-gm"),
                            prev: this.el.querySelector(".js-prev"),
                            next: this.el.querySelector(".js-next")
                        }, this.last = -1, this.current = 0, this.total = this.items.length - 1, this.direction = !0, this.init()
                    }

                    init() {
                        this.getCache(), this.addEvents()
                    }

                    addEvents() {
                        var {close: t, prev: e, next: i} = this.btns;
                        t.addEventListener("click", this.close), e.addEventListener("click", this.prev), i.addEventListener("click", this.next), this.triggers.forEach((t => t.addEventListener("click", this.open))), document.addEventListener("keydown", this.key)
                    }

                    getCache() {
                        this.points = [], this.cache = this.items.map(((t, e) => {
                            var i = t.querySelector(".js-gm-inner"), n = t.querySelector("video"),
                                r = t.querySelector("img"), s = this.texts[e], a = null;
                            n && (a = new Fa({el: t.querySelector(".js-gm-icon")})).trigger.addEventListener("click", this.toggleVid);
                            var {left: o} = t.getBoundingClientRect();
                            return this.points[e] = o, {left: o, item: t, inner: i, vid: n, circle: a, img: r, text: s}
                        }))
                    }

                    reset() {
                        0 === this.current ? xn.set(this.slides, {x: 0}) : this.current === this.total && xn.set(this.slides, {x: -this.points[this.points.length - 1]})
                    }

                    animate() {
                        var t = this.cache[this.last], e = this.cache[this.current];
                        t && t.vid && t.vid.pause(), this.current !== this.total || this.direction ? 0 === this.current && this.direction ? xn.set(this.slides, {x: 0}) : xn.to(this.slides, {
                            duration: 1.25,
                            x: -this.points[this.current],
                            ease: "expo"
                        }) : xn.set(this.slides, {x: -this.points[this.points.length - 1]}), xn.to([t.text, this.bullets[this.last]], {
                            duration: 1.25,
                            autoAlpha: 0,
                            yPercent: -50,
                            ease: "expo"
                        }), xn.fromTo([e.text, this.bullets[this.current]], {
                            autoAlpha: 0,
                            yPercent: 100
                        }, {duration: 1.25, autoAlpha: 1, yPercent: 0, ease: "expo"})
                    }

                    togglebullets() {
                        xn.set(this.bullets[this.last], {
                            autoAlpha: 0,
                            yPercent: -50
                        }), xn.set(this.bullets[this.current], {autoAlpha: 1, yPercent: 0})
                    }

                    removeEvents() {
                        var {close: t, prev: e, next: i} = this.btns;
                        t.removeEventListener("click", this.close), e.removeEventListener("click", this.prev), i.removeEventListener("click", this.next), this.triggers.forEach((t => t.removeEventListener("click", this.open))), document.removeEventListener("keydown", this.key)
                    }

                    destroy() {
                        this.removeEvents()
                    }
                }(t))
            }

            initReports() {
                var t = this.el.querySelector(".js-report-tabs");
                t && (this.report = new class {
                    constructor(t) {
                        var e, i, n;
                        n = t => {
                            var {currentTarget: e} = t, i = document.querySelector(e.id);
                            Ta.scrollTo(i.offsetTop), this.elems.forEach((t => {
                                t.classList.remove("is-active")
                            })), e.classList.add("is-active")
                        }, (i = "scrollDown") in (e = this) ? Object.defineProperty(e, i, {
                            value: n,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : e[i] = n, this.el = t || fo(".js-report-tabs"), this.elems = [...mo(".js-report-tabs__item", this.el)], this.init()
                    }

                    init() {
                        this.elems.forEach((t => {
                            Eo(t, "a", "click", this.scrollDown)
                        }))
                    }
                }(t))
            }

            initScrollDown() {
                var t = this.el.querySelector(".c-hero-sb");
                t && Eo(t, "a", "click", this.targetScrollDown)
            }

            targetScrollDown() {
                Ta.scrollDown()
            }

            initScrollAnimations() {
                var t = this.el.querySelectorAll("[data-scroll]");
                t && (this.scrollAnimations = new po(t))
            }

            initParallax() {
                var t = document.querySelectorAll(".js-parallax");
                t && (this.parallax = new xo(t))
            }

            initSmooth() {
                var t = document.querySelectorAll(".js-smooth-section");
                t && (this.smooth = new class {
                    constructor() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : mo(".js-smooth-section");
                        go(this, "run", (t => {
                            var {current: e} = t;
                            this.current = e, !this.resizing && this.transformSections()
                        })), go(this, "resize", (() => {
                            this.resizing = !0, this.getSections(), Vn.emit("resize:on-reset"), this.transformSections(), this.resizing = !1
                        })), this.elems = [...t], this.current = 0, this.resizing = !1, this.init()
                    }

                    init() {
                        this.getSections(), this.addEvents(), this.preload()
                    }

                    addEvents() {
                        Vn.on(Da.TICK, this.run), Vn.on(wa.RESIZE, this.resize)
                    }

                    preload() {
                        this.promises = [], mo("img").forEach((t => {
                            this.promises.push(new Promise((e => {
                                var i = new Image;
                                i.onload = () => e(), i.src = t.src
                            })))
                        })), Promise.all(this.promises).then((() => this.resize()))
                    }

                    setHeight() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.elems[this.elems.length - 1].getBoundingClientRect().bottom;
                        n.scrollP.style.height = "".concat(t, "px"), n.scrollHeight = t - n.height
                    }

                    getSections() {
                        if (this.elems) {
                            var t = this.elems.length - 1;
                            this.sections = [...this.elems].map(((e, i) => {
                                e.style.transform = "translate3d(0, 0, 0)";
                                var {top: r, bottom: s} = e.getBoundingClientRect();
                                return i === t && this.setHeight(s), {
                                    el: e,
                                    start: r - n.height - 100,
                                    end: s + 100,
                                    out: !0
                                }
                            }))
                        }
                    }

                    transformSections() {
                        this.sections.length > 0 && this.sections.forEach((t => {
                            this.visible(t) || this.resizing ? (t.out && (t.out = !1), this.transform(t.el)) : t.out || (t.out = !0, this.transform(t.el))
                        }))
                    }

                    transform(t) {
                        t.style.transform = "translate3d(0, ".concat(-this.current, "px, 0)")
                    }

                    visible(t) {
                        var {start: e, end: i} = t,
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.current;
                        return n > e && n < i
                    }

                    removeEvents() {
                        Vn.off(Da.TICK, this.run), Vn.off(wa.RESIZE, this.resize)
                    }

                    destroy() {
                        this.removeEvents(), this.cache = null
                    }
                }(t))
            }

            initDraggable() {
                var t = this.el.querySelector(".js-img-slider");
                t && (this.draggable = new Ao({el: t, navigation: !0}))
            }

            initGalleries() {
                var t = this.el.querySelectorAll(".js-slider-txt"), e = this.el.querySelectorAll(".js-slider-img-txt"),
                    i = this.el.querySelectorAll(".js-slider-full");
                (t || e || i) && (this.galleries = []), t && t.forEach((t => {
                    var e = new Ao({el: t, navigation: !0, bullets: !0});
                    this.galleries.push(e)
                })), e && e.forEach((t => {
                    var e = new To({el: t, navigation: !0, bullets: !0});
                    this.galleries.push(e)
                })), i && i.forEach((t => {
                    this.galleries.push(new So({el: t, navigation: !0, bullets: !0}))
                }))
            }

            initSkiReport() {
                var t = this.el.querySelector(".js-ski");
                t && (this.ski = new class {
                    constructor(t) {
                        fh(this, "anchor", (() => {
                            xn.to(Ta.state, {target: this.rect.top, ease: "power3.inOut", duration: 1})
                        })), fh(this, "toggle", (() => {
                            this.flipped ? (this.flipped = !1, this.el.classList.remove("is-active"), this.tl.reverse()) : (this.flipped = !0, this.el.classList.add("is-active"), this.tl.play())
                        })), this.el = t, this.ui = {
                            toggle: fo(".js-ski-toggle"),
                            tabs: [...mo(".js-ski-tab")],
                            imgOuter: fo(".js-ski-img", this.el),
                            imgInner: fo(".js-ski-img-inner", this.el),
                            imgScale: fo(".js-ski-scale", this.el),
                            anch: document.querySelector(".js-to-ski")
                        }, this.rect = this.el.getBoundingClientRect(), this.tl = xn.timeline({paused: !0}), this.init()
                    }

                    init() {
                        this.setCache(), this.setTl(), this.addEvents()
                    }

                    addEvents() {
                        var {toggle: t, anch: e} = this.ui;
                        t.addEventListener("click", this.toggle), e && e.addEventListener("click", this.anchor)
                    }

                    setCache() {
                        this.cache = this.ui.tabs.map((t => {
                            var e = !0, i = fo(".js-ski-dp-toggle", t), n = mo(".js-ski-tab-tab", t),
                                r = xn.timeline({paused: !0}).to(n, {
                                    autoAlpha: xn.utils.wrap([0, 1]),
                                    ease: "power1",
                                    duration: .35
                                });
                            i.addEventListener("click", (() => s()));
                            var s = () => {
                                e ? (e = !1, t.classList.remove("is-active"), r.play()) : (e = !0, t.classList.add("is-active"), r.reverse())
                            };
                            return {el: t}
                        }))
                    }

                    setTl() {
                        var {tabs: t, imgOuter: e, imgInner: i, imgScale: n} = this.ui;
                        this.tl.to(t[0], {autoAlpha: 0, ease: "power1.out", duration: .5}).to(t[1], {
                            autoAlpha: 1,
                            ease: "power1.out",
                            duration: .5
                        }).to([e, i], {
                            xPercent: xn.utils.wrap([100, -100]),
                            scale: xn.utils.wrap([1, 1.2]),
                            ease: "power3.inOut",
                            duration: 1
                        }, 0).from(n, {scale: 1.2, ease: "power3.inOut", duration: 1}, 0)
                    }
                }(t), vh())
            }

            initParallaxSlider() {
                var t = this.el.querySelector(".js-ps");
                t && t.classList.contains("js-ps--s") ? this.ps = new Do({
                    el: t,
                    navigation: !0,
                    bullets: !0
                }) : t && (this.ps = new class {
                    constructor() {
                        var t = this;
                        Co(this, "ui", {}), Co(this, "run", (() => {
                            var t = this.state, {target: e, a: i, b: n, c: r} = t;
                            i.current += (e - i.current) * i.ease, i.rounded = Math.round(100 * i.current) / 100, n.current += (e - n.current) * i.ease, n.rounded = Math.round(100 * i.current) / 100, r.current += (e - r.current) * r.ease, r.rounded = Math.round(100 * r.current) / 100, t.progress = i.rounded / t.max, !t.resizing && this.transformSlides()
                        })), Co(this, "down", (t => {
                            var {x: e, y: i, target: n} = t;
                            if (n.closest(".js-ps-drag")) {
                                var r = this.state;
                                r.dragging = !0, r.cancel.x = e, r.cancel.y = i, r.on = r.target + e * this.opts.speed
                            }
                        })), Co(this, "move", (t => {
                            var {x: e, y: i, e: n} = t, r = this.state;
                            if (r.dragging) {
                                var {cancel: s} = r;
                                Math.abs(e - s.x) > Math.abs(i - s.y) && n.cancelable && (n.preventDefault(), n.stopPropagation()), r.target = r.on - e * this.opts.speed, this.clamp()
                            }
                        })), Co(this, "up", (() => {
                            this.state.dragging = !1, xn.utils.snap(this.snap, this.state.target)
                        })), Co(this, "toggle", (() => {
                            var t = this.state, {winter: e, summer: i, container: n} = this.ui;
                            t.index = t.last = 0, xn.timeline().to(n, {
                                alpha: 0,
                                duration: .35,
                                ease: "power1.out"
                            }).add((() => {
                                t.flipped ? (t.flipped = !1, this.el.classList.remove("is-active")) : (t.flipped = !0, this.el.classList.add("is-active")), this.resize(!0, t.flipped ? i : e)
                            })).to(n, {alpha: 1, duration: .35, ease: "power1.out"})
                        })), Co(this, "prev", (() => {
                            var t = this.state;
                            t.last = t.index, t.index = 0 === t.index ? t.total : t.index - 1, t.target = t.max / t.total * t.index, this.updatePips()
                        })), Co(this, "next", (() => {
                            var t = this.state;
                            t.last = t.index, t.index = t.index === t.total ? 0 : t.index + 1, t.target = t.max / t.total * t.index, this.updatePips()
                        })), Co(this, "resize", (function () {
                            var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
                                i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t.ui.summer,
                                n = t.state, {a: r, b: s, c: a} = n;
                            n.resizing = !0, t.setCache(i), t.clamp(), r.current = r.rounded = s.current = s.rounded = a.current = a.rounded = e ? n.target = 0 : n.target, t.transformSlides(), n.resizing = !1
                        })), this.el = document.querySelector(".js-ps"), this.ui.btn = this.el.querySelector(".js-ps-toggle"), this.ui.winter = this.el.querySelectorAll(".js-winter"), this.ui.summer = this.el.querySelectorAll(".js-summer"), this.ui.container = this.el.querySelector(".js-ps-drag"), this.ui.prev = this.el.querySelector(".js-prev"), this.ui.next = this.el.querySelector(".js-next"), this.pips = [this.el.querySelector(".js-pips-1"), this.el.querySelector(".js-pips-2")], this.bullets = [this.pips[0].querySelectorAll(".js-pip"), this.pips[1].querySelectorAll(".js-pip")], this.state = {
                            on: 0,
                            max: 0,
                            target: 0,
                            cancel: {x: 0, y: 0},
                            a: {current: 0, rounded: 0, ease: .1},
                            b: {current: 0, rounded: 0, ease: .0925},
                            c: {current: 0, rounded: 0, ease: .085},
                            index: 0,
                            dragging: !1,
                            resizing: !1
                        }, this.opts = {speed: 2, ease: .085}, this.init()
                    }

                    init() {
                        this.setCache(), this.addEvents()
                    }

                    addEvents() {
                        var {prev: t, next: e, btn: i} = this.ui;
                        Vn.on(Da.TICK, this.run), Vn.on(wa.RESIZE, this.resize), Vn.on(Ma.DOWN, this.down), Vn.on(Ma.MOVE, this.move), Vn.on(Ma.UP, this.up), i.addEventListener("click", this.toggle), t.addEventListener("click", this.prev), e.addEventListener("click", this.next)
                    }

                    setCache() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.ui.winter, {width: e} = n,
                            i = t.length - 1;
                        this.snap = [], t === this.ui.winter ? xn.to(this.pips, {
                            alpha: xn.utils.wrap([1, 0]),
                            duration: .5,
                            ease: "power1"
                        }) : xn.to(this.pips, {
                            alpha: xn.utils.wrap([0, 1]),
                            duration: .5,
                            ease: "power1"
                        }), this.cache = [...t].map(((t, n) => {
                            t.style.transform = "translate3d(0, 0, 0)";
                            var {left: r, right: s} = t.getBoundingClientRect();
                            return n === i && (this.state.max = s - e + e / 2, this.state.total = parseInt(t.closest("[data-index]").dataset.index)), this.snap.push(r), {
                                el: t,
                                start: r - e - 50,
                                end: s + 50,
                                out: !0,
                                ease: t.dataset.ease
                            }
                        }))
                    }

                    transform(t, e) {
                        t.style.transform = "translate3d(".concat(-e, "px, 0, 0)")
                    }

                    transformSlides() {
                        this.cache.forEach((t => {
                            var e = this.state["".concat(t.ease)].rounded;
                            this.visible(t, e) || this.state.resizing ? (t.out && (t.out = !1), this.transform(t.el, e)) : t.out || (t.out = !0, this.transform(t.el, e))
                        }))
                    }

                    visible(t, e) {
                        var {start: i, end: n} = t;
                        return e > i && e < n
                    }

                    updatePips() {
                        var t = this.state, e = t.flipped ? this.bullets[1] : this.bullets[0];
                        console.log(t.last, t.index, e), e[t.last].classList.remove("is-active"), e[t.index].classList.add("is-active")
                    }

                    clamp() {
                        var t = this.state;
                        t.target = xn.utils.clamp(0, t.max, t.target)
                    }

                    removeEvents() {
                        var {prev: t, next: e, btn: i} = this.ui;
                        Vn.off(Da.TICK, this.run), Vn.off(wa.RESIZE, this.resize), Vn.off(Ma.DOWN, this.down), Vn.off(Ma.MOVE, this.move), Vn.off(Ma.UP, this.up), i.removeEventListener("click", this.toggle), t.removeEventListener("click", this.prev), e.removeEventListener("click", this.next)
                    }

                    destroy() {
                        this.removeEvents(), this.state = null, this.opts = null, this.ui = null
                    }
                })
            }

            initVimeo() {
                var t = this.el.querySelectorAll(".js-vimeo");
                t && (this.vimeo = [], t.forEach((t => {
                    var e = new hh(t);
                    this.vimeo.push(e)
                })))
            }

            heroHeightMobile() {
                var t = this.el.querySelector(".js-hero");
                t && (n.isLandscape || n.isPhone) && (t.style.height = "".concat(n.height, "px"))
            }

            initDraggableSlider() {
                this.slider = new dh
            }

            initFlight() {
                var t = this.el.querySelector(".js-flight");
                t && (this.flight = new class {
                    constructor(t) {
                        mh(this, "enter", (t => {
                            var {currentTarget: e} = t;
                            this.last = this.current, this.current = [...this.circles].indexOf(e), this.animate()
                        })), mh(this, "leave", (() => {
                            this.locs[this.current].classList.remove("is-active")
                        })), mh(this, "next", (() => {
                            this.last = this.current, this.current = xn.utils.wrap(0, this.total, this.current + 1), this.animate()
                        })), mh(this, "prev", (() => {
                            this.last = this.current, this.current = xn.utils.wrap(0, this.total, this.current - 1), this.animate()
                        })), this.el = t, this.paths = mo(".js-flight-line path", this.el), this.marker = mo(".js-flight-marker path", this.el), this.markerDot = fo(".js-flight-marker circle", this.el), this.circles = mo(".js-flight-circles circle", this.el), this.locs = [...mo(".js-flight-loc", this.el)], this.label = fo(".js-flight-label", this.el), this.nav = {
                            prev: fo(".js-prev", this.el),
                            next: fo(".js-next", this.el)
                        }, this.last = 0, this.current = 0, this.total = this.locs.length, this.init()
                    }

                    init() {
                        xn.set("#drawIt", {drawSVG: "0 100%"}), this.circles.forEach((t => xn.set(t, {scale: 0}))), this.marker.forEach((t => xn.set(t, {
                            y: 10,
                            alpha: 0
                        }))), this.setCache(), this.addEvents()
                    }

                    setCache() {
                        this.cache = [];
                        var t = this.el.getBoundingClientRect();
                        this.circles.forEach(((e, i) => {
                            var n = e.getBoundingClientRect(), r = n.left - t.left + n.width / 2,
                                s = n.top - t.top + 3 * n.height, a = this.locs[i];
                            e.addEventListener("mouseenter", this.enter), e.addEventListener("mouseleave", this.leave), this.cache.push({
                                loc: a,
                                left: r,
                                top: s,
                                rect: n
                            })
                        }))
                    }

                    animations() {
                        this.tl = xn.timeline({
                            paused: !0,
                            scrollTrigger: {trigger: this.el, start: "top 50%", end: "top top"}
                        }), this.tl.to("#drawIt", {
                            drawSVG: "100% 0",
                            ease: "power3.inOut",
                            duration: 2
                        }, 0), this.marker.forEach((t => {
                            this.tl.to(t, {y: 0, alpha: 1, ease: "elastic", duration: 2}, 1)
                        })), this.tl.fromTo(this.markerDot, {scale: 0}, {
                            scale: 1,
                            ease: "elastic",
                            duration: 2
                        }, 1), this.tl.fromTo(this.label, {alpha: 0}, {
                            alpha: 1,
                            ease: "power3.inOut",
                            duration: 1
                        }, 1), this.circles.forEach((t => {
                            this.tl.to(t, {scale: 1, ease: "elastic", duration: 2}, .5)
                        })), this.tl.fromTo("#drawIt", {drawSVG: "100% 100%"}, {
                            drawSVG: "0% 100%",
                            ease: "power3.inOut",
                            duration: 3,
                            repeat: -1,
                            repeatDelay: 2,
                            stagger: 0
                        }, 4)
                    }

                    animate() {
                        this.locs[this.last].classList.remove("is-active"), this.locs[this.current].classList.add("is-active")
                    }

                    addEvents() {
                        this.animations(), this.cache.forEach((t => {
                            var {loc: e, left: i, top: n} = t;
                            e && xn.set(e, {top: n, left: i})
                        }))
                    }

                    destroy() {
                    }
                }(t))
            }

            initMap() {
                var t = this.el.querySelector(".js-map");
                t && (this.map = new class {
                    constructor(t) {
                        gh(this, "pipClick", (t => {
                            var {currentTarget: e} = t;
                            if (!this.animating) {
                                var i = this.ui.pips.indexOf(e);
                                i !== this.current && (this.last = this.current, this.current = i, this.animate())
                            }
                        })), gh(this, "clickPrev", (() => {
                            this.animating || (this.last = this.current, this.current = 0 === this.current ? this.total : this.current - 1, this.animate())
                        })), gh(this, "clickNext", (() => {
                            this.animating || (this.last = this.current, this.current = this.current === this.total ? 0 : this.current + 1, this.animate())
                        })), gh(this, "animate", (() => {
                            this.animating = !0, this.z += 1;
                            var t = this.cache[this.last], e = this.cache[this.current];
                            this.tl.clear(), this.isOpen ? this.tl.to(this.ui.bg, {
                                x: xn.utils.clamp(-this.max, 0, -e.offset),
                                duration: 1,
                                ease: "power3.inOut"
                            }, 0) : (this.isOpen = !0, this.tl.set(".js-map-content", {autoAlpha: 1}).fromTo(".js-map-mask", {xPercent: xn.utils.wrap([100, -100])}, {
                                xPercent: 0,
                                duration: 1,
                                ease: "power3.inOut"
                            }, 0)), this.tl.set([e.el, e.img], {autoAlpha: 1}, 0), t && this.tl.to(t.items, {
                                alpha: 0,
                                y: "-2rem",
                                duration: .5,
                                stagger: .1,
                                ease: "power2.inOut"
                            }, 0), this.tl.set(e.img, {zIndex: this.z}, 0).fromTo(e.items, {
                                alpha: 0,
                                y: "2rem"
                            }, {
                                alpha: 1,
                                y: 0,
                                duration: .85,
                                stagger: .1,
                                ease: "expo"
                            }, .5).fromTo([e.img, e.imgInner], {xPercent: xn.utils.wrap([100, -100])}, {
                                xPercent: 0,
                                duration: .85,
                                ease: "power3.inOut"
                            }, .25), t && this.tl.set([t.el, t.img], {autoAlpha: 0}), this.tl.add((() => {
                                this.animating = !1
                            })).restart(), this.toggleBullets()
                        })), gh(this, "close", (() => {
                            this.animating = !0, this.last = -1, this.current = 0;
                            var {pips: t, bullets: e} = this.ui;
                            this.tl.clear().to(".js-map-mask", {
                                xPercent: xn.utils.wrap([100, -100]),
                                duration: 1,
                                ease: "power3.inOut"
                            }).set([".js-map-content", ".js-map-loc"], {autoAlpha: 0}).add((() => {
                                e.forEach((t => t.classList.remove("is-active"))), t.forEach((t => t.classList.remove("is-active"))), this.animating = !1, this.isOpen = !1
                            })).play()
                        })), this.el = t, this.ui = {
                            pips: [...mo(".js-map-pip")],
                            locs: [...mo(".js-map-loc")],
                            prev: fo(".js-prev", this.el),
                            next: fo(".js-next", this.el),
                            bullets: mo(".js-pip", this.el),
                            close: fo(".js-map-close"),
                            bg: fo(".js-map-bg", this.el)
                        }, this.last = -1, this.current = 0, this.total = this.ui.locs.length - 1, this.z = this.total + 1, this.animating = !1, this.isOpen = !1, this.tl = xn.timeline({paused: !0}), this.init()
                    }

                    init() {
                        this.setCache(), this.addEvents()
                    }

                    addEvents() {
                        var {pips: t, prev: e, next: i, close: n} = this.ui;
                        t.forEach((t => t.addEventListener("click", this.pipClick))), e.addEventListener("click", this.clickPrev), i.addEventListener("click", this.clickNext), n.addEventListener("click", this.close), Vn.on("map:animate", this.animate)
                    }

                    setCache() {
                        var t = mo(".js-map-loc-img"), e = this.ui.bg.parentNode.getBoundingClientRect().width;
                        this.max = this.ui.bg.getBoundingClientRect().width - e, this.cache = this.ui.locs.map(((i, n) => {
                            var r = mo(".js-s", i), s = t[n], a = fo(".js-map-loc-img__inner", s), {
                                left: o,
                                width: h
                            } = this.ui.pips[n].getBoundingClientRect(), l = o - h / 2 - e / 2;
                            return 0 !== n && xn.set(i, {autoAlpha: 0}), {
                                el: i,
                                items: r,
                                img: s,
                                imgInner: a,
                                offset: l
                            }
                        }))
                    }

                    toggleBullets() {
                        var {bullets: t, pips: e} = this.ui;
                        this.last > -1 && t[this.last].classList.remove("is-active"), t[this.current].classList.add("is-active"), this.last > -1 && e[this.last].classList.remove("is-active"), e[this.current].classList.add("is-active")
                    }

                    removeEvents() {
                    }

                    destroy() {
                    }
                }(t))
            }

            initDisclaimer() {
                var t = this.el.querySelector(".js-s-foot");
                t && (this.disclaimer = new class {
                    constructor(t) {
                        this.init()
                    }

                    init() {
                        var t = fo(".js-s-foot");
                        t && xn.from(t, {
                            scrollTrigger: {trigger: t.parentNode, scrub: !0, end: "bottom bottom"},
                            yPercent: -60,
                            ease: "none"
                        })
                    }
                }(t))
            }

            initGlobe() {
                var t = this.el.querySelector("#globekit-canvas");
                t && (this.globe = new Mf(t))
            }

            initBtns() {
                var t = this.el.querySelectorAll(".js-g-btn");
                t.length && (this.btns = [...t].map((t => new class {
                    constructor(t) {
                        Af(this, "enter", (() => {
                            this.bounds(), this.active = !0, this.tl.isActive() && Vn.off(Da.TICK, this.run), Vn.on(Da.TICK, this.run), this.tl.clear().to(this.texts[0], {
                                yPercent: -100,
                                duration: .35,
                                ease: "power2.inOut"
                            }).to(this.arrows[0], {
                                xPercent: 100,
                                duration: .35,
                                ease: "power2.inOut"
                            }, 0).to(this.texts[1], {
                                yPercent: -100,
                                duration: .75,
                                ease: "expo"
                            }, .15).to(this.arrows[1], {
                                xPercent: 100,
                                duration: 1,
                                ease: "expo"
                            }, .15).to(this.mask, {alpha: .85, duration: 1, ease: "power1"}, 0).play()
                        })), Af(this, "leave", (() => {
                            this.tl.clear().to(this.texts[1], {
                                yPercent: 0,
                                duration: .35,
                                ease: "power2.inOut"
                            }).to(this.arrows[1], {
                                xPercent: 0,
                                duration: .35,
                                ease: "power2.inOut"
                            }, 0).to(this.texts[0], {
                                yPercent: 0,
                                duration: .75,
                                ease: "expo"
                            }, .15).to(this.arrows[0], {
                                xPercent: 0,
                                duration: 1,
                                ease: "expo"
                            }, .15).to(this.mask, {alpha: 0, duration: 1, ease: "power1"}, 0).add((() => {
                                this.active = !1, Vn.off(Da.TICK, this.run)
                            })).play()
                        })), Af(this, "run", (t => {
                            var {mouse: e} = t;
                            this.m = e.rounded;
                            var i = this.m.x + this.x, n = this.m.y - this.y;
                            this.el.style.setProperty("--pos-x", "".concat(i, "px")), this.el.style.setProperty("--pos-y", "".concat(n, "px"))
                        })), this.el = t, this.mask = fo(".js-g-mask", this.el), this.texts = mo(".js-g-txt", this.el), this.arrows = mo(".js-g-arr", this.el), this.x = 0, this.y = 0, this.el.addEventListener("mouseenter", this.enter), this.el.addEventListener("mouseleave", this.leave), this.tl = xn.timeline({paused: !0}), this.bounds()
                    }

                    bounds() {
                        var {left: t, top: e} = this.el.getBoundingClientRect();
                        this.x = -t, this.y = e
                    }

                    destroy() {
                        this.el.removeEventListener("mouseenter", this.enter), this.el.removeEventListener("mouseleave", this.leave), this.tl.kill(), this.active && Vn.off(Da.TICK, this.run)
                    }
                }(t))))
            }

            destroy() {
                if (this.scrollAnimations && this.scrollAnimations.destroy(), this.lazyLoad && this.lazyLoad.destroy(), this.smooth && this.smooth.destroy(), this.parallax && this.parallax.destroy(), this.draggable && this.draggable.destroy(), this.ps && this.ps.destroy(), this.galleries && this.galleries.forEach((t => {
                    t.destroy(), this.galleries.pop()
                })), this.lb && this.lb.destroy(), this.flight && this.flight.destroy(), this.triggered && this.triggered.destroy(), this.btns && this.btns.forEach((t => t.destroy())), this.globe && this.globe.destroy(), this.gm && this.gm.destroy(), this.vimeo) for (var t = this.vimeo.length, e = 0; e < t; e++) {
                    var i = this.vimeo[e];
                    i.destroy(), i = null, e === t && (this.vimeo = null)
                }
            }
        }

        const Rf = Lf;
        const Ff = class extends Rf {
            onEnter() {
                super.onEnter()
            }

            onLeave() {
                super.onLeave()
            }

            onEnterCompleted() {
                super.onEnterCompleted(), this.homeSlider = new Do({
                    el: document.querySelector(".js-home-slider"),
                    navigation: !0,
                    bullets: !0
                }), this.lottieAnis = new class {
                    constructor() {
                        var t, e, i;
                        i = t => {
                            t.forEach((t => {
                                if (t.isIntersecting) {
                                    var e = this.elems.indexOf(t.target), i = this.animations[e];
                                    i.isIntersected = !0, i.animation.play(), this.stillObserving() ? this.observer.unobserve(t.target) : this.observer.disconnect()
                                }
                            }))
                        }, (e = "handler") in (t = this) ? Object.defineProperty(t, e, {
                            value: i,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : t[e] = i, this.el = n.body, this.elems = [...document.querySelectorAll(".js-bm")], this.animations = null, this.options = null, this.observer = null, this.init()
                    }

                    createObserver() {
                        this.observer = new IntersectionObserver(this.handler, {
                            root: null,
                            rootMargin: "0px 0px -30% 0px",
                            threshold: [0, 0]
                        })
                    }

                    setAnimations() {
                        this.animations = [], this.elems.forEach((t => {
                            this.animations.push({
                                animation: Ja().loadAnimation({
                                    container: t,
                                    renderer: "svg",
                                    loop: !1,
                                    autoplay: !1,
                                    path: "/static/lottie/".concat(t.dataset.name, "/data.json")
                                }), isIntersected: !1
                            })
                        }))
                    }

                    stillObserving() {
                        return this.animations.some((t => !t.isIntersected))
                    }

                    destroy() {
                        this.animations.forEach((t => t.animation.destroy())), this.observer.disconnect(), this.observer = null, this.elems = null
                    }

                    run() {
                        this.elems.forEach((t => this.observer.observe(t)))
                    }

                    init() {
                        this.setAnimations(), this.createObserver(), this.run()
                    }
                }
            }

            onLeaveCompleted() {
                super.onLeaveCompleted(), this.homeSlider && this.homeSlider.destroy()
            }
        };

        function kf(t, e, i, n, r, s, a) {
            try {
                var o = t[s](a), h = o.value
            } catch (t) {
                return void i(t)
            }
            o.done ? e(h) : Promise.resolve(h).then(n, r)
        }

        function Of(t) {
            return function () {
                var e = this, i = arguments;
                return new Promise((function (n, r) {
                    var s = t.apply(e, i);

                    function a(t) {
                        kf(s, n, r, a, o, "next", t)
                    }

                    function o(t) {
                        kf(s, n, r, a, o, "throw", t)
                    }

                    a(void 0)
                }))
            }
        }

        function zf(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }

        const Bf = class {
            constructor() {
                zf(this, "open", (t => {
                    var {triggers: e, title: i, sliders: r} = this.ui, s = [].slice.call(e).indexOf(t.target, 0);
                    n.isLightbox = !0, this.loadImages(s), i.textContent = r[s].dataset.lbTitle, xn.to(this.el, {
                        duration: .5,
                        autoAlpha: 1,
                        ease: "power1"
                    }), Pa.state.isUp && Pa.close()
                })), zf(this, "close", (() => {
                    var {wrapper: t, title: e, pips: i} = this.ui;
                    xn.to(this.el, {
                        duration: .5, autoAlpha: 0, ease: "power1", onComplete: () => {
                            this.draggable.destroy(), this.draggable = null, this.slides.forEach((e => {
                                t.removeChild(e)
                            })), e.textContent = "", i.textContent = "", n.isLightbox = !1
                        }
                    })
                })), this.el = document.querySelector(".js-lb"), this.ui = {
                    title: this.el.querySelector(".js-lb__title"),
                    wrapper: this.el.querySelector(".js-lb__wrapper"),
                    sliders: document.querySelectorAll(".js-listing-has-lb"),
                    triggers: document.querySelectorAll(".js-lb-open"),
                    pips: this.el.querySelector(".js-pips"),
                    close: this.el.querySelector(".js-lb__close")
                }, this.draggable = null, this.init()
            }

            loadImage(t, e) {
                return new Promise((e => {
                    var i = document.createElement("img");
                    Eo(i, "a", "load", (i => e(t))), i.src = t, this.slides.push(i)
                }))
            }

            loadImages(t) {
                var e = this;
                return Of((function* () {
                    e.el.classList.add("is-loading"), e.slides = null, e.slides = [];
                    var i = JSON.parse(e.ui.sliders[t].dataset.lbImages), n = i.map(function () {
                        var t = Of((function* (t) {
                            var n = i.indexOf(t, 0);
                            yield e.loadImage(t, n)
                        }));
                        return function (e) {
                            return t.apply(this, arguments)
                        }
                    }());
                    return yield Promise.all(n), e.createSlider()
                }))()
            }

            createSlider() {
                var t = this.slides.length - 1;
                this.el.classList.remove("is-loading"), this.slides.forEach(((e, i) => {
                    this.ui.wrapper.appendChild(e), this.createBullet(i), e.style.left = "".concat(100 * i, "%"), e.draggable = !1, e.classList.add("js-drag-item"), i === t && (this.draggable = new Ao({
                        el: this.el,
                        bullets: !0,
                        navigation: !0
                    }))
                }))
            }

            createBullet(t) {
                var e = document.createElement("div");
                e.classList.add("c-pips-pip", "js-pip"), 0 === t && e.classList.add("is-active"), this.ui.pips.appendChild(e)
            }

            on() {
                var {triggers: t, close: e} = this.ui;
                t.forEach((t => {
                    Eo(t, "a", "click", this.open)
                })), Eo(e, "a", "click", this.close)
            }

            off() {
                var {triggers: t, close: e} = this.ui;
                t.forEach((t => {
                    Eo(t, "r", "click", this.open)
                })), Eo(e, "r", "click", this.close)
            }

            destroy() {
                this.off(), this.draggable && (this.draggable.destroy(), this.draggable = null)
            }

            init() {
                this.on()
            }
        };
        const Nf = class {
            constructor(t, e) {
                var i, n, r;
                r = () => {
                    this.isAnimating || (this.isAnimating = !0, this.isOpen ? (this.isOpen = !1, this.close()) : (this.isOpen = !0, this.open()))
                }, (n = "toggle") in (i = this) ? Object.defineProperty(i, n, {
                    value: r,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : i[n] = r, this.el = t, this.smooth = e, this.btn = this.el.querySelector(".js-pushdown__toggle"), this.content = this.el.querySelector(".js-pushdown__content"), this.isOpen = !1, this.isAnimating = !1, this.init()
            }

            open() {
                this.el.classList.add("is-active"), xn.set(this.content, {
                    height: "auto",
                    alpha: 1
                }), xn.from(this.content, {
                    duration: 1.1, height: 0, alpha: 0, ease: "power3.inOut", onComplete: () => {
                        this.isAnimating = !1, n.isSmooth && (Ta.setMaxHeight(), this.smooth.onResize())
                    }
                })
            }

            close() {
                this.el.classList.remove("is-active"), xn.to(this.content, {
                    duration: 1.1,
                    height: 0,
                    alpha: 0,
                    ease: "power3.inOut",
                    onComplete: () => {
                        this.isAnimating = !1, n.isSmooth && (Ta.setMaxHeight(), this.smooth.onResize())
                    }
                })
            }

            on() {
                Eo(this.btn, "a", "click", this.toggle)
            }

            off() {
                Eo(this.btn, "r", "click", this.toggle)
            }

            destroy() {
                this.off(), this.isOpen = this.isAnimating = null, this.smooth = null
            }

            init() {
                this.on()
            }
        };
        const jf = class extends Rf {
            onEnter() {
                super.onEnter()
            }

            onLeave() {
                super.onLeave()
            }

            onEnterCompleted() {
                super.onEnterCompleted(), this.initSliders(), this.initPushdowns(), this.lightbox = new Bf
            }

            onLeaveCompleted() {
                super.onLeaveCompleted(), this.sliders && this.sliders.forEach((t => {
                    t.destroy(), this.sliders.pop()
                })), this.pushdowns && this.pushdowns.forEach((t => {
                    t.destroy(), this.pushdowns.pop()
                })), this.lightbox.destroy()
            }

            initSliders() {
                var t = this.el.querySelectorAll(".js-listing-slider");
                t && (this.sliders = [], t.forEach((t => {
                    var e = new Ao({el: t, bullets: !0});
                    this.sliders.push(e)
                })))
            }

            initPushdowns() {
                var t = this.el.querySelectorAll(".js-pushdown");
                t && (this.pushdowns = [], t.forEach((t => {
                    var e = new Nf(t, this.smooth);
                    this.pushdowns.push(e)
                })))
            }
        };

        function Vf() {
        }

        void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function (t) {
            return "number" == typeof t && isFinite(t) && Math.floor(t) === t
        }), void 0 === Math.sign && (Math.sign = function (t) {
            return t < 0 ? -1 : t > 0 ? 1 : +t
        }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
            get: function () {
                return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
            }
        }), void 0 === Object.assign && (Object.assign = function (t) {
            if (null == t) throw new TypeError("Cannot convert undefined or null to object");
            for (var e = Object(t), i = 1; i < arguments.length; i++) {
                var n = arguments[i];
                if (null != n) for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
            }
            return e
        }), Object.assign(Vf.prototype, {
            addEventListener: function (t, e) {
                void 0 === this._listeners && (this._listeners = {});
                var i = this._listeners;
                void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e)
            }, hasEventListener: function (t, e) {
                if (void 0 === this._listeners) return !1;
                var i = this._listeners;
                return void 0 !== i[t] && -1 !== i[t].indexOf(e)
            }, removeEventListener: function (t, e) {
                if (void 0 !== this._listeners) {
                    var i = this._listeners[t];
                    if (void 0 !== i) {
                        var n = i.indexOf(e);
                        -1 !== n && i.splice(n, 1)
                    }
                }
            }, dispatchEvent: function (t) {
                if (void 0 !== this._listeners) {
                    var e = this._listeners[t.type];
                    if (void 0 !== e) {
                        t.target = this;
                        for (var i = e.slice(0), n = 0, r = i.length; n < r; n++) i[n].call(this, t)
                    }
                }
            }
        });
        var Gf, Uf, Hf, Wf = 0, qf = 1, Xf = 2, Yf = 100, Zf = 1e3, Jf = 1001, Qf = 1002, Kf = 1003, $f = 1004,
            tm = 1005, em = 1006, im = 1008, nm = 1009, rm = 1012, sm = 1015, am = 1016, om = 1020, hm = 1022,
            lm = 1023, cm = 1026, um = 1027, pm = 2300, dm = 2301, fm = 2302, mm = 2400, gm = 2401, vm = 2402, ym = 3e3,
            bm = {
                DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function () {
                    for (var t = [], e = 0; e < 256; e++) t[e] = (e < 16 ? "0" : "") + e.toString(16);
                    return function () {
                        var e = 4294967295 * Math.random() | 0, i = 4294967295 * Math.random() | 0,
                            n = 4294967295 * Math.random() | 0, r = 4294967295 * Math.random() | 0;
                        return (t[255 & e] + t[e >> 8 & 255] + t[e >> 16 & 255] + t[e >> 24 & 255] + "-" + t[255 & i] + t[i >> 8 & 255] + "-" + t[i >> 16 & 15 | 64] + t[i >> 24 & 255] + "-" + t[63 & n | 128] + t[n >> 8 & 255] + "-" + t[n >> 16 & 255] + t[n >> 24 & 255] + t[255 & r] + t[r >> 8 & 255] + t[r >> 16 & 255] + t[r >> 24 & 255]).toUpperCase()
                    }
                }(), clamp: function (t, e, i) {
                    return Math.max(e, Math.min(i, t))
                }, euclideanModulo: function (t, e) {
                    return (t % e + e) % e
                }, mapLinear: function (t, e, i, n, r) {
                    return n + (t - e) * (r - n) / (i - e)
                }, lerp: function (t, e, i) {
                    return (1 - i) * t + i * e
                }, smoothstep: function (t, e, i) {
                    return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t)
                }, smootherstep: function (t, e, i) {
                    return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10)
                }, randInt: function (t, e) {
                    return t + Math.floor(Math.random() * (e - t + 1))
                }, randFloat: function (t, e) {
                    return t + Math.random() * (e - t)
                }, randFloatSpread: function (t) {
                    return t * (.5 - Math.random())
                }, degToRad: function (t) {
                    return t * bm.DEG2RAD
                }, radToDeg: function (t) {
                    return t * bm.RAD2DEG
                }, isPowerOfTwo: function (t) {
                    return 0 == (t & t - 1) && 0 !== t
                }, ceilPowerOfTwo: function (t) {
                    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
                }, floorPowerOfTwo: function (t) {
                    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                }
            };

        function xm(t, e) {
            this.x = t || 0, this.y = e || 0
        }

        function wm(t, e, i, n) {
            this._x = t || 0, this._y = e || 0, this._z = i || 0, this._w = void 0 !== n ? n : 1
        }

        function _m(t, e, i) {
            this.x = t || 0, this.y = e || 0, this.z = i || 0
        }

        function Em() {
            this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
        }

        Object.defineProperties(xm.prototype, {
            width: {
                get: function () {
                    return this.x
                }, set: function (t) {
                    this.x = t
                }
            }, height: {
                get: function () {
                    return this.y
                }, set: function (t) {
                    this.y = t
                }
            }
        }), Object.assign(xm.prototype, {
            isVector2: !0, set: function (t, e) {
                return this.x = t, this.y = e, this
            }, setScalar: function (t) {
                return this.x = t, this.y = t, this
            }, setX: function (t) {
                return this.x = t, this
            }, setY: function (t) {
                return this.y = t, this
            }, setComponent: function (t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }, getComponent: function (t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }, clone: function () {
                return new this.constructor(this.x, this.y)
            }, copy: function (t) {
                return this.x = t.x, this.y = t.y, this
            }, add: function (t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
            }, addScalar: function (t) {
                return this.x += t, this.y += t, this
            }, addVectors: function (t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this
            }, addScaledVector: function (t, e) {
                return this.x += t.x * e, this.y += t.y * e, this
            }, sub: function (t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
            }, subScalar: function (t) {
                return this.x -= t, this.y -= t, this
            }, subVectors: function (t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this
            }, multiply: function (t) {
                return this.x *= t.x, this.y *= t.y, this
            }, multiplyScalar: function (t) {
                return this.x *= t, this.y *= t, this
            }, divide: function (t) {
                return this.x /= t.x, this.y /= t.y, this
            }, divideScalar: function (t) {
                return this.multiplyScalar(1 / t)
            }, applyMatrix3: function (t) {
                var e = this.x, i = this.y, n = t.elements;
                return this.x = n[0] * e + n[3] * i + n[6], this.y = n[1] * e + n[4] * i + n[7], this
            }, min: function (t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
            }, max: function (t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
            }, clamp: function (t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
            }, clampScalar: function (t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
            }, clampLength: function (t, e) {
                var i = this.length();
                return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
            }, floor: function () {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            }, ceil: function () {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
            }, round: function () {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            }, roundToZero: function () {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
            }, negate: function () {
                return this.x = -this.x, this.y = -this.y, this
            }, dot: function (t) {
                return this.x * t.x + this.y * t.y
            }, cross: function (t) {
                return this.x * t.y - this.y * t.x
            }, lengthSq: function () {
                return this.x * this.x + this.y * this.y
            }, length: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }, manhattanLength: function () {
                return Math.abs(this.x) + Math.abs(this.y)
            }, normalize: function () {
                return this.divideScalar(this.length() || 1)
            }, angle: function () {
                var t = Math.atan2(this.y, this.x);
                return t < 0 && (t += 2 * Math.PI), t
            }, distanceTo: function (t) {
                return Math.sqrt(this.distanceToSquared(t))
            }, distanceToSquared: function (t) {
                var e = this.x - t.x, i = this.y - t.y;
                return e * e + i * i
            }, manhattanDistanceTo: function (t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
            }, setLength: function (t) {
                return this.normalize().multiplyScalar(t)
            }, lerp: function (t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
            }, lerpVectors: function (t, e, i) {
                return this.subVectors(e, t).multiplyScalar(i).add(t)
            }, equals: function (t) {
                return t.x === this.x && t.y === this.y
            }, fromArray: function (t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
            }, toArray: function (t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
            }, fromBufferAttribute: function (t, e, i) {
                return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
            }, rotateAround: function (t, e) {
                var i = Math.cos(e), n = Math.sin(e), r = this.x - t.x, s = this.y - t.y;
                return this.x = r * i - s * n + t.x, this.y = r * n + s * i + t.y, this
            }
        }), Object.assign(wm, {
            slerp: function (t, e, i, n) {
                return i.copy(t).slerp(e, n)
            }, slerpFlat: function (t, e, i, n, r, s, a) {
                var o = i[n + 0], h = i[n + 1], l = i[n + 2], c = i[n + 3], u = r[s + 0], p = r[s + 1], d = r[s + 2],
                    f = r[s + 3];
                if (c !== f || o !== u || h !== p || l !== d) {
                    var m = 1 - a, g = o * u + h * p + l * d + c * f, v = g >= 0 ? 1 : -1, y = 1 - g * g;
                    if (y > Number.EPSILON) {
                        var b = Math.sqrt(y), x = Math.atan2(b, g * v);
                        m = Math.sin(m * x) / b, a = Math.sin(a * x) / b
                    }
                    var w = a * v;
                    if (o = o * m + u * w, h = h * m + p * w, l = l * m + d * w, c = c * m + f * w, m === 1 - a) {
                        var _ = 1 / Math.sqrt(o * o + h * h + l * l + c * c);
                        o *= _, h *= _, l *= _, c *= _
                    }
                }
                t[e] = o, t[e + 1] = h, t[e + 2] = l, t[e + 3] = c
            }
        }), Object.defineProperties(wm.prototype, {
            x: {
                get: function () {
                    return this._x
                }, set: function (t) {
                    this._x = t, this.onChangeCallback()
                }
            }, y: {
                get: function () {
                    return this._y
                }, set: function (t) {
                    this._y = t, this.onChangeCallback()
                }
            }, z: {
                get: function () {
                    return this._z
                }, set: function (t) {
                    this._z = t, this.onChangeCallback()
                }
            }, w: {
                get: function () {
                    return this._w
                }, set: function (t) {
                    this._w = t, this.onChangeCallback()
                }
            }
        }), Object.assign(wm.prototype, {
            isQuaternion: !0, set: function (t, e, i, n) {
                return this._x = t, this._y = e, this._z = i, this._w = n, this.onChangeCallback(), this
            }, clone: function () {
                return new this.constructor(this._x, this._y, this._z, this._w)
            }, copy: function (t) {
                return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this
            }, setFromEuler: function (t, e) {
                if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                var i = t._x, n = t._y, r = t._z, s = t.order, a = Math.cos, o = Math.sin, h = a(i / 2), l = a(n / 2),
                    c = a(r / 2), u = o(i / 2), p = o(n / 2), d = o(r / 2);
                return "XYZ" === s ? (this._x = u * l * c + h * p * d, this._y = h * p * c - u * l * d, this._z = h * l * d + u * p * c, this._w = h * l * c - u * p * d) : "YXZ" === s ? (this._x = u * l * c + h * p * d, this._y = h * p * c - u * l * d, this._z = h * l * d - u * p * c, this._w = h * l * c + u * p * d) : "ZXY" === s ? (this._x = u * l * c - h * p * d, this._y = h * p * c + u * l * d, this._z = h * l * d + u * p * c, this._w = h * l * c - u * p * d) : "ZYX" === s ? (this._x = u * l * c - h * p * d, this._y = h * p * c + u * l * d, this._z = h * l * d - u * p * c, this._w = h * l * c + u * p * d) : "YZX" === s ? (this._x = u * l * c + h * p * d, this._y = h * p * c + u * l * d, this._z = h * l * d - u * p * c, this._w = h * l * c - u * p * d) : "XZY" === s && (this._x = u * l * c - h * p * d, this._y = h * p * c - u * l * d, this._z = h * l * d + u * p * c, this._w = h * l * c + u * p * d), !1 !== e && this.onChangeCallback(), this
            }, setFromAxisAngle: function (t, e) {
                var i = e / 2, n = Math.sin(i);
                return this._x = t.x * n, this._y = t.y * n, this._z = t.z * n, this._w = Math.cos(i), this.onChangeCallback(), this
            }, setFromRotationMatrix: function (t) {
                var e, i = t.elements, n = i[0], r = i[4], s = i[8], a = i[1], o = i[5], h = i[9], l = i[2], c = i[6],
                    u = i[10], p = n + o + u;
                return p > 0 ? (e = .5 / Math.sqrt(p + 1), this._w = .25 / e, this._x = (c - h) * e, this._y = (s - l) * e, this._z = (a - r) * e) : n > o && n > u ? (e = 2 * Math.sqrt(1 + n - o - u), this._w = (c - h) / e, this._x = .25 * e, this._y = (r + a) / e, this._z = (s + l) / e) : o > u ? (e = 2 * Math.sqrt(1 + o - n - u), this._w = (s - l) / e, this._x = (r + a) / e, this._y = .25 * e, this._z = (h + c) / e) : (e = 2 * Math.sqrt(1 + u - n - o), this._w = (a - r) / e, this._x = (s + l) / e, this._y = (h + c) / e, this._z = .25 * e), this.onChangeCallback(), this
            }, setFromUnitVectors: function (t, e) {
                var i = t.dot(e) + 1;
                return i < 1e-6 ? (i = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = i)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = i), this.normalize()
            }, angleTo: function (t) {
                return 2 * Math.acos(Math.abs(bm.clamp(this.dot(t), -1, 1)))
            }, rotateTowards: function (t, e) {
                var i = this.angleTo(t);
                if (0 === i) return this;
                var n = Math.min(1, e / i);
                return this.slerp(t, n), this
            }, inverse: function () {
                return this.conjugate()
            }, conjugate: function () {
                return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
            }, dot: function (t) {
                return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            }, lengthSq: function () {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }, length: function () {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }, normalize: function () {
                var t = this.length();
                return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this.onChangeCallback(), this
            }, multiply: function (t, e) {
                return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
            }, premultiply: function (t) {
                return this.multiplyQuaternions(t, this)
            }, multiplyQuaternions: function (t, e) {
                var i = t._x, n = t._y, r = t._z, s = t._w, a = e._x, o = e._y, h = e._z, l = e._w;
                return this._x = i * l + s * a + n * h - r * o, this._y = n * l + s * o + r * a - i * h, this._z = r * l + s * h + i * o - n * a, this._w = s * l - i * a - n * o - r * h, this.onChangeCallback(), this
            }, slerp: function (t, e) {
                if (0 === e) return this;
                if (1 === e) return this.copy(t);
                var i = this._x, n = this._y, r = this._z, s = this._w, a = s * t._w + i * t._x + n * t._y + r * t._z;
                if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = s, this._x = i, this._y = n, this._z = r, this;
                var o = 1 - a * a;
                if (o <= Number.EPSILON) {
                    var h = 1 - e;
                    return this._w = h * s + e * this._w, this._x = h * i + e * this._x, this._y = h * n + e * this._y, this._z = h * r + e * this._z, this.normalize()
                }
                var l = Math.sqrt(o), c = Math.atan2(l, a), u = Math.sin((1 - e) * c) / l, p = Math.sin(e * c) / l;
                return this._w = s * u + this._w * p, this._x = i * u + this._x * p, this._y = n * u + this._y * p, this._z = r * u + this._z * p, this.onChangeCallback(), this
            }, equals: function (t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
            }, fromArray: function (t, e) {
                return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this
            }, toArray: function (t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
            }, onChange: function (t) {
                return this.onChangeCallback = t, this
            }, onChangeCallback: function () {
            }
        }), Object.assign(_m.prototype, {
            isVector3: !0, set: function (t, e, i) {
                return this.x = t, this.y = e, this.z = i, this
            }, setScalar: function (t) {
                return this.x = t, this.y = t, this.z = t, this
            }, setX: function (t) {
                return this.x = t, this
            }, setY: function (t) {
                return this.y = t, this
            }, setZ: function (t) {
                return this.z = t, this
            }, setComponent: function (t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }, getComponent: function (t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }, clone: function () {
                return new this.constructor(this.x, this.y, this.z)
            }, copy: function (t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this
            }, add: function (t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
            }, addScalar: function (t) {
                return this.x += t, this.y += t, this.z += t, this
            }, addVectors: function (t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
            }, addScaledVector: function (t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
            }, sub: function (t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
            }, subScalar: function (t) {
                return this.x -= t, this.y -= t, this.z -= t, this
            }, subVectors: function (t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
            }, multiply: function (t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
            }, multiplyScalar: function (t) {
                return this.x *= t, this.y *= t, this.z *= t, this
            }, multiplyVectors: function (t, e) {
                return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
            }, applyEuler: (Uf = new wm, function (t) {
                return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Uf.setFromEuler(t))
            }), applyAxisAngle: function () {
                var t = new wm;
                return function (e, i) {
                    return this.applyQuaternion(t.setFromAxisAngle(e, i))
                }
            }(), applyMatrix3: function (t) {
                var e = this.x, i = this.y, n = this.z, r = t.elements;
                return this.x = r[0] * e + r[3] * i + r[6] * n, this.y = r[1] * e + r[4] * i + r[7] * n, this.z = r[2] * e + r[5] * i + r[8] * n, this
            }, applyMatrix4: function (t) {
                var e = this.x, i = this.y, n = this.z, r = t.elements,
                    s = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
                return this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * s, this.y = (r[1] * e + r[5] * i + r[9] * n + r[13]) * s, this.z = (r[2] * e + r[6] * i + r[10] * n + r[14]) * s, this
            }, applyQuaternion: function (t) {
                var e = this.x, i = this.y, n = this.z, r = t.x, s = t.y, a = t.z, o = t.w, h = o * e + s * n - a * i,
                    l = o * i + a * e - r * n, c = o * n + r * i - s * e, u = -r * e - s * i - a * n;
                return this.x = h * o + u * -r + l * -a - c * -s, this.y = l * o + u * -s + c * -r - h * -a, this.z = c * o + u * -a + h * -s - l * -r, this
            }, project: function (t) {
                return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
            }, unproject: function (t) {
                return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
            }, transformDirection: function (t) {
                var e = this.x, i = this.y, n = this.z, r = t.elements;
                return this.x = r[0] * e + r[4] * i + r[8] * n, this.y = r[1] * e + r[5] * i + r[9] * n, this.z = r[2] * e + r[6] * i + r[10] * n, this.normalize()
            }, divide: function (t) {
                return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
            }, divideScalar: function (t) {
                return this.multiplyScalar(1 / t)
            }, min: function (t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
            }, max: function (t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
            }, clamp: function (t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
            }, clampScalar: function (t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
            }, clampLength: function (t, e) {
                var i = this.length();
                return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
            }, floor: function () {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
            }, ceil: function () {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
            }, round: function () {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
            }, roundToZero: function () {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
            }, negate: function () {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
            }, dot: function (t) {
                return this.x * t.x + this.y * t.y + this.z * t.z
            }, lengthSq: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }, length: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }, manhattanLength: function () {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }, normalize: function () {
                return this.divideScalar(this.length() || 1)
            }, setLength: function (t) {
                return this.normalize().multiplyScalar(t)
            }, lerp: function (t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
            }, lerpVectors: function (t, e, i) {
                return this.subVectors(e, t).multiplyScalar(i).add(t)
            }, cross: function (t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
            }, crossVectors: function (t, e) {
                var i = t.x, n = t.y, r = t.z, s = e.x, a = e.y, o = e.z;
                return this.x = n * o - r * a, this.y = r * s - i * o, this.z = i * a - n * s, this
            }, projectOnVector: function (t) {
                var e = t.dot(this) / t.lengthSq();
                return this.copy(t).multiplyScalar(e)
            }, projectOnPlane: (Gf = new _m, function (t) {
                return Gf.copy(this).projectOnVector(t), this.sub(Gf)
            }), reflect: function () {
                var t = new _m;
                return function (e) {
                    return this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)))
                }
            }(), angleTo: function (t) {
                var e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
                return Math.acos(bm.clamp(e, -1, 1))
            }, distanceTo: function (t) {
                return Math.sqrt(this.distanceToSquared(t))
            }, distanceToSquared: function (t) {
                var e = this.x - t.x, i = this.y - t.y, n = this.z - t.z;
                return e * e + i * i + n * n
            }, manhattanDistanceTo: function (t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
            }, setFromSpherical: function (t) {
                return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
            }, setFromSphericalCoords: function (t, e, i) {
                var n = Math.sin(e) * t;
                return this.x = n * Math.sin(i), this.y = Math.cos(e) * t, this.z = n * Math.cos(i), this
            }, setFromCylindrical: function (t) {
                return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
            }, setFromCylindricalCoords: function (t, e, i) {
                return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this
            }, setFromMatrixPosition: function (t) {
                var e = t.elements;
                return this.x = e[12], this.y = e[13], this.z = e[14], this
            }, setFromMatrixScale: function (t) {
                var e = this.setFromMatrixColumn(t, 0).length(), i = this.setFromMatrixColumn(t, 1).length(),
                    n = this.setFromMatrixColumn(t, 2).length();
                return this.x = e, this.y = i, this.z = n, this
            }, setFromMatrixColumn: function (t, e) {
                return this.fromArray(t.elements, 4 * e)
            }, equals: function (t) {
                return t.x === this.x && t.y === this.y && t.z === this.z
            }, fromArray: function (t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
            }, toArray: function (t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
            }, fromBufferAttribute: function (t, e, i) {
                return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
            }
        }), Object.assign(Em.prototype, {
            isMatrix3: !0, set: function (t, e, i, n, r, s, a, o, h) {
                var l = this.elements;
                return l[0] = t, l[1] = n, l[2] = a, l[3] = e, l[4] = r, l[5] = o, l[6] = i, l[7] = s, l[8] = h, this
            }, identity: function () {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
            }, clone: function () {
                return (new this.constructor).fromArray(this.elements)
            }, copy: function (t) {
                var e = this.elements, i = t.elements;
                return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this
            }, setFromMatrix4: function (t) {
                var e = t.elements;
                return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
            }, applyToBufferAttribute: function () {
                var t = new _m;
                return function (e) {
                    for (var i = 0, n = e.count; i < n; i++) t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix3(this), e.setXYZ(i, t.x, t.y, t.z);
                    return e
                }
            }(), multiply: function (t) {
                return this.multiplyMatrices(this, t)
            }, premultiply: function (t) {
                return this.multiplyMatrices(t, this)
            }, multiplyMatrices: function (t, e) {
                var i = t.elements, n = e.elements, r = this.elements, s = i[0], a = i[3], o = i[6], h = i[1], l = i[4],
                    c = i[7], u = i[2], p = i[5], d = i[8], f = n[0], m = n[3], g = n[6], v = n[1], y = n[4], b = n[7],
                    x = n[2], w = n[5], _ = n[8];
                return r[0] = s * f + a * v + o * x, r[3] = s * m + a * y + o * w, r[6] = s * g + a * b + o * _, r[1] = h * f + l * v + c * x, r[4] = h * m + l * y + c * w, r[7] = h * g + l * b + c * _, r[2] = u * f + p * v + d * x, r[5] = u * m + p * y + d * w, r[8] = u * g + p * b + d * _, this
            }, multiplyScalar: function (t) {
                var e = this.elements;
                return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
            }, determinant: function () {
                var t = this.elements, e = t[0], i = t[1], n = t[2], r = t[3], s = t[4], a = t[5], o = t[6], h = t[7],
                    l = t[8];
                return e * s * l - e * a * h - i * r * l + i * a * o + n * r * h - n * s * o
            }, getInverse: function (t, e) {
                t && t.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
                var i = t.elements, n = this.elements, r = i[0], s = i[1], a = i[2], o = i[3], h = i[4], l = i[5],
                    c = i[6], u = i[7], p = i[8], d = p * h - l * u, f = l * c - p * o, m = u * o - h * c,
                    g = r * d + s * f + a * m;
                if (0 === g) {
                    var v = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                    if (!0 === e) throw new Error(v);
                    return console.warn(v), this.identity()
                }
                var y = 1 / g;
                return n[0] = d * y, n[1] = (a * u - p * s) * y, n[2] = (l * s - a * h) * y, n[3] = f * y, n[4] = (p * r - a * c) * y, n[5] = (a * o - l * r) * y, n[6] = m * y, n[7] = (s * c - u * r) * y, n[8] = (h * r - s * o) * y, this
            }, transpose: function () {
                var t, e = this.elements;
                return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
            }, getNormalMatrix: function (t) {
                return this.setFromMatrix4(t).getInverse(this).transpose()
            }, transposeIntoArray: function (t) {
                var e = this.elements;
                return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
            }, setUvTransform: function (t, e, i, n, r, s, a) {
                var o = Math.cos(r), h = Math.sin(r);
                this.set(i * o, i * h, -i * (o * s + h * a) + s + t, -n * h, n * o, -n * (-h * s + o * a) + a + e, 0, 0, 1)
            }, scale: function (t, e) {
                var i = this.elements;
                return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= e, i[4] *= e, i[7] *= e, this
            }, rotate: function (t) {
                var e = Math.cos(t), i = Math.sin(t), n = this.elements, r = n[0], s = n[3], a = n[6], o = n[1],
                    h = n[4], l = n[7];
                return n[0] = e * r + i * o, n[3] = e * s + i * h, n[6] = e * a + i * l, n[1] = -i * r + e * o, n[4] = -i * s + e * h, n[7] = -i * a + e * l, this
            }, translate: function (t, e) {
                var i = this.elements;
                return i[0] += t * i[2], i[3] += t * i[5], i[6] += t * i[8], i[1] += e * i[2], i[4] += e * i[5], i[7] += e * i[8], this
            }, equals: function (t) {
                for (var e = this.elements, i = t.elements, n = 0; n < 9; n++) if (e[n] !== i[n]) return !1;
                return !0
            }, fromArray: function (t, e) {
                void 0 === e && (e = 0);
                for (var i = 0; i < 9; i++) this.elements[i] = t[i + e];
                return this
            }, toArray: function (t, e) {
                void 0 === t && (t = []), void 0 === e && (e = 0);
                var i = this.elements;
                return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t
            }
        });
        var Mm, Am, Sm, Tm, Dm, Cm, Pm, Im, Lm, Rm, Fm, km, Om, zm, Bm = {
            getDataURL: function (t) {
                var e;
                if ("undefined" == typeof HTMLCanvasElement) return t.src;
                if (t instanceof HTMLCanvasElement) e = t; else {
                    void 0 === Hf && (Hf = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), Hf.width = t.width, Hf.height = t.height;
                    var i = Hf.getContext("2d");
                    t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height), e = Hf
                }
                return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
            }
        }, Nm = 0;

        function jm(t, e, i, n, r, s, a, o, h, l) {
            Object.defineProperty(this, "id", {value: Nm++}), this.uuid = bm.generateUUID(), this.name = "", this.image = void 0 !== t ? t : jm.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : jm.DEFAULT_MAPPING, this.wrapS = void 0 !== i ? i : Jf, this.wrapT = void 0 !== n ? n : Jf, this.magFilter = void 0 !== r ? r : em, this.minFilter = void 0 !== s ? s : im, this.anisotropy = void 0 !== h ? h : 1, this.format = void 0 !== a ? a : lm, this.type = void 0 !== o ? o : nm, this.offset = new xm(0, 0), this.repeat = new xm(1, 1), this.center = new xm(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Em, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== l ? l : ym, this.version = 0, this.onUpdate = null
        }

        function Vm(t, e, i, n) {
            this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = void 0 !== n ? n : 1
        }

        function Gm(t, e, i) {
            this.width = t, this.height = e, this.scissor = new Vm(0, 0, t, e), this.scissorTest = !1, this.viewport = new Vm(0, 0, t, e), i = i || {}, this.texture = new jm(void 0, void 0, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps, this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : em, this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
        }

        function Um(t, e, i) {
            Gm.call(this, t, e, i), this.samples = 4
        }

        function Hm(t, e, i) {
            Gm.call(this, t, e, i)
        }

        function Wm(t, e, i, n, r, s, a, o, h, l, c, u) {
            jm.call(this, null, s, a, o, h, l, n, r, c, u), this.image = {
                data: t,
                width: e,
                height: i
            }, this.magFilter = void 0 !== h ? h : Kf, this.minFilter = void 0 !== l ? l : Kf, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
        }

        function qm(t, e) {
            this.min = void 0 !== t ? t : new _m(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new _m(-1 / 0, -1 / 0, -1 / 0)
        }

        function Xm(t, e) {
            this.center = void 0 !== t ? t : new _m, this.radius = void 0 !== e ? e : 0
        }

        function Ym(t, e) {
            this.normal = void 0 !== t ? t : new _m(1, 0, 0), this.constant = void 0 !== e ? e : 0
        }

        function Zm(t, e, i, n, r, s) {
            this.planes = [void 0 !== t ? t : new Ym, void 0 !== e ? e : new Ym, void 0 !== i ? i : new Ym, void 0 !== n ? n : new Ym, void 0 !== r ? r : new Ym, void 0 !== s ? s : new Ym]
        }

        function Jm() {
            this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
        }

        jm.DEFAULT_IMAGE = void 0, jm.DEFAULT_MAPPING = 300, jm.prototype = Object.assign(Object.create(Vf.prototype), {
            constructor: jm, isTexture: !0, updateMatrix: function () {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }, clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
            }, toJSON: function (t) {
                var e = void 0 === t || "string" == typeof t;
                if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                var i = {
                    metadata: {version: 4.5, type: "Texture", generator: "Texture.toJSON"},
                    uuid: this.uuid,
                    name: this.name,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    type: this.type,
                    encoding: this.encoding,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                if (void 0 !== this.image) {
                    var n = this.image;
                    if (void 0 === n.uuid && (n.uuid = bm.generateUUID()), !e && void 0 === t.images[n.uuid]) {
                        var r;
                        if (Array.isArray(n)) {
                            r = [];
                            for (var s = 0, a = n.length; s < a; s++) r.push(Bm.getDataURL(n[s]))
                        } else r = Bm.getDataURL(n);
                        t.images[n.uuid] = {uuid: n.uuid, url: r}
                    }
                    i.image = n.uuid
                }
                return e || (t.textures[this.uuid] = i), i
            }, dispose: function () {
                this.dispatchEvent({type: "dispose"})
            }, transformUv: function (t) {
                if (300 !== this.mapping) return t;
                if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                    case Zf:
                        t.x = t.x - Math.floor(t.x);
                        break;
                    case Jf:
                        t.x = t.x < 0 ? 0 : 1;
                        break;
                    case Qf:
                        1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                }
                if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                    case Zf:
                        t.y = t.y - Math.floor(t.y);
                        break;
                    case Jf:
                        t.y = t.y < 0 ? 0 : 1;
                        break;
                    case Qf:
                        1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                }
                return this.flipY && (t.y = 1 - t.y), t
            }
        }), Object.defineProperty(jm.prototype, "needsUpdate", {
            set: function (t) {
                !0 === t && this.version++
            }
        }), Object.assign(Vm.prototype, {
            isVector4: !0, set: function (t, e, i, n) {
                return this.x = t, this.y = e, this.z = i, this.w = n, this
            }, setScalar: function (t) {
                return this.x = t, this.y = t, this.z = t, this.w = t, this
            }, setX: function (t) {
                return this.x = t, this
            }, setY: function (t) {
                return this.y = t, this
            }, setZ: function (t) {
                return this.z = t, this
            }, setW: function (t) {
                return this.w = t, this
            }, setComponent: function (t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    case 3:
                        this.w = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }, getComponent: function (t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }, clone: function () {
                return new this.constructor(this.x, this.y, this.z, this.w)
            }, copy: function (t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
            }, add: function (t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
            }, addScalar: function (t) {
                return this.x += t, this.y += t, this.z += t, this.w += t, this
            }, addVectors: function (t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
            }, addScaledVector: function (t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
            }, sub: function (t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
            }, subScalar: function (t) {
                return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
            }, subVectors: function (t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
            }, multiplyScalar: function (t) {
                return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
            }, applyMatrix4: function (t) {
                var e = this.x, i = this.y, n = this.z, r = this.w, s = t.elements;
                return this.x = s[0] * e + s[4] * i + s[8] * n + s[12] * r, this.y = s[1] * e + s[5] * i + s[9] * n + s[13] * r, this.z = s[2] * e + s[6] * i + s[10] * n + s[14] * r, this.w = s[3] * e + s[7] * i + s[11] * n + s[15] * r, this
            }, divideScalar: function (t) {
                return this.multiplyScalar(1 / t)
            }, setAxisAngleFromQuaternion: function (t) {
                this.w = 2 * Math.acos(t.w);
                var e = Math.sqrt(1 - t.w * t.w);
                return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
            }, setAxisAngleFromRotationMatrix: function (t) {
                var e, i, n, r, s = .01, a = .1, o = t.elements, h = o[0], l = o[4], c = o[8], u = o[1], p = o[5],
                    d = o[9], f = o[2], m = o[6], g = o[10];
                if (Math.abs(l - u) < s && Math.abs(c - f) < s && Math.abs(d - m) < s) {
                    if (Math.abs(l + u) < a && Math.abs(c + f) < a && Math.abs(d + m) < a && Math.abs(h + p + g - 3) < a) return this.set(1, 0, 0, 0), this;
                    e = Math.PI;
                    var v = (h + 1) / 2, y = (p + 1) / 2, b = (g + 1) / 2, x = (l + u) / 4, w = (c + f) / 4,
                        _ = (d + m) / 4;
                    return v > y && v > b ? v < s ? (i = 0, n = .707106781, r = .707106781) : (n = x / (i = Math.sqrt(v)), r = w / i) : y > b ? y < s ? (i = .707106781, n = 0, r = .707106781) : (i = x / (n = Math.sqrt(y)), r = _ / n) : b < s ? (i = .707106781, n = .707106781, r = 0) : (i = w / (r = Math.sqrt(b)), n = _ / r), this.set(i, n, r, e), this
                }
                var E = Math.sqrt((m - d) * (m - d) + (c - f) * (c - f) + (u - l) * (u - l));
                return Math.abs(E) < .001 && (E = 1), this.x = (m - d) / E, this.y = (c - f) / E, this.z = (u - l) / E, this.w = Math.acos((h + p + g - 1) / 2), this
            }, min: function (t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
            }, max: function (t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
            }, clamp: function (t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
            }, clampScalar: function (t, e) {
                return void 0 === Mm && (Mm = new Vm, Am = new Vm), Mm.set(t, t, t, t), Am.set(e, e, e, e), this.clamp(Mm, Am)
            }, clampLength: function (t, e) {
                var i = this.length();
                return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
            }, floor: function () {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            }, ceil: function () {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            }, round: function () {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            }, roundToZero: function () {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
            }, negate: function () {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            }, dot: function (t) {
                return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
            }, lengthSq: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }, length: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }, manhattanLength: function () {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }, normalize: function () {
                return this.divideScalar(this.length() || 1)
            }, setLength: function (t) {
                return this.normalize().multiplyScalar(t)
            }, lerp: function (t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
            }, lerpVectors: function (t, e, i) {
                return this.subVectors(e, t).multiplyScalar(i).add(t)
            }, equals: function (t) {
                return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
            }, fromArray: function (t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
            }, toArray: function (t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
            }, fromBufferAttribute: function (t, e, i) {
                return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
            }
        }), Gm.prototype = Object.assign(Object.create(Vf.prototype), {
            constructor: Gm,
            isWebGLRenderTarget: !0,
            setSize: function (t, e) {
                this.width === t && this.height === e || (this.width = t, this.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (t) {
                return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
            },
            dispose: function () {
                this.dispatchEvent({type: "dispose"})
            }
        }), Um.prototype = Object.assign(Object.create(Gm.prototype), {
            constructor: Um,
            isWebGLMultisampleRenderTarget: !0,
            copy: function (t) {
                return Gm.prototype.copy.call(this, t), this.samples = t.samples, this
            }
        }), Hm.prototype = Object.create(Gm.prototype), Hm.prototype.constructor = Hm, Hm.prototype.isWebGLRenderTargetCube = !0, Wm.prototype = Object.create(jm.prototype), Wm.prototype.constructor = Wm, Wm.prototype.isDataTexture = !0, Object.assign(qm.prototype, {
            isBox3: !0, set: function (t, e) {
                return this.min.copy(t), this.max.copy(e), this
            }, setFromArray: function (t) {
                for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, s = -1 / 0, a = -1 / 0, o = 0, h = t.length; o < h; o += 3) {
                    var l = t[o], c = t[o + 1], u = t[o + 2];
                    l < e && (e = l), c < i && (i = c), u < n && (n = u), l > r && (r = l), c > s && (s = c), u > a && (a = u)
                }
                return this.min.set(e, i, n), this.max.set(r, s, a), this
            }, setFromBufferAttribute: function (t) {
                for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, s = -1 / 0, a = -1 / 0, o = 0, h = t.count; o < h; o++) {
                    var l = t.getX(o), c = t.getY(o), u = t.getZ(o);
                    l < e && (e = l), c < i && (i = c), u < n && (n = u), l > r && (r = l), c > s && (s = c), u > a && (a = u)
                }
                return this.min.set(e, i, n), this.max.set(r, s, a), this
            }, setFromPoints: function (t) {
                this.makeEmpty();
                for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                return this
            }, setFromCenterAndSize: function () {
                var t = new _m;
                return function (e, i) {
                    var n = t.copy(i).multiplyScalar(.5);
                    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                }
            }(), setFromObject: function (t) {
                return this.makeEmpty(), this.expandByObject(t)
            }, clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            }, makeEmpty: function () {
                return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
            }, isEmpty: function () {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }, getCenter: function (t) {
                return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new _m), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }, getSize: function (t) {
                return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new _m), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            }, expandByPoint: function (t) {
                return this.min.min(t), this.max.max(t), this
            }, expandByVector: function (t) {
                return this.min.sub(t), this.max.add(t), this
            }, expandByScalar: function (t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            }, expandByObject: function () {
                var t, e, i, n = new _m;

                function r(r) {
                    var s = r.geometry;
                    if (void 0 !== s) if (s.isGeometry) {
                        var a = s.vertices;
                        for (e = 0, i = a.length; e < i; e++) n.copy(a[e]), n.applyMatrix4(r.matrixWorld), t.expandByPoint(n)
                    } else if (s.isBufferGeometry) {
                        var o = s.attributes.position;
                        if (void 0 !== o) for (e = 0, i = o.count; e < i; e++) n.fromBufferAttribute(o, e).applyMatrix4(r.matrixWorld), t.expandByPoint(n)
                    }
                }

                return function (e) {
                    return t = this, e.updateMatrixWorld(!0), e.traverse(r), this
                }
            }(), containsPoint: function (t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
            }, containsBox: function (t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
            }, getParameter: function (t, e) {
                return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new _m), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
            }, intersectsBox: function (t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
            }, intersectsSphere: (Tm = new _m, function (t) {
                return this.clampPoint(t.center, Tm), Tm.distanceToSquared(t.center) <= t.radius * t.radius
            }), intersectsPlane: function (t) {
                var e, i;
                return t.normal.x > 0 ? (e = t.normal.x * this.min.x, i = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, i = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t.constant && i >= -t.constant
            }, intersectsTriangle: function () {
                var t = new _m, e = new _m, i = new _m, n = new _m, r = new _m, s = new _m, a = new _m, o = new _m,
                    h = new _m, l = new _m;

                function c(n) {
                    var r, s;
                    for (r = 0, s = n.length - 3; r <= s; r += 3) {
                        a.fromArray(n, r);
                        var o = h.x * Math.abs(a.x) + h.y * Math.abs(a.y) + h.z * Math.abs(a.z), l = t.dot(a),
                            c = e.dot(a), u = i.dot(a);
                        if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > o) return !1
                    }
                    return !0
                }

                return function (a) {
                    if (this.isEmpty()) return !1;
                    this.getCenter(o), h.subVectors(this.max, o), t.subVectors(a.a, o), e.subVectors(a.b, o), i.subVectors(a.c, o), n.subVectors(e, t), r.subVectors(i, e), s.subVectors(t, i);
                    var u = [0, -n.z, n.y, 0, -r.z, r.y, 0, -s.z, s.y, n.z, 0, -n.x, r.z, 0, -r.x, s.z, 0, -s.x, -n.y, n.x, 0, -r.y, r.x, 0, -s.y, s.x, 0];
                    return !!c(u) && (!!c(u = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (l.crossVectors(n, r), c(u = [l.x, l.y, l.z])))
                }
            }(), clampPoint: function (t, e) {
                return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new _m), e.copy(t).clamp(this.min, this.max)
            }, distanceToPoint: function () {
                var t = new _m;
                return function (e) {
                    return t.copy(e).clamp(this.min, this.max).sub(e).length()
                }
            }(), getBoundingSphere: function () {
                var t = new _m;
                return function (e) {
                    return void 0 === e && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(e.center), e.radius = .5 * this.getSize(t).length(), e
                }
            }(), intersect: function (t) {
                return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
            }, union: function (t) {
                return this.min.min(t.min), this.max.max(t.max), this
            }, applyMatrix4: (Sm = [new _m, new _m, new _m, new _m, new _m, new _m, new _m, new _m], function (t) {
                return this.isEmpty() || (Sm[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), Sm[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), Sm[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), Sm[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), Sm[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), Sm[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), Sm[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), Sm[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(Sm)), this
            }), translate: function (t) {
                return this.min.add(t), this.max.add(t), this
            }, equals: function (t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }), Object.assign(Xm.prototype, {
            set: function (t, e) {
                return this.center.copy(t), this.radius = e, this
            }, setFromPoints: (Dm = new qm, function (t, e) {
                var i = this.center;
                void 0 !== e ? i.copy(e) : Dm.setFromPoints(t).getCenter(i);
                for (var n = 0, r = 0, s = t.length; r < s; r++) n = Math.max(n, i.distanceToSquared(t[r]));
                return this.radius = Math.sqrt(n), this
            }), clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                return this.center.copy(t.center), this.radius = t.radius, this
            }, empty: function () {
                return this.radius <= 0
            }, containsPoint: function (t) {
                return t.distanceToSquared(this.center) <= this.radius * this.radius
            }, distanceToPoint: function (t) {
                return t.distanceTo(this.center) - this.radius
            }, intersectsSphere: function (t) {
                var e = this.radius + t.radius;
                return t.center.distanceToSquared(this.center) <= e * e
            }, intersectsBox: function (t) {
                return t.intersectsSphere(this)
            }, intersectsPlane: function (t) {
                return Math.abs(t.distanceToPoint(this.center)) <= this.radius
            }, clampPoint: function (t, e) {
                var i = this.center.distanceToSquared(t);
                return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new _m), e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
            }, getBoundingBox: function (t) {
                return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new qm), t.set(this.center, this.center), t.expandByScalar(this.radius), t
            }, applyMatrix4: function (t) {
                return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
            }, translate: function (t) {
                return this.center.add(t), this
            }, equals: function (t) {
                return t.center.equals(this.center) && t.radius === this.radius
            }
        }), Object.assign(Ym.prototype, {
            set: function (t, e) {
                return this.normal.copy(t), this.constant = e, this
            }, setComponents: function (t, e, i, n) {
                return this.normal.set(t, e, i), this.constant = n, this
            }, setFromNormalAndCoplanarPoint: function (t, e) {
                return this.normal.copy(t), this.constant = -e.dot(this.normal), this
            }, setFromCoplanarPoints: function () {
                var t = new _m, e = new _m;
                return function (i, n, r) {
                    var s = t.subVectors(r, n).cross(e.subVectors(i, n)).normalize();
                    return this.setFromNormalAndCoplanarPoint(s, i), this
                }
            }(), clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                return this.normal.copy(t.normal), this.constant = t.constant, this
            }, normalize: function () {
                var t = 1 / this.normal.length();
                return this.normal.multiplyScalar(t), this.constant *= t, this
            }, negate: function () {
                return this.constant *= -1, this.normal.negate(), this
            }, distanceToPoint: function (t) {
                return this.normal.dot(t) + this.constant
            }, distanceToSphere: function (t) {
                return this.distanceToPoint(t.center) - t.radius
            }, projectPoint: function (t, e) {
                return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new _m), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
            }, intersectLine: function () {
                var t = new _m;
                return function (e, i) {
                    void 0 === i && (console.warn("THREE.Plane: .intersectLine() target is now required"), i = new _m);
                    var n = e.delta(t), r = this.normal.dot(n);
                    if (0 === r) return 0 === this.distanceToPoint(e.start) ? i.copy(e.start) : void 0;
                    var s = -(e.start.dot(this.normal) + this.constant) / r;
                    return s < 0 || s > 1 ? void 0 : i.copy(n).multiplyScalar(s).add(e.start)
                }
            }(), intersectsLine: function (t) {
                var e = this.distanceToPoint(t.start), i = this.distanceToPoint(t.end);
                return e < 0 && i > 0 || i < 0 && e > 0
            }, intersectsBox: function (t) {
                return t.intersectsPlane(this)
            }, intersectsSphere: function (t) {
                return t.intersectsPlane(this)
            }, coplanarPoint: function (t) {
                return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new _m), t.copy(this.normal).multiplyScalar(-this.constant)
            }, applyMatrix4: function () {
                var t = new _m, e = new Em;
                return function (i, n) {
                    var r = n || e.getNormalMatrix(i), s = this.coplanarPoint(t).applyMatrix4(i),
                        a = this.normal.applyMatrix3(r).normalize();
                    return this.constant = -s.dot(a), this
                }
            }(), translate: function (t) {
                return this.constant -= t.dot(this.normal), this
            }, equals: function (t) {
                return t.normal.equals(this.normal) && t.constant === this.constant
            }
        }), Object.assign(Zm.prototype, {
            set: function (t, e, i, n, r, s) {
                var a = this.planes;
                return a[0].copy(t), a[1].copy(e), a[2].copy(i), a[3].copy(n), a[4].copy(r), a[5].copy(s), this
            }, clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                for (var e = this.planes, i = 0; i < 6; i++) e[i].copy(t.planes[i]);
                return this
            }, setFromMatrix: function (t) {
                var e = this.planes, i = t.elements, n = i[0], r = i[1], s = i[2], a = i[3], o = i[4], h = i[5],
                    l = i[6], c = i[7], u = i[8], p = i[9], d = i[10], f = i[11], m = i[12], g = i[13], v = i[14],
                    y = i[15];
                return e[0].setComponents(a - n, c - o, f - u, y - m).normalize(), e[1].setComponents(a + n, c + o, f + u, y + m).normalize(), e[2].setComponents(a + r, c + h, f + p, y + g).normalize(), e[3].setComponents(a - r, c - h, f - p, y - g).normalize(), e[4].setComponents(a - s, c - l, f - d, y - v).normalize(), e[5].setComponents(a + s, c + l, f + d, y + v).normalize(), this
            }, intersectsObject: (Pm = new Xm, function (t) {
                var e = t.geometry;
                return null === e.boundingSphere && e.computeBoundingSphere(), Pm.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Pm)
            }), intersectsSprite: function () {
                var t = new Xm;
                return function (e) {
                    return t.center.set(0, 0, 0), t.radius = .7071067811865476, t.applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
                }
            }(), intersectsSphere: function (t) {
                for (var e = this.planes, i = t.center, n = -t.radius, r = 0; r < 6; r++) {
                    if (e[r].distanceToPoint(i) < n) return !1
                }
                return !0
            }, intersectsBox: (Cm = new _m, function (t) {
                for (var e = this.planes, i = 0; i < 6; i++) {
                    var n = e[i];
                    if (Cm.x = n.normal.x > 0 ? t.max.x : t.min.x, Cm.y = n.normal.y > 0 ? t.max.y : t.min.y, Cm.z = n.normal.z > 0 ? t.max.z : t.min.z, n.distanceToPoint(Cm) < 0) return !1
                }
                return !0
            }), containsPoint: function (t) {
                for (var e = this.planes, i = 0; i < 6; i++) if (e[i].distanceToPoint(t) < 0) return !1;
                return !0
            }
        }), Object.assign(Jm.prototype, {
            isMatrix4: !0, set: function (t, e, i, n, r, s, a, o, h, l, c, u, p, d, f, m) {
                var g = this.elements;
                return g[0] = t, g[4] = e, g[8] = i, g[12] = n, g[1] = r, g[5] = s, g[9] = a, g[13] = o, g[2] = h, g[6] = l, g[10] = c, g[14] = u, g[3] = p, g[7] = d, g[11] = f, g[15] = m, this
            }, identity: function () {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }, clone: function () {
                return (new Jm).fromArray(this.elements)
            }, copy: function (t) {
                var e = this.elements, i = t.elements;
                return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this
            }, copyPosition: function (t) {
                var e = this.elements, i = t.elements;
                return e[12] = i[12], e[13] = i[13], e[14] = i[14], this
            }, extractBasis: function (t, e, i) {
                return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
            }, makeBasis: function (t, e, i) {
                return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this
            }, extractRotation: function () {
                var t = new _m;
                return function (e) {
                    var i = this.elements, n = e.elements, r = 1 / t.setFromMatrixColumn(e, 0).length(),
                        s = 1 / t.setFromMatrixColumn(e, 1).length(), a = 1 / t.setFromMatrixColumn(e, 2).length();
                    return i[0] = n[0] * r, i[1] = n[1] * r, i[2] = n[2] * r, i[3] = 0, i[4] = n[4] * s, i[5] = n[5] * s, i[6] = n[6] * s, i[7] = 0, i[8] = n[8] * a, i[9] = n[9] * a, i[10] = n[10] * a, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this
                }
            }(), makeRotationFromEuler: function (t) {
                t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                var e = this.elements, i = t.x, n = t.y, r = t.z, s = Math.cos(i), a = Math.sin(i), o = Math.cos(n),
                    h = Math.sin(n), l = Math.cos(r), c = Math.sin(r);
                if ("XYZ" === t.order) {
                    var u = s * l, p = s * c, d = a * l, f = a * c;
                    e[0] = o * l, e[4] = -o * c, e[8] = h, e[1] = p + d * h, e[5] = u - f * h, e[9] = -a * o, e[2] = f - u * h, e[6] = d + p * h, e[10] = s * o
                } else if ("YXZ" === t.order) {
                    var m = o * l, g = o * c, v = h * l, y = h * c;
                    e[0] = m + y * a, e[4] = v * a - g, e[8] = s * h, e[1] = s * c, e[5] = s * l, e[9] = -a, e[2] = g * a - v, e[6] = y + m * a, e[10] = s * o
                } else if ("ZXY" === t.order) {
                    m = o * l, g = o * c, v = h * l, y = h * c;
                    e[0] = m - y * a, e[4] = -s * c, e[8] = v + g * a, e[1] = g + v * a, e[5] = s * l, e[9] = y - m * a, e[2] = -s * h, e[6] = a, e[10] = s * o
                } else if ("ZYX" === t.order) {
                    u = s * l, p = s * c, d = a * l, f = a * c;
                    e[0] = o * l, e[4] = d * h - p, e[8] = u * h + f, e[1] = o * c, e[5] = f * h + u, e[9] = p * h - d, e[2] = -h, e[6] = a * o, e[10] = s * o
                } else if ("YZX" === t.order) {
                    var b = s * o, x = s * h, w = a * o, _ = a * h;
                    e[0] = o * l, e[4] = _ - b * c, e[8] = w * c + x, e[1] = c, e[5] = s * l, e[9] = -a * l, e[2] = -h * l, e[6] = x * c + w, e[10] = b - _ * c
                } else if ("XZY" === t.order) {
                    b = s * o, x = s * h, w = a * o, _ = a * h;
                    e[0] = o * l, e[4] = -c, e[8] = h * l, e[1] = b * c + _, e[5] = s * l, e[9] = x * c - w, e[2] = w * c - x, e[6] = a * l, e[10] = _ * c + b
                }
                return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            }, makeRotationFromQuaternion: (Om = new _m(0, 0, 0), zm = new _m(1, 1, 1), function (t) {
                return this.compose(Om, t, zm)
            }), lookAt: (Rm = new _m, Fm = new _m, km = new _m, function (t, e, i) {
                var n = this.elements;
                return km.subVectors(t, e), 0 === km.lengthSq() && (km.z = 1), km.normalize(), Rm.crossVectors(i, km), 0 === Rm.lengthSq() && (1 === Math.abs(i.z) ? km.x += 1e-4 : km.z += 1e-4, km.normalize(), Rm.crossVectors(i, km)), Rm.normalize(), Fm.crossVectors(km, Rm), n[0] = Rm.x, n[4] = Fm.x, n[8] = km.x, n[1] = Rm.y, n[5] = Fm.y, n[9] = km.y, n[2] = Rm.z, n[6] = Fm.z, n[10] = km.z, this
            }), multiply: function (t, e) {
                return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
            }, premultiply: function (t) {
                return this.multiplyMatrices(t, this)
            }, multiplyMatrices: function (t, e) {
                var i = t.elements, n = e.elements, r = this.elements, s = i[0], a = i[4], o = i[8], h = i[12],
                    l = i[1], c = i[5], u = i[9], p = i[13], d = i[2], f = i[6], m = i[10], g = i[14], v = i[3],
                    y = i[7], b = i[11], x = i[15], w = n[0], _ = n[4], E = n[8], M = n[12], A = n[1], S = n[5],
                    T = n[9], D = n[13], C = n[2], P = n[6], I = n[10], L = n[14], R = n[3], F = n[7], k = n[11],
                    O = n[15];
                return r[0] = s * w + a * A + o * C + h * R, r[4] = s * _ + a * S + o * P + h * F, r[8] = s * E + a * T + o * I + h * k, r[12] = s * M + a * D + o * L + h * O, r[1] = l * w + c * A + u * C + p * R, r[5] = l * _ + c * S + u * P + p * F, r[9] = l * E + c * T + u * I + p * k, r[13] = l * M + c * D + u * L + p * O, r[2] = d * w + f * A + m * C + g * R, r[6] = d * _ + f * S + m * P + g * F, r[10] = d * E + f * T + m * I + g * k, r[14] = d * M + f * D + m * L + g * O, r[3] = v * w + y * A + b * C + x * R, r[7] = v * _ + y * S + b * P + x * F, r[11] = v * E + y * T + b * I + x * k, r[15] = v * M + y * D + b * L + x * O, this
            }, multiplyScalar: function (t) {
                var e = this.elements;
                return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
            }, applyToBufferAttribute: function () {
                var t = new _m;
                return function (e) {
                    for (var i = 0, n = e.count; i < n; i++) t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix4(this), e.setXYZ(i, t.x, t.y, t.z);
                    return e
                }
            }(), determinant: function () {
                var t = this.elements, e = t[0], i = t[4], n = t[8], r = t[12], s = t[1], a = t[5], o = t[9], h = t[13],
                    l = t[2], c = t[6], u = t[10], p = t[14];
                return t[3] * (+r * o * c - n * h * c - r * a * u + i * h * u + n * a * p - i * o * p) + t[7] * (+e * o * p - e * h * u + r * s * u - n * s * p + n * h * l - r * o * l) + t[11] * (+e * h * c - e * a * p - r * s * c + i * s * p + r * a * l - i * h * l) + t[15] * (-n * a * l - e * o * c + e * a * u + n * s * c - i * s * u + i * o * l)
            }, transpose: function () {
                var t, e = this.elements;
                return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
            }, setPosition: function (t, e, i) {
                var n = this.elements;
                return t.isVector3 ? (n[12] = t.x, n[13] = t.y, n[14] = t.z) : (n[12] = t, n[13] = e, n[14] = i), this
            }, getInverse: function (t, e) {
                var i = this.elements, n = t.elements, r = n[0], s = n[1], a = n[2], o = n[3], h = n[4], l = n[5],
                    c = n[6], u = n[7], p = n[8], d = n[9], f = n[10], m = n[11], g = n[12], v = n[13], y = n[14],
                    b = n[15], x = d * y * u - v * f * u + v * c * m - l * y * m - d * c * b + l * f * b,
                    w = g * f * u - p * y * u - g * c * m + h * y * m + p * c * b - h * f * b,
                    _ = p * v * u - g * d * u + g * l * m - h * v * m - p * l * b + h * d * b,
                    E = g * d * c - p * v * c - g * l * f + h * v * f + p * l * y - h * d * y,
                    M = r * x + s * w + a * _ + o * E;
                if (0 === M) {
                    var A = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                    if (!0 === e) throw new Error(A);
                    return console.warn(A), this.identity()
                }
                var S = 1 / M;
                return i[0] = x * S, i[1] = (v * f * o - d * y * o - v * a * m + s * y * m + d * a * b - s * f * b) * S, i[2] = (l * y * o - v * c * o + v * a * u - s * y * u - l * a * b + s * c * b) * S, i[3] = (d * c * o - l * f * o - d * a * u + s * f * u + l * a * m - s * c * m) * S, i[4] = w * S, i[5] = (p * y * o - g * f * o + g * a * m - r * y * m - p * a * b + r * f * b) * S, i[6] = (g * c * o - h * y * o - g * a * u + r * y * u + h * a * b - r * c * b) * S, i[7] = (h * f * o - p * c * o + p * a * u - r * f * u - h * a * m + r * c * m) * S, i[8] = _ * S, i[9] = (g * d * o - p * v * o - g * s * m + r * v * m + p * s * b - r * d * b) * S, i[10] = (h * v * o - g * l * o + g * s * u - r * v * u - h * s * b + r * l * b) * S, i[11] = (p * l * o - h * d * o - p * s * u + r * d * u + h * s * m - r * l * m) * S, i[12] = E * S, i[13] = (p * v * a - g * d * a + g * s * f - r * v * f - p * s * y + r * d * y) * S, i[14] = (g * l * a - h * v * a - g * s * c + r * v * c + h * s * y - r * l * y) * S, i[15] = (h * d * a - p * l * a + p * s * c - r * d * c - h * s * f + r * l * f) * S, this
            }, scale: function (t) {
                var e = this.elements, i = t.x, n = t.y, r = t.z;
                return e[0] *= i, e[4] *= n, e[8] *= r, e[1] *= i, e[5] *= n, e[9] *= r, e[2] *= i, e[6] *= n, e[10] *= r, e[3] *= i, e[7] *= n, e[11] *= r, this
            }, getMaxScaleOnAxis: function () {
                var t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                    i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                return Math.sqrt(Math.max(e, i, n))
            }, makeTranslation: function (t, e, i) {
                return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this
            }, makeRotationX: function (t) {
                var e = Math.cos(t), i = Math.sin(t);
                return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this
            }, makeRotationY: function (t) {
                var e = Math.cos(t), i = Math.sin(t);
                return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this
            }, makeRotationZ: function (t) {
                var e = Math.cos(t), i = Math.sin(t);
                return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }, makeRotationAxis: function (t, e) {
                var i = Math.cos(e), n = Math.sin(e), r = 1 - i, s = t.x, a = t.y, o = t.z, h = r * s, l = r * a;
                return this.set(h * s + i, h * a - n * o, h * o + n * a, 0, h * a + n * o, l * a + i, l * o - n * s, 0, h * o - n * a, l * o + n * s, r * o * o + i, 0, 0, 0, 0, 1), this
            }, makeScale: function (t, e, i) {
                return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
            }, makeShear: function (t, e, i) {
                return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1), this
            }, compose: function (t, e, i) {
                var n = this.elements, r = e._x, s = e._y, a = e._z, o = e._w, h = r + r, l = s + s, c = a + a,
                    u = r * h, p = r * l, d = r * c, f = s * l, m = s * c, g = a * c, v = o * h, y = o * l, b = o * c,
                    x = i.x, w = i.y, _ = i.z;
                return n[0] = (1 - (f + g)) * x, n[1] = (p + b) * x, n[2] = (d - y) * x, n[3] = 0, n[4] = (p - b) * w, n[5] = (1 - (u + g)) * w, n[6] = (m + v) * w, n[7] = 0, n[8] = (d + y) * _, n[9] = (m - v) * _, n[10] = (1 - (u + f)) * _, n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this
            }, decompose: (Im = new _m, Lm = new Jm, function (t, e, i) {
                var n = this.elements, r = Im.set(n[0], n[1], n[2]).length(), s = Im.set(n[4], n[5], n[6]).length(),
                    a = Im.set(n[8], n[9], n[10]).length();
                this.determinant() < 0 && (r = -r), t.x = n[12], t.y = n[13], t.z = n[14], Lm.copy(this);
                var o = 1 / r, h = 1 / s, l = 1 / a;
                return Lm.elements[0] *= o, Lm.elements[1] *= o, Lm.elements[2] *= o, Lm.elements[4] *= h, Lm.elements[5] *= h, Lm.elements[6] *= h, Lm.elements[8] *= l, Lm.elements[9] *= l, Lm.elements[10] *= l, e.setFromRotationMatrix(Lm), i.x = r, i.y = s, i.z = a, this
            }), makePerspective: function (t, e, i, n, r, s) {
                void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                var a = this.elements, o = 2 * r / (e - t), h = 2 * r / (i - n), l = (e + t) / (e - t),
                    c = (i + n) / (i - n), u = -(s + r) / (s - r), p = -2 * s * r / (s - r);
                return a[0] = o, a[4] = 0, a[8] = l, a[12] = 0, a[1] = 0, a[5] = h, a[9] = c, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = u, a[14] = p, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
            }, makeOrthographic: function (t, e, i, n, r, s) {
                var a = this.elements, o = 1 / (e - t), h = 1 / (i - n), l = 1 / (s - r), c = (e + t) * o,
                    u = (i + n) * h, p = (s + r) * l;
                return a[0] = 2 * o, a[4] = 0, a[8] = 0, a[12] = -c, a[1] = 0, a[5] = 2 * h, a[9] = 0, a[13] = -u, a[2] = 0, a[6] = 0, a[10] = -2 * l, a[14] = -p, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
            }, equals: function (t) {
                for (var e = this.elements, i = t.elements, n = 0; n < 16; n++) if (e[n] !== i[n]) return !1;
                return !0
            }, fromArray: function (t, e) {
                void 0 === e && (e = 0);
                for (var i = 0; i < 16; i++) this.elements[i] = t[i + e];
                return this
            }, toArray: function (t, e) {
                void 0 === t && (t = []), void 0 === e && (e = 0);
                var i = this.elements;
                return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t
            }
        });
        var Qm = {
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            begin_vertex: "vec3 transformed = vec3( position );",
            beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
            color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
            common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
            defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
            lights_pars_begin: "uniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif",
            lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif",
            logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif",
            map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
            map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
            normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif",
            normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\t#ifdef USE_TANGENT\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy = normalScale * mapN.xy;\n\t\t\tnormal = normalize( vTBN * mapN );\n\t\t#else\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t\t#endif\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment: "#if defined( DITHERING )\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
            shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif",
            shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
            uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
            uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
            uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
            uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
            uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
            uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif",
            background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
            depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
            distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
            normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
            shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
        };

        function Km(t) {
            var e = {};
            for (var i in t) for (var n in e[i] = {}, t[i]) {
                var r = t[i][n];
                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[i][n] = r.clone() : Array.isArray(r) ? e[i][n] = r.slice() : e[i][n] = r
            }
            return e
        }

        function $m(t) {
            for (var e = {}, i = 0; i < t.length; i++) {
                var n = Km(t[i]);
                for (var r in n) e[r] = n[r]
            }
            return e
        }

        var tg, eg, ig, ng = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        };

        function rg(t, e, i) {
            return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
        }

        Object.assign(rg.prototype, {
            isColor: !0, r: 1, g: 1, b: 1, set: function (t) {
                return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
            }, setScalar: function (t) {
                return this.r = t, this.g = t, this.b = t, this
            }, setHex: function (t) {
                return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
            }, setRGB: function (t, e, i) {
                return this.r = t, this.g = e, this.b = i, this
            }, setHSL: function () {
                function t(t, e, i) {
                    return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
                }

                return function (e, i, n) {
                    if (e = bm.euclideanModulo(e, 1), i = bm.clamp(i, 0, 1), n = bm.clamp(n, 0, 1), 0 === i) this.r = this.g = this.b = n; else {
                        var r = n <= .5 ? n * (1 + i) : n + i - n * i, s = 2 * n - r;
                        this.r = t(s, r, e + 1 / 3), this.g = t(s, r, e), this.b = t(s, r, e - 1 / 3)
                    }
                    return this
                }
            }(), setStyle: function (t) {
                function e(e) {
                    void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                }

                var i;
                if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                    var n, r = i[1], s = i[2];
                    switch (r) {
                        case"rgb":
                        case"rgba":
                            if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(s)) return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, e(n[5]), this;
                            if (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(s)) return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, e(n[5]), this;
                            break;
                        case"hsl":
                        case"hsla":
                            if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(s)) {
                                var a = parseFloat(n[1]) / 360, o = parseInt(n[2], 10) / 100,
                                    h = parseInt(n[3], 10) / 100;
                                return e(n[5]), this.setHSL(a, o, h)
                            }
                    }
                } else if (i = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                    var l, c = (l = i[1]).length;
                    if (3 === c) return this.r = parseInt(l.charAt(0) + l.charAt(0), 16) / 255, this.g = parseInt(l.charAt(1) + l.charAt(1), 16) / 255, this.b = parseInt(l.charAt(2) + l.charAt(2), 16) / 255, this;
                    if (6 === c) return this.r = parseInt(l.charAt(0) + l.charAt(1), 16) / 255, this.g = parseInt(l.charAt(2) + l.charAt(3), 16) / 255, this.b = parseInt(l.charAt(4) + l.charAt(5), 16) / 255, this
                }
                t && t.length > 0 && (void 0 !== (l = ng[t]) ? this.setHex(l) : console.warn("THREE.Color: Unknown color " + t));
                return this
            }, clone: function () {
                return new this.constructor(this.r, this.g, this.b)
            }, copy: function (t) {
                return this.r = t.r, this.g = t.g, this.b = t.b, this
            }, copyGammaToLinear: function (t, e) {
                return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
            }, copyLinearToGamma: function (t, e) {
                void 0 === e && (e = 2);
                var i = e > 0 ? 1 / e : 1;
                return this.r = Math.pow(t.r, i), this.g = Math.pow(t.g, i), this.b = Math.pow(t.b, i), this
            }, convertGammaToLinear: function (t) {
                return this.copyGammaToLinear(this, t), this
            }, convertLinearToGamma: function (t) {
                return this.copyLinearToGamma(this, t), this
            }, copySRGBToLinear: function () {
                function t(t) {
                    return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
                }

                return function (e) {
                    return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this
                }
            }(), copyLinearToSRGB: function () {
                function t(t) {
                    return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
                }

                return function (e) {
                    return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this
                }
            }(), convertSRGBToLinear: function () {
                return this.copySRGBToLinear(this), this
            }, convertLinearToSRGB: function () {
                return this.copyLinearToSRGB(this), this
            }, getHex: function () {
                return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
            }, getHexString: function () {
                return ("000000" + this.getHex().toString(16)).slice(-6)
            }, getHSL: function (t) {
                void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = {h: 0, s: 0, l: 0});
                var e, i, n = this.r, r = this.g, s = this.b, a = Math.max(n, r, s), o = Math.min(n, r, s),
                    h = (o + a) / 2;
                if (o === a) e = 0, i = 0; else {
                    var l = a - o;
                    switch (i = h <= .5 ? l / (a + o) : l / (2 - a - o), a) {
                        case n:
                            e = (r - s) / l + (r < s ? 6 : 0);
                            break;
                        case r:
                            e = (s - n) / l + 2;
                            break;
                        case s:
                            e = (n - r) / l + 4
                    }
                    e /= 6
                }
                return t.h = e, t.s = i, t.l = h, t
            }, getStyle: function () {
                return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
            }, offsetHSL: (ig = {}, function (t, e, i) {
                return this.getHSL(ig), ig.h += t, ig.s += e, ig.l += i, this.setHSL(ig.h, ig.s, ig.l), this
            }), add: function (t) {
                return this.r += t.r, this.g += t.g, this.b += t.b, this
            }, addColors: function (t, e) {
                return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
            }, addScalar: function (t) {
                return this.r += t, this.g += t, this.b += t, this
            }, sub: function (t) {
                return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
            }, multiply: function (t) {
                return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
            }, multiplyScalar: function (t) {
                return this.r *= t, this.g *= t, this.b *= t, this
            }, lerp: function (t, e) {
                return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
            }, lerpHSL: (tg = {h: 0, s: 0, l: 0}, eg = {h: 0, s: 0, l: 0}, function (t, e) {
                this.getHSL(tg), t.getHSL(eg);
                var i = bm.lerp(tg.h, eg.h, e), n = bm.lerp(tg.s, eg.s, e), r = bm.lerp(tg.l, eg.l, e);
                return this.setHSL(i, n, r), this
            }), equals: function (t) {
                return t.r === this.r && t.g === this.g && t.b === this.b
            }, fromArray: function (t, e) {
                return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
            }, toArray: function (t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
            }, toJSON: function () {
                return this.getHex()
            }
        });
        var sg, ag = {
            common: {
                diffuse: {value: new rg(15658734)},
                opacity: {value: 1},
                map: {value: null},
                uvTransform: {value: new Em},
                alphaMap: {value: null}
            },
            specularmap: {specularMap: {value: null}},
            envmap: {
                envMap: {value: null},
                flipEnvMap: {value: -1},
                reflectivity: {value: 1},
                refractionRatio: {value: .98},
                maxMipLevel: {value: 0}
            },
            aomap: {aoMap: {value: null}, aoMapIntensity: {value: 1}},
            lightmap: {lightMap: {value: null}, lightMapIntensity: {value: 1}},
            emissivemap: {emissiveMap: {value: null}},
            bumpmap: {bumpMap: {value: null}, bumpScale: {value: 1}},
            normalmap: {normalMap: {value: null}, normalScale: {value: new xm(1, 1)}},
            displacementmap: {
                displacementMap: {value: null},
                displacementScale: {value: 1},
                displacementBias: {value: 0}
            },
            roughnessmap: {roughnessMap: {value: null}},
            metalnessmap: {metalnessMap: {value: null}},
            gradientmap: {gradientMap: {value: null}},
            fog: {
                fogDensity: {value: 25e-5},
                fogNear: {value: 1},
                fogFar: {value: 2e3},
                fogColor: {value: new rg(16777215)}
            },
            lights: {
                ambientLightColor: {value: []},
                lightProbe: {value: []},
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {value: []},
                directionalShadowMatrix: {value: []},
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotShadowMap: {value: []},
                spotShadowMatrix: {value: []},
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {value: []},
                pointShadowMatrix: {value: []},
                hemisphereLights: {value: [], properties: {direction: {}, skyColor: {}, groundColor: {}}},
                rectAreaLights: {value: [], properties: {color: {}, position: {}, width: {}, height: {}}}
            },
            points: {
                diffuse: {value: new rg(15658734)},
                opacity: {value: 1},
                size: {value: 1},
                scale: {value: 1},
                map: {value: null},
                uvTransform: {value: new Em}
            },
            sprite: {
                diffuse: {value: new rg(15658734)},
                opacity: {value: 1},
                center: {value: new xm(.5, .5)},
                rotation: {value: 0},
                map: {value: null},
                uvTransform: {value: new Em}
            }
        }, og = {
            basic: {
                uniforms: $m([ag.common, ag.specularmap, ag.envmap, ag.aomap, ag.lightmap, ag.fog]),
                vertexShader: Qm.meshbasic_vert,
                fragmentShader: Qm.meshbasic_frag
            },
            lambert: {
                uniforms: $m([ag.common, ag.specularmap, ag.envmap, ag.aomap, ag.lightmap, ag.emissivemap, ag.fog, ag.lights, {emissive: {value: new rg(0)}}]),
                vertexShader: Qm.meshlambert_vert,
                fragmentShader: Qm.meshlambert_frag
            },
            phong: {
                uniforms: $m([ag.common, ag.specularmap, ag.envmap, ag.aomap, ag.lightmap, ag.emissivemap, ag.bumpmap, ag.normalmap, ag.displacementmap, ag.gradientmap, ag.fog, ag.lights, {
                    emissive: {value: new rg(0)},
                    specular: {value: new rg(1118481)},
                    shininess: {value: 30}
                }]), vertexShader: Qm.meshphong_vert, fragmentShader: Qm.meshphong_frag
            },
            standard: {
                uniforms: $m([ag.common, ag.envmap, ag.aomap, ag.lightmap, ag.emissivemap, ag.bumpmap, ag.normalmap, ag.displacementmap, ag.roughnessmap, ag.metalnessmap, ag.fog, ag.lights, {
                    emissive: {value: new rg(0)},
                    roughness: {value: .5},
                    metalness: {value: .5},
                    envMapIntensity: {value: 1}
                }]), vertexShader: Qm.meshphysical_vert, fragmentShader: Qm.meshphysical_frag
            },
            matcap: {
                uniforms: $m([ag.common, ag.bumpmap, ag.normalmap, ag.displacementmap, ag.fog, {matcap: {value: null}}]),
                vertexShader: Qm.meshmatcap_vert,
                fragmentShader: Qm.meshmatcap_frag
            },
            points: {uniforms: $m([ag.points, ag.fog]), vertexShader: Qm.points_vert, fragmentShader: Qm.points_frag},
            dashed: {
                uniforms: $m([ag.common, ag.fog, {
                    scale: {value: 1},
                    dashSize: {value: 1},
                    totalSize: {value: 2}
                }]), vertexShader: Qm.linedashed_vert, fragmentShader: Qm.linedashed_frag
            },
            depth: {
                uniforms: $m([ag.common, ag.displacementmap]),
                vertexShader: Qm.depth_vert,
                fragmentShader: Qm.depth_frag
            },
            normal: {
                uniforms: $m([ag.common, ag.bumpmap, ag.normalmap, ag.displacementmap, {opacity: {value: 1}}]),
                vertexShader: Qm.normal_vert,
                fragmentShader: Qm.normal_frag
            },
            sprite: {uniforms: $m([ag.sprite, ag.fog]), vertexShader: Qm.sprite_vert, fragmentShader: Qm.sprite_frag},
            background: {
                uniforms: {uvTransform: {value: new Em}, t2D: {value: null}},
                vertexShader: Qm.background_vert,
                fragmentShader: Qm.background_frag
            },
            cube: {
                uniforms: {tCube: {value: null}, tFlip: {value: -1}, opacity: {value: 1}},
                vertexShader: Qm.cube_vert,
                fragmentShader: Qm.cube_frag
            },
            equirect: {
                uniforms: {tEquirect: {value: null}},
                vertexShader: Qm.equirect_vert,
                fragmentShader: Qm.equirect_frag
            },
            distanceRGBA: {
                uniforms: $m([ag.common, ag.displacementmap, {
                    referencePosition: {value: new _m},
                    nearDistance: {value: 1},
                    farDistance: {value: 1e3}
                }]), vertexShader: Qm.distanceRGBA_vert, fragmentShader: Qm.distanceRGBA_frag
            },
            shadow: {
                uniforms: $m([ag.lights, ag.fog, {color: {value: new rg(0)}, opacity: {value: 1}}]),
                vertexShader: Qm.shadow_vert,
                fragmentShader: Qm.shadow_frag
            }
        };

        function hg() {
            var t = null, e = !1, i = null;

            function n(r, s) {
                !1 !== e && (i(r, s), t.requestAnimationFrame(n))
            }

            return {
                start: function () {
                    !0 !== e && null !== i && (t.requestAnimationFrame(n), e = !0)
                }, stop: function () {
                    e = !1
                }, setAnimationLoop: function (t) {
                    i = t
                }, setContext: function (e) {
                    t = e
                }
            }
        }

        function lg(t) {
            var e = new WeakMap;
            return {
                get: function (t) {
                    return t.isInterleavedBufferAttribute && (t = t.data), e.get(t)
                }, remove: function (i) {
                    i.isInterleavedBufferAttribute && (i = i.data);
                    var n = e.get(i);
                    n && (t.deleteBuffer(n.buffer), e.delete(i))
                }, update: function (i, n) {
                    i.isInterleavedBufferAttribute && (i = i.data);
                    var r = e.get(i);
                    void 0 === r ? e.set(i, function (e, i) {
                        var n = e.array, r = e.dynamic ? 35048 : 35044, s = t.createBuffer();
                        t.bindBuffer(i, s), t.bufferData(i, n, r), e.onUploadCallback();
                        var a = 5126;
                        return n instanceof Float32Array ? a = 5126 : n instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : n instanceof Uint16Array ? a = 5123 : n instanceof Int16Array ? a = 5122 : n instanceof Uint32Array ? a = 5125 : n instanceof Int32Array ? a = 5124 : n instanceof Int8Array ? a = 5120 : n instanceof Uint8Array && (a = 5121), {
                            buffer: s,
                            type: a,
                            bytesPerElement: n.BYTES_PER_ELEMENT,
                            version: e.version
                        }
                    }(i, n)) : r.version < i.version && (!function (e, i, n) {
                        var r = i.array, s = i.updateRange;
                        t.bindBuffer(n, e), !1 === i.dynamic ? t.bufferData(n, r, 35044) : -1 === s.count ? t.bufferSubData(n, 0, r) : 0 === s.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t.bufferSubData(n, s.offset * r.BYTES_PER_ELEMENT, r.subarray(s.offset, s.offset + s.count)), s.count = -1)
                    }(r.buffer, i, n), r.version = i.version)
                }
            }
        }

        function cg(t, e, i, n, r, s) {
            this.a = t, this.b = e, this.c = i, this.normal = n && n.isVector3 ? n : new _m, this.vertexNormals = Array.isArray(n) ? n : [], this.color = r && r.isColor ? r : new rg, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== s ? s : 0
        }

        function ug(t, e, i, n) {
            this._x = t || 0, this._y = e || 0, this._z = i || 0, this._order = n || ug.DefaultOrder
        }

        function pg() {
            this.mask = 1
        }

        og.physical = {
            uniforms: $m([og.standard.uniforms, {clearCoat: {value: 0}, clearCoatRoughness: {value: 0}}]),
            vertexShader: Qm.meshphysical_vert,
            fragmentShader: Qm.meshphysical_frag
        }, Object.assign(cg.prototype, {
            clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
                for (var e = 0, i = t.vertexNormals.length; e < i; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
                for (e = 0, i = t.vertexColors.length; e < i; e++) this.vertexColors[e] = t.vertexColors[e].clone();
                return this
            }
        }), ug.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], ug.DefaultOrder = "XYZ", Object.defineProperties(ug.prototype, {
            x: {
                get: function () {
                    return this._x
                }, set: function (t) {
                    this._x = t, this.onChangeCallback()
                }
            }, y: {
                get: function () {
                    return this._y
                }, set: function (t) {
                    this._y = t, this.onChangeCallback()
                }
            }, z: {
                get: function () {
                    return this._z
                }, set: function (t) {
                    this._z = t, this.onChangeCallback()
                }
            }, order: {
                get: function () {
                    return this._order
                }, set: function (t) {
                    this._order = t, this.onChangeCallback()
                }
            }
        }), Object.assign(ug.prototype, {
            isEuler: !0, set: function (t, e, i, n) {
                return this._x = t, this._y = e, this._z = i, this._order = n || this._order, this.onChangeCallback(), this
            }, clone: function () {
                return new this.constructor(this._x, this._y, this._z, this._order)
            }, copy: function (t) {
                return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this
            }, setFromRotationMatrix: function (t, e, i) {
                var n = bm.clamp, r = t.elements, s = r[0], a = r[4], o = r[8], h = r[1], l = r[5], c = r[9], u = r[2],
                    p = r[6], d = r[10];
                return "XYZ" === (e = e || this._order) ? (this._y = Math.asin(n(o, -1, 1)), Math.abs(o) < .99999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-a, s)) : (this._x = Math.atan2(p, l), this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-n(c, -1, 1)), Math.abs(c) < .99999 ? (this._y = Math.atan2(o, d), this._z = Math.atan2(h, l)) : (this._y = Math.atan2(-u, s), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(n(p, -1, 1)), Math.abs(p) < .99999 ? (this._y = Math.atan2(-u, d), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(h, s))) : "ZYX" === e ? (this._y = Math.asin(-n(u, -1, 1)), Math.abs(u) < .99999 ? (this._x = Math.atan2(p, d), this._z = Math.atan2(h, s)) : (this._x = 0, this._z = Math.atan2(-a, l))) : "YZX" === e ? (this._z = Math.asin(n(h, -1, 1)), Math.abs(h) < .99999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-u, s)) : (this._x = 0, this._y = Math.atan2(o, d))) : "XZY" === e ? (this._z = Math.asin(-n(a, -1, 1)), Math.abs(a) < .99999 ? (this._x = Math.atan2(p, l), this._y = Math.atan2(o, s)) : (this._x = Math.atan2(-c, d), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e), this._order = e, !1 !== i && this.onChangeCallback(), this
            }, setFromQuaternion: function () {
                var t = new Jm;
                return function (e, i, n) {
                    return t.makeRotationFromQuaternion(e), this.setFromRotationMatrix(t, i, n)
                }
            }(), setFromVector3: function (t, e) {
                return this.set(t.x, t.y, t.z, e || this._order)
            }, reorder: (sg = new wm, function (t) {
                return sg.setFromEuler(this), this.setFromQuaternion(sg, t)
            }), equals: function (t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            }, fromArray: function (t) {
                return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this.onChangeCallback(), this
            }, toArray: function (t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
            }, toVector3: function (t) {
                return t ? t.set(this._x, this._y, this._z) : new _m(this._x, this._y, this._z)
            }, onChange: function (t) {
                return this.onChangeCallback = t, this
            }, onChangeCallback: function () {
            }
        }), Object.assign(pg.prototype, {
            set: function (t) {
                this.mask = 1 << t | 0
            }, enable: function (t) {
                this.mask |= 1 << t | 0
            }, toggle: function (t) {
                this.mask ^= 1 << t | 0
            }, disable: function (t) {
                this.mask &= ~(1 << t | 0)
            }, test: function (t) {
                return 0 != (this.mask & t.mask)
            }
        });
        var dg, fg, mg, gg = 0;

        function vg() {
            Object.defineProperty(this, "id", {value: gg++}), this.uuid = bm.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = vg.DefaultUp.clone();
            var t = new _m, e = new ug, i = new wm, n = new _m(1, 1, 1);
            e.onChange((function () {
                i.setFromEuler(e, !1)
            })), i.onChange((function () {
                e.setFromQuaternion(i, void 0, !1)
            })), Object.defineProperties(this, {
                position: {configurable: !0, enumerable: !0, value: t},
                rotation: {configurable: !0, enumerable: !0, value: e},
                quaternion: {configurable: !0, enumerable: !0, value: i},
                scale: {configurable: !0, enumerable: !0, value: n},
                modelViewMatrix: {value: new Jm},
                normalMatrix: {value: new Em}
            }), this.matrix = new Jm, this.matrixWorld = new Jm, this.matrixAutoUpdate = vg.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new pg, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
        }

        vg.DefaultUp = new _m(0, 1, 0), vg.DefaultMatrixAutoUpdate = !0, vg.prototype = Object.assign(Object.create(Vf.prototype), {
            constructor: vg, isObject3D: !0, onBeforeRender: function () {
            }, onAfterRender: function () {
            }, applyMatrix: function (t) {
                this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
            }, applyQuaternion: function (t) {
                return this.quaternion.premultiply(t), this
            }, setRotationFromAxisAngle: function (t, e) {
                this.quaternion.setFromAxisAngle(t, e)
            }, setRotationFromEuler: function (t) {
                this.quaternion.setFromEuler(t, !0)
            }, setRotationFromMatrix: function (t) {
                this.quaternion.setFromRotationMatrix(t)
            }, setRotationFromQuaternion: function (t) {
                this.quaternion.copy(t)
            }, rotateOnAxis: (mg = new wm, function (t, e) {
                return mg.setFromAxisAngle(t, e), this.quaternion.multiply(mg), this
            }), rotateOnWorldAxis: function () {
                var t = new wm;
                return function (e, i) {
                    return t.setFromAxisAngle(e, i), this.quaternion.premultiply(t), this
                }
            }(), rotateX: function () {
                var t = new _m(1, 0, 0);
                return function (e) {
                    return this.rotateOnAxis(t, e)
                }
            }(), rotateY: function () {
                var t = new _m(0, 1, 0);
                return function (e) {
                    return this.rotateOnAxis(t, e)
                }
            }(), rotateZ: function () {
                var t = new _m(0, 0, 1);
                return function (e) {
                    return this.rotateOnAxis(t, e)
                }
            }(), translateOnAxis: function () {
                var t = new _m;
                return function (e, i) {
                    return t.copy(e).applyQuaternion(this.quaternion), this.position.add(t.multiplyScalar(i)), this
                }
            }(), translateX: function () {
                var t = new _m(1, 0, 0);
                return function (e) {
                    return this.translateOnAxis(t, e)
                }
            }(), translateY: function () {
                var t = new _m(0, 1, 0);
                return function (e) {
                    return this.translateOnAxis(t, e)
                }
            }(), translateZ: function () {
                var t = new _m(0, 0, 1);
                return function (e) {
                    return this.translateOnAxis(t, e)
                }
            }(), localToWorld: function (t) {
                return t.applyMatrix4(this.matrixWorld)
            }, worldToLocal: (fg = new Jm, function (t) {
                return t.applyMatrix4(fg.getInverse(this.matrixWorld))
            }), lookAt: function () {
                var t = new wm, e = new Jm, i = new _m, n = new _m;
                return function (r, s, a) {
                    r.isVector3 ? i.copy(r) : i.set(r, s, a);
                    var o = this.parent;
                    this.updateWorldMatrix(!0, !1), n.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? e.lookAt(n, i, this.up) : e.lookAt(i, n, this.up), this.quaternion.setFromRotationMatrix(e), o && (e.extractRotation(o.matrixWorld), t.setFromRotationMatrix(e), this.quaternion.premultiply(t.inverse()))
                }
            }(), add: function (t) {
                if (arguments.length > 1) {
                    for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
                    return this
                }
                return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, t.dispatchEvent({type: "added"}), this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
            }, remove: function (t) {
                if (arguments.length > 1) {
                    for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                    return this
                }
                var i = this.children.indexOf(t);
                return -1 !== i && (t.parent = null, t.dispatchEvent({type: "removed"}), this.children.splice(i, 1)), this
            }, attach: (dg = new Jm, function (t) {
                return this.updateWorldMatrix(!0, !1), dg.getInverse(this.matrixWorld), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), dg.multiply(t.parent.matrixWorld)), t.applyMatrix(dg), t.updateWorldMatrix(!1, !1), this.add(t), this
            }), getObjectById: function (t) {
                return this.getObjectByProperty("id", t)
            }, getObjectByName: function (t) {
                return this.getObjectByProperty("name", t)
            }, getObjectByProperty: function (t, e) {
                if (this[t] === e) return this;
                for (var i = 0, n = this.children.length; i < n; i++) {
                    var r = this.children[i].getObjectByProperty(t, e);
                    if (void 0 !== r) return r
                }
            }, getWorldPosition: function (t) {
                return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new _m), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld)
            }, getWorldQuaternion: function () {
                var t = new _m, e = new _m;
                return function (i) {
                    return void 0 === i && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), i = new wm), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, i, e), i
                }
            }(), getWorldScale: function () {
                var t = new _m, e = new wm;
                return function (i) {
                    return void 0 === i && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), i = new _m), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, e, i), i
                }
            }(), getWorldDirection: function (t) {
                void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new _m), this.updateMatrixWorld(!0);
                var e = this.matrixWorld.elements;
                return t.set(e[8], e[9], e[10]).normalize()
            }, raycast: function () {
            }, traverse: function (t) {
                t(this);
                for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverse(t)
            }, traverseVisible: function (t) {
                if (!1 !== this.visible) {
                    t(this);
                    for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t)
                }
            }, traverseAncestors: function (t) {
                var e = this.parent;
                null !== e && (t(e), e.traverseAncestors(t))
            }, updateMatrix: function () {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
            }, updateMatrixWorld: function (t) {
                this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t)
            }, updateWorldMatrix: function (t, e) {
                var i = this.parent;
                if (!0 === t && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) for (var n = this.children, r = 0, s = n.length; r < s; r++) n[r].updateWorldMatrix(!1, !0)
            }, toJSON: function (t) {
                var e = void 0 === t || "string" == typeof t, i = {};
                e && (t = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {}
                }, i.metadata = {version: 4.5, type: "Object", generator: "Object3D.toJSON"});
                var n = {};

                function r(e, i) {
                    return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)), i.uuid
                }

                if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), !0 === this.castShadow && (n.castShadow = !0), !0 === this.receiveShadow && (n.receiveShadow = !0), !1 === this.visible && (n.visible = !1), !1 === this.frustumCulled && (n.frustumCulled = !1), 0 !== this.renderOrder && (n.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1), this.isMesh && 0 !== this.drawMode && (n.drawMode = this.drawMode), this.isMesh || this.isLine || this.isPoints) {
                    n.geometry = r(t.geometries, this.geometry);
                    var s = this.geometry.parameters;
                    if (void 0 !== s && void 0 !== s.shapes) {
                        var a = s.shapes;
                        if (Array.isArray(a)) for (var o = 0, h = a.length; o < h; o++) {
                            var l = a[o];
                            r(t.shapes, l)
                        } else r(t.shapes, a)
                    }
                }
                if (void 0 !== this.material) if (Array.isArray(this.material)) {
                    var c = [];
                    for (o = 0, h = this.material.length; o < h; o++) c.push(r(t.materials, this.material[o]));
                    n.material = c
                } else n.material = r(t.materials, this.material);
                if (this.children.length > 0) {
                    n.children = [];
                    for (o = 0; o < this.children.length; o++) n.children.push(this.children[o].toJSON(t).object)
                }
                if (e) {
                    var u = m(t.geometries), p = m(t.materials), d = m(t.textures), f = m(t.images);
                    a = m(t.shapes);
                    u.length > 0 && (i.geometries = u), p.length > 0 && (i.materials = p), d.length > 0 && (i.textures = d), f.length > 0 && (i.images = f), a.length > 0 && (i.shapes = a)
                }
                return i.object = n, i;

                function m(t) {
                    var e = [];
                    for (var i in t) {
                        var n = t[i];
                        delete n.metadata, e.push(n)
                    }
                    return e
                }
            }, clone: function (t) {
                return (new this.constructor).copy(this, t)
            }, copy: function (t, e) {
                if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e) for (var i = 0; i < t.children.length; i++) {
                    var n = t.children[i];
                    this.add(n.clone())
                }
                return this
            }
        });
        var yg, bg, xg = 0;

        function wg() {
            Object.defineProperty(this, "id", {value: xg += 2}), this.uuid = bm.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
        }

        function _g(t, e, i) {
            if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === i, this.dynamic = !1, this.updateRange = {
                offset: 0,
                count: -1
            }, this.version = 0
        }

        function Eg(t, e, i) {
            _g.call(this, new Int8Array(t), e, i)
        }

        function Mg(t, e, i) {
            _g.call(this, new Uint8Array(t), e, i)
        }

        function Ag(t, e, i) {
            _g.call(this, new Uint8ClampedArray(t), e, i)
        }

        function Sg(t, e, i) {
            _g.call(this, new Int16Array(t), e, i)
        }

        function Tg(t, e, i) {
            _g.call(this, new Uint16Array(t), e, i)
        }

        function Dg(t, e, i) {
            _g.call(this, new Int32Array(t), e, i)
        }

        function Cg(t, e, i) {
            _g.call(this, new Uint32Array(t), e, i)
        }

        function Pg(t, e, i) {
            _g.call(this, new Float32Array(t), e, i)
        }

        function Ig(t, e, i) {
            _g.call(this, new Float64Array(t), e, i)
        }

        function Lg() {
            this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
        }

        function Rg(t) {
            if (0 === t.length) return -1 / 0;
            for (var e = t[0], i = 1, n = t.length; i < n; ++i) t[i] > e && (e = t[i]);
            return e
        }

        wg.prototype = Object.assign(Object.create(Vf.prototype), {
            constructor: wg, isGeometry: !0, applyMatrix: function (t) {
                for (var e = (new Em).getNormalMatrix(t), i = 0, n = this.vertices.length; i < n; i++) {
                    this.vertices[i].applyMatrix4(t)
                }
                for (i = 0, n = this.faces.length; i < n; i++) {
                    var r = this.faces[i];
                    r.normal.applyMatrix3(e).normalize();
                    for (var s = 0, a = r.vertexNormals.length; s < a; s++) r.vertexNormals[s].applyMatrix3(e).normalize()
                }
                return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
            }, rotateX: function () {
                var t = new Jm;
                return function (e) {
                    return t.makeRotationX(e), this.applyMatrix(t), this
                }
            }(), rotateY: function () {
                var t = new Jm;
                return function (e) {
                    return t.makeRotationY(e), this.applyMatrix(t), this
                }
            }(), rotateZ: function () {
                var t = new Jm;
                return function (e) {
                    return t.makeRotationZ(e), this.applyMatrix(t), this
                }
            }(), translate: function () {
                var t = new Jm;
                return function (e, i, n) {
                    return t.makeTranslation(e, i, n), this.applyMatrix(t), this
                }
            }(), scale: function () {
                var t = new Jm;
                return function (e, i, n) {
                    return t.makeScale(e, i, n), this.applyMatrix(t), this
                }
            }(), lookAt: (bg = new vg, function (t) {
                bg.lookAt(t), bg.updateMatrix(), this.applyMatrix(bg.matrix)
            }), fromBufferGeometry: function (t) {
                var e = this, i = null !== t.index ? t.index.array : void 0, n = t.attributes, r = n.position.array,
                    s = void 0 !== n.normal ? n.normal.array : void 0, a = void 0 !== n.color ? n.color.array : void 0,
                    o = void 0 !== n.uv ? n.uv.array : void 0, h = void 0 !== n.uv2 ? n.uv2.array : void 0;
                void 0 !== h && (this.faceVertexUvs[1] = []);
                for (var l = 0; l < r.length; l += 3) e.vertices.push((new _m).fromArray(r, l)), void 0 !== a && e.colors.push((new rg).fromArray(a, l));

                function c(t, i, n, r) {
                    var l = void 0 === a ? [] : [e.colors[t].clone(), e.colors[i].clone(), e.colors[n].clone()],
                        c = new cg(t, i, n, void 0 === s ? [] : [(new _m).fromArray(s, 3 * t), (new _m).fromArray(s, 3 * i), (new _m).fromArray(s, 3 * n)], l, r);
                    e.faces.push(c), void 0 !== o && e.faceVertexUvs[0].push([(new xm).fromArray(o, 2 * t), (new xm).fromArray(o, 2 * i), (new xm).fromArray(o, 2 * n)]), void 0 !== h && e.faceVertexUvs[1].push([(new xm).fromArray(h, 2 * t), (new xm).fromArray(h, 2 * i), (new xm).fromArray(h, 2 * n)])
                }

                var u = t.groups;
                if (u.length > 0) for (l = 0; l < u.length; l++) for (var p = u[l], d = p.start, f = d, m = d + p.count; f < m; f += 3) void 0 !== i ? c(i[f], i[f + 1], i[f + 2], p.materialIndex) : c(f, f + 1, f + 2, p.materialIndex); else if (void 0 !== i) for (l = 0; l < i.length; l += 3) c(i[l], i[l + 1], i[l + 2]); else for (l = 0; l < r.length / 3; l += 3) c(l, l + 1, l + 2);
                return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
            }, center: (yg = new _m, function () {
                return this.computeBoundingBox(), this.boundingBox.getCenter(yg).negate(), this.translate(yg.x, yg.y, yg.z), this
            }), normalize: function () {
                this.computeBoundingSphere();
                var t = this.boundingSphere.center, e = this.boundingSphere.radius, i = 0 === e ? 1 : 1 / e, n = new Jm;
                return n.set(i, 0, 0, -i * t.x, 0, i, 0, -i * t.y, 0, 0, i, -i * t.z, 0, 0, 0, 1), this.applyMatrix(n), this
            }, computeFaceNormals: function () {
                for (var t = new _m, e = new _m, i = 0, n = this.faces.length; i < n; i++) {
                    var r = this.faces[i], s = this.vertices[r.a], a = this.vertices[r.b], o = this.vertices[r.c];
                    t.subVectors(o, a), e.subVectors(s, a), t.cross(e), t.normalize(), r.normal.copy(t)
                }
            }, computeVertexNormals: function (t) {
                var e, i, n, r, s, a;
                for (void 0 === t && (t = !0), a = new Array(this.vertices.length), e = 0, i = this.vertices.length; e < i; e++) a[e] = new _m;
                if (t) {
                    var o, h, l, c = new _m, u = new _m;
                    for (n = 0, r = this.faces.length; n < r; n++) s = this.faces[n], o = this.vertices[s.a], h = this.vertices[s.b], l = this.vertices[s.c], c.subVectors(l, h), u.subVectors(o, h), c.cross(u), a[s.a].add(c), a[s.b].add(c), a[s.c].add(c)
                } else for (this.computeFaceNormals(), n = 0, r = this.faces.length; n < r; n++) a[(s = this.faces[n]).a].add(s.normal), a[s.b].add(s.normal), a[s.c].add(s.normal);
                for (e = 0, i = this.vertices.length; e < i; e++) a[e].normalize();
                for (n = 0, r = this.faces.length; n < r; n++) {
                    var p = (s = this.faces[n]).vertexNormals;
                    3 === p.length ? (p[0].copy(a[s.a]), p[1].copy(a[s.b]), p[2].copy(a[s.c])) : (p[0] = a[s.a].clone(), p[1] = a[s.b].clone(), p[2] = a[s.c].clone())
                }
                this.faces.length > 0 && (this.normalsNeedUpdate = !0)
            }, computeFlatVertexNormals: function () {
                var t, e, i;
                for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) {
                    var n = (i = this.faces[t]).vertexNormals;
                    3 === n.length ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] = i.normal.clone())
                }
                this.faces.length > 0 && (this.normalsNeedUpdate = !0)
            }, computeMorphNormals: function () {
                var t, e, i, n, r;
                for (i = 0, n = this.faces.length; i < n; i++) for ((r = this.faces[i]).__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), t = 0, e = r.vertexNormals.length; t < e; t++) r.__originalVertexNormals[t] ? r.__originalVertexNormals[t].copy(r.vertexNormals[t]) : r.__originalVertexNormals[t] = r.vertexNormals[t].clone();
                var s = new wg;
                for (s.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) {
                    if (!this.morphNormals[t]) {
                        this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = [];
                        var a = this.morphNormals[t].faceNormals, o = this.morphNormals[t].vertexNormals;
                        for (i = 0, n = this.faces.length; i < n; i++) h = new _m, l = {
                            a: new _m,
                            b: new _m,
                            c: new _m
                        }, a.push(h), o.push(l)
                    }
                    var h, l, c = this.morphNormals[t];
                    for (s.vertices = this.morphTargets[t].vertices, s.computeFaceNormals(), s.computeVertexNormals(), i = 0, n = this.faces.length; i < n; i++) r = this.faces[i], h = c.faceNormals[i], l = c.vertexNormals[i], h.copy(r.normal), l.a.copy(r.vertexNormals[0]), l.b.copy(r.vertexNormals[1]), l.c.copy(r.vertexNormals[2])
                }
                for (i = 0, n = this.faces.length; i < n; i++) (r = this.faces[i]).normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals
            }, computeBoundingBox: function () {
                null === this.boundingBox && (this.boundingBox = new qm), this.boundingBox.setFromPoints(this.vertices)
            }, computeBoundingSphere: function () {
                null === this.boundingSphere && (this.boundingSphere = new Xm), this.boundingSphere.setFromPoints(this.vertices)
            }, merge: function (t, e, i) {
                if (t && t.isGeometry) {
                    var n, r = this.vertices.length, s = this.vertices, a = t.vertices, o = this.faces, h = t.faces,
                        l = this.faceVertexUvs[0], c = t.faceVertexUvs[0], u = this.colors, p = t.colors;
                    void 0 === i && (i = 0), void 0 !== e && (n = (new Em).getNormalMatrix(e));
                    for (var d = 0, f = a.length; d < f; d++) {
                        var m = a[d].clone();
                        void 0 !== e && m.applyMatrix4(e), s.push(m)
                    }
                    for (d = 0, f = p.length; d < f; d++) u.push(p[d].clone());
                    for (d = 0, f = h.length; d < f; d++) {
                        var g, v, y, b = h[d], x = b.vertexNormals, w = b.vertexColors;
                        (g = new cg(b.a + r, b.b + r, b.c + r)).normal.copy(b.normal), void 0 !== n && g.normal.applyMatrix3(n).normalize();
                        for (var _ = 0, E = x.length; _ < E; _++) v = x[_].clone(), void 0 !== n && v.applyMatrix3(n).normalize(), g.vertexNormals.push(v);
                        g.color.copy(b.color);
                        for (_ = 0, E = w.length; _ < E; _++) y = w[_], g.vertexColors.push(y.clone());
                        g.materialIndex = b.materialIndex + i, o.push(g)
                    }
                    for (d = 0, f = c.length; d < f; d++) {
                        var M = c[d], A = [];
                        if (void 0 !== M) {
                            for (_ = 0, E = M.length; _ < E; _++) A.push(M[_].clone());
                            l.push(A)
                        }
                    }
                } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t)
            }, mergeMesh: function (t) {
                t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
            }, mergeVertices: function () {
                var t, e, i, n, r, s, a, o, h = {}, l = [], c = [], u = Math.pow(10, 4);
                for (i = 0, n = this.vertices.length; i < n; i++) t = this.vertices[i], void 0 === h[e = Math.round(t.x * u) + "_" + Math.round(t.y * u) + "_" + Math.round(t.z * u)] ? (h[e] = i, l.push(this.vertices[i]), c[i] = l.length - 1) : c[i] = c[h[e]];
                var p = [];
                for (i = 0, n = this.faces.length; i < n; i++) {
                    (r = this.faces[i]).a = c[r.a], r.b = c[r.b], r.c = c[r.c], s = [r.a, r.b, r.c];
                    for (var d = 0; d < 3; d++) if (s[d] === s[(d + 1) % 3]) {
                        p.push(i);
                        break
                    }
                }
                for (i = p.length - 1; i >= 0; i--) {
                    var f = p[i];
                    for (this.faces.splice(f, 1), a = 0, o = this.faceVertexUvs.length; a < o; a++) this.faceVertexUvs[a].splice(f, 1)
                }
                var m = this.vertices.length - l.length;
                return this.vertices = l, m
            }, setFromPoints: function (t) {
                this.vertices = [];
                for (var e = 0, i = t.length; e < i; e++) {
                    var n = t[e];
                    this.vertices.push(new _m(n.x, n.y, n.z || 0))
                }
                return this
            }, sortFacesByMaterialIndex: function () {
                for (var t = this.faces, e = t.length, i = 0; i < e; i++) t[i]._id = i;
                t.sort((function (t, e) {
                    return t.materialIndex - e.materialIndex
                }));
                var n, r, s = this.faceVertexUvs[0], a = this.faceVertexUvs[1];
                s && s.length === e && (n = []), a && a.length === e && (r = []);
                for (i = 0; i < e; i++) {
                    var o = t[i]._id;
                    n && n.push(s[o]), r && r.push(a[o])
                }
                n && (this.faceVertexUvs[0] = n), r && (this.faceVertexUvs[1] = r)
            }, toJSON: function () {
                var t = {metadata: {version: 4.5, type: "Geometry", generator: "Geometry.toJSON"}};
                if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                    var e = this.parameters;
                    for (var i in e) void 0 !== e[i] && (t[i] = e[i]);
                    return t
                }
                for (var n = [], r = 0; r < this.vertices.length; r++) {
                    var s = this.vertices[r];
                    n.push(s.x, s.y, s.z)
                }
                var a = [], o = [], h = {}, l = [], c = {}, u = [], p = {};
                for (r = 0; r < this.faces.length; r++) {
                    var d = this.faces[r], f = void 0 !== this.faceVertexUvs[0][r], m = d.normal.length() > 0,
                        g = d.vertexNormals.length > 0, v = 1 !== d.color.r || 1 !== d.color.g || 1 !== d.color.b,
                        y = d.vertexColors.length > 0, b = 0;
                    if (b = E(b, 0, 0), b = E(b, 1, !0), b = E(b, 2, !1), b = E(b, 3, f), b = E(b, 4, m), b = E(b, 5, g), b = E(b, 6, v), b = E(b, 7, y), a.push(b), a.push(d.a, d.b, d.c), a.push(d.materialIndex), f) {
                        var x = this.faceVertexUvs[0][r];
                        a.push(S(x[0]), S(x[1]), S(x[2]))
                    }
                    if (m && a.push(M(d.normal)), g) {
                        var w = d.vertexNormals;
                        a.push(M(w[0]), M(w[1]), M(w[2]))
                    }
                    if (v && a.push(A(d.color)), y) {
                        var _ = d.vertexColors;
                        a.push(A(_[0]), A(_[1]), A(_[2]))
                    }
                }

                function E(t, e, i) {
                    return i ? t | 1 << e : t & ~(1 << e)
                }

                function M(t) {
                    var e = t.x.toString() + t.y.toString() + t.z.toString();
                    return void 0 !== h[e] || (h[e] = o.length / 3, o.push(t.x, t.y, t.z)), h[e]
                }

                function A(t) {
                    var e = t.r.toString() + t.g.toString() + t.b.toString();
                    return void 0 !== c[e] || (c[e] = l.length, l.push(t.getHex())), c[e]
                }

                function S(t) {
                    var e = t.x.toString() + t.y.toString();
                    return void 0 !== p[e] || (p[e] = u.length / 2, u.push(t.x, t.y)), p[e]
                }

                return t.data = {}, t.data.vertices = n, t.data.normals = o, l.length > 0 && (t.data.colors = l), u.length > 0 && (t.data.uvs = [u]), t.data.faces = a, t
            }, clone: function () {
                return (new wg).copy(this)
            }, copy: function (t) {
                var e, i, n, r, s, a;
                this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                var o = t.vertices;
                for (e = 0, i = o.length; e < i; e++) this.vertices.push(o[e].clone());
                var h = t.colors;
                for (e = 0, i = h.length; e < i; e++) this.colors.push(h[e].clone());
                var l = t.faces;
                for (e = 0, i = l.length; e < i; e++) this.faces.push(l[e].clone());
                for (e = 0, i = t.faceVertexUvs.length; e < i; e++) {
                    var c = t.faceVertexUvs[e];
                    for (void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []), n = 0, r = c.length; n < r; n++) {
                        var u = c[n], p = [];
                        for (s = 0, a = u.length; s < a; s++) {
                            var d = u[s];
                            p.push(d.clone())
                        }
                        this.faceVertexUvs[e].push(p)
                    }
                }
                var f = t.morphTargets;
                for (e = 0, i = f.length; e < i; e++) {
                    var m = {};
                    if (m.name = f[e].name, void 0 !== f[e].vertices) for (m.vertices = [], n = 0, r = f[e].vertices.length; n < r; n++) m.vertices.push(f[e].vertices[n].clone());
                    if (void 0 !== f[e].normals) for (m.normals = [], n = 0, r = f[e].normals.length; n < r; n++) m.normals.push(f[e].normals[n].clone());
                    this.morphTargets.push(m)
                }
                var g = t.morphNormals;
                for (e = 0, i = g.length; e < i; e++) {
                    var v = {};
                    if (void 0 !== g[e].vertexNormals) for (v.vertexNormals = [], n = 0, r = g[e].vertexNormals.length; n < r; n++) {
                        var y = g[e].vertexNormals[n], b = {};
                        b.a = y.a.clone(), b.b = y.b.clone(), b.c = y.c.clone(), v.vertexNormals.push(b)
                    }
                    if (void 0 !== g[e].faceNormals) for (v.faceNormals = [], n = 0, r = g[e].faceNormals.length; n < r; n++) v.faceNormals.push(g[e].faceNormals[n].clone());
                    this.morphNormals.push(v)
                }
                var x = t.skinWeights;
                for (e = 0, i = x.length; e < i; e++) this.skinWeights.push(x[e].clone());
                var w = t.skinIndices;
                for (e = 0, i = w.length; e < i; e++) this.skinIndices.push(w[e].clone());
                var _ = t.lineDistances;
                for (e = 0, i = _.length; e < i; e++) this.lineDistances.push(_[e]);
                var E = t.boundingBox;
                null !== E && (this.boundingBox = E.clone());
                var M = t.boundingSphere;
                return null !== M && (this.boundingSphere = M.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
            }, dispose: function () {
                this.dispatchEvent({type: "dispose"})
            }
        }), Object.defineProperty(_g.prototype, "needsUpdate", {
            set: function (t) {
                !0 === t && this.version++
            }
        }), Object.assign(_g.prototype, {
            isBufferAttribute: !0, onUploadCallback: function () {
            }, setArray: function (t) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                return this.count = void 0 !== t ? t.length / this.itemSize : 0, this.array = t, this
            }, setDynamic: function (t) {
                return this.dynamic = t, this
            }, copy: function (t) {
                return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.dynamic = t.dynamic, this
            }, copyAt: function (t, e, i) {
                t *= this.itemSize, i *= e.itemSize;
                for (var n = 0, r = this.itemSize; n < r; n++) this.array[t + n] = e.array[i + n];
                return this
            }, copyArray: function (t) {
                return this.array.set(t), this
            }, copyColorsArray: function (t) {
                for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                    var s = t[n];
                    void 0 === s && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), s = new rg), e[i++] = s.r, e[i++] = s.g, e[i++] = s.b
                }
                return this
            }, copyVector2sArray: function (t) {
                for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                    var s = t[n];
                    void 0 === s && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n), s = new xm), e[i++] = s.x, e[i++] = s.y
                }
                return this
            }, copyVector3sArray: function (t) {
                for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                    var s = t[n];
                    void 0 === s && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), s = new _m), e[i++] = s.x, e[i++] = s.y, e[i++] = s.z
                }
                return this
            }, copyVector4sArray: function (t) {
                for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                    var s = t[n];
                    void 0 === s && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), s = new Vm), e[i++] = s.x, e[i++] = s.y, e[i++] = s.z, e[i++] = s.w
                }
                return this
            }, set: function (t, e) {
                return void 0 === e && (e = 0), this.array.set(t, e), this
            }, getX: function (t) {
                return this.array[t * this.itemSize]
            }, setX: function (t, e) {
                return this.array[t * this.itemSize] = e, this
            }, getY: function (t) {
                return this.array[t * this.itemSize + 1]
            }, setY: function (t, e) {
                return this.array[t * this.itemSize + 1] = e, this
            }, getZ: function (t) {
                return this.array[t * this.itemSize + 2]
            }, setZ: function (t, e) {
                return this.array[t * this.itemSize + 2] = e, this
            }, getW: function (t) {
                return this.array[t * this.itemSize + 3]
            }, setW: function (t, e) {
                return this.array[t * this.itemSize + 3] = e, this
            }, setXY: function (t, e, i) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this
            }, setXYZ: function (t, e, i, n) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this
            }, setXYZW: function (t, e, i, n, r) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this.array[t + 3] = r, this
            }, onUpload: function (t) {
                return this.onUploadCallback = t, this
            }, clone: function () {
                return new this.constructor(this.array, this.itemSize).copy(this)
            }, toJSON: function () {
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.prototype.slice.call(this.array),
                    normalized: this.normalized
                }
            }
        }), Eg.prototype = Object.create(_g.prototype), Eg.prototype.constructor = Eg, Mg.prototype = Object.create(_g.prototype), Mg.prototype.constructor = Mg, Ag.prototype = Object.create(_g.prototype), Ag.prototype.constructor = Ag, Sg.prototype = Object.create(_g.prototype), Sg.prototype.constructor = Sg, Tg.prototype = Object.create(_g.prototype), Tg.prototype.constructor = Tg, Dg.prototype = Object.create(_g.prototype), Dg.prototype.constructor = Dg, Cg.prototype = Object.create(_g.prototype), Cg.prototype.constructor = Cg, Pg.prototype = Object.create(_g.prototype), Pg.prototype.constructor = Pg, Ig.prototype = Object.create(_g.prototype), Ig.prototype.constructor = Ig, Object.assign(Lg.prototype, {
            computeGroups: function (t) {
                for (var e, i = [], n = void 0, r = t.faces, s = 0; s < r.length; s++) {
                    var a = r[s];
                    a.materialIndex !== n && (n = a.materialIndex, void 0 !== e && (e.count = 3 * s - e.start, i.push(e)), e = {
                        start: 3 * s,
                        materialIndex: n
                    })
                }
                void 0 !== e && (e.count = 3 * s - e.start, i.push(e)), this.groups = i
            }, fromGeometry: function (t) {
                var e, i = t.faces, n = t.vertices, r = t.faceVertexUvs, s = r[0] && r[0].length > 0,
                    a = r[1] && r[1].length > 0, o = t.morphTargets, h = o.length;
                if (h > 0) {
                    e = [];
                    for (var l = 0; l < h; l++) e[l] = {name: o[l].name, data: []};
                    this.morphTargets.position = e
                }
                var c, u = t.morphNormals, p = u.length;
                if (p > 0) {
                    c = [];
                    for (l = 0; l < p; l++) c[l] = {name: u[l].name, data: []};
                    this.morphTargets.normal = c
                }
                var d = t.skinIndices, f = t.skinWeights, m = d.length === n.length, g = f.length === n.length;
                n.length > 0 && 0 === i.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
                for (l = 0; l < i.length; l++) {
                    var v = i[l];
                    this.vertices.push(n[v.a], n[v.b], n[v.c]);
                    var y = v.vertexNormals;
                    if (3 === y.length) this.normals.push(y[0], y[1], y[2]); else {
                        var b = v.normal;
                        this.normals.push(b, b, b)
                    }
                    var x, w = v.vertexColors;
                    if (3 === w.length) this.colors.push(w[0], w[1], w[2]); else {
                        var _ = v.color;
                        this.colors.push(_, _, _)
                    }
                    if (!0 === s) void 0 !== (x = r[0][l]) ? this.uvs.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", l), this.uvs.push(new xm, new xm, new xm));
                    if (!0 === a) void 0 !== (x = r[1][l]) ? this.uvs2.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", l), this.uvs2.push(new xm, new xm, new xm));
                    for (var E = 0; E < h; E++) {
                        var M = o[E].vertices;
                        e[E].data.push(M[v.a], M[v.b], M[v.c])
                    }
                    for (E = 0; E < p; E++) {
                        var A = u[E].vertexNormals[l];
                        c[E].data.push(A.a, A.b, A.c)
                    }
                    m && this.skinIndices.push(d[v.a], d[v.b], d[v.c]), g && this.skinWeights.push(f[v.a], f[v.b], f[v.c])
                }
                return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
            }
        });
        var Fg = 1;

        function kg() {
            Object.defineProperty(this, "id", {value: Fg += 2}), this.uuid = bm.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                start: 0,
                count: 1 / 0
            }, this.userData = {}
        }

        function Og(t, e, i, n, r, s) {
            wg.call(this), this.type = "BoxGeometry", this.parameters = {
                width: t,
                height: e,
                depth: i,
                widthSegments: n,
                heightSegments: r,
                depthSegments: s
            }, this.fromBufferGeometry(new zg(t, e, i, n, r, s)), this.mergeVertices()
        }

        function zg(t, e, i, n, r, s) {
            kg.call(this), this.type = "BoxBufferGeometry", this.parameters = {
                width: t,
                height: e,
                depth: i,
                widthSegments: n,
                heightSegments: r,
                depthSegments: s
            };
            var a = this;
            t = t || 1, e = e || 1, i = i || 1, n = Math.floor(n) || 1, r = Math.floor(r) || 1, s = Math.floor(s) || 1;
            var o = [], h = [], l = [], c = [], u = 0, p = 0;

            function d(t, e, i, n, r, s, d, f, m, g, v) {
                var y, b, x = s / m, w = d / g, _ = s / 2, E = d / 2, M = f / 2, A = m + 1, S = g + 1, T = 0, D = 0,
                    C = new _m;
                for (b = 0; b < S; b++) {
                    var P = b * w - E;
                    for (y = 0; y < A; y++) {
                        var I = y * x - _;
                        C[t] = I * n, C[e] = P * r, C[i] = M, h.push(C.x, C.y, C.z), C[t] = 0, C[e] = 0, C[i] = f > 0 ? 1 : -1, l.push(C.x, C.y, C.z), c.push(y / m), c.push(1 - b / g), T += 1
                    }
                }
                for (b = 0; b < g; b++) for (y = 0; y < m; y++) {
                    var L = u + y + A * b, R = u + y + A * (b + 1), F = u + (y + 1) + A * (b + 1),
                        k = u + (y + 1) + A * b;
                    o.push(L, R, k), o.push(R, F, k), D += 6
                }
                a.addGroup(p, D, v), p += D, u += T
            }

            d("z", "y", "x", -1, -1, i, e, t, s, r, 0), d("z", "y", "x", 1, -1, i, e, -t, s, r, 1), d("x", "z", "y", 1, 1, t, i, e, n, s, 2), d("x", "z", "y", 1, -1, t, i, -e, n, s, 3), d("x", "y", "z", 1, -1, t, e, i, n, r, 4), d("x", "y", "z", -1, -1, t, e, -i, n, r, 5), this.setIndex(o), this.addAttribute("position", new Pg(h, 3)), this.addAttribute("normal", new Pg(l, 3)), this.addAttribute("uv", new Pg(c, 2))
        }

        function Bg(t, e, i, n) {
            wg.call(this), this.type = "PlaneGeometry", this.parameters = {
                width: t,
                height: e,
                widthSegments: i,
                heightSegments: n
            }, this.fromBufferGeometry(new Ng(t, e, i, n)), this.mergeVertices()
        }

        function Ng(t, e, i, n) {
            kg.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                width: t,
                height: e,
                widthSegments: i,
                heightSegments: n
            };
            var r, s, a = (t = t || 1) / 2, o = (e = e || 1) / 2, h = Math.floor(i) || 1, l = Math.floor(n) || 1,
                c = h + 1, u = l + 1, p = t / h, d = e / l, f = [], m = [], g = [], v = [];
            for (s = 0; s < u; s++) {
                var y = s * d - o;
                for (r = 0; r < c; r++) {
                    var b = r * p - a;
                    m.push(b, -y, 0), g.push(0, 0, 1), v.push(r / h), v.push(1 - s / l)
                }
            }
            for (s = 0; s < l; s++) for (r = 0; r < h; r++) {
                var x = r + c * s, w = r + c * (s + 1), _ = r + 1 + c * (s + 1), E = r + 1 + c * s;
                f.push(x, w, E), f.push(w, _, E)
            }
            this.setIndex(f), this.addAttribute("position", new Pg(m, 3)), this.addAttribute("normal", new Pg(g, 3)), this.addAttribute("uv", new Pg(v, 2))
        }

        kg.prototype = Object.assign(Object.create(Vf.prototype), {
            constructor: kg, isBufferGeometry: !0, getIndex: function () {
                return this.index
            }, setIndex: function (t) {
                Array.isArray(t) ? this.index = new (Rg(t) > 65535 ? Cg : Tg)(t, 1) : this.index = t
            }, addAttribute: function (t, e) {
                return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : (this.attributes[t] = e, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(t, new _g(arguments[1], arguments[2])))
            }, getAttribute: function (t) {
                return this.attributes[t]
            }, removeAttribute: function (t) {
                return delete this.attributes[t], this
            }, addGroup: function (t, e, i) {
                this.groups.push({start: t, count: e, materialIndex: void 0 !== i ? i : 0})
            }, clearGroups: function () {
                this.groups = []
            }, setDrawRange: function (t, e) {
                this.drawRange.start = t, this.drawRange.count = e
            }, applyMatrix: function (t) {
                var e = this.attributes.position;
                void 0 !== e && (t.applyToBufferAttribute(e), e.needsUpdate = !0);
                var i = this.attributes.normal;
                void 0 !== i && ((new Em).getNormalMatrix(t).applyToBufferAttribute(i), i.needsUpdate = !0);
                var n = this.attributes.tangent;
                void 0 !== n && ((new Em).getNormalMatrix(t).applyToBufferAttribute(n), n.needsUpdate = !0);
                return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
            }, rotateX: function () {
                var t = new Jm;
                return function (e) {
                    return t.makeRotationX(e), this.applyMatrix(t), this
                }
            }(), rotateY: function () {
                var t = new Jm;
                return function (e) {
                    return t.makeRotationY(e), this.applyMatrix(t), this
                }
            }(), rotateZ: function () {
                var t = new Jm;
                return function (e) {
                    return t.makeRotationZ(e), this.applyMatrix(t), this
                }
            }(), translate: function () {
                var t = new Jm;
                return function (e, i, n) {
                    return t.makeTranslation(e, i, n), this.applyMatrix(t), this
                }
            }(), scale: function () {
                var t = new Jm;
                return function (e, i, n) {
                    return t.makeScale(e, i, n), this.applyMatrix(t), this
                }
            }(), lookAt: function () {
                var t = new vg;
                return function (e) {
                    t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
                }
            }(), center: function () {
                var t = new _m;
                return function () {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this
                }
            }(), setFromObject: function (t) {
                var e = t.geometry;
                if (t.isPoints || t.isLine) {
                    var i = new Pg(3 * e.vertices.length, 3), n = new Pg(3 * e.colors.length, 3);
                    if (this.addAttribute("position", i.copyVector3sArray(e.vertices)), this.addAttribute("color", n.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
                        var r = new Pg(e.lineDistances.length, 1);
                        this.addAttribute("lineDistance", r.copyArray(e.lineDistances))
                    }
                    null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
                } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
                return this
            }, setFromPoints: function (t) {
                for (var e = [], i = 0, n = t.length; i < n; i++) {
                    var r = t[i];
                    e.push(r.x, r.y, r.z || 0)
                }
                return this.addAttribute("position", new Pg(e, 3)), this
            }, updateFromObject: function (t) {
                var e, i = t.geometry;
                if (t.isMesh) {
                    var n = i.__directGeometry;
                    if (!0 === i.elementsNeedUpdate && (n = void 0, i.elementsNeedUpdate = !1), void 0 === n) return this.fromGeometry(i);
                    n.verticesNeedUpdate = i.verticesNeedUpdate, n.normalsNeedUpdate = i.normalsNeedUpdate, n.colorsNeedUpdate = i.colorsNeedUpdate, n.uvsNeedUpdate = i.uvsNeedUpdate, n.groupsNeedUpdate = i.groupsNeedUpdate, i.verticesNeedUpdate = !1, i.normalsNeedUpdate = !1, i.colorsNeedUpdate = !1, i.uvsNeedUpdate = !1, i.groupsNeedUpdate = !1, i = n
                }
                return !0 === i.verticesNeedUpdate && (void 0 !== (e = this.attributes.position) && (e.copyVector3sArray(i.vertices), e.needsUpdate = !0), i.verticesNeedUpdate = !1), !0 === i.normalsNeedUpdate && (void 0 !== (e = this.attributes.normal) && (e.copyVector3sArray(i.normals), e.needsUpdate = !0), i.normalsNeedUpdate = !1), !0 === i.colorsNeedUpdate && (void 0 !== (e = this.attributes.color) && (e.copyColorsArray(i.colors), e.needsUpdate = !0), i.colorsNeedUpdate = !1), i.uvsNeedUpdate && (void 0 !== (e = this.attributes.uv) && (e.copyVector2sArray(i.uvs), e.needsUpdate = !0), i.uvsNeedUpdate = !1), i.lineDistancesNeedUpdate && (void 0 !== (e = this.attributes.lineDistance) && (e.copyArray(i.lineDistances), e.needsUpdate = !0), i.lineDistancesNeedUpdate = !1), i.groupsNeedUpdate && (i.computeGroups(t.geometry), this.groups = i.groups, i.groupsNeedUpdate = !1), this
            }, fromGeometry: function (t) {
                return t.__directGeometry = (new Lg).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
            }, fromDirectGeometry: function (t) {
                var e = new Float32Array(3 * t.vertices.length);
                if (this.addAttribute("position", new _g(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
                    var i = new Float32Array(3 * t.normals.length);
                    this.addAttribute("normal", new _g(i, 3).copyVector3sArray(t.normals))
                }
                if (t.colors.length > 0) {
                    var n = new Float32Array(3 * t.colors.length);
                    this.addAttribute("color", new _g(n, 3).copyColorsArray(t.colors))
                }
                if (t.uvs.length > 0) {
                    var r = new Float32Array(2 * t.uvs.length);
                    this.addAttribute("uv", new _g(r, 2).copyVector2sArray(t.uvs))
                }
                if (t.uvs2.length > 0) {
                    var s = new Float32Array(2 * t.uvs2.length);
                    this.addAttribute("uv2", new _g(s, 2).copyVector2sArray(t.uvs2))
                }
                for (var a in this.groups = t.groups, t.morphTargets) {
                    for (var o = [], h = t.morphTargets[a], l = 0, c = h.length; l < c; l++) {
                        var u = h[l], p = new Pg(3 * u.data.length, 3);
                        p.name = u.name, o.push(p.copyVector3sArray(u.data))
                    }
                    this.morphAttributes[a] = o
                }
                if (t.skinIndices.length > 0) {
                    var d = new Pg(4 * t.skinIndices.length, 4);
                    this.addAttribute("skinIndex", d.copyVector4sArray(t.skinIndices))
                }
                if (t.skinWeights.length > 0) {
                    var f = new Pg(4 * t.skinWeights.length, 4);
                    this.addAttribute("skinWeight", f.copyVector4sArray(t.skinWeights))
                }
                return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
            }, computeBoundingBox: function () {
                var t = new qm;
                return function () {
                    null === this.boundingBox && (this.boundingBox = new qm);
                    var e = this.attributes.position, i = this.morphAttributes.position;
                    if (void 0 !== e) {
                        if (this.boundingBox.setFromBufferAttribute(e), i) for (var n = 0, r = i.length; n < r; n++) {
                            var s = i[n];
                            t.setFromBufferAttribute(s), this.boundingBox.expandByPoint(t.min), this.boundingBox.expandByPoint(t.max)
                        }
                    } else this.boundingBox.makeEmpty();
                    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                }
            }(), computeBoundingSphere: function () {
                var t = new qm, e = new qm, i = new _m;
                return function () {
                    null === this.boundingSphere && (this.boundingSphere = new Xm);
                    var n = this.attributes.position, r = this.morphAttributes.position;
                    if (n) {
                        var s = this.boundingSphere.center;
                        if (t.setFromBufferAttribute(n), r) for (var a = 0, o = r.length; a < o; a++) {
                            var h = r[a];
                            e.setFromBufferAttribute(h), t.expandByPoint(e.min), t.expandByPoint(e.max)
                        }
                        t.getCenter(s);
                        var l = 0;
                        for (a = 0, o = n.count; a < o; a++) i.fromBufferAttribute(n, a), l = Math.max(l, s.distanceToSquared(i));
                        if (r) for (a = 0, o = r.length; a < o; a++) for (var c = 0, u = (h = r[a]).count; c < u; c++) i.fromBufferAttribute(h, c), l = Math.max(l, s.distanceToSquared(i));
                        this.boundingSphere.radius = Math.sqrt(l), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                }
            }(), computeFaceNormals: function () {
            }, computeVertexNormals: function () {
                var t = this.index, e = this.attributes;
                if (e.position) {
                    var i = e.position.array;
                    if (void 0 === e.normal) this.addAttribute("normal", new _g(new Float32Array(i.length), 3)); else for (var n = e.normal.array, r = 0, s = n.length; r < s; r++) n[r] = 0;
                    var a, o, h, l = e.normal.array, c = new _m, u = new _m, p = new _m, d = new _m, f = new _m;
                    if (t) {
                        var m = t.array;
                        for (r = 0, s = t.count; r < s; r += 3) a = 3 * m[r + 0], o = 3 * m[r + 1], h = 3 * m[r + 2], c.fromArray(i, a), u.fromArray(i, o), p.fromArray(i, h), d.subVectors(p, u), f.subVectors(c, u), d.cross(f), l[a] += d.x, l[a + 1] += d.y, l[a + 2] += d.z, l[o] += d.x, l[o + 1] += d.y, l[o + 2] += d.z, l[h] += d.x, l[h + 1] += d.y, l[h + 2] += d.z
                    } else for (r = 0, s = i.length; r < s; r += 9) c.fromArray(i, r), u.fromArray(i, r + 3), p.fromArray(i, r + 6), d.subVectors(p, u), f.subVectors(c, u), d.cross(f), l[r] = d.x, l[r + 1] = d.y, l[r + 2] = d.z, l[r + 3] = d.x, l[r + 4] = d.y, l[r + 5] = d.z, l[r + 6] = d.x, l[r + 7] = d.y, l[r + 8] = d.z;
                    this.normalizeNormals(), e.normal.needsUpdate = !0
                }
            }, merge: function (t, e) {
                if (t && t.isBufferGeometry) {
                    void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                    var i = this.attributes;
                    for (var n in i) if (void 0 !== t.attributes[n]) for (var r = i[n].array, s = t.attributes[n], a = s.array, o = s.itemSize * e, h = Math.min(a.length, r.length - o), l = 0, c = o; l < h; l++, c++) r[c] = a[l];
                    return this
                }
                console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t)
            }, normalizeNormals: function () {
                var t = new _m;
                return function () {
                    for (var e = this.attributes.normal, i = 0, n = e.count; i < n; i++) t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.normalize(), e.setXYZ(i, t.x, t.y, t.z)
                }
            }(), toNonIndexed: function () {
                function t(t, e) {
                    for (var i = t.array, n = t.itemSize, r = new i.constructor(e.length * n), s = 0, a = 0, o = 0, h = e.length; o < h; o++) {
                        s = e[o] * n;
                        for (var l = 0; l < n; l++) r[a++] = i[s++]
                    }
                    return new _g(r, n)
                }

                if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                var e = new kg, i = this.index.array, n = this.attributes;
                for (var r in n) {
                    var s = t(n[r], i);
                    e.addAttribute(r, s)
                }
                var a = this.morphAttributes;
                for (r in a) {
                    for (var o = [], h = a[r], l = 0, c = h.length; l < c; l++) {
                        s = t(h[l], i);
                        o.push(s)
                    }
                    e.morphAttributes[r] = o
                }
                for (var u = this.groups, p = (l = 0, u.length); l < p; l++) {
                    var d = u[l];
                    e.addGroup(d.start, d.count, d.materialIndex)
                }
                return e
            }, toJSON: function () {
                var t = {metadata: {version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON"}};
                if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                    var e = this.parameters;
                    for (var i in e) void 0 !== e[i] && (t[i] = e[i]);
                    return t
                }
                t.data = {attributes: {}};
                var n = this.index;
                null !== n && (t.data.index = {
                    type: n.array.constructor.name,
                    array: Array.prototype.slice.call(n.array)
                });
                var r = this.attributes;
                for (var i in r) {
                    var s = (p = r[i]).toJSON();
                    "" !== p.name && (s.name = p.name), t.data.attributes[i] = s
                }
                var a = {}, o = !1;
                for (var i in this.morphAttributes) {
                    for (var h = this.morphAttributes[i], l = [], c = 0, u = h.length; c < u; c++) {
                        var p;
                        s = (p = h[c]).toJSON();
                        "" !== p.name && (s.name = p.name), l.push(s)
                    }
                    l.length > 0 && (a[i] = l, o = !0)
                }
                o && (t.data.morphAttributes = a);
                var d = this.groups;
                d.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(d)));
                var f = this.boundingSphere;
                return null !== f && (t.data.boundingSphere = {center: f.center.toArray(), radius: f.radius}), t
            }, clone: function () {
                return (new kg).copy(this)
            }, copy: function (t) {
                var e, i, n;
                this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                var r = t.index;
                null !== r && this.setIndex(r.clone());
                var s = t.attributes;
                for (e in s) {
                    var a = s[e];
                    this.addAttribute(e, a.clone())
                }
                var o = t.morphAttributes;
                for (e in o) {
                    var h = [], l = o[e];
                    for (i = 0, n = l.length; i < n; i++) h.push(l[i].clone());
                    this.morphAttributes[e] = h
                }
                var c = t.groups;
                for (i = 0, n = c.length; i < n; i++) {
                    var u = c[i];
                    this.addGroup(u.start, u.count, u.materialIndex)
                }
                var p = t.boundingBox;
                null !== p && (this.boundingBox = p.clone());
                var d = t.boundingSphere;
                return null !== d && (this.boundingSphere = d.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
            }, dispose: function () {
                this.dispatchEvent({type: "dispose"})
            }
        }), Og.prototype = Object.create(wg.prototype), Og.prototype.constructor = Og, zg.prototype = Object.create(kg.prototype), zg.prototype.constructor = zg, Bg.prototype = Object.create(wg.prototype), Bg.prototype.constructor = Bg, Ng.prototype = Object.create(kg.prototype), Ng.prototype.constructor = Ng;
        var jg = 0;

        function Vg() {
            Object.defineProperty(this, "id", {value: jg++}), this.uuid = bm.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = 1, this.side = 0, this.flatShading = !1, this.vertexTangents = !1, this.vertexColors = 0, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = Yf, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.userData = {}, this.needsUpdate = !0
        }

        Vg.prototype = Object.assign(Object.create(Vf.prototype), {
            constructor: Vg, isMaterial: !0, onBeforeCompile: function () {
            }, setValues: function (t) {
                if (void 0 !== t) for (var e in t) {
                    var i = t[e];
                    if (void 0 !== i) if ("shading" !== e) {
                        var n = this[e];
                        void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                    } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === i; else console.warn("THREE.Material: '" + e + "' parameter is undefined.")
                }
            }, toJSON: function (t) {
                var e = void 0 === t || "string" == typeof t;
                e && (t = {textures: {}, images: {}});
                var i = {metadata: {version: 4.5, type: "Material", generator: "Material.toJSON"}};

                function n(t) {
                    var e = [];
                    for (var i in t) {
                        var n = t[i];
                        delete n.metadata, e.push(n)
                    }
                    return e
                }

                if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearCoat && (i.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (i.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(t).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid, i.reflectivity = this.reflectivity, void 0 !== this.combine && (i.combine = this.combine), void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (i.size = this.size), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (i.blending = this.blending), !0 === this.flatShading && (i.flatShading = this.flatShading), 0 !== this.side && (i.side = this.side), 0 !== this.vertexColors && (i.vertexColors = this.vertexColors), this.opacity < 1 && (i.opacity = this.opacity), !0 === this.transparent && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, 0 !== this.rotation && (i.rotation = this.rotation), !0 === this.polygonOffset && (i.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits), 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), !0 === this.dithering && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (i.morphTargets = !0), !0 === this.skinning && (i.skinning = !0), !1 === this.visible && (i.visible = !1), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), e) {
                    var r = n(t.textures), s = n(t.images);
                    r.length > 0 && (i.textures = r), s.length > 0 && (i.images = s)
                }
                return i
            }, clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.userData = JSON.parse(JSON.stringify(t.userData)), this.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection;
                var e = t.clippingPlanes, i = null;
                if (null !== e) {
                    var n = e.length;
                    i = new Array(n);
                    for (var r = 0; r !== n; ++r) i[r] = e[r].clone()
                }
                return this.clippingPlanes = i, this.shadowSide = t.shadowSide, this
            }, dispose: function () {
                this.dispatchEvent({type: "dispose"})
            }
        });
        var Gg, Ug, Hg, Wg, qg, Xg, Yg, Zg, Jg, Qg, Kg, $g;

        function tv(t) {
            Vg.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1
            }, this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0]
            }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
        }

        function ev(t, e) {
            this.origin = void 0 !== t ? t : new _m, this.direction = void 0 !== e ? e : new _m
        }

        function iv(t, e, i) {
            this.a = void 0 !== t ? t : new _m, this.b = void 0 !== e ? e : new _m, this.c = void 0 !== i ? i : new _m
        }

        function nv(t) {
            Vg.call(this), this.type = "MeshBasicMaterial", this.color = new rg(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(t)
        }

        function rv(t, e) {
            vg.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new kg, this.material = void 0 !== e ? e : new nv({color: 16777215 * Math.random()}), this.drawMode = 0, this.updateMorphTargets()
        }

        function sv(t, e, i, n) {
            var r, s, a = new rg(0), o = 0, h = null, l = 0;

            function c(t, i) {
                e.buffers.color.setClear(t.r, t.g, t.b, i, n)
            }

            return {
                getClearColor: function () {
                    return a
                }, setClearColor: function (t, e) {
                    a.set(t), c(a, o = void 0 !== e ? e : 1)
                }, getClearAlpha: function () {
                    return o
                }, setClearAlpha: function (t) {
                    c(a, o = t)
                }, render: function (e, n, u, p) {
                    var d = n.background, f = t.vr, m = f.getSession && f.getSession();
                    if (m && "additive" === m.environmentBlendMode && (d = null), null === d ? (c(a, o), h = null, l = 0) : d && d.isColor && (c(d, 1), p = !0, h = null, l = 0), (t.autoClear || p) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), d && (d.isCubeTexture || d.isWebGLRenderTargetCube)) {
                        void 0 === s && ((s = new rv(new zg(1, 1, 1), new tv({
                            type: "BackgroundCubeMaterial",
                            uniforms: Km(og.cube.uniforms),
                            vertexShader: og.cube.vertexShader,
                            fragmentShader: og.cube.fragmentShader,
                            side: 1,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        }))).geometry.removeAttribute("normal"), s.geometry.removeAttribute("uv"), s.onBeforeRender = function (t, e, i) {
                            this.matrixWorld.copyPosition(i.matrixWorld)
                        }, Object.defineProperty(s.material, "map", {
                            get: function () {
                                return this.uniforms.tCube.value
                            }
                        }), i.update(s));
                        var g = d.isWebGLRenderTargetCube ? d.texture : d;
                        s.material.uniforms.tCube.value = g, s.material.uniforms.tFlip.value = d.isWebGLRenderTargetCube ? 1 : -1, h === d && l === g.version || (s.material.needsUpdate = !0, h = d, l = g.version), e.unshift(s, s.geometry, s.material, 0, 0, null)
                    } else d && d.isTexture && (void 0 === r && ((r = new rv(new Ng(2, 2), new tv({
                        type: "BackgroundMaterial",
                        uniforms: Km(og.background.uniforms),
                        vertexShader: og.background.vertexShader,
                        fragmentShader: og.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    }))).geometry.removeAttribute("normal"), Object.defineProperty(r.material, "map", {
                        get: function () {
                            return this.uniforms.t2D.value
                        }
                    }), i.update(r)), r.material.uniforms.t2D.value = d, !0 === d.matrixAutoUpdate && d.updateMatrix(), r.material.uniforms.uvTransform.value.copy(d.matrix), h === d && l === d.version || (r.material.needsUpdate = !0, h = d, l = d.version), e.unshift(r, r.geometry, r.material, 0, 0, null))
                }
            }
        }

        function av(t, e, i, n) {
            var r;
            this.setMode = function (t) {
                r = t
            }, this.render = function (e, n) {
                t.drawArrays(r, e, n), i.update(n, r)
            }, this.renderInstances = function (s, a, o) {
                var h;
                if (n.isWebGL2) h = t; else if (null === (h = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                h[n.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](r, a, o, s.maxInstancedCount), i.update(o, r, s.maxInstancedCount)
            }
        }

        function ov(t, e, i) {
            var n;

            function r(e) {
                if ("highp" === e) {
                    if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                    e = "mediump"
                }
                return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
            }

            var s = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext,
                a = void 0 !== i.precision ? i.precision : "highp", o = r(a);
            o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."), a = o);
            var h = !0 === i.logarithmicDepthBuffer, l = t.getParameter(34930), c = t.getParameter(35660),
                u = t.getParameter(3379), p = t.getParameter(34076), d = t.getParameter(34921),
                f = t.getParameter(36347), m = t.getParameter(36348), g = t.getParameter(36349), v = c > 0,
                y = s || !!e.get("OES_texture_float");
            return {
                isWebGL2: s,
                getMaxAnisotropy: function () {
                    if (void 0 !== n) return n;
                    var i = e.get("EXT_texture_filter_anisotropic");
                    return n = null !== i ? t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                },
                getMaxPrecision: r,
                precision: a,
                logarithmicDepthBuffer: h,
                maxTextures: l,
                maxVertexTextures: c,
                maxTextureSize: u,
                maxCubemapSize: p,
                maxAttributes: d,
                maxVertexUniforms: f,
                maxVaryings: m,
                maxFragmentUniforms: g,
                vertexTextures: v,
                floatFragmentTextures: y,
                floatVertexTextures: v && y,
                maxSamples: s ? t.getParameter(36183) : 0
            }
        }

        function hv() {
            var t = this, e = null, i = 0, n = !1, r = !1, s = new Ym, a = new Em, o = {value: null, needsUpdate: !1};

            function h() {
                o.value !== e && (o.value = e, o.needsUpdate = i > 0), t.numPlanes = i, t.numIntersection = 0
            }

            function l(e, i, n, r) {
                var h = null !== e ? e.length : 0, l = null;
                if (0 !== h) {
                    if (l = o.value, !0 !== r || null === l) {
                        var c = n + 4 * h, u = i.matrixWorldInverse;
                        a.getNormalMatrix(u), (null === l || l.length < c) && (l = new Float32Array(c));
                        for (var p = 0, d = n; p !== h; ++p, d += 4) s.copy(e[p]).applyMatrix4(u, a), s.normal.toArray(l, d), l[d + 3] = s.constant
                    }
                    o.value = l, o.needsUpdate = !0
                }
                return t.numPlanes = h, l
            }

            this.uniform = o, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, r, s) {
                var a = 0 !== t.length || r || 0 !== i || n;
                return n = r, e = l(t, s, 0), i = t.length, a
            }, this.beginShadows = function () {
                r = !0, l(null)
            }, this.endShadows = function () {
                r = !1, h()
            }, this.setState = function (t, s, a, c, u, p) {
                if (!n || null === t || 0 === t.length || r && !a) r ? l(null) : h(); else {
                    var d = r ? 0 : i, f = 4 * d, m = u.clippingState || null;
                    o.value = m, m = l(t, c, f, p);
                    for (var g = 0; g !== f; ++g) m[g] = e[g];
                    u.clippingState = m, this.numIntersection = s ? this.numPlanes : 0, this.numPlanes += d
                }
            }
        }

        function lv(t) {
            var e = {};
            return {
                get: function (i) {
                    if (void 0 !== e[i]) return e[i];
                    var n;
                    switch (i) {
                        case"WEBGL_depth_texture":
                            n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case"EXT_texture_filter_anisotropic":
                            n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case"WEBGL_compressed_texture_s3tc":
                            n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case"WEBGL_compressed_texture_pvrtc":
                            n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            n = t.getExtension(i)
                    }
                    return null === n && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), e[i] = n, n
                }
            }
        }

        function cv(t, e, i) {
            var n = {}, r = {};

            function s(t) {
                var a = t.target, o = n[a.id];
                for (var h in null !== o.index && e.remove(o.index), o.attributes) e.remove(o.attributes[h]);
                a.removeEventListener("dispose", s), delete n[a.id];
                var l = r[o.id];
                l && (e.remove(l), delete r[o.id]), i.memory.geometries--
            }

            return {
                get: function (t, e) {
                    var r = n[e.id];
                    return r || (e.addEventListener("dispose", s), e.isBufferGeometry ? r = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new kg).setFromObject(t)), r = e._bufferGeometry), n[e.id] = r, i.memory.geometries++, r)
                }, update: function (t) {
                    var i = t.index, n = t.attributes;
                    for (var r in null !== i && e.update(i, 34963), n) e.update(n[r], 34962);
                    var s = t.morphAttributes;
                    for (var r in s) for (var a = s[r], o = 0, h = a.length; o < h; o++) e.update(a[o], 34962)
                }, getWireframeAttribute: function (t) {
                    var i = r[t.id];
                    if (i) return i;
                    var n, s = [], a = t.index, o = t.attributes;
                    if (null !== a) for (var h = 0, l = (n = a.array).length; h < l; h += 3) {
                        var c = n[h + 0], u = n[h + 1], p = n[h + 2];
                        s.push(c, u, u, p, p, c)
                    } else for (h = 0, l = (n = o.position.array).length / 3 - 1; h < l; h += 3) {
                        c = h + 0, u = h + 1, p = h + 2;
                        s.push(c, u, u, p, p, c)
                    }
                    return i = new (Rg(s) > 65535 ? Cg : Tg)(s, 1), e.update(i, 34963), r[t.id] = i, i
                }
            }
        }

        function uv(t, e, i, n) {
            var r, s, a;
            this.setMode = function (t) {
                r = t
            }, this.setIndex = function (t) {
                s = t.type, a = t.bytesPerElement
            }, this.render = function (e, n) {
                t.drawElements(r, n, s, e * a), i.update(n, r)
            }, this.renderInstances = function (o, h, l) {
                var c;
                if (n.isWebGL2) c = t; else if (null === (c = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                c[n.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](r, l, s, h * a, o.maxInstancedCount), i.update(l, r, o.maxInstancedCount)
            }
        }

        function pv(t) {
            var e = {frame: 0, calls: 0, triangles: 0, points: 0, lines: 0};
            return {
                memory: {geometries: 0, textures: 0}, render: e, programs: null, autoReset: !0, reset: function () {
                    e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                }, update: function (t, i, n) {
                    switch (n = n || 1, e.calls++, i) {
                        case 4:
                            e.triangles += n * (t / 3);
                            break;
                        case 5:
                        case 6:
                            e.triangles += n * (t - 2);
                            break;
                        case 1:
                            e.lines += n * (t / 2);
                            break;
                        case 3:
                            e.lines += n * (t - 1);
                            break;
                        case 2:
                            e.lines += n * t;
                            break;
                        case 0:
                            e.points += n * t;
                            break;
                        default:
                            console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                    }
                }
            }
        }

        function dv(t, e) {
            return Math.abs(e[1]) - Math.abs(t[1])
        }

        function fv(t) {
            var e = {}, i = new Float32Array(8);
            return {
                update: function (n, r, s, a) {
                    var o = n.morphTargetInfluences, h = o.length, l = e[r.id];
                    if (void 0 === l) {
                        l = [];
                        for (var c = 0; c < h; c++) l[c] = [c, 0];
                        e[r.id] = l
                    }
                    var u = s.morphTargets && r.morphAttributes.position,
                        p = s.morphNormals && r.morphAttributes.normal;
                    for (c = 0; c < h; c++) {
                        0 !== (d = l[c])[1] && (u && r.removeAttribute("morphTarget" + c), p && r.removeAttribute("morphNormal" + c))
                    }
                    for (c = 0; c < h; c++) {
                        (d = l[c])[0] = c, d[1] = o[c]
                    }
                    for (l.sort(dv), c = 0; c < 8; c++) {
                        var d;
                        if (d = l[c]) {
                            var f = d[0], m = d[1];
                            if (m) {
                                u && r.addAttribute("morphTarget" + c, u[f]), p && r.addAttribute("morphNormal" + c, p[f]), i[c] = m;
                                continue
                            }
                        }
                        i[c] = 0
                    }
                    a.getUniforms().setValue(t, "morphTargetInfluences", i)
                }
            }
        }

        function mv(t, e) {
            var i = {};
            return {
                update: function (n) {
                    var r = e.render.frame, s = n.geometry, a = t.get(n, s);
                    return i[a.id] !== r && (s.isGeometry && a.updateFromObject(n), t.update(a), i[a.id] = r), a
                }, dispose: function () {
                    i = {}
                }
            }
        }

        function gv(t, e, i, n, r, s, a, o, h, l) {
            t = void 0 !== t ? t : [], e = void 0 !== e ? e : 301, a = void 0 !== a ? a : hm, jm.call(this, t, e, i, n, r, s, a, o, h, l), this.flipY = !1
        }

        function vv(t, e, i, n) {
            jm.call(this, null), this.image = {
                data: t,
                width: e,
                height: i,
                depth: n
            }, this.magFilter = Kf, this.minFilter = Kf, this.wrapR = Jf, this.generateMipmaps = !1, this.flipY = !1
        }

        function yv(t, e, i, n) {
            jm.call(this, null), this.image = {
                data: t,
                width: e,
                height: i,
                depth: n
            }, this.magFilter = Kf, this.minFilter = Kf, this.wrapR = Jf, this.generateMipmaps = !1, this.flipY = !1
        }

        tv.prototype = Object.create(Vg.prototype), tv.prototype.constructor = tv, tv.prototype.isShaderMaterial = !0, tv.prototype.copy = function (t) {
            return Vg.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Km(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this
        }, tv.prototype.toJSON = function (t) {
            var e = Vg.prototype.toJSON.call(this, t);
            for (var i in e.uniforms = {}, this.uniforms) {
                var n = this.uniforms[i].value;
                n && n.isTexture ? e.uniforms[i] = {
                    type: "t",
                    value: n.toJSON(t).uuid
                } : n && n.isColor ? e.uniforms[i] = {
                    type: "c",
                    value: n.getHex()
                } : n && n.isVector2 ? e.uniforms[i] = {
                    type: "v2",
                    value: n.toArray()
                } : n && n.isVector3 ? e.uniforms[i] = {
                    type: "v3",
                    value: n.toArray()
                } : n && n.isVector4 ? e.uniforms[i] = {
                    type: "v4",
                    value: n.toArray()
                } : n && n.isMatrix3 ? e.uniforms[i] = {
                    type: "m3",
                    value: n.toArray()
                } : n && n.isMatrix4 ? e.uniforms[i] = {type: "m4", value: n.toArray()} : e.uniforms[i] = {value: n}
            }
            Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
            var r = {};
            for (var s in this.extensions) !0 === this.extensions[s] && (r[s] = !0);
            return Object.keys(r).length > 0 && (e.extensions = r), e
        }, Object.assign(ev.prototype, {
            set: function (t, e) {
                return this.origin.copy(t), this.direction.copy(e), this
            }, clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                return this.origin.copy(t.origin), this.direction.copy(t.direction), this
            }, at: function (t, e) {
                return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new _m), e.copy(this.direction).multiplyScalar(t).add(this.origin)
            }, lookAt: function (t) {
                return this.direction.copy(t).sub(this.origin).normalize(), this
            }, recast: function () {
                var t = new _m;
                return function (e) {
                    return this.origin.copy(this.at(e, t)), this
                }
            }(), closestPointToPoint: function (t, e) {
                void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new _m), e.subVectors(t, this.origin);
                var i = e.dot(this.direction);
                return i < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(i).add(this.origin)
            }, distanceToPoint: function (t) {
                return Math.sqrt(this.distanceSqToPoint(t))
            }, distanceSqToPoint: function () {
                var t = new _m;
                return function (e) {
                    var i = t.subVectors(e, this.origin).dot(this.direction);
                    return i < 0 ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(i).add(this.origin), t.distanceToSquared(e))
                }
            }(), distanceSqToSegment: (Ug = new _m, Hg = new _m, Wg = new _m, function (t, e, i, n) {
                Ug.copy(t).add(e).multiplyScalar(.5), Hg.copy(e).sub(t).normalize(), Wg.copy(this.origin).sub(Ug);
                var r, s, a, o, h = .5 * t.distanceTo(e), l = -this.direction.dot(Hg), c = Wg.dot(this.direction),
                    u = -Wg.dot(Hg), p = Wg.lengthSq(), d = Math.abs(1 - l * l);
                if (d > 0) if (s = l * c - u, o = h * d, (r = l * u - c) >= 0) if (s >= -o) if (s <= o) {
                    var f = 1 / d;
                    a = (r *= f) * (r + l * (s *= f) + 2 * c) + s * (l * r + s + 2 * u) + p
                } else s = h, a = -(r = Math.max(0, -(l * s + c))) * r + s * (s + 2 * u) + p; else s = -h, a = -(r = Math.max(0, -(l * s + c))) * r + s * (s + 2 * u) + p; else s <= -o ? a = -(r = Math.max(0, -(-l * h + c))) * r + (s = r > 0 ? -h : Math.min(Math.max(-h, -u), h)) * (s + 2 * u) + p : s <= o ? (r = 0, a = (s = Math.min(Math.max(-h, -u), h)) * (s + 2 * u) + p) : a = -(r = Math.max(0, -(l * h + c))) * r + (s = r > 0 ? h : Math.min(Math.max(-h, -u), h)) * (s + 2 * u) + p; else s = l > 0 ? -h : h, a = -(r = Math.max(0, -(l * s + c))) * r + s * (s + 2 * u) + p;
                return i && i.copy(this.direction).multiplyScalar(r).add(this.origin), n && n.copy(Hg).multiplyScalar(s).add(Ug), a
            }), intersectSphere: function () {
                var t = new _m;
                return function (e, i) {
                    t.subVectors(e.center, this.origin);
                    var n = t.dot(this.direction), r = t.dot(t) - n * n, s = e.radius * e.radius;
                    if (r > s) return null;
                    var a = Math.sqrt(s - r), o = n - a, h = n + a;
                    return o < 0 && h < 0 ? null : o < 0 ? this.at(h, i) : this.at(o, i)
                }
            }(), intersectsSphere: function (t) {
                return this.distanceSqToPoint(t.center) <= t.radius * t.radius
            }, distanceToPlane: function (t) {
                var e = t.normal.dot(this.direction);
                if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                var i = -(this.origin.dot(t.normal) + t.constant) / e;
                return i >= 0 ? i : null
            }, intersectPlane: function (t, e) {
                var i = this.distanceToPlane(t);
                return null === i ? null : this.at(i, e)
            }, intersectsPlane: function (t) {
                var e = t.distanceToPoint(this.origin);
                return 0 === e || t.normal.dot(this.direction) * e < 0
            }, intersectBox: function (t, e) {
                var i, n, r, s, a, o, h = 1 / this.direction.x, l = 1 / this.direction.y, c = 1 / this.direction.z,
                    u = this.origin;
                return h >= 0 ? (i = (t.min.x - u.x) * h, n = (t.max.x - u.x) * h) : (i = (t.max.x - u.x) * h, n = (t.min.x - u.x) * h), l >= 0 ? (r = (t.min.y - u.y) * l, s = (t.max.y - u.y) * l) : (r = (t.max.y - u.y) * l, s = (t.min.y - u.y) * l), i > s || r > n ? null : ((r > i || i != i) && (i = r), (s < n || n != n) && (n = s), c >= 0 ? (a = (t.min.z - u.z) * c, o = (t.max.z - u.z) * c) : (a = (t.max.z - u.z) * c, o = (t.min.z - u.z) * c), i > o || a > n ? null : ((a > i || i != i) && (i = a), (o < n || n != n) && (n = o), n < 0 ? null : this.at(i >= 0 ? i : n, e)))
            }, intersectsBox: (Gg = new _m, function (t) {
                return null !== this.intersectBox(t, Gg)
            }), intersectTriangle: function () {
                var t = new _m, e = new _m, i = new _m, n = new _m;
                return function (r, s, a, o, h) {
                    e.subVectors(s, r), i.subVectors(a, r), n.crossVectors(e, i);
                    var l, c = this.direction.dot(n);
                    if (c > 0) {
                        if (o) return null;
                        l = 1
                    } else {
                        if (!(c < 0)) return null;
                        l = -1, c = -c
                    }
                    t.subVectors(this.origin, r);
                    var u = l * this.direction.dot(i.crossVectors(t, i));
                    if (u < 0) return null;
                    var p = l * this.direction.dot(e.cross(t));
                    if (p < 0) return null;
                    if (u + p > c) return null;
                    var d = -l * t.dot(n);
                    return d < 0 ? null : this.at(d / c, h)
                }
            }(), applyMatrix4: function (t) {
                return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
            }, equals: function (t) {
                return t.origin.equals(this.origin) && t.direction.equals(this.direction)
            }
        }), Object.assign(iv, {
            getNormal: (Xg = new _m, function (t, e, i, n) {
                void 0 === n && (console.warn("THREE.Triangle: .getNormal() target is now required"), n = new _m), n.subVectors(i, e), Xg.subVectors(t, e), n.cross(Xg);
                var r = n.lengthSq();
                return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0)
            }), getBarycoord: function () {
                var t = new _m, e = new _m, i = new _m;
                return function (n, r, s, a, o) {
                    t.subVectors(a, r), e.subVectors(s, r), i.subVectors(n, r);
                    var h = t.dot(t), l = t.dot(e), c = t.dot(i), u = e.dot(e), p = e.dot(i), d = h * u - l * l;
                    if (void 0 === o && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), o = new _m), 0 === d) return o.set(-2, -1, -1);
                    var f = 1 / d, m = (u * c - l * p) * f, g = (h * p - l * c) * f;
                    return o.set(1 - m - g, g, m)
                }
            }(), containsPoint: function () {
                var t = new _m;
                return function (e, i, n, r) {
                    return iv.getBarycoord(e, i, n, r, t), t.x >= 0 && t.y >= 0 && t.x + t.y <= 1
                }
            }(), getUV: (qg = new _m, function (t, e, i, n, r, s, a, o) {
                return this.getBarycoord(t, e, i, n, qg), o.set(0, 0), o.addScaledVector(r, qg.x), o.addScaledVector(s, qg.y), o.addScaledVector(a, qg.z), o
            }), isFrontFacing: function () {
                var t = new _m, e = new _m;
                return function (i, n, r, s) {
                    return t.subVectors(r, n), e.subVectors(i, n), t.cross(e).dot(s) < 0
                }
            }()
        }), Object.assign(iv.prototype, {
            set: function (t, e, i) {
                return this.a.copy(t), this.b.copy(e), this.c.copy(i), this
            },
            setFromPointsAndIndices: function (t, e, i, n) {
                return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (t) {
                return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
            },
            getArea: function () {
                var t = new _m, e = new _m;
                return function () {
                    return t.subVectors(this.c, this.b), e.subVectors(this.a, this.b), .5 * t.cross(e).length()
                }
            }(),
            getMidpoint: function (t) {
                return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new _m), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            },
            getNormal: function (t) {
                return iv.getNormal(this.a, this.b, this.c, t)
            },
            getPlane: function (t) {
                return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new _m), t.setFromCoplanarPoints(this.a, this.b, this.c)
            },
            getBarycoord: function (t, e) {
                return iv.getBarycoord(t, this.a, this.b, this.c, e)
            },
            getUV: function (t, e, i, n, r) {
                return iv.getUV(t, this.a, this.b, this.c, e, i, n, r)
            },
            containsPoint: function (t) {
                return iv.containsPoint(t, this.a, this.b, this.c)
            },
            isFrontFacing: function (t) {
                return iv.isFrontFacing(this.a, this.b, this.c, t)
            },
            intersectsBox: function (t) {
                return t.intersectsTriangle(this)
            },
            closestPointToPoint: (Yg = new _m, Zg = new _m, Jg = new _m, Qg = new _m, Kg = new _m, $g = new _m, function (t, e) {
                void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new _m);
                var i, n, r = this.a, s = this.b, a = this.c;
                Yg.subVectors(s, r), Zg.subVectors(a, r), Qg.subVectors(t, r);
                var o = Yg.dot(Qg), h = Zg.dot(Qg);
                if (o <= 0 && h <= 0) return e.copy(r);
                Kg.subVectors(t, s);
                var l = Yg.dot(Kg), c = Zg.dot(Kg);
                if (l >= 0 && c <= l) return e.copy(s);
                var u = o * c - l * h;
                if (u <= 0 && o >= 0 && l <= 0) return i = o / (o - l), e.copy(r).addScaledVector(Yg, i);
                $g.subVectors(t, a);
                var p = Yg.dot($g), d = Zg.dot($g);
                if (d >= 0 && p <= d) return e.copy(a);
                var f = p * h - o * d;
                if (f <= 0 && h >= 0 && d <= 0) return n = h / (h - d), e.copy(r).addScaledVector(Zg, n);
                var m = l * d - p * c;
                if (m <= 0 && c - l >= 0 && p - d >= 0) return Jg.subVectors(a, s), n = (c - l) / (c - l + (p - d)), e.copy(s).addScaledVector(Jg, n);
                var g = 1 / (m + f + u);
                return i = f * g, n = u * g, e.copy(r).addScaledVector(Yg, i).addScaledVector(Zg, n)
            }),
            equals: function (t) {
                return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            }
        }), nv.prototype = Object.create(Vg.prototype), nv.prototype.constructor = nv, nv.prototype.isMeshBasicMaterial = !0, nv.prototype.copy = function (t) {
            return Vg.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
        }, rv.prototype = Object.assign(Object.create(vg.prototype), {
            constructor: rv, isMesh: !0, setDrawMode: function (t) {
                this.drawMode = t
            }, copy: function (t) {
                return vg.prototype.copy.call(this, t), this.drawMode = t.drawMode, void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this
            }, updateMorphTargets: function () {
                var t, e, i, n = this.geometry;
                if (n.isBufferGeometry) {
                    var r = n.morphAttributes, s = Object.keys(r);
                    if (s.length > 0) {
                        var a = r[s[0]];
                        if (void 0 !== a) for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = a.length; t < e; t++) i = a[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = t
                    }
                } else {
                    var o = n.morphTargets;
                    void 0 !== o && o.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }, raycast: function () {
                var t = new Jm, e = new ev, i = new Xm, n = new _m, r = new _m, s = new _m, a = new _m, o = new _m,
                    h = new _m, l = new _m, c = new _m, u = new _m, p = new xm, d = new xm, f = new xm, m = new _m,
                    g = new _m;

                function v(t, e, i, n, r, s, a, o) {
                    if (null === (1 === e.side ? n.intersectTriangle(a, s, r, !0, o) : n.intersectTriangle(r, s, a, 2 !== e.side, o))) return null;
                    g.copy(o), g.applyMatrix4(t.matrixWorld);
                    var h = i.ray.origin.distanceTo(g);
                    return h < i.near || h > i.far ? null : {distance: h, point: g.clone(), object: t}
                }

                function y(t, e, i, g, y, b, x, w, _, E) {
                    n.fromBufferAttribute(y, w), r.fromBufferAttribute(y, _), s.fromBufferAttribute(y, E);
                    var M = t.morphTargetInfluences;
                    if (e.morphTargets && b && M) {
                        l.set(0, 0, 0), c.set(0, 0, 0), u.set(0, 0, 0);
                        for (var A = 0, S = b.length; A < S; A++) {
                            var T = M[A], D = b[A];
                            0 !== T && (a.fromBufferAttribute(D, w), o.fromBufferAttribute(D, _), h.fromBufferAttribute(D, E), l.addScaledVector(a.sub(n), T), c.addScaledVector(o.sub(r), T), u.addScaledVector(h.sub(s), T))
                        }
                        n.add(l), r.add(c), s.add(u)
                    }
                    var C = v(t, e, i, g, n, r, s, m);
                    if (C) {
                        x && (p.fromBufferAttribute(x, w), d.fromBufferAttribute(x, _), f.fromBufferAttribute(x, E), C.uv = iv.getUV(m, n, r, s, p, d, f, new xm));
                        var P = new cg(w, _, E);
                        iv.getNormal(n, r, s, P.normal), C.face = P
                    }
                    return C
                }

                return function (n, r) {
                    var s, a = this.geometry, o = this.material, h = this.matrixWorld;
                    if (void 0 !== o && (null === a.boundingSphere && a.computeBoundingSphere(), i.copy(a.boundingSphere), i.applyMatrix4(h), !1 !== n.ray.intersectsSphere(i) && (t.getInverse(h), e.copy(n.ray).applyMatrix4(t), null === a.boundingBox || !1 !== e.intersectsBox(a.boundingBox)))) if (a.isBufferGeometry) {
                        var l, c, u, g, b, x, w, _, E, M = a.index, A = a.attributes.position,
                            S = a.morphAttributes.position, T = a.attributes.uv, D = a.groups, C = a.drawRange;
                        if (null !== M) if (Array.isArray(o)) for (g = 0, x = D.length; g < x; g++) for (E = o[(_ = D[g]).materialIndex], b = Math.max(_.start, C.start), w = Math.min(_.start + _.count, C.start + C.count); b < w; b += 3) l = M.getX(b), c = M.getX(b + 1), u = M.getX(b + 2), (s = y(this, E, n, e, A, S, T, l, c, u)) && (s.faceIndex = Math.floor(b / 3), s.face.materialIndex = _.materialIndex, r.push(s)); else for (g = Math.max(0, C.start), x = Math.min(M.count, C.start + C.count); g < x; g += 3) l = M.getX(g), c = M.getX(g + 1), u = M.getX(g + 2), (s = y(this, o, n, e, A, S, T, l, c, u)) && (s.faceIndex = Math.floor(g / 3), r.push(s)); else if (void 0 !== A) if (Array.isArray(o)) for (g = 0, x = D.length; g < x; g++) for (E = o[(_ = D[g]).materialIndex], b = Math.max(_.start, C.start), w = Math.min(_.start + _.count, C.start + C.count); b < w; b += 3) (s = y(this, E, n, e, A, S, T, l = b, c = b + 1, u = b + 2)) && (s.faceIndex = Math.floor(b / 3), s.face.materialIndex = _.materialIndex, r.push(s)); else for (g = Math.max(0, C.start), x = Math.min(A.count, C.start + C.count); g < x; g += 3) (s = y(this, o, n, e, A, S, T, l = g, c = g + 1, u = g + 2)) && (s.faceIndex = Math.floor(g / 3), r.push(s))
                    } else if (a.isGeometry) {
                        var P, I, L, R, F = Array.isArray(o), k = a.vertices, O = a.faces, z = a.faceVertexUvs[0];
                        z.length > 0 && (R = z);
                        for (var B = 0, N = O.length; B < N; B++) {
                            var j = O[B], V = F ? o[j.materialIndex] : o;
                            if (void 0 !== V && (P = k[j.a], I = k[j.b], L = k[j.c], s = v(this, V, n, e, P, I, L, m))) {
                                if (R && R[B]) {
                                    var G = R[B];
                                    p.copy(G[0]), d.copy(G[1]), f.copy(G[2]), s.uv = iv.getUV(m, P, I, L, p, d, f, new xm)
                                }
                                s.face = j, s.faceIndex = B, r.push(s)
                            }
                        }
                    }
                }
            }(), clone: function () {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), gv.prototype = Object.create(jm.prototype), gv.prototype.constructor = gv, gv.prototype.isCubeTexture = !0, Object.defineProperty(gv.prototype, "images", {
            get: function () {
                return this.image
            }, set: function (t) {
                this.image = t
            }
        }), vv.prototype = Object.create(jm.prototype), vv.prototype.constructor = vv, vv.prototype.isDataTexture2DArray = !0, yv.prototype = Object.create(jm.prototype), yv.prototype.constructor = yv, yv.prototype.isDataTexture3D = !0;
        var bv = new jm, xv = new vv, wv = new yv, _v = new gv, Ev = [], Mv = [], Av = new Float32Array(16),
            Sv = new Float32Array(9), Tv = new Float32Array(4);

        function Dv(t, e, i) {
            var n = t[0];
            if (n <= 0 || n > 0) return t;
            var r = e * i, s = Ev[r];
            if (void 0 === s && (s = new Float32Array(r), Ev[r] = s), 0 !== e) {
                n.toArray(s, 0);
                for (var a = 1, o = 0; a !== e; ++a) o += i, t[a].toArray(s, o)
            }
            return s
        }

        function Cv(t, e) {
            if (t.length !== e.length) return !1;
            for (var i = 0, n = t.length; i < n; i++) if (t[i] !== e[i]) return !1;
            return !0
        }

        function Pv(t, e) {
            for (var i = 0, n = e.length; i < n; i++) t[i] = e[i]
        }

        function Iv(t, e) {
            var i = Mv[e];
            void 0 === i && (i = new Int32Array(e), Mv[e] = i);
            for (var n = 0; n !== e; ++n) i[n] = t.allocateTextureUnit();
            return i
        }

        function Lv(t, e) {
            var i = this.cache;
            i[0] !== e && (t.uniform1f(this.addr, e), i[0] = e)
        }

        function Rv(t, e) {
            var i = this.cache;
            if (void 0 !== e.x) i[0] === e.x && i[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y); else {
                if (Cv(i, e)) return;
                t.uniform2fv(this.addr, e), Pv(i, e)
            }
        }

        function Fv(t, e) {
            var i = this.cache;
            if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z); else if (void 0 !== e.r) i[0] === e.r && i[1] === e.g && i[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), i[0] = e.r, i[1] = e.g, i[2] = e.b); else {
                if (Cv(i, e)) return;
                t.uniform3fv(this.addr, e), Pv(i, e)
            }
        }

        function kv(t, e) {
            var i = this.cache;
            if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w); else {
                if (Cv(i, e)) return;
                t.uniform4fv(this.addr, e), Pv(i, e)
            }
        }

        function Ov(t, e) {
            var i = this.cache, n = e.elements;
            if (void 0 === n) {
                if (Cv(i, e)) return;
                t.uniformMatrix2fv(this.addr, !1, e), Pv(i, e)
            } else {
                if (Cv(i, n)) return;
                Tv.set(n), t.uniformMatrix2fv(this.addr, !1, Tv), Pv(i, n)
            }
        }

        function zv(t, e) {
            var i = this.cache, n = e.elements;
            if (void 0 === n) {
                if (Cv(i, e)) return;
                t.uniformMatrix3fv(this.addr, !1, e), Pv(i, e)
            } else {
                if (Cv(i, n)) return;
                Sv.set(n), t.uniformMatrix3fv(this.addr, !1, Sv), Pv(i, n)
            }
        }

        function Bv(t, e) {
            var i = this.cache, n = e.elements;
            if (void 0 === n) {
                if (Cv(i, e)) return;
                t.uniformMatrix4fv(this.addr, !1, e), Pv(i, e)
            } else {
                if (Cv(i, n)) return;
                Av.set(n), t.uniformMatrix4fv(this.addr, !1, Av), Pv(i, n)
            }
        }

        function Nv(t, e, i) {
            var n = this.cache, r = i.allocateTextureUnit();
            n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.safeSetTexture2D(e || bv, r)
        }

        function jv(t, e, i) {
            var n = this.cache, r = i.allocateTextureUnit();
            n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture2DArray(e || xv, r)
        }

        function Vv(t, e, i) {
            var n = this.cache, r = i.allocateTextureUnit();
            n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture3D(e || wv, r)
        }

        function Gv(t, e, i) {
            var n = this.cache, r = i.allocateTextureUnit();
            n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.safeSetTextureCube(e || _v, r)
        }

        function Uv(t, e) {
            var i = this.cache;
            i[0] !== e && (t.uniform1i(this.addr, e), i[0] = e)
        }

        function Hv(t, e) {
            var i = this.cache;
            Cv(i, e) || (t.uniform2iv(this.addr, e), Pv(i, e))
        }

        function Wv(t, e) {
            var i = this.cache;
            Cv(i, e) || (t.uniform3iv(this.addr, e), Pv(i, e))
        }

        function qv(t, e) {
            var i = this.cache;
            Cv(i, e) || (t.uniform4iv(this.addr, e), Pv(i, e))
        }

        function Xv(t, e) {
            t.uniform1fv(this.addr, e)
        }

        function Yv(t, e) {
            t.uniform1iv(this.addr, e)
        }

        function Zv(t, e) {
            t.uniform2iv(this.addr, e)
        }

        function Jv(t, e) {
            t.uniform3iv(this.addr, e)
        }

        function Qv(t, e) {
            t.uniform4iv(this.addr, e)
        }

        function Kv(t, e) {
            var i = Dv(e, this.size, 2);
            t.uniform2fv(this.addr, i)
        }

        function $v(t, e) {
            var i = Dv(e, this.size, 3);
            t.uniform3fv(this.addr, i)
        }

        function ty(t, e) {
            var i = Dv(e, this.size, 4);
            t.uniform4fv(this.addr, i)
        }

        function ey(t, e) {
            var i = Dv(e, this.size, 4);
            t.uniformMatrix2fv(this.addr, !1, i)
        }

        function iy(t, e) {
            var i = Dv(e, this.size, 9);
            t.uniformMatrix3fv(this.addr, !1, i)
        }

        function ny(t, e) {
            var i = Dv(e, this.size, 16);
            t.uniformMatrix4fv(this.addr, !1, i)
        }

        function ry(t, e, i) {
            var n = e.length, r = Iv(i, n);
            t.uniform1iv(this.addr, r);
            for (var s = 0; s !== n; ++s) i.safeSetTexture2D(e[s] || bv, r[s])
        }

        function sy(t, e, i) {
            var n = e.length, r = Iv(i, n);
            t.uniform1iv(this.addr, r);
            for (var s = 0; s !== n; ++s) i.safeSetTextureCube(e[s] || _v, r[s])
        }

        function ay(t, e, i) {
            this.id = t, this.addr = i, this.cache = [], this.setValue = function (t) {
                switch (t) {
                    case 5126:
                        return Lv;
                    case 35664:
                        return Rv;
                    case 35665:
                        return Fv;
                    case 35666:
                        return kv;
                    case 35674:
                        return Ov;
                    case 35675:
                        return zv;
                    case 35676:
                        return Bv;
                    case 35678:
                    case 36198:
                        return Nv;
                    case 35679:
                        return Vv;
                    case 35680:
                        return Gv;
                    case 36289:
                        return jv;
                    case 5124:
                    case 35670:
                        return Uv;
                    case 35667:
                    case 35671:
                        return Hv;
                    case 35668:
                    case 35672:
                        return Wv;
                    case 35669:
                    case 35673:
                        return qv
                }
            }(e.type)
        }

        function oy(t, e, i) {
            this.id = t, this.addr = i, this.cache = [], this.size = e.size, this.setValue = function (t) {
                switch (t) {
                    case 5126:
                        return Xv;
                    case 35664:
                        return Kv;
                    case 35665:
                        return $v;
                    case 35666:
                        return ty;
                    case 35674:
                        return ey;
                    case 35675:
                        return iy;
                    case 35676:
                        return ny;
                    case 35678:
                        return ry;
                    case 35680:
                        return sy;
                    case 5124:
                    case 35670:
                        return Yv;
                    case 35667:
                    case 35671:
                        return Zv;
                    case 35668:
                    case 35672:
                        return Jv;
                    case 35669:
                    case 35673:
                        return Qv
                }
            }(e.type)
        }

        function hy(t) {
            this.id = t, this.seq = [], this.map = {}
        }

        oy.prototype.updateCache = function (t) {
            var e = this.cache;
            t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), Pv(e, t)
        }, hy.prototype.setValue = function (t, e, i) {
            for (var n = this.seq, r = 0, s = n.length; r !== s; ++r) {
                var a = n[r];
                a.setValue(t, e[a.id], i)
            }
        };
        var ly = /([\w\d_]+)(\])?(\[|\.)?/g;

        function cy(t, e) {
            t.seq.push(e), t.map[e.id] = e
        }

        function uy(t, e, i) {
            var n = t.name, r = n.length;
            for (ly.lastIndex = 0; ;) {
                var s = ly.exec(n), a = ly.lastIndex, o = s[1], h = "]" === s[2], l = s[3];
                if (h && (o |= 0), void 0 === l || "[" === l && a + 2 === r) {
                    cy(i, void 0 === l ? new ay(o, t, e) : new oy(o, t, e));
                    break
                }
                var c = i.map[o];
                void 0 === c && cy(i, c = new hy(o)), i = c
            }
        }

        function py(t, e) {
            this.seq = [], this.map = {};
            for (var i = t.getProgramParameter(e, 35718), n = 0; n < i; ++n) {
                var r = t.getActiveUniform(e, n);
                uy(r, t.getUniformLocation(e, r.name), this)
            }
        }

        function dy(t, e, i, n) {
            var r = t.createShader(e);
            return t.shaderSource(r, i), t.compileShader(r), !0 === n && (!1 === t.getShaderParameter(r, 35713) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(r) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", 35633 === e ? "vertex" : "fragment", t.getShaderInfoLog(r), function (t) {
                for (var e = t.split("\n"), i = 0; i < e.length; i++) e[i] = i + 1 + ": " + e[i];
                return e.join("\n")
            }(i))), r
        }

        py.prototype.setValue = function (t, e, i, n) {
            var r = this.map[e];
            void 0 !== r && r.setValue(t, i, n)
        }, py.prototype.setOptional = function (t, e, i) {
            var n = e[i];
            void 0 !== n && this.setValue(t, i, n)
        }, py.upload = function (t, e, i, n) {
            for (var r = 0, s = e.length; r !== s; ++r) {
                var a = e[r], o = i[a.id];
                !1 !== o.needsUpdate && a.setValue(t, o.value, n)
            }
        }, py.seqWithValue = function (t, e) {
            for (var i = [], n = 0, r = t.length; n !== r; ++n) {
                var s = t[n];
                s.id in e && i.push(s)
            }
            return i
        };
        var fy = 0;

        function my(t) {
            switch (t) {
                case ym:
                    return ["Linear", "( value )"];
                case 3001:
                    return ["sRGB", "( value )"];
                case 3002:
                    return ["RGBE", "( value )"];
                case 3004:
                    return ["RGBM", "( value, 7.0 )"];
                case 3005:
                    return ["RGBM", "( value, 16.0 )"];
                case 3006:
                    return ["RGBD", "( value, 256.0 )"];
                case 3007:
                    return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                default:
                    throw new Error("unsupported encoding: " + t)
            }
        }

        function gy(t, e) {
            var i = my(e);
            return "vec4 " + t + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }"
        }

        function vy(t, e) {
            var i;
            switch (e) {
                case 1:
                    i = "Linear";
                    break;
                case 2:
                    i = "Reinhard";
                    break;
                case 3:
                    i = "Uncharted2";
                    break;
                case 4:
                    i = "OptimizedCineon";
                    break;
                case 5:
                    i = "ACESFilmic";
                    break;
                default:
                    throw new Error("unsupported toneMapping: " + e)
            }
            return "vec3 " + t + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
        }

        function yy(t) {
            return "" !== t
        }

        function by(t, e) {
            return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
        }

        function xy(t, e) {
            return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
        }

        function wy(t) {
            return t.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, (function (t, e) {
                var i = Qm[e];
                if (void 0 === i) throw new Error("Can not resolve #include <" + e + ">");
                return wy(i)
            }))
        }

        function _y(t) {
            return t.replace(/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, (function (t, e, i, n) {
                for (var r = "", s = parseInt(e); s < parseInt(i); s++) r += n.replace(/\[ i \]/g, "[ " + s + " ]");
                return r
            }))
        }

        function Ey(t, e, i, n, r, s, a, o) {
            var h = t.context, l = n.defines, c = r.vertexShader, u = r.fragmentShader, p = "SHADOWMAP_TYPE_BASIC";
            1 === s.shadowMapType ? p = "SHADOWMAP_TYPE_PCF" : 2 === s.shadowMapType && (p = "SHADOWMAP_TYPE_PCF_SOFT");
            var d = "ENVMAP_TYPE_CUBE", f = "ENVMAP_MODE_REFLECTION", m = "ENVMAP_BLENDING_MULTIPLY";
            if (s.envMap) {
                switch (n.envMap.mapping) {
                    case 301:
                    case 302:
                        d = "ENVMAP_TYPE_CUBE";
                        break;
                    case 306:
                    case 307:
                        d = "ENVMAP_TYPE_CUBE_UV";
                        break;
                    case 303:
                    case 304:
                        d = "ENVMAP_TYPE_EQUIREC";
                        break;
                    case 305:
                        d = "ENVMAP_TYPE_SPHERE"
                }
                switch (n.envMap.mapping) {
                    case 302:
                    case 304:
                        f = "ENVMAP_MODE_REFRACTION"
                }
                switch (n.combine) {
                    case 0:
                        m = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case 1:
                        m = "ENVMAP_BLENDING_MIX";
                        break;
                    case 2:
                        m = "ENVMAP_BLENDING_ADD"
                }
            }
            var g, v, y, b, x, w = t.gammaFactor > 0 ? t.gammaFactor : 1, _ = a.isWebGL2 ? "" : function (t, e, i) {
                return [(t = t || {}).derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap && !e.objectSpaceNormalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t.shaderTextureLOD || e.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(yy).join("\n")
            }(n.extensions, s, e), E = function (t) {
                var e = [];
                for (var i in t) {
                    var n = t[i];
                    !1 !== n && e.push("#define " + i + " " + n)
                }
                return e.join("\n")
            }(l), M = h.createProgram();
            if (n.isRawShaderMaterial ? ((g = [E].filter(yy).join("\n")).length > 0 && (g += "\n"), (v = [_, E].filter(yy).join("\n")).length > 0 && (v += "\n")) : (g = ["precision " + s.precision + " float;", "precision " + s.precision + " int;", "#define SHADER_NAME " + r.name, E, s.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + w, "#define MAX_BONES " + s.maxBones, s.useFog && s.fog ? "#define USE_FOG" : "", s.useFog && s.fogExp ? "#define FOG_EXP2" : "", s.map ? "#define USE_MAP" : "", s.envMap ? "#define USE_ENVMAP" : "", s.envMap ? "#define " + f : "", s.lightMap ? "#define USE_LIGHTMAP" : "", s.aoMap ? "#define USE_AOMAP" : "", s.emissiveMap ? "#define USE_EMISSIVEMAP" : "", s.bumpMap ? "#define USE_BUMPMAP" : "", s.normalMap ? "#define USE_NORMALMAP" : "", s.normalMap && s.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", s.displacementMap && s.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", s.specularMap ? "#define USE_SPECULARMAP" : "", s.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", s.metalnessMap ? "#define USE_METALNESSMAP" : "", s.alphaMap ? "#define USE_ALPHAMAP" : "", s.vertexTangents ? "#define USE_TANGENT" : "", s.vertexColors ? "#define USE_COLOR" : "", s.flatShading ? "#define FLAT_SHADED" : "", s.skinning ? "#define USE_SKINNING" : "", s.useVertexTexture ? "#define BONE_TEXTURE" : "", s.morphTargets ? "#define USE_MORPHTARGETS" : "", s.morphNormals && !1 === s.flatShading ? "#define USE_MORPHNORMALS" : "", s.doubleSided ? "#define DOUBLE_SIDED" : "", s.flipSided ? "#define FLIP_SIDED" : "", s.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", s.shadowMapEnabled ? "#define " + p : "", s.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", s.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", s.logarithmicDepthBuffer && (a.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(yy).join("\n"), v = [_, "precision " + s.precision + " float;", "precision " + s.precision + " int;", "#define SHADER_NAME " + r.name, E, s.alphaTest ? "#define ALPHATEST " + s.alphaTest + (s.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + w, s.useFog && s.fog ? "#define USE_FOG" : "", s.useFog && s.fogExp ? "#define FOG_EXP2" : "", s.map ? "#define USE_MAP" : "", s.matcap ? "#define USE_MATCAP" : "", s.envMap ? "#define USE_ENVMAP" : "", s.envMap ? "#define " + d : "", s.envMap ? "#define " + f : "", s.envMap ? "#define " + m : "", s.lightMap ? "#define USE_LIGHTMAP" : "", s.aoMap ? "#define USE_AOMAP" : "", s.emissiveMap ? "#define USE_EMISSIVEMAP" : "", s.bumpMap ? "#define USE_BUMPMAP" : "", s.normalMap ? "#define USE_NORMALMAP" : "", s.normalMap && s.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", s.specularMap ? "#define USE_SPECULARMAP" : "", s.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", s.metalnessMap ? "#define USE_METALNESSMAP" : "", s.alphaMap ? "#define USE_ALPHAMAP" : "", s.vertexTangents ? "#define USE_TANGENT" : "", s.vertexColors ? "#define USE_COLOR" : "", s.gradientMap ? "#define USE_GRADIENTMAP" : "", s.flatShading ? "#define FLAT_SHADED" : "", s.doubleSided ? "#define DOUBLE_SIDED" : "", s.flipSided ? "#define FLIP_SIDED" : "", s.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", s.shadowMapEnabled ? "#define " + p : "", s.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", s.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", s.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", s.logarithmicDepthBuffer && (a.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", s.envMap && (a.isWebGL2 || e.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== s.toneMapping ? "#define TONE_MAPPING" : "", 0 !== s.toneMapping ? Qm.tonemapping_pars_fragment : "", 0 !== s.toneMapping ? vy("toneMapping", s.toneMapping) : "", s.dithering ? "#define DITHERING" : "", s.outputEncoding || s.mapEncoding || s.matcapEncoding || s.envMapEncoding || s.emissiveMapEncoding ? Qm.encodings_pars_fragment : "", s.mapEncoding ? gy("mapTexelToLinear", s.mapEncoding) : "", s.matcapEncoding ? gy("matcapTexelToLinear", s.matcapEncoding) : "", s.envMapEncoding ? gy("envMapTexelToLinear", s.envMapEncoding) : "", s.emissiveMapEncoding ? gy("emissiveMapTexelToLinear", s.emissiveMapEncoding) : "", s.outputEncoding ? (y = "linearToOutputTexel", b = s.outputEncoding, x = my(b), "vec4 " + y + "( vec4 value ) { return LinearTo" + x[0] + x[1] + "; }") : "", s.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(yy).join("\n")), c = xy(c = by(c = wy(c), s), s), u = xy(u = by(u = wy(u), s), s), c = _y(c), u = _y(u), a.isWebGL2 && !n.isRawShaderMaterial) {
                var A = !1, S = /^\s*#version\s+300\s+es\s*\n/;
                n.isShaderMaterial && null !== c.match(S) && null !== u.match(S) && (A = !0, c = c.replace(S, ""), u = u.replace(S, "")), g = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, v = ["#version 300 es\n", "#define varying in", A ? "" : "out highp vec4 pc_fragColor;", A ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v
            }
            var T, D, C = v + u, P = dy(h, 35633, g + c, t.debug.checkShaderErrors),
                I = dy(h, 35632, C, t.debug.checkShaderErrors);
            if (h.attachShader(M, P), h.attachShader(M, I), void 0 !== n.index0AttributeName ? h.bindAttribLocation(M, 0, n.index0AttributeName) : !0 === s.morphTargets && h.bindAttribLocation(M, 0, "position"), h.linkProgram(M), t.debug.checkShaderErrors) {
                var L = h.getProgramInfoLog(M).trim(), R = h.getShaderInfoLog(P).trim(),
                    F = h.getShaderInfoLog(I).trim(), k = !0, O = !0;
                !1 === h.getProgramParameter(M, 35714) ? (k = !1, console.error("THREE.WebGLProgram: shader error: ", h.getError(), "35715", h.getProgramParameter(M, 35715), "gl.getProgramInfoLog", L, R, F)) : "" !== L ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", L) : "" !== R && "" !== F || (O = !1), O && (this.diagnostics = {
                    runnable: k,
                    material: n,
                    programLog: L,
                    vertexShader: {log: R, prefix: g},
                    fragmentShader: {log: F, prefix: v}
                })
            }
            return h.deleteShader(P), h.deleteShader(I), this.getUniforms = function () {
                return void 0 === T && (T = new py(h, M, o)), T
            }, this.getAttributes = function () {
                return void 0 === D && (D = function (t, e) {
                    for (var i = {}, n = t.getProgramParameter(e, 35721), r = 0; r < n; r++) {
                        var s = t.getActiveAttrib(e, r).name;
                        i[s] = t.getAttribLocation(e, s)
                    }
                    return i
                }(h, M)), D
            }, this.destroy = function () {
                h.deleteProgram(M), this.program = void 0
            }, Object.defineProperties(this, {
                uniforms: {
                    get: function () {
                        return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                    }
                }, attributes: {
                    get: function () {
                        return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                    }
                }
            }), this.name = r.name, this.id = fy++, this.code = i, this.usedTimes = 1, this.program = M, this.vertexShader = P, this.fragmentShader = I, this
        }

        function My(t, e, i, n) {
            var r = [], s = {
                    MeshDepthMaterial: "depth",
                    MeshDistanceMaterial: "distanceRGBA",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshToonMaterial: "phong",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    MeshMatcapMaterial: "matcap",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points",
                    ShadowMaterial: "shadow",
                    SpriteMaterial: "sprite"
                },
                a = ["precision", "supportsVertexTextures", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];

            function o(t, e) {
                var i;
                return t ? t.isTexture ? i = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), i = t.texture.encoding) : i = ym, i === ym && e && (i = 3007), i
            }

            this.getParameters = function (e, n, r, a, h, l, c) {
                var u = s[e.type], p = c.isSkinnedMesh ? function (t) {
                    var e = t.skeleton.bones;
                    if (i.floatVertexTextures) return 1024;
                    var n = i.maxVertexUniforms, r = Math.floor((n - 20) / 4), s = Math.min(r, e.length);
                    return s < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + s + "."), 0) : s
                }(c) : 0, d = i.precision;
                null !== e.precision && (d = i.getMaxPrecision(e.precision)) !== e.precision && console.warn("THREE.WebGLProgram.getParameters:", e.precision, "not supported, using", d, "instead.");
                var f = t.getRenderTarget();
                return {
                    shaderID: u,
                    precision: d,
                    supportsVertexTextures: i.vertexTextures,
                    outputEncoding: o(f ? f.texture : null, t.gammaOutput),
                    map: !!e.map,
                    mapEncoding: o(e.map, t.gammaInput),
                    matcap: !!e.matcap,
                    matcapEncoding: o(e.matcap, t.gammaInput),
                    envMap: !!e.envMap,
                    envMapMode: e.envMap && e.envMap.mapping,
                    envMapEncoding: o(e.envMap, t.gammaInput),
                    envMapCubeUV: !!e.envMap && (306 === e.envMap.mapping || 307 === e.envMap.mapping),
                    lightMap: !!e.lightMap,
                    aoMap: !!e.aoMap,
                    emissiveMap: !!e.emissiveMap,
                    emissiveMapEncoding: o(e.emissiveMap, t.gammaInput),
                    bumpMap: !!e.bumpMap,
                    normalMap: !!e.normalMap,
                    objectSpaceNormalMap: 1 === e.normalMapType,
                    displacementMap: !!e.displacementMap,
                    roughnessMap: !!e.roughnessMap,
                    metalnessMap: !!e.metalnessMap,
                    specularMap: !!e.specularMap,
                    alphaMap: !!e.alphaMap,
                    gradientMap: !!e.gradientMap,
                    combine: e.combine,
                    vertexTangents: e.normalMap && e.vertexTangents,
                    vertexColors: e.vertexColors,
                    fog: !!a,
                    useFog: e.fog,
                    fogExp: a && a.isFogExp2,
                    flatShading: e.flatShading,
                    sizeAttenuation: e.sizeAttenuation,
                    logarithmicDepthBuffer: i.logarithmicDepthBuffer,
                    skinning: e.skinning && p > 0,
                    maxBones: p,
                    useVertexTexture: i.floatVertexTextures,
                    morphTargets: e.morphTargets,
                    morphNormals: e.morphNormals,
                    maxMorphTargets: t.maxMorphTargets,
                    maxMorphNormals: t.maxMorphNormals,
                    numDirLights: n.directional.length,
                    numPointLights: n.point.length,
                    numSpotLights: n.spot.length,
                    numRectAreaLights: n.rectArea.length,
                    numHemiLights: n.hemi.length,
                    numClippingPlanes: h,
                    numClipIntersection: l,
                    dithering: e.dithering,
                    shadowMapEnabled: t.shadowMap.enabled && c.receiveShadow && r.length > 0,
                    shadowMapType: t.shadowMap.type,
                    toneMapping: t.toneMapping,
                    physicallyCorrectLights: t.physicallyCorrectLights,
                    premultipliedAlpha: e.premultipliedAlpha,
                    alphaTest: e.alphaTest,
                    doubleSided: 2 === e.side,
                    flipSided: 1 === e.side,
                    depthPacking: void 0 !== e.depthPacking && e.depthPacking
                }
            }, this.getProgramCode = function (e, i) {
                var n = [];
                if (i.shaderID ? n.push(i.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines) for (var r in e.defines) n.push(r), n.push(e.defines[r]);
                for (var s = 0; s < a.length; s++) n.push(i[a[s]]);
                return n.push(e.onBeforeCompile.toString()), n.push(t.gammaOutput), n.push(t.gammaFactor), n.join()
            }, this.acquireProgram = function (s, a, o, h) {
                for (var l, c = 0, u = r.length; c < u; c++) {
                    var p = r[c];
                    if (p.code === h) {
                        ++(l = p).usedTimes;
                        break
                    }
                }
                return void 0 === l && (l = new Ey(t, e, h, s, a, o, i, n), r.push(l)), l
            }, this.releaseProgram = function (t) {
                if (0 == --t.usedTimes) {
                    var e = r.indexOf(t);
                    r[e] = r[r.length - 1], r.pop(), t.destroy()
                }
            }, this.programs = r
        }

        function Ay() {
            var t = new WeakMap;
            return {
                get: function (e) {
                    var i = t.get(e);
                    return void 0 === i && (i = {}, t.set(e, i)), i
                }, remove: function (e) {
                    t.delete(e)
                }, update: function (e, i, n) {
                    t.get(e)[i] = n
                }, dispose: function () {
                    t = new WeakMap
                }
            }
        }

        function Sy(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
        }

        function Ty(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
        }

        function Dy() {
            var t = [], e = 0, i = [], n = [], r = {id: -1};

            function s(i, n, s, a, o, h) {
                var l = t[e];
                return void 0 === l ? (l = {
                    id: i.id,
                    object: i,
                    geometry: n,
                    material: s,
                    program: s.program || r,
                    groupOrder: a,
                    renderOrder: i.renderOrder,
                    z: o,
                    group: h
                }, t[e] = l) : (l.id = i.id, l.object = i, l.geometry = n, l.material = s, l.program = s.program || r, l.groupOrder = a, l.renderOrder = i.renderOrder, l.z = o, l.group = h), e++, l
            }

            return {
                opaque: i, transparent: n, init: function () {
                    e = 0, i.length = 0, n.length = 0
                }, push: function (t, e, r, a, o, h) {
                    var l = s(t, e, r, a, o, h);
                    (!0 === r.transparent ? n : i).push(l)
                }, unshift: function (t, e, r, a, o, h) {
                    var l = s(t, e, r, a, o, h);
                    (!0 === r.transparent ? n : i).unshift(l)
                }, sort: function () {
                    i.length > 1 && i.sort(Sy), n.length > 1 && n.sort(Ty)
                }
            }
        }

        function Cy() {
            var t = {};

            function e(i) {
                var n = i.target;
                n.removeEventListener("dispose", e), delete t[n.id]
            }

            return {
                get: function (i, n) {
                    var r, s = t[i.id];
                    return void 0 === s ? (r = new Dy, t[i.id] = {}, t[i.id][n.id] = r, i.addEventListener("dispose", e)) : void 0 === (r = s[n.id]) && (r = new Dy, s[n.id] = r), r
                }, dispose: function () {
                    t = {}
                }
            }
        }

        function Py() {
            var t = {};
            return {
                get: function (e) {
                    if (void 0 !== t[e.id]) return t[e.id];
                    var i;
                    switch (e.type) {
                        case"DirectionalLight":
                            i = {
                                direction: new _m,
                                color: new rg,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new xm
                            };
                            break;
                        case"SpotLight":
                            i = {
                                position: new _m,
                                direction: new _m,
                                color: new rg,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new xm
                            };
                            break;
                        case"PointLight":
                            i = {
                                position: new _m,
                                color: new rg,
                                distance: 0,
                                decay: 0,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new xm,
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3
                            };
                            break;
                        case"HemisphereLight":
                            i = {direction: new _m, skyColor: new rg, groundColor: new rg};
                            break;
                        case"RectAreaLight":
                            i = {color: new rg, position: new _m, halfWidth: new _m, halfHeight: new _m}
                    }
                    return t[e.id] = i, i
                }
            }
        }

        var Iy = 0;

        function Ly() {
            for (var t = new Py, e = {
                id: Iy++,
                hash: {
                    stateID: -1,
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    shadowsLength: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                point: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: []
            }, i = 0; i < 9; i++) e.probe.push(new _m);
            var n = new _m, r = new Jm, s = new Jm;
            return {
                setup: function (i, a, o) {
                    for (var h = 0, l = 0, c = 0, u = 0; u < 9; u++) e.probe[u].set(0, 0, 0);
                    for (var p = 0, d = 0, f = 0, m = 0, g = 0, v = o.matrixWorldInverse, y = (u = 0, i.length); u < y; u++) {
                        var b = i[u], x = b.color, w = b.intensity, _ = b.distance,
                            E = b.shadow && b.shadow.map ? b.shadow.map.texture : null;
                        if (b.isAmbientLight) h += x.r * w, l += x.g * w, c += x.b * w; else if (b.isLightProbe) for (var M = 0; M < 9; M++) e.probe[M].addScaledVector(b.sh.coefficients[M], w); else if (b.isDirectionalLight) {
                            if ((S = t.get(b)).color.copy(b.color).multiplyScalar(b.intensity), S.direction.setFromMatrixPosition(b.matrixWorld), n.setFromMatrixPosition(b.target.matrixWorld), S.direction.sub(n), S.direction.transformDirection(v), S.shadow = b.castShadow, b.castShadow) {
                                var A = b.shadow;
                                S.shadowBias = A.bias, S.shadowRadius = A.radius, S.shadowMapSize = A.mapSize
                            }
                            e.directionalShadowMap[p] = E, e.directionalShadowMatrix[p] = b.shadow.matrix, e.directional[p] = S, p++
                        } else if (b.isSpotLight) {
                            if ((S = t.get(b)).position.setFromMatrixPosition(b.matrixWorld), S.position.applyMatrix4(v), S.color.copy(x).multiplyScalar(w), S.distance = _, S.direction.setFromMatrixPosition(b.matrixWorld), n.setFromMatrixPosition(b.target.matrixWorld), S.direction.sub(n), S.direction.transformDirection(v), S.coneCos = Math.cos(b.angle), S.penumbraCos = Math.cos(b.angle * (1 - b.penumbra)), S.decay = b.decay, S.shadow = b.castShadow, b.castShadow) {
                                A = b.shadow;
                                S.shadowBias = A.bias, S.shadowRadius = A.radius, S.shadowMapSize = A.mapSize
                            }
                            e.spotShadowMap[f] = E, e.spotShadowMatrix[f] = b.shadow.matrix, e.spot[f] = S, f++
                        } else if (b.isRectAreaLight) {
                            (S = t.get(b)).color.copy(x).multiplyScalar(w), S.position.setFromMatrixPosition(b.matrixWorld), S.position.applyMatrix4(v), s.identity(), r.copy(b.matrixWorld), r.premultiply(v), s.extractRotation(r), S.halfWidth.set(.5 * b.width, 0, 0), S.halfHeight.set(0, .5 * b.height, 0), S.halfWidth.applyMatrix4(s), S.halfHeight.applyMatrix4(s), e.rectArea[m] = S, m++
                        } else if (b.isPointLight) {
                            if ((S = t.get(b)).position.setFromMatrixPosition(b.matrixWorld), S.position.applyMatrix4(v), S.color.copy(b.color).multiplyScalar(b.intensity), S.distance = b.distance, S.decay = b.decay, S.shadow = b.castShadow, b.castShadow) {
                                A = b.shadow;
                                S.shadowBias = A.bias, S.shadowRadius = A.radius, S.shadowMapSize = A.mapSize, S.shadowCameraNear = A.camera.near, S.shadowCameraFar = A.camera.far
                            }
                            e.pointShadowMap[d] = E, e.pointShadowMatrix[d] = b.shadow.matrix, e.point[d] = S, d++
                        } else if (b.isHemisphereLight) {
                            var S;
                            (S = t.get(b)).direction.setFromMatrixPosition(b.matrixWorld), S.direction.transformDirection(v), S.direction.normalize(), S.skyColor.copy(b.color).multiplyScalar(w), S.groundColor.copy(b.groundColor).multiplyScalar(w), e.hemi[g] = S, g++
                        }
                    }
                    e.ambient[0] = h, e.ambient[1] = l, e.ambient[2] = c, e.directional.length = p, e.spot.length = f, e.rectArea.length = m, e.point.length = d, e.hemi.length = g, e.hash.stateID = e.id, e.hash.directionalLength = p, e.hash.pointLength = d, e.hash.spotLength = f, e.hash.rectAreaLength = m, e.hash.hemiLength = g, e.hash.shadowsLength = a.length
                }, state: e
            }
        }

        function Ry() {
            var t = new Ly, e = [], i = [];
            return {
                init: function () {
                    e.length = 0, i.length = 0
                }, state: {lightsArray: e, shadowsArray: i, lights: t}, setupLights: function (n) {
                    t.setup(e, i, n)
                }, pushLight: function (t) {
                    e.push(t)
                }, pushShadow: function (t) {
                    i.push(t)
                }
            }
        }

        function Fy() {
            var t = {};

            function e(i) {
                var n = i.target;
                n.removeEventListener("dispose", e), delete t[n.id]
            }

            return {
                get: function (i, n) {
                    var r;
                    return void 0 === t[i.id] ? (r = new Ry, t[i.id] = {}, t[i.id][n.id] = r, i.addEventListener("dispose", e)) : void 0 === t[i.id][n.id] ? (r = new Ry, t[i.id][n.id] = r) : r = t[i.id][n.id], r
                }, dispose: function () {
                    t = {}
                }
            }
        }

        function ky(t) {
            Vg.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(t)
        }

        function Oy(t) {
            Vg.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new _m, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(t)
        }

        function zy(t, e, i) {
            for (var n = new Zm, r = new Jm, s = new xm, a = new xm(i, i), o = new _m, h = new _m, l = new Array(4), c = new Array(4), u = {}, p = {
                0: 1,
                1: 0,
                2: 2
            }, d = [new _m(1, 0, 0), new _m(-1, 0, 0), new _m(0, 0, 1), new _m(0, 0, -1), new _m(0, 1, 0), new _m(0, -1, 0)], f = [new _m(0, 1, 0), new _m(0, 1, 0), new _m(0, 1, 0), new _m(0, 1, 0), new _m(0, 0, 1), new _m(0, 0, -1)], m = [new Vm, new Vm, new Vm, new Vm, new Vm, new Vm], g = 0; 4 !== g; ++g) {
                var v = 0 != (1 & g), y = 0 != (2 & g), b = new ky({depthPacking: 3201, morphTargets: v, skinning: y});
                l[g] = b;
                var x = new Oy({morphTargets: v, skinning: y});
                c[g] = x
            }
            var w = this;

            function _(e, i, n, r, s, a) {
                var o = e.geometry, h = null, d = l, f = e.customDepthMaterial;
                if (n && (d = c, f = e.customDistanceMaterial), f) h = f; else {
                    var m = !1;
                    i.morphTargets && (o && o.isBufferGeometry ? m = o.morphAttributes && o.morphAttributes.position && o.morphAttributes.position.length > 0 : o && o.isGeometry && (m = o.morphTargets && o.morphTargets.length > 0)), e.isSkinnedMesh && !1 === i.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e);
                    var g = 0;
                    m && (g |= 1), e.isSkinnedMesh && i.skinning && (g |= 2), h = d[g]
                }
                if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
                    var v = h.uuid, y = i.uuid, b = u[v];
                    void 0 === b && (b = {}, u[v] = b);
                    var x = b[y];
                    void 0 === x && (x = h.clone(), b[y] = x), h = x
                }
                return h.visible = i.visible, h.wireframe = i.wireframe, h.side = null != i.shadowSide ? i.shadowSide : p[i.side], h.clipShadows = i.clipShadows, h.clippingPlanes = i.clippingPlanes, h.clipIntersection = i.clipIntersection, h.wireframeLinewidth = i.wireframeLinewidth, h.linewidth = i.linewidth, n && h.isMeshDistanceMaterial && (h.referencePosition.copy(r), h.nearDistance = s, h.farDistance = a), h
            }

            function E(i, r, s, a) {
                if (!1 !== i.visible) {
                    if (i.layers.test(r.layers) && (i.isMesh || i.isLine || i.isPoints) && i.castShadow && (!i.frustumCulled || n.intersectsObject(i))) {
                        i.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, i.matrixWorld);
                        var o = e.update(i), l = i.material;
                        if (Array.isArray(l)) for (var c = o.groups, u = 0, p = c.length; u < p; u++) {
                            var d = c[u], f = l[d.materialIndex];
                            if (f && f.visible) {
                                var m = _(i, f, a, h, s.near, s.far);
                                t.renderBufferDirect(s, null, o, m, i, d)
                            }
                        } else if (l.visible) {
                            m = _(i, l, a, h, s.near, s.far);
                            t.renderBufferDirect(s, null, o, m, i, null)
                        }
                    }
                    for (var g = i.children, v = 0, y = g.length; v < y; v++) E(g[v], r, s, a)
                }
            }

            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function (e, i, l) {
                if (!1 !== w.enabled && (!1 !== w.autoUpdate || !1 !== w.needsUpdate) && 0 !== e.length) {
                    var c, u = t.getRenderTarget(), p = t.getActiveCubeFace(), g = t.getActiveMipMapLevel(),
                        v = t.state;
                    v.setBlending(0), v.buffers.color.setClear(1, 1, 1, 1), v.buffers.depth.setTest(!0), v.setScissorTest(!1);
                    for (var y = 0, b = e.length; y < b; y++) {
                        var x = e[y], _ = x.shadow, M = x && x.isPointLight;
                        if (void 0 !== _) {
                            var A = _.camera;
                            if (s.copy(_.mapSize), s.min(a), M) {
                                var S = s.x, T = s.y;
                                m[0].set(2 * S, T, S, T), m[1].set(0, T, S, T), m[2].set(3 * S, T, S, T), m[3].set(S, T, S, T), m[4].set(3 * S, 0, S, T), m[5].set(S, 0, S, T), s.x *= 4, s.y *= 2
                            }
                            if (null === _.map) {
                                var D = {minFilter: Kf, magFilter: Kf, format: lm};
                                _.map = new Gm(s.x, s.y, D), _.map.texture.name = x.name + ".shadowMap", A.updateProjectionMatrix()
                            }
                            _.isSpotLightShadow && _.update(x);
                            var C = _.map, P = _.matrix;
                            h.setFromMatrixPosition(x.matrixWorld), A.position.copy(h), M ? (c = 6, P.makeTranslation(-h.x, -h.y, -h.z)) : (c = 1, o.setFromMatrixPosition(x.target.matrixWorld), A.lookAt(o), A.updateMatrixWorld(), P.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), P.multiply(A.projectionMatrix), P.multiply(A.matrixWorldInverse)), t.setRenderTarget(C), t.clear();
                            for (var I = 0; I < c; I++) {
                                if (M) {
                                    o.copy(A.position), o.add(d[I]), A.up.copy(f[I]), A.lookAt(o), A.updateMatrixWorld();
                                    var L = m[I];
                                    v.viewport(L)
                                }
                                r.multiplyMatrices(A.projectionMatrix, A.matrixWorldInverse), n.setFromMatrix(r), E(i, l, A, M)
                            }
                        } else console.warn("THREE.WebGLShadowMap:", x, "has no shadow.")
                    }
                    w.needsUpdate = !1, t.setRenderTarget(u, p, g)
                }
            }
        }

        function By(t, e, i, n) {
            var r = new function () {
                    var e = !1, i = new Vm, n = null, r = new Vm(0, 0, 0, 0);
                    return {
                        setMask: function (i) {
                            n === i || e || (t.colorMask(i, i, i, i), n = i)
                        }, setLocked: function (t) {
                            e = t
                        }, setClear: function (e, n, s, a, o) {
                            !0 === o && (e *= a, n *= a, s *= a), i.set(e, n, s, a), !1 === r.equals(i) && (t.clearColor(e, n, s, a), r.copy(i))
                        }, reset: function () {
                            e = !1, n = null, r.set(-1, 0, 0, 0)
                        }
                    }
                }, s = new function () {
                    var e = !1, i = null, n = null, r = null;
                    return {
                        setTest: function (t) {
                            t ? N(2929) : j(2929)
                        }, setMask: function (n) {
                            i === n || e || (t.depthMask(n), i = n)
                        }, setFunc: function (e) {
                            if (n !== e) {
                                if (e) switch (e) {
                                    case 0:
                                        t.depthFunc(512);
                                        break;
                                    case 1:
                                        t.depthFunc(519);
                                        break;
                                    case 2:
                                        t.depthFunc(513);
                                        break;
                                    case 3:
                                    default:
                                        t.depthFunc(515);
                                        break;
                                    case 4:
                                        t.depthFunc(514);
                                        break;
                                    case 5:
                                        t.depthFunc(518);
                                        break;
                                    case 6:
                                        t.depthFunc(516);
                                        break;
                                    case 7:
                                        t.depthFunc(517)
                                } else t.depthFunc(515);
                                n = e
                            }
                        }, setLocked: function (t) {
                            e = t
                        }, setClear: function (e) {
                            r !== e && (t.clearDepth(e), r = e)
                        }, reset: function () {
                            e = !1, i = null, n = null, r = null
                        }
                    }
                }, a = new function () {
                    var e = !1, i = null, n = null, r = null, s = null, a = null, o = null, h = null, l = null;
                    return {
                        setTest: function (t) {
                            t ? N(2960) : j(2960)
                        }, setMask: function (n) {
                            i === n || e || (t.stencilMask(n), i = n)
                        }, setFunc: function (e, i, a) {
                            n === e && r === i && s === a || (t.stencilFunc(e, i, a), n = e, r = i, s = a)
                        }, setOp: function (e, i, n) {
                            a === e && o === i && h === n || (t.stencilOp(e, i, n), a = e, o = i, h = n)
                        }, setLocked: function (t) {
                            e = t
                        }, setClear: function (e) {
                            l !== e && (t.clearStencil(e), l = e)
                        }, reset: function () {
                            e = !1, i = null, n = null, r = null, s = null, a = null, o = null, h = null, l = null
                        }
                    }
                }, o = t.getParameter(34921), h = new Uint8Array(o), l = new Uint8Array(o), c = new Uint8Array(o), u = {},
                p = null, d = null, f = null, m = null, g = null, v = null, y = null, b = null, x = null, w = null,
                _ = !1, E = null, M = null, A = null, S = null, T = null, D = t.getParameter(35661), C = !1, P = 0,
                I = t.getParameter(7938);
            -1 !== I.indexOf("WebGL") ? (P = parseFloat(/^WebGL\ ([0-9])/.exec(I)[1]), C = P >= 1) : -1 !== I.indexOf("OpenGL ES") && (P = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(I)[1]), C = P >= 2);
            var L = null, R = {}, F = new Vm, k = new Vm;

            function O(e, i, n) {
                var r = new Uint8Array(4), s = t.createTexture();
                t.bindTexture(e, s), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
                for (var a = 0; a < n; a++) t.texImage2D(i + a, 0, 6408, 1, 1, 0, 6408, 5121, r);
                return s
            }

            var z = {};

            function B(i, r) {
                (h[i] = 1, 0 === l[i] && (t.enableVertexAttribArray(i), l[i] = 1), c[i] !== r) && ((n.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, r), c[i] = r)
            }

            function N(e) {
                !0 !== u[e] && (t.enable(e), u[e] = !0)
            }

            function j(e) {
                !1 !== u[e] && (t.disable(e), u[e] = !1)
            }

            function V(e, n, r, s, a, o, h, l) {
                if (0 !== e) {
                    if (f || (N(3042), f = !0), 5 === e) a = a || n, o = o || r, h = h || s, n === g && a === b || (t.blendEquationSeparate(i.convert(n), i.convert(a)), g = n, b = a), r === v && s === y && o === x && h === w || (t.blendFuncSeparate(i.convert(r), i.convert(s), i.convert(o), i.convert(h)), v = r, y = s, x = o, w = h), m = e, _ = null; else if (e !== m || l !== _) {
                        if (g === Yf && b === Yf || (t.blendEquation(32774), g = Yf, b = Yf), l) switch (e) {
                            case 1:
                                t.blendFuncSeparate(1, 771, 1, 771);
                                break;
                            case 2:
                                t.blendFunc(1, 1);
                                break;
                            case 3:
                                t.blendFuncSeparate(0, 0, 769, 771);
                                break;
                            case 4:
                                t.blendFuncSeparate(0, 768, 0, 770);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                        } else switch (e) {
                            case 1:
                                t.blendFuncSeparate(770, 771, 1, 771);
                                break;
                            case 2:
                                t.blendFunc(770, 1);
                                break;
                            case 3:
                                t.blendFunc(0, 769);
                                break;
                            case 4:
                                t.blendFunc(0, 768);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                        }
                        v = null, y = null, x = null, w = null, m = e, _ = l
                    }
                } else f && (j(3042), f = !1)
            }

            function G(e) {
                E !== e && (e ? t.frontFace(2304) : t.frontFace(2305), E = e)
            }

            function U(e) {
                0 !== e ? (N(2884), e !== M && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : j(2884), M = e
            }

            function H(e, i, n) {
                e ? (N(32823), S === i && T === n || (t.polygonOffset(i, n), S = i, T = n)) : j(32823)
            }

            function W(e) {
                void 0 === e && (e = 33984 + D - 1), L !== e && (t.activeTexture(e), L = e)
            }

            return z[3553] = O(3553, 3553, 1), z[34067] = O(34067, 34069, 6), r.setClear(0, 0, 0, 1), s.setClear(1), a.setClear(0), N(2929), s.setFunc(3), G(!1), U(1), N(2884), V(0), {
                buffers: {color: r, depth: s, stencil: a}, initAttributes: function () {
                    for (var t = 0, e = h.length; t < e; t++) h[t] = 0
                }, enableAttribute: function (t) {
                    B(t, 0)
                }, enableAttributeAndDivisor: B, disableUnusedAttributes: function () {
                    for (var e = 0, i = l.length; e !== i; ++e) l[e] !== h[e] && (t.disableVertexAttribArray(e), l[e] = 0)
                }, enable: N, disable: j, getCompressedTextureFormats: function () {
                    if (null === p && (p = [], e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1") || e.get("WEBGL_compressed_texture_astc"))) for (var i = t.getParameter(34467), n = 0; n < i.length; n++) p.push(i[n]);
                    return p
                }, useProgram: function (e) {
                    return d !== e && (t.useProgram(e), d = e, !0)
                }, setBlending: V, setMaterial: function (t, e) {
                    2 === t.side ? j(2884) : N(2884);
                    var i = 1 === t.side;
                    e && (i = !i), G(i), 1 === t.blending && !1 === t.transparent ? V(0) : V(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), s.setFunc(t.depthFunc), s.setTest(t.depthTest), s.setMask(t.depthWrite), r.setMask(t.colorWrite), H(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
                }, setFlipSided: G, setCullFace: U, setLineWidth: function (e) {
                    e !== A && (C && t.lineWidth(e), A = e)
                }, setPolygonOffset: H, setScissorTest: function (t) {
                    t ? N(3089) : j(3089)
                }, activeTexture: W, bindTexture: function (e, i) {
                    null === L && W();
                    var n = R[L];
                    void 0 === n && (n = {
                        type: void 0,
                        texture: void 0
                    }, R[L] = n), n.type === e && n.texture === i || (t.bindTexture(e, i || z[e]), n.type = e, n.texture = i)
                }, compressedTexImage2D: function () {
                    try {
                        t.compressedTexImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                }, texImage2D: function () {
                    try {
                        t.texImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                }, texImage3D: function () {
                    try {
                        t.texImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                }, scissor: function (e) {
                    !1 === F.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), F.copy(e))
                }, viewport: function (e) {
                    !1 === k.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), k.copy(e))
                }, reset: function () {
                    for (var e = 0; e < l.length; e++) 1 === l[e] && (t.disableVertexAttribArray(e), l[e] = 0);
                    u = {}, p = null, L = null, R = {}, d = null, m = null, E = null, M = null, r.reset(), s.reset(), a.reset()
                }
            }
        }

        function Ny(t, e, i, n, r, s, a) {
            var o, h = {}, l = "undefined" != typeof OffscreenCanvas;

            function c(t, e) {
                return l ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
            }

            function u(t, e, i, n) {
                var r = 1;
                if ((t.width > n || t.height > n) && (r = n / Math.max(t.width, t.height)), r < 1 || !0 === e) {
                    if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                        var s = e ? bm.floorPowerOfTwo : Math.floor, a = s(r * t.width), h = s(r * t.height);
                        void 0 === o && (o = c(a, h));
                        var l = i ? c(a, h) : o;
                        return l.width = a, l.height = h, l.getContext("2d").drawImage(t, 0, 0, a, h), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + a + "x" + h + ")."), l
                    }
                    return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
                }
                return t
            }

            function p(t) {
                return bm.isPowerOfTwo(t.width) && bm.isPowerOfTwo(t.height)
            }

            function d(t, e) {
                return t.generateMipmaps && e && t.minFilter !== Kf && t.minFilter !== em
            }

            function f(e, i, r, s) {
                t.generateMipmap(e), n.get(i).__maxMipLevel = Math.log(Math.max(r, s)) * Math.LOG2E
            }

            function m(t, i) {
                if (!r.isWebGL2) return t;
                var n = t;
                return 6403 === t && (5126 === i && (n = 33326), 5131 === i && (n = 33325), 5121 === i && (n = 33321)), 6407 === t && (5126 === i && (n = 34837), 5131 === i && (n = 34843), 5121 === i && (n = 32849)), 6408 === t && (5126 === i && (n = 34836), 5131 === i && (n = 34842), 5121 === i && (n = 32856)), 33325 === n || 33326 === n || 34842 === n || 34836 === n ? e.get("EXT_color_buffer_float") : 34843 !== n && 34837 !== n || console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."), n
            }

            function g(t) {
                return t === Kf || t === $f || t === tm ? 9728 : 9729
            }

            function v(e) {
                var i = e.target;
                i.removeEventListener("dispose", v), function (e) {
                    var i = n.get(e);
                    if (void 0 === i.__webglInit) return;
                    t.deleteTexture(i.__webglTexture), n.remove(e)
                }(i), i.isVideoTexture && delete h[i.id], a.memory.textures--
            }

            function y(e) {
                var i = e.target;
                i.removeEventListener("dispose", y), function (e) {
                    var i = n.get(e), r = n.get(e.texture);
                    if (!e) return;
                    void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture);
                    e.depthTexture && e.depthTexture.dispose();
                    if (e.isWebGLRenderTargetCube) for (var s = 0; s < 6; s++) t.deleteFramebuffer(i.__webglFramebuffer[s]), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer[s]); else t.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer);
                    n.remove(e.texture), n.remove(e)
                }(i), a.memory.textures--
            }

            var b = 0;

            function x(t, e) {
                var r = n.get(t);
                if (t.isVideoTexture && function (t) {
                    var e = t.id, i = a.render.frame;
                    h[e] !== i && (h[e] = i, t.update())
                }(t), t.version > 0 && r.__version !== t.version) {
                    var s = t.image;
                    if (void 0 === s) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else {
                        if (!1 !== s.complete) return void A(r, t, e);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                i.activeTexture(33984 + e), i.bindTexture(3553, r.__webglTexture)
            }

            function w(e, a) {
                var o = n.get(e);
                if (6 === e.image.length) if (e.version > 0 && o.__version !== e.version) {
                    M(o, e), i.activeTexture(33984 + a), i.bindTexture(34067, o.__webglTexture), t.pixelStorei(37440, e.flipY);
                    for (var h = e && e.isCompressedTexture, l = e.image[0] && e.image[0].isDataTexture, c = [], g = 0; g < 6; g++) c[g] = h || l ? l ? e.image[g].image : e.image[g] : u(e.image[g], !1, !0, r.maxCubemapSize);
                    var v = c[0], y = p(v) || r.isWebGL2, b = s.convert(e.format), x = s.convert(e.type), w = m(b, x);
                    E(34067, e, y);
                    for (g = 0; g < 6; g++) if (h) for (var _, A = c[g].mipmaps, S = 0, T = A.length; S < T; S++) _ = A[S], e.format !== lm && e.format !== hm ? i.getCompressedTextureFormats().indexOf(b) > -1 ? i.compressedTexImage2D(34069 + g, S, w, _.width, _.height, 0, _.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i.texImage2D(34069 + g, S, w, _.width, _.height, 0, b, x, _.data); else l ? i.texImage2D(34069 + g, 0, w, c[g].width, c[g].height, 0, b, x, c[g].data) : i.texImage2D(34069 + g, 0, w, b, x, c[g]);
                    o.__maxMipLevel = h ? A.length - 1 : 0, d(e, y) && f(34067, e, v.width, v.height), o.__version = e.version, e.onUpdate && e.onUpdate(e)
                } else i.activeTexture(33984 + a), i.bindTexture(34067, o.__webglTexture)
            }

            function _(t, e) {
                i.activeTexture(33984 + e), i.bindTexture(34067, n.get(t).__webglTexture)
            }

            function E(i, a, o) {
                var h;
                if (o ? (t.texParameteri(i, 10242, s.convert(a.wrapS)), t.texParameteri(i, 10243, s.convert(a.wrapT)), 32879 !== i && 35866 !== i || t.texParameteri(i, 32882, s.convert(a.wrapR)), t.texParameteri(i, 10240, s.convert(a.magFilter)), t.texParameteri(i, 10241, s.convert(a.minFilter))) : (t.texParameteri(i, 10242, 33071), t.texParameteri(i, 10243, 33071), 32879 !== i && 35866 !== i || t.texParameteri(i, 32882, 33071), a.wrapS === Jf && a.wrapT === Jf || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(i, 10240, g(a.magFilter)), t.texParameteri(i, 10241, g(a.minFilter)), a.minFilter !== Kf && a.minFilter !== em && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), h = e.get("EXT_texture_filter_anisotropic")) {
                    if (a.type === sm && null === e.get("OES_texture_float_linear")) return;
                    if (a.type === am && null === (r.isWebGL2 || e.get("OES_texture_half_float_linear"))) return;
                    (a.anisotropy > 1 || n.get(a).__currentAnisotropy) && (t.texParameterf(i, h.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())), n.get(a).__currentAnisotropy = a.anisotropy)
                }
            }

            function M(e, i) {
                void 0 === e.__webglInit && (e.__webglInit = !0, i.addEventListener("dispose", v), e.__webglTexture = t.createTexture(), a.memory.textures++)
            }

            function A(e, n, a) {
                var o = 3553;
                n.isDataTexture2DArray && (o = 35866), n.isDataTexture3D && (o = 32879), M(e, n), i.activeTexture(33984 + a), i.bindTexture(o, e.__webglTexture), t.pixelStorei(37440, n.flipY), t.pixelStorei(37441, n.premultiplyAlpha), t.pixelStorei(3317, n.unpackAlignment);
                var h = function (t) {
                        return !r.isWebGL2 && (t.wrapS !== Jf || t.wrapT !== Jf || t.minFilter !== Kf && t.minFilter !== em)
                    }(n) && !1 === p(n.image), l = u(n.image, h, !1, r.maxTextureSize), c = p(l) || r.isWebGL2,
                    g = s.convert(n.format), v = s.convert(n.type), y = m(g, v);
                E(o, n, c);
                var b, x = n.mipmaps;
                if (n.isDepthTexture) {
                    if (y = 6402, n.type === sm) {
                        if (!r.isWebGL2) throw new Error("Float Depth Texture only supported in WebGL2.0");
                        y = 36012
                    } else r.isWebGL2 && (y = 33189);
                    n.format === cm && 6402 === y && n.type !== rm && 1014 !== n.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n.type = rm, v = s.convert(n.type)), n.format === um && (y = 34041, n.type !== om && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n.type = om, v = s.convert(n.type))), i.texImage2D(3553, 0, y, l.width, l.height, 0, g, v, null)
                } else if (n.isDataTexture) if (x.length > 0 && c) {
                    for (var w = 0, _ = x.length; w < _; w++) b = x[w], i.texImage2D(3553, w, y, b.width, b.height, 0, g, v, b.data);
                    n.generateMipmaps = !1, e.__maxMipLevel = x.length - 1
                } else i.texImage2D(3553, 0, y, l.width, l.height, 0, g, v, l.data), e.__maxMipLevel = 0; else if (n.isCompressedTexture) {
                    for (w = 0, _ = x.length; w < _; w++) b = x[w], n.format !== lm && n.format !== hm ? i.getCompressedTextureFormats().indexOf(g) > -1 ? i.compressedTexImage2D(3553, w, y, b.width, b.height, 0, b.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i.texImage2D(3553, w, y, b.width, b.height, 0, g, v, b.data);
                    e.__maxMipLevel = x.length - 1
                } else if (n.isDataTexture2DArray) i.texImage3D(35866, 0, y, l.width, l.height, l.depth, 0, g, v, l.data), e.__maxMipLevel = 0; else if (n.isDataTexture3D) i.texImage3D(32879, 0, y, l.width, l.height, l.depth, 0, g, v, l.data), e.__maxMipLevel = 0; else if (x.length > 0 && c) {
                    for (w = 0, _ = x.length; w < _; w++) b = x[w], i.texImage2D(3553, w, y, g, v, b);
                    n.generateMipmaps = !1, e.__maxMipLevel = x.length - 1
                } else i.texImage2D(3553, 0, y, g, v, l), e.__maxMipLevel = 0;
                d(n, c) && f(3553, n, l.width, l.height), e.__version = n.version, n.onUpdate && n.onUpdate(n)
            }

            function S(e, r, a, o) {
                var h = s.convert(r.texture.format), l = s.convert(r.texture.type), c = m(h, l);
                i.texImage2D(o, 0, c, r.width, r.height, 0, h, l, null), t.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, a, o, n.get(r.texture).__webglTexture, 0), t.bindFramebuffer(36160, null)
            }

            function T(e, i, n) {
                if (t.bindRenderbuffer(36161, e), i.depthBuffer && !i.stencilBuffer) {
                    if (n) {
                        var r = C(i);
                        t.renderbufferStorageMultisample(36161, r, 33189, i.width, i.height)
                    } else t.renderbufferStorage(36161, 33189, i.width, i.height);
                    t.framebufferRenderbuffer(36160, 36096, 36161, e)
                } else if (i.depthBuffer && i.stencilBuffer) {
                    if (n) {
                        r = C(i);
                        t.renderbufferStorageMultisample(36161, r, 34041, i.width, i.height)
                    } else t.renderbufferStorage(36161, 34041, i.width, i.height);
                    t.framebufferRenderbuffer(36160, 33306, 36161, e)
                } else {
                    var a = m(s.convert(i.texture.format), s.convert(i.texture.type));
                    if (n) {
                        r = C(i);
                        t.renderbufferStorageMultisample(36161, r, a, i.width, i.height)
                    } else t.renderbufferStorage(36161, a, i.width, i.height)
                }
                t.bindRenderbuffer(36161, null)
            }

            function D(e) {
                var i = n.get(e), r = !0 === e.isWebGLRenderTargetCube;
                if (e.depthTexture) {
                    if (r) throw new Error("target.depthTexture not supported in Cube render targets");
                    !function (e, i) {
                        if (i && i.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported");
                        if (t.bindFramebuffer(36160, e), !i.depthTexture || !i.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        n.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), x(i.depthTexture, 0);
                        var r = n.get(i.depthTexture).__webglTexture;
                        if (i.depthTexture.format === cm) t.framebufferTexture2D(36160, 36096, 3553, r, 0); else {
                            if (i.depthTexture.format !== um) throw new Error("Unknown depthTexture format");
                            t.framebufferTexture2D(36160, 33306, 3553, r, 0)
                        }
                    }(i.__webglFramebuffer, e)
                } else if (r) {
                    i.__webglDepthbuffer = [];
                    for (var s = 0; s < 6; s++) t.bindFramebuffer(36160, i.__webglFramebuffer[s]), i.__webglDepthbuffer[s] = t.createRenderbuffer(), T(i.__webglDepthbuffer[s], e)
                } else t.bindFramebuffer(36160, i.__webglFramebuffer), i.__webglDepthbuffer = t.createRenderbuffer(), T(i.__webglDepthbuffer, e);
                t.bindFramebuffer(36160, null)
            }

            function C(t) {
                return r.isWebGL2 && t.isWebGLMultisampleRenderTarget ? Math.min(r.maxSamples, t.samples) : 0
            }

            var P = !1, I = !1;
            this.allocateTextureUnit = function () {
                var t = b;
                return t >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + r.maxTextures), b += 1, t
            }, this.resetTextureUnits = function () {
                b = 0
            }, this.setTexture2D = x, this.setTexture2DArray = function (t, e) {
                var r = n.get(t);
                t.version > 0 && r.__version !== t.version ? A(r, t, e) : (i.activeTexture(33984 + e), i.bindTexture(35866, r.__webglTexture))
            }, this.setTexture3D = function (t, e) {
                var r = n.get(t);
                t.version > 0 && r.__version !== t.version ? A(r, t, e) : (i.activeTexture(33984 + e), i.bindTexture(32879, r.__webglTexture))
            }, this.setTextureCube = w, this.setTextureCubeDynamic = _, this.setupRenderTarget = function (e) {
                var o = n.get(e), h = n.get(e.texture);
                e.addEventListener("dispose", y), h.__webglTexture = t.createTexture(), a.memory.textures++;
                var l = !0 === e.isWebGLRenderTargetCube, c = !0 === e.isWebGLMultisampleRenderTarget,
                    u = p(e) || r.isWebGL2;
                if (l) {
                    o.__webglFramebuffer = [];
                    for (var g = 0; g < 6; g++) o.__webglFramebuffer[g] = t.createFramebuffer()
                } else if (o.__webglFramebuffer = t.createFramebuffer(), c) if (r.isWebGL2) {
                    o.__webglMultisampledFramebuffer = t.createFramebuffer(), o.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, o.__webglColorRenderbuffer);
                    var v = m(s.convert(e.texture.format), s.convert(e.texture.type)), b = C(e);
                    t.renderbufferStorageMultisample(36161, b, v, e.width, e.height), t.bindFramebuffer(36160, o.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, o.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (o.__webglDepthRenderbuffer = t.createRenderbuffer(), T(o.__webglDepthRenderbuffer, e, !0)), t.bindFramebuffer(36160, null)
                } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                if (l) {
                    i.bindTexture(34067, h.__webglTexture), E(34067, e.texture, u);
                    for (g = 0; g < 6; g++) S(o.__webglFramebuffer[g], e, 36064, 34069 + g);
                    d(e.texture, u) && f(34067, e.texture, e.width, e.height), i.bindTexture(34067, null)
                } else i.bindTexture(3553, h.__webglTexture), E(3553, e.texture, u), S(o.__webglFramebuffer, e, 36064, 3553), d(e.texture, u) && f(3553, e.texture, e.width, e.height), i.bindTexture(3553, null);
                e.depthBuffer && D(e)
            }, this.updateRenderTargetMipmap = function (t) {
                var e = t.texture;
                if (d(e, p(t) || r.isWebGL2)) {
                    var s = t.isWebGLRenderTargetCube ? 34067 : 3553, a = n.get(e).__webglTexture;
                    i.bindTexture(s, a), f(s, e, t.width, t.height), i.bindTexture(s, null)
                }
            }, this.updateMultisampleRenderTarget = function (e) {
                if (e.isWebGLMultisampleRenderTarget) if (r.isWebGL2) {
                    var i = n.get(e);
                    t.bindFramebuffer(36008, i.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, i.__webglFramebuffer);
                    var s = e.width, a = e.height, o = 16384;
                    e.depthBuffer && (o |= 256), e.stencilBuffer && (o |= 1024), t.blitFramebuffer(0, 0, s, a, 0, 0, s, a, o, 9728)
                } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
            }, this.safeSetTexture2D = function (t, e) {
                t && t.isWebGLRenderTarget && (!1 === P && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), P = !0), t = t.texture), x(t, e)
            }, this.safeSetTextureCube = function (t, e) {
                t && t.isWebGLRenderTargetCube && (!1 === I && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), I = !0), t = t.texture), t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? w(t, e) : _(t, e)
            }
        }

        function jy(t, e, i) {
            return {
                convert: function (t) {
                    var n;
                    if (t === Zf) return 10497;
                    if (t === Jf) return 33071;
                    if (t === Qf) return 33648;
                    if (t === Kf) return 9728;
                    if (t === $f) return 9984;
                    if (t === tm) return 9986;
                    if (t === em) return 9729;
                    if (1007 === t) return 9985;
                    if (t === im) return 9987;
                    if (t === nm) return 5121;
                    if (1017 === t) return 32819;
                    if (1018 === t) return 32820;
                    if (1019 === t) return 33635;
                    if (1010 === t) return 5120;
                    if (1011 === t) return 5122;
                    if (t === rm) return 5123;
                    if (1013 === t) return 5124;
                    if (1014 === t) return 5125;
                    if (t === sm) return 5126;
                    if (t === am) {
                        if (i.isWebGL2) return 5131;
                        if (null !== (n = e.get("OES_texture_half_float"))) return n.HALF_FLOAT_OES
                    }
                    if (1021 === t) return 6406;
                    if (t === hm) return 6407;
                    if (t === lm) return 6408;
                    if (1024 === t) return 6409;
                    if (1025 === t) return 6410;
                    if (t === cm) return 6402;
                    if (t === um) return 34041;
                    if (1028 === t) return 6403;
                    if (t === Yf) return 32774;
                    if (101 === t) return 32778;
                    if (102 === t) return 32779;
                    if (200 === t) return 0;
                    if (201 === t) return 1;
                    if (202 === t) return 768;
                    if (203 === t) return 769;
                    if (204 === t) return 770;
                    if (205 === t) return 771;
                    if (206 === t) return 772;
                    if (207 === t) return 773;
                    if (208 === t) return 774;
                    if (209 === t) return 775;
                    if (210 === t) return 776;
                    if ((33776 === t || 33777 === t || 33778 === t || 33779 === t) && null !== (n = e.get("WEBGL_compressed_texture_s3tc"))) {
                        if (33776 === t) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (33777 === t) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (33778 === t) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (33779 === t) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                    if ((35840 === t || 35841 === t || 35842 === t || 35843 === t) && null !== (n = e.get("WEBGL_compressed_texture_pvrtc"))) {
                        if (35840 === t) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (35841 === t) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (35842 === t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (35843 === t) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (36196 === t && null !== (n = e.get("WEBGL_compressed_texture_etc1"))) return n.COMPRESSED_RGB_ETC1_WEBGL;
                    if ((37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t) && null !== (n = e.get("WEBGL_compressed_texture_astc"))) return t;
                    if (103 === t || 104 === t) {
                        if (i.isWebGL2) {
                            if (103 === t) return 32775;
                            if (104 === t) return 32776
                        }
                        if (null !== (n = e.get("EXT_blend_minmax"))) {
                            if (103 === t) return n.MIN_EXT;
                            if (104 === t) return n.MAX_EXT
                        }
                    }
                    if (t === om) {
                        if (i.isWebGL2) return 34042;
                        if (null !== (n = e.get("WEBGL_depth_texture"))) return n.UNSIGNED_INT_24_8_WEBGL
                    }
                    return 0
                }
            }
        }

        function Vy() {
            vg.call(this), this.type = "Group"
        }

        function Gy() {
            vg.call(this), this.type = "Camera", this.matrixWorldInverse = new Jm, this.projectionMatrix = new Jm, this.projectionMatrixInverse = new Jm
        }

        function Uy(t, e, i, n) {
            Gy.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
        }

        function Hy(t) {
            Uy.call(this), this.cameras = t || []
        }

        ky.prototype = Object.create(Vg.prototype), ky.prototype.constructor = ky, ky.prototype.isMeshDepthMaterial = !0, ky.prototype.copy = function (t) {
            return Vg.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
        }, Oy.prototype = Object.create(Vg.prototype), Oy.prototype.constructor = Oy, Oy.prototype.isMeshDistanceMaterial = !0, Oy.prototype.copy = function (t) {
            return Vg.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
        }, Vy.prototype = Object.assign(Object.create(vg.prototype), {
            constructor: Vy,
            isGroup: !0
        }), Gy.prototype = Object.assign(Object.create(vg.prototype), {
            constructor: Gy,
            isCamera: !0,
            copy: function (t, e) {
                return vg.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
            },
            getWorldDirection: function (t) {
                void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new _m), this.updateMatrixWorld(!0);
                var e = this.matrixWorld.elements;
                return t.set(-e[8], -e[9], -e[10]).normalize()
            },
            updateMatrixWorld: function (t) {
                vg.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
            },
            clone: function () {
                return (new this.constructor).copy(this)
            }
        }), Uy.prototype = Object.assign(Object.create(Gy.prototype), {
            constructor: Uy, isPerspectiveCamera: !0, copy: function (t, e) {
                return Gy.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
            }, setFocalLength: function (t) {
                var e = .5 * this.getFilmHeight() / t;
                this.fov = 2 * bm.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
            }, getFocalLength: function () {
                var t = Math.tan(.5 * bm.DEG2RAD * this.fov);
                return .5 * this.getFilmHeight() / t
            }, getEffectiveFOV: function () {
                return 2 * bm.RAD2DEG * Math.atan(Math.tan(.5 * bm.DEG2RAD * this.fov) / this.zoom)
            }, getFilmWidth: function () {
                return this.filmGauge * Math.min(this.aspect, 1)
            }, getFilmHeight: function () {
                return this.filmGauge / Math.max(this.aspect, 1)
            }, setViewOffset: function (t, e, i, n, r, s) {
                this.aspect = t / e, null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
            }, clearViewOffset: function () {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            }, updateProjectionMatrix: function () {
                var t = this.near, e = t * Math.tan(.5 * bm.DEG2RAD * this.fov) / this.zoom, i = 2 * e,
                    n = this.aspect * i, r = -.5 * n, s = this.view;
                if (null !== this.view && this.view.enabled) {
                    var a = s.fullWidth, o = s.fullHeight;
                    r += s.offsetX * n / a, e -= s.offsetY * i / o, n *= s.width / a, i *= s.height / o
                }
                var h = this.filmOffset;
                0 !== h && (r += t * h / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, e, e - i, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
            }, toJSON: function (t) {
                var e = vg.prototype.toJSON.call(this, t);
                return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
            }
        }), Hy.prototype = Object.assign(Object.create(Uy.prototype), {constructor: Hy, isArrayCamera: !0});
        var Wy, qy, Xy, Yy, Zy, Jy, Qy = new _m, Ky = new _m;

        function $y(t, e, i) {
            Qy.setFromMatrixPosition(e.matrixWorld), Ky.setFromMatrixPosition(i.matrixWorld);
            var n = Qy.distanceTo(Ky), r = e.projectionMatrix.elements, s = i.projectionMatrix.elements,
                a = r[14] / (r[10] - 1), o = r[14] / (r[10] + 1), h = (r[9] + 1) / r[5], l = (r[9] - 1) / r[5],
                c = (r[8] - 1) / r[0], u = (s[8] + 1) / s[0], p = a * c, d = a * u, f = n / (-c + u), m = f * -c;
            e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld);
            var g = a + f, v = o + f, y = p - m, b = d + (n - m), x = h * o / v * g, w = l * o / v * g;
            t.projectionMatrix.makePerspective(y, b, x, w, g, v)
        }

        function tb(t) {
            var e, i, n = this, r = null, s = null, a = null, o = [], h = new Jm, l = new Jm, c = 1, u = "local-floor";
            "undefined" != typeof window && "VRFrameData" in window && (s = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", w, !1));
            var p = new Jm, d = new wm, f = new _m, m = new Uy;
            m.viewport = new Vm, m.layers.enable(1);
            var g = new Uy;
            g.viewport = new Vm, g.layers.enable(2);
            var v = new Hy([m, g]);

            function y() {
                return null !== r && !0 === r.isPresenting
            }

            v.layers.enable(1), v.layers.enable(2);
            var b, x = new xm;

            function w() {
                if (y()) {
                    var s = r.getEyeParameters("left");
                    e = 2 * s.renderWidth * c, i = s.renderHeight * c, b = t.getPixelRatio(), t.getSize(x), t.setDrawingBufferSize(e, i, 1), m.viewport.set(0, 0, e / 2, i), g.viewport.set(e / 2, 0, e / 2, i), A.start()
                } else n.enabled && t.setDrawingBufferSize(x.width, x.height, b), A.stop()
            }

            var _ = [];

            function E(t) {
                for (var e = navigator.getGamepads && navigator.getGamepads(), i = 0, n = 0, r = e.length; i < r; i++) {
                    var s = e[i];
                    if (s && ("Daydream Controller" === s.id || "Gear VR Controller" === s.id || "Oculus Go Controller" === s.id || "OpenVR Gamepad" === s.id || s.id.startsWith("Oculus Touch") || s.id.startsWith("Spatial Controller"))) {
                        if (n === t) return s;
                        n++
                    }
                }
            }

            function M(t, n) {
                null !== n && 4 === n.length && t.set(n[0] * e, n[1] * i, n[2] * e, n[3] * i)
            }

            this.enabled = !1, this.getController = function (t) {
                var e = o[t];
                return void 0 === e && ((e = new Vy).matrixAutoUpdate = !1, e.visible = !1, o[t] = e), e
            }, this.getDevice = function () {
                return r
            }, this.setDevice = function (t) {
                void 0 !== t && (r = t), A.setContext(t)
            }, this.setFramebufferScaleFactor = function (t) {
                c = t
            }, this.setReferenceSpaceType = function (t) {
                u = t
            }, this.setPoseTarget = function (t) {
                void 0 !== t && (a = t)
            }, this.getCamera = function (t) {
                var e = "local-floor" === u ? 1.6 : 0;
                if (!1 === y()) return t.position.set(0, e, 0), t.rotation.set(0, 0, 0), t;
                if (r.depthNear = t.near, r.depthFar = t.far, r.getFrameData(s), "local-floor" === u) {
                    var i = r.stageParameters;
                    i ? h.fromArray(i.sittingToStandingTransform) : h.makeTranslation(0, e, 0)
                }
                var n = s.pose, c = null !== a ? a : t;
                c.matrix.copy(h), c.matrix.decompose(c.position, c.quaternion, c.scale), null !== n.orientation && (d.fromArray(n.orientation), c.quaternion.multiply(d)), null !== n.position && (d.setFromRotationMatrix(h), f.fromArray(n.position), f.applyQuaternion(d), c.position.add(f)), c.updateMatrixWorld(), m.near = t.near, g.near = t.near, m.far = t.far, g.far = t.far, m.matrixWorldInverse.fromArray(s.leftViewMatrix), g.matrixWorldInverse.fromArray(s.rightViewMatrix), l.getInverse(h), "local-floor" === u && (m.matrixWorldInverse.multiply(l), g.matrixWorldInverse.multiply(l));
                var b = c.parent;
                null !== b && (p.getInverse(b.matrixWorld), m.matrixWorldInverse.multiply(p), g.matrixWorldInverse.multiply(p)), m.matrixWorld.getInverse(m.matrixWorldInverse), g.matrixWorld.getInverse(g.matrixWorldInverse), m.projectionMatrix.fromArray(s.leftProjectionMatrix), g.projectionMatrix.fromArray(s.rightProjectionMatrix), $y(v, m, g);
                var x = r.getLayers();
                if (x.length) {
                    var w = x[0];
                    M(m.viewport, w.leftBounds), M(g.viewport, w.rightBounds)
                }
                return function () {
                    for (var t = 0; t < o.length; t++) {
                        var e = o[t], i = E(t);
                        if (void 0 !== i && void 0 !== i.pose) {
                            if (null === i.pose) return;
                            var n = i.pose;
                            !1 === n.hasPosition && e.position.set(.2, -.6, -.05), null !== n.position && e.position.fromArray(n.position), null !== n.orientation && e.quaternion.fromArray(n.orientation), e.matrix.compose(e.position, e.quaternion, e.scale), e.matrix.premultiply(h), e.matrix.decompose(e.position, e.quaternion, e.scale), e.matrixWorldNeedsUpdate = !0, e.visible = !0;
                            var r = "Daydream Controller" === i.id ? 0 : 1;
                            void 0 === _[t] && (_[t] = !1), _[t] !== i.buttons[r].pressed && (_[t] = i.buttons[r].pressed, !0 === _[t] ? e.dispatchEvent({type: "selectstart"}) : (e.dispatchEvent({type: "selectend"}), e.dispatchEvent({type: "select"})))
                        } else e.visible = !1
                    }
                }(), v
            }, this.getStandingMatrix = function () {
                return h
            }, this.isPresenting = y;
            var A = new hg;
            this.setAnimationLoop = function (t) {
                A.setAnimationLoop(t), y() && A.start()
            }, this.submitFrame = function () {
                y() && r.submitFrame()
            }, this.dispose = function () {
                "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", w)
            }, this.setFrameOfReferenceType = function () {
                console.warn("THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.")
            }
        }

        function eb(t) {
            var e = t.context, i = null, n = null, r = "local-floor", s = null, a = [], o = [];

            function h() {
                return null !== i && null !== n
            }

            var l = new Uy;
            l.layers.enable(1), l.viewport = new Vm;
            var c = new Uy;
            c.layers.enable(2), c.viewport = new Vm;
            var u = new Hy([l, c]);

            function p(t) {
                for (var e = 0; e < a.length; e++) o[e] === t.inputSource && a[e].dispatchEvent({type: t.type})
            }

            function d() {
                t.setFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), v.stop()
            }

            function f(t) {
                n = t, v.setContext(i), v.start()
            }

            function m(t, e) {
                null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld)
            }

            u.layers.enable(1), u.layers.enable(2), this.enabled = !1, this.getController = function (t) {
                var e = a[t];
                return void 0 === e && ((e = new Vy).matrixAutoUpdate = !1, e.visible = !1, a[t] = e), e
            }, this.setFramebufferScaleFactor = function (t) {
            }, this.setReferenceSpaceType = function (t) {
                r = t
            }, this.getSession = function () {
                return i
            }, this.setSession = function (t) {
                null !== (i = t) && (i.addEventListener("select", p), i.addEventListener("selectstart", p), i.addEventListener("selectend", p), i.addEventListener("end", d), i.updateRenderState({baseLayer: new XRWebGLLayer(i, e)}), i.requestReferenceSpace(r).then(f), o = i.inputSources, i.addEventListener("inputsourceschange", (function () {
                    o = i.inputSources, console.log(o);
                    for (var t = 0; t < a.length; t++) {
                        a[t].userData.inputSource = o[t]
                    }
                })))
            }, this.getCamera = function (t) {
                if (h()) {
                    var e = t.parent, i = u.cameras;
                    m(u, e);
                    for (var n = 0; n < i.length; n++) m(i[n], e);
                    t.matrixWorld.copy(u.matrixWorld);
                    for (var r = t.children, s = (n = 0, r.length); n < s; n++) r[n].updateMatrixWorld(!0);
                    return $y(u, l, c), u
                }
                return t
            }, this.isPresenting = h;
            var g = null;
            var v = new hg;
            v.setAnimationLoop((function (e, r) {
                if (null !== (s = r.getViewerPose(n))) {
                    var h = s.views, l = i.renderState.baseLayer;
                    t.setFramebuffer(l.framebuffer);
                    for (var c = 0; c < h.length; c++) {
                        var p = h[c], d = l.getViewport(p), f = p.transform.inverse.matrix, m = u.cameras[c];
                        m.matrix.fromArray(f).getInverse(m.matrix), m.projectionMatrix.fromArray(p.projectionMatrix), m.viewport.set(d.x, d.y, d.width, d.height), 0 === c && u.matrix.copy(m.matrix)
                    }
                }
                for (c = 0; c < a.length; c++) {
                    var v = a[c], y = o[c];
                    if (y) {
                        var b = r.getPose(y.targetRaySpace, n);
                        if (null !== b) {
                            v.matrix.fromArray(b.transform.matrix), v.matrix.decompose(v.position, v.rotation, v.scale), v.visible = !0;
                            continue
                        }
                    }
                    v.visible = !1
                }
                g && g(e)
            })), this.setAnimationLoop = function (t) {
                g = t
            }, this.dispose = function () {
            }, this.getStandingMatrix = function () {
                return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new Jm
            }, this.getDevice = function () {
                console.warn("THREE.WebXRManager: getDevice() has been deprecated.")
            }, this.setDevice = function () {
                console.warn("THREE.WebXRManager: setDevice() has been deprecated.")
            }, this.setFrameOfReferenceType = function () {
                console.warn("THREE.WebXRManager: setFrameOfReferenceType() has been deprecated.")
            }, this.submitFrame = function () {
            }
        }

        function ib(t) {
            console.log("THREE.WebGLRenderer", "105");
            var e = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                i = void 0 !== t.context ? t.context : null, n = void 0 !== t.alpha && t.alpha,
                r = void 0 === t.depth || t.depth, s = void 0 === t.stencil || t.stencil,
                a = void 0 !== t.antialias && t.antialias, o = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                h = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                l = void 0 !== t.powerPreference ? t.powerPreference : "default",
                c = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat, u = null, p = null;
            this.domElement = e, this.context = null, this.debug = {checkShaderErrors: !0}, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = 1, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
            var d, f, m, g, v, y, b, x, w, _, E, M, A, S, T, D, C, P, I = this, L = !1, R = null, F = 0, k = 0,
                O = null, z = null, B = -1, N = {geometry: null, program: null, wireframe: !1}, j = null, V = null,
                G = new Vm, U = new Vm, H = null, W = e.width, q = e.height, X = 1, Y = new Vm(0, 0, W, q),
                Z = new Vm(0, 0, W, q), J = !1, Q = new Zm, K = new hv, $ = !1, tt = !1, et = new Jm, it = new _m;

            function nt() {
                return null === O ? X : 1
            }

            try {
                var rt = {
                    alpha: n,
                    depth: r,
                    stencil: s,
                    antialias: a,
                    premultipliedAlpha: o,
                    preserveDrawingBuffer: h,
                    powerPreference: l,
                    failIfMajorPerformanceCaveat: c,
                    xrCompatible: !0
                };
                if (e.addEventListener("webglcontextlost", ht, !1), e.addEventListener("webglcontextrestored", lt, !1), null === (d = i || e.getContext("webgl", rt) || e.getContext("experimental-webgl", rt))) throw null !== e.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                void 0 === d.getShaderPrecisionFormat && (d.getShaderPrecisionFormat = function () {
                    return {rangeMin: 1, rangeMax: 1, precision: 1}
                })
            } catch (t) {
                throw console.error("THREE.WebGLRenderer: " + t.message), t
            }

            function st() {
                f = new lv(d), (m = new ov(d, f, t)).isWebGL2 || (f.get("WEBGL_depth_texture"), f.get("OES_texture_float"), f.get("OES_texture_half_float"), f.get("OES_texture_half_float_linear"), f.get("OES_standard_derivatives"), f.get("OES_element_index_uint"), f.get("ANGLE_instanced_arrays")), f.get("OES_texture_float_linear"), P = new jy(d, f, m), (g = new By(d, f, P, m)).scissor(U.copy(Z).multiplyScalar(X)), g.viewport(G.copy(Y).multiplyScalar(X)), v = new pv(d), y = new Ay, b = new Ny(d, f, g, y, m, P, v), x = new lg(d), w = new cv(d, x, v), _ = new mv(w, v), T = new fv(d), E = new My(I, f, m, b), M = new Cy, A = new Fy, S = new sv(I, g, _, o), D = new av(d, f, v, m), C = new uv(d, f, v, m), v.programs = E.programs, I.context = d, I.capabilities = m, I.extensions = f, I.properties = y, I.renderLists = M, I.state = g, I.info = v
            }

            st();
            var at = "undefined" != typeof navigator && "xr" in navigator && "supportsSession" in navigator.xr ? new eb(I) : new tb(I);
            this.vr = at;
            var ot = new zy(I, _, m.maxTextureSize);

            function ht(t) {
                t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), L = !0
            }

            function lt() {
                console.log("THREE.WebGLRenderer: Context Restored."), L = !1, st()
            }

            function ct(t) {
                var e = t.target;
                e.removeEventListener("dispose", ct), function (t) {
                    ut(t), y.remove(t)
                }(e)
            }

            function ut(t) {
                var e = y.get(t).program;
                t.program = void 0, void 0 !== e && E.releaseProgram(e)
            }

            this.shadowMap = ot, this.getContext = function () {
                return d
            }, this.getContextAttributes = function () {
                return d.getContextAttributes()
            }, this.forceContextLoss = function () {
                var t = f.get("WEBGL_lose_context");
                t && t.loseContext()
            }, this.forceContextRestore = function () {
                var t = f.get("WEBGL_lose_context");
                t && t.restoreContext()
            }, this.getPixelRatio = function () {
                return X
            }, this.setPixelRatio = function (t) {
                void 0 !== t && (X = t, this.setSize(W, q, !1))
            }, this.getSize = function (t) {
                return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new xm), t.set(W, q)
            }, this.setSize = function (t, i, n) {
                at.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (W = t, q = i, e.width = t * X, e.height = i * X, !1 !== n && (e.style.width = t + "px", e.style.height = i + "px"), this.setViewport(0, 0, t, i))
            }, this.getDrawingBufferSize = function (t) {
                return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new xm), t.set(W * X, q * X)
            }, this.setDrawingBufferSize = function (t, i, n) {
                W = t, q = i, X = n, e.width = t * n, e.height = i * n, this.setViewport(0, 0, t, i)
            }, this.getCurrentViewport = function (t) {
                return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new Vm), t.copy(G)
            }, this.getViewport = function (t) {
                return t.copy(Y)
            }, this.setViewport = function (t, e, i, n) {
                t.isVector4 ? Y.set(t.x, t.y, t.z, t.w) : Y.set(t, e, i, n), g.viewport(G.copy(Y).multiplyScalar(X))
            }, this.getScissor = function (t) {
                return t.copy(Z)
            }, this.setScissor = function (t, e, i, n) {
                t.isVector4 ? Z.set(t.x, t.y, t.z, t.w) : Z.set(t, e, i, n), g.scissor(U.copy(Z).multiplyScalar(X))
            }, this.getScissorTest = function () {
                return J
            }, this.setScissorTest = function (t) {
                g.setScissorTest(J = t)
            }, this.getClearColor = function () {
                return S.getClearColor()
            }, this.setClearColor = function () {
                S.setClearColor.apply(S, arguments)
            }, this.getClearAlpha = function () {
                return S.getClearAlpha()
            }, this.setClearAlpha = function () {
                S.setClearAlpha.apply(S, arguments)
            }, this.clear = function (t, e, i) {
                var n = 0;
                (void 0 === t || t) && (n |= 16384), (void 0 === e || e) && (n |= 256), (void 0 === i || i) && (n |= 1024), d.clear(n)
            }, this.clearColor = function () {
                this.clear(!0, !1, !1)
            }, this.clearDepth = function () {
                this.clear(!1, !0, !1)
            }, this.clearStencil = function () {
                this.clear(!1, !1, !0)
            }, this.dispose = function () {
                e.removeEventListener("webglcontextlost", ht, !1), e.removeEventListener("webglcontextrestored", lt, !1), M.dispose(), A.dispose(), y.dispose(), _.dispose(), at.dispose(), dt.stop()
            }, this.renderBufferImmediate = function (t, e) {
                g.initAttributes();
                var i = y.get(t);
                t.hasPositions && !i.position && (i.position = d.createBuffer()), t.hasNormals && !i.normal && (i.normal = d.createBuffer()), t.hasUvs && !i.uv && (i.uv = d.createBuffer()), t.hasColors && !i.color && (i.color = d.createBuffer());
                var n = e.getAttributes();
                t.hasPositions && (d.bindBuffer(34962, i.position), d.bufferData(34962, t.positionArray, 35048), g.enableAttribute(n.position), d.vertexAttribPointer(n.position, 3, 5126, !1, 0, 0)), t.hasNormals && (d.bindBuffer(34962, i.normal), d.bufferData(34962, t.normalArray, 35048), g.enableAttribute(n.normal), d.vertexAttribPointer(n.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (d.bindBuffer(34962, i.uv), d.bufferData(34962, t.uvArray, 35048), g.enableAttribute(n.uv), d.vertexAttribPointer(n.uv, 2, 5126, !1, 0, 0)), t.hasColors && (d.bindBuffer(34962, i.color), d.bufferData(34962, t.colorArray, 35048), g.enableAttribute(n.color), d.vertexAttribPointer(n.color, 3, 5126, !1, 0, 0)), g.disableUnusedAttributes(), d.drawArrays(4, 0, t.count), t.count = 0
            }, this.renderBufferDirect = function (t, e, i, n, r, s) {
                var a = r.isMesh && r.matrixWorld.determinant() < 0;
                g.setMaterial(n, a);
                var o = yt(t, e, n, r), h = !1;
                N.geometry === i.id && N.program === o.id && N.wireframe === (!0 === n.wireframe) || (N.geometry = i.id, N.program = o.id, N.wireframe = !0 === n.wireframe, h = !0), r.morphTargetInfluences && (T.update(r, i, n, o), h = !0);
                var l, c = i.index, u = i.attributes.position, p = 1;
                !0 === n.wireframe && (c = w.getWireframeAttribute(i), p = 2);
                var v = D;
                null !== c && (l = x.get(c), (v = C).setIndex(l)), h && (!function (t, e, i) {
                    if (i && i.isInstancedBufferGeometry && !m.isWebGL2 && null === f.get("ANGLE_instanced_arrays")) return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    g.initAttributes();
                    var n = i.attributes, r = e.getAttributes(), s = t.defaultAttributeValues;
                    for (var a in r) {
                        var o = r[a];
                        if (o >= 0) {
                            var h = n[a];
                            if (void 0 !== h) {
                                var l = h.normalized, c = h.itemSize, u = x.get(h);
                                if (void 0 === u) continue;
                                var p = u.buffer, v = u.type, y = u.bytesPerElement;
                                if (h.isInterleavedBufferAttribute) {
                                    var b = h.data, w = b.stride, _ = h.offset;
                                    b && b.isInstancedInterleavedBuffer ? (g.enableAttributeAndDivisor(o, b.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = b.meshPerAttribute * b.count)) : g.enableAttribute(o), d.bindBuffer(34962, p), d.vertexAttribPointer(o, c, v, l, w * y, _ * y)
                                } else h.isInstancedBufferAttribute ? (g.enableAttributeAndDivisor(o, h.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = h.meshPerAttribute * h.count)) : g.enableAttribute(o), d.bindBuffer(34962, p), d.vertexAttribPointer(o, c, v, l, 0, 0)
                            } else if (void 0 !== s) {
                                var E = s[a];
                                if (void 0 !== E) switch (E.length) {
                                    case 2:
                                        d.vertexAttrib2fv(o, E);
                                        break;
                                    case 3:
                                        d.vertexAttrib3fv(o, E);
                                        break;
                                    case 4:
                                        d.vertexAttrib4fv(o, E);
                                        break;
                                    default:
                                        d.vertexAttrib1fv(o, E)
                                }
                            }
                        }
                    }
                    g.disableUnusedAttributes()
                }(n, o, i), null !== c && d.bindBuffer(34963, l.buffer));
                var y = 1 / 0;
                null !== c ? y = c.count : void 0 !== u && (y = u.count);
                var b = i.drawRange.start * p, _ = i.drawRange.count * p, E = null !== s ? s.start * p : 0,
                    M = null !== s ? s.count * p : 1 / 0, A = Math.max(b, E), S = Math.min(y, b + _, E + M) - 1,
                    P = Math.max(0, S - A + 1);
                if (0 !== P) {
                    if (r.isMesh) if (!0 === n.wireframe) g.setLineWidth(n.wireframeLinewidth * nt()), v.setMode(1); else switch (r.drawMode) {
                        case 0:
                            v.setMode(4);
                            break;
                        case 1:
                            v.setMode(5);
                            break;
                        case 2:
                            v.setMode(6)
                    } else if (r.isLine) {
                        var I = n.linewidth;
                        void 0 === I && (I = 1), g.setLineWidth(I * nt()), r.isLineSegments ? v.setMode(1) : r.isLineLoop ? v.setMode(2) : v.setMode(3)
                    } else r.isPoints ? v.setMode(0) : r.isSprite && v.setMode(4);
                    i && i.isInstancedBufferGeometry ? i.maxInstancedCount > 0 && v.renderInstances(i, A, P) : v.render(A, P)
                }
            }, this.compile = function (t, e) {
                (p = A.get(t, e)).init(), t.traverse((function (t) {
                    t.isLight && (p.pushLight(t), t.castShadow && p.pushShadow(t))
                })), p.setupLights(e), t.traverse((function (e) {
                    if (e.material) if (Array.isArray(e.material)) for (var i = 0; i < e.material.length; i++) vt(e.material[i], t.fog, e); else vt(e.material, t.fog, e)
                }))
            };
            var pt = null;
            var dt = new hg;

            function ft(t, e, i, n) {
                if (!1 !== t.visible) {
                    if (t.layers.test(e.layers)) if (t.isGroup) i = t.renderOrder; else if (t.isLight) p.pushLight(t), t.castShadow && p.pushShadow(t); else if (t.isSprite) {
                        if (!t.frustumCulled || Q.intersectsSprite(t)) {
                            n && it.setFromMatrixPosition(t.matrixWorld).applyMatrix4(et);
                            var r = _.update(t);
                            (s = t.material).visible && u.push(t, r, s, i, it.z, null)
                        }
                    } else if (t.isImmediateRenderObject) n && it.setFromMatrixPosition(t.matrixWorld).applyMatrix4(et), u.push(t, null, t.material, i, it.z, null); else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(), !t.frustumCulled || Q.intersectsObject(t))) {
                        n && it.setFromMatrixPosition(t.matrixWorld).applyMatrix4(et);
                        r = _.update(t);
                        var s = t.material;
                        if (Array.isArray(s)) for (var a = r.groups, o = 0, h = a.length; o < h; o++) {
                            var l = a[o], c = s[l.materialIndex];
                            c && c.visible && u.push(t, r, c, i, it.z, l)
                        } else s.visible && u.push(t, r, s, i, it.z, null)
                    }
                    var d = t.children;
                    for (o = 0, h = d.length; o < h; o++) ft(d[o], e, i, n)
                }
            }

            function mt(t, e, i, n) {
                for (var r = 0, s = t.length; r < s; r++) {
                    var a = t[r], o = a.object, h = a.geometry, l = void 0 === n ? a.material : n, c = a.group;
                    if (i.isArrayCamera) {
                        V = i;
                        for (var u = i.cameras, d = 0, f = u.length; d < f; d++) {
                            var m = u[d];
                            o.layers.test(m.layers) && (g.viewport(G.copy(m.viewport)), p.setupLights(m), gt(o, e, m, h, l, c))
                        }
                    } else V = null, gt(o, e, i, h, l, c)
                }
            }

            function gt(t, e, i, n, r, s) {
                if (t.onBeforeRender(I, e, i, n, r, s), p = A.get(e, V || i), t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
                    g.setMaterial(r);
                    var a = yt(i, e.fog, r, t);
                    N.geometry = null, N.program = null, N.wireframe = !1, function (t, e) {
                        t.render((function (t) {
                            I.renderBufferImmediate(t, e)
                        }))
                    }(t, a)
                } else I.renderBufferDirect(i, e.fog, n, r, t, s);
                t.onAfterRender(I, e, i, n, r, s), p = A.get(e, V || i)
            }

            function vt(t, e, i) {
                var n = y.get(t), r = p.state.lights, s = p.state.shadowsArray, a = n.lightsHash, o = r.state.hash,
                    h = E.getParameters(t, r.state, s, e, K.numPlanes, K.numIntersection, i),
                    l = E.getProgramCode(t, h), c = n.program, u = !0;
                if (void 0 === c) t.addEventListener("dispose", ct); else if (c.code !== l) ut(t); else if (a.stateID !== o.stateID || a.directionalLength !== o.directionalLength || a.pointLength !== o.pointLength || a.spotLength !== o.spotLength || a.rectAreaLength !== o.rectAreaLength || a.hemiLength !== o.hemiLength || a.shadowsLength !== o.shadowsLength) a.stateID = o.stateID, a.directionalLength = o.directionalLength, a.pointLength = o.pointLength, a.spotLength = o.spotLength, a.rectAreaLength = o.rectAreaLength, a.hemiLength = o.hemiLength, a.shadowsLength = o.shadowsLength, u = !1; else {
                    if (void 0 !== h.shaderID) return;
                    u = !1
                }
                if (u) {
                    if (h.shaderID) {
                        var d = og[h.shaderID];
                        n.shader = {
                            name: t.type,
                            uniforms: Km(d.uniforms),
                            vertexShader: d.vertexShader,
                            fragmentShader: d.fragmentShader
                        }
                    } else n.shader = {
                        name: t.type,
                        uniforms: t.uniforms,
                        vertexShader: t.vertexShader,
                        fragmentShader: t.fragmentShader
                    };
                    t.onBeforeCompile(n.shader, I), l = E.getProgramCode(t, h), c = E.acquireProgram(t, n.shader, h, l), n.program = c, t.program = c
                }
                var f = c.getAttributes();
                if (t.morphTargets) {
                    t.numSupportedMorphTargets = 0;
                    for (var m = 0; m < I.maxMorphTargets; m++) f["morphTarget" + m] >= 0 && t.numSupportedMorphTargets++
                }
                if (t.morphNormals) {
                    t.numSupportedMorphNormals = 0;
                    for (m = 0; m < I.maxMorphNormals; m++) f["morphNormal" + m] >= 0 && t.numSupportedMorphNormals++
                }
                var g = n.shader.uniforms;
                (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (n.numClippingPlanes = K.numPlanes, n.numIntersection = K.numIntersection, g.clippingPlanes = K.uniform), n.fog = e, void 0 === a && (n.lightsHash = a = {}), a.stateID = o.stateID, a.directionalLength = o.directionalLength, a.pointLength = o.pointLength, a.spotLength = o.spotLength, a.rectAreaLength = o.rectAreaLength, a.hemiLength = o.hemiLength, a.shadowsLength = o.shadowsLength, t.lights && (g.ambientLightColor.value = r.state.ambient, g.lightProbe.value = r.state.probe, g.directionalLights.value = r.state.directional, g.spotLights.value = r.state.spot, g.rectAreaLights.value = r.state.rectArea, g.pointLights.value = r.state.point, g.hemisphereLights.value = r.state.hemi, g.directionalShadowMap.value = r.state.directionalShadowMap, g.directionalShadowMatrix.value = r.state.directionalShadowMatrix, g.spotShadowMap.value = r.state.spotShadowMap, g.spotShadowMatrix.value = r.state.spotShadowMatrix, g.pointShadowMap.value = r.state.pointShadowMap, g.pointShadowMatrix.value = r.state.pointShadowMatrix);
                var v = n.program.getUniforms(), b = py.seqWithValue(v.seq, g);
                n.uniformsList = b
            }

            function yt(t, e, i, n) {
                b.resetTextureUnits();
                var r = y.get(i), s = p.state.lights, a = r.lightsHash, o = s.state.hash;
                if ($ && (tt || t !== j)) {
                    var h = t === j && i.id === B;
                    K.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, t, r, h)
                }
                !1 === i.needsUpdate && (void 0 === r.program || i.fog && r.fog !== e ? i.needsUpdate = !0 : (!i.lights || a.stateID === o.stateID && a.directionalLength === o.directionalLength && a.pointLength === o.pointLength && a.spotLength === o.spotLength && a.rectAreaLength === o.rectAreaLength && a.hemiLength === o.hemiLength && a.shadowsLength === o.shadowsLength) && (void 0 === r.numClippingPlanes || r.numClippingPlanes === K.numPlanes && r.numIntersection === K.numIntersection) || (i.needsUpdate = !0)), i.needsUpdate && (vt(i, e, n), i.needsUpdate = !1);
                var l = !1, c = !1, u = !1, f = r.program, v = f.getUniforms(), x = r.shader.uniforms;
                if (g.useProgram(f.program) && (l = !0, c = !0, u = !0), i.id !== B && (B = i.id, c = !0), l || j !== t) {
                    if (v.setValue(d, "projectionMatrix", t.projectionMatrix), m.logarithmicDepthBuffer && v.setValue(d, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), j !== t && (j = t, c = !0, u = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.envMap) {
                        var w = v.map.cameraPosition;
                        void 0 !== w && w.setValue(d, it.setFromMatrixPosition(t.matrixWorld))
                    }
                    (i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && v.setValue(d, "viewMatrix", t.matrixWorldInverse)
                }
                if (i.skinning) {
                    v.setOptional(d, n, "bindMatrix"), v.setOptional(d, n, "bindMatrixInverse");
                    var _ = n.skeleton;
                    if (_) {
                        var E = _.bones;
                        if (m.floatVertexTextures) {
                            if (void 0 === _.boneTexture) {
                                var M = Math.sqrt(4 * E.length);
                                M = bm.ceilPowerOfTwo(M), M = Math.max(M, 4);
                                var A = new Float32Array(M * M * 4);
                                A.set(_.boneMatrices);
                                var S = new Wm(A, M, M, lm, sm);
                                S.needsUpdate = !0, _.boneMatrices = A, _.boneTexture = S, _.boneTextureSize = M
                            }
                            v.setValue(d, "boneTexture", _.boneTexture, b), v.setValue(d, "boneTextureSize", _.boneTextureSize)
                        } else v.setOptional(d, _, "boneMatrices")
                    }
                }
                return c && (v.setValue(d, "toneMappingExposure", I.toneMappingExposure), v.setValue(d, "toneMappingWhitePoint", I.toneMappingWhitePoint), i.lights && function (t, e) {
                    t.ambientLightColor.needsUpdate = e, t.lightProbe.needsUpdate = e, t.directionalLights.needsUpdate = e, t.pointLights.needsUpdate = e, t.spotLights.needsUpdate = e, t.rectAreaLights.needsUpdate = e, t.hemisphereLights.needsUpdate = e
                }(x, u), e && i.fog && function (t, e) {
                    t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                }(x, e), i.isMeshBasicMaterial ? bt(x, i) : i.isMeshLambertMaterial ? (bt(x, i), function (t, e) {
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                }(x, i)) : i.isMeshPhongMaterial ? (bt(x, i), i.isMeshToonMaterial ? function (t, e) {
                    xt(t, e), e.gradientMap && (t.gradientMap.value = e.gradientMap)
                }(x, i) : xt(x, i)) : i.isMeshStandardMaterial ? (bt(x, i), i.isMeshPhysicalMaterial ? function (t, e) {
                    wt(t, e), t.reflectivity.value = e.reflectivity, t.clearCoat.value = e.clearCoat, t.clearCoatRoughness.value = e.clearCoatRoughness
                }(x, i) : wt(x, i)) : i.isMeshMatcapMaterial ? (bt(x, i), function (t, e) {
                    e.matcap && (t.matcap.value = e.matcap);
                    e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                    e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                    e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }(x, i)) : i.isMeshDepthMaterial ? (bt(x, i), function (t, e) {
                    e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }(x, i)) : i.isMeshDistanceMaterial ? (bt(x, i), function (t, e) {
                    e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
                    t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                }(x, i)) : i.isMeshNormalMaterial ? (bt(x, i), function (t, e) {
                    e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                    e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                    e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }(x, i)) : i.isLineBasicMaterial ? (function (t, e) {
                    t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
                }(x, i), i.isLineDashedMaterial && function (t, e) {
                    t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                }(x, i)) : i.isPointsMaterial ? function (t, e) {
                    t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * X, t.scale.value = .5 * q, t.map.value = e.map, null !== e.map && (!0 === e.map.matrixAutoUpdate && e.map.updateMatrix(), t.uvTransform.value.copy(e.map.matrix))
                }(x, i) : i.isSpriteMaterial ? function (t, e) {
                    t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, t.map.value = e.map, null !== e.map && (!0 === e.map.matrixAutoUpdate && e.map.updateMatrix(), t.uvTransform.value.copy(e.map.matrix))
                }(x, i) : i.isShadowMaterial && (x.color.value.copy(i.color), x.opacity.value = i.opacity), void 0 !== x.ltc_1 && (x.ltc_1.value = ag.LTC_1), void 0 !== x.ltc_2 && (x.ltc_2.value = ag.LTC_2), py.upload(d, r.uniformsList, x, b)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (py.upload(d, r.uniformsList, x, b), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && v.setValue(d, "center", n.center), v.setValue(d, "modelViewMatrix", n.modelViewMatrix), v.setValue(d, "normalMatrix", n.normalMatrix), v.setValue(d, "modelMatrix", n.matrixWorld), f
            }

            function bt(t, e) {
                var i;
                t.opacity.value = e.opacity, e.color && t.diffuse.value.copy(e.color), e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap.value = e.specularMap), e.envMap && (t.envMap.value = e.envMap, t.flipEnvMap.value = e.envMap.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio, t.maxMipLevel.value = y.get(e.envMap).__maxMipLevel), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity), e.map ? i = e.map : e.specularMap ? i = e.specularMap : e.displacementMap ? i = e.displacementMap : e.normalMap ? i = e.normalMap : e.bumpMap ? i = e.bumpMap : e.roughnessMap ? i = e.roughnessMap : e.metalnessMap ? i = e.metalnessMap : e.alphaMap ? i = e.alphaMap : e.emissiveMap && (i = e.emissiveMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix))
            }

            function xt(t, e) {
                t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }

            function wt(t, e) {
                t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
            }

            dt.setAnimationLoop((function (t) {
                at.isPresenting() || pt && pt(t)
            })), "undefined" != typeof window && dt.setContext(window), this.setAnimationLoop = function (t) {
                pt = t, at.setAnimationLoop(t), dt.start()
            }, this.render = function (t, e) {
                var i, n;
                if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), i = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), n = arguments[3]), e && e.isCamera) {
                    if (!L) {
                        N.geometry = null, N.program = null, N.wireframe = !1, B = -1, j = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), at.enabled && (e = at.getCamera(e)), (p = A.get(t, e)).init(), t.onBeforeRender(I, t, e, i || O), et.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), Q.setFromMatrix(et), tt = this.localClippingEnabled, $ = K.init(this.clippingPlanes, tt, e), (u = M.get(t, e)).init(), ft(t, e, 0, I.sortObjects), !0 === I.sortObjects && u.sort(), $ && K.beginShadows();
                        var r = p.state.shadowsArray;
                        ot.render(r, t, e), p.setupLights(e), $ && K.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== i && this.setRenderTarget(i), S.render(u, t, e, n);
                        var s = u.opaque, a = u.transparent;
                        if (t.overrideMaterial) {
                            var o = t.overrideMaterial;
                            s.length && mt(s, t, e, o), a.length && mt(a, t, e, o)
                        } else s.length && mt(s, t, e), a.length && mt(a, t, e);
                        t.onAfterRender(I, t, e), null !== O && (b.updateRenderTargetMipmap(O), b.updateMultisampleRenderTarget(O)), g.buffers.depth.setTest(!0), g.buffers.depth.setMask(!0), g.buffers.color.setMask(!0), g.setPolygonOffset(!1), at.enabled && at.submitFrame(), u = null, p = null
                    }
                } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
            }, this.setFramebuffer = function (t) {
                R !== t && d.bindFramebuffer(36160, t), R = t
            }, this.getActiveCubeFace = function () {
                return F
            }, this.getActiveMipMapLevel = function () {
                return k
            }, this.getRenderTarget = function () {
                return O
            }, this.setRenderTarget = function (t, e, i) {
                O = t, F = e, k = i, t && void 0 === y.get(t).__webglFramebuffer && b.setupRenderTarget(t);
                var n = R, r = !1;
                if (t) {
                    var s = y.get(t).__webglFramebuffer;
                    t.isWebGLRenderTargetCube ? (n = s[e || 0], r = !0) : n = t.isWebGLMultisampleRenderTarget ? y.get(t).__webglMultisampledFramebuffer : s, G.copy(t.viewport), U.copy(t.scissor), H = t.scissorTest
                } else G.copy(Y).multiplyScalar(X), U.copy(Z).multiplyScalar(X), H = J;
                if (z !== n && (d.bindFramebuffer(36160, n), z = n), g.viewport(G), g.scissor(U), g.setScissorTest(H), r) {
                    var a = y.get(t.texture);
                    d.framebufferTexture2D(36160, 36064, 34069 + (e || 0), a.__webglTexture, i || 0)
                }
            }, this.readRenderTargetPixels = function (t, e, i, n, r, s, a) {
                if (t && t.isWebGLRenderTarget) {
                    var o = y.get(t).__webglFramebuffer;
                    if (t.isWebGLRenderTargetCube && void 0 !== a && (o = o[a]), o) {
                        var h = !1;
                        o !== z && (d.bindFramebuffer(36160, o), h = !0);
                        try {
                            var l = t.texture, c = l.format, u = l.type;
                            if (c !== lm && P.convert(c) !== d.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            if (!(u === nm || P.convert(u) === d.getParameter(35738) || u === sm && (m.isWebGL2 || f.get("OES_texture_float") || f.get("WEBGL_color_buffer_float")) || u === am && (m.isWebGL2 ? f.get("EXT_color_buffer_float") : f.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            36053 === d.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - n && i >= 0 && i <= t.height - r && d.readPixels(e, i, n, r, P.convert(c), P.convert(u), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                        } finally {
                            h && d.bindFramebuffer(36160, z)
                        }
                    }
                } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
            }, this.copyFramebufferToTexture = function (t, e, i) {
                var n = e.image.width, r = e.image.height, s = P.convert(e.format);
                b.setTexture2D(e, 0), d.copyTexImage2D(3553, i || 0, s, t.x, t.y, n, r, 0)
            }, this.copyTextureToTexture = function (t, e, i, n) {
                var r = e.image.width, s = e.image.height, a = P.convert(i.format), o = P.convert(i.type);
                b.setTexture2D(i, 0), e.isDataTexture ? d.texSubImage2D(3553, n || 0, t.x, t.y, r, s, a, o, e.image.data) : d.texSubImage2D(3553, n || 0, t.x, t.y, a, o, e.image)
            }
        }

        function nb(t, e) {
            this.name = "", this.color = new rg(t), this.density = void 0 !== e ? e : 25e-5
        }

        function rb(t, e, i) {
            this.name = "", this.color = new rg(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== i ? i : 1e3
        }

        function sb() {
            vg.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0
        }

        function ab(t, e) {
            this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.dynamic = !1, this.updateRange = {
                offset: 0,
                count: -1
            }, this.version = 0
        }

        function ob(t, e, i, n) {
            this.data = t, this.itemSize = e, this.offset = i, this.normalized = !0 === n
        }

        function hb(t) {
            Vg.call(this), this.type = "SpriteMaterial", this.color = new rg(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, this.setValues(t)
        }

        function lb(t) {
            if (vg.call(this), this.type = "Sprite", void 0 === Wy) {
                Wy = new kg;
                var e = new ab(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5);
                Wy.setIndex([0, 1, 2, 0, 2, 3]), Wy.addAttribute("position", new ob(e, 3, 0, !1)), Wy.addAttribute("uv", new ob(e, 2, 3, !1))
            }
            this.geometry = Wy, this.material = void 0 !== t ? t : new hb, this.center = new xm(.5, .5)
        }

        function cb() {
            vg.call(this), this.type = "LOD", Object.defineProperties(this, {levels: {enumerable: !0, value: []}})
        }

        function ub(t, e) {
            t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), rv.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Jm, this.bindMatrixInverse = new Jm
        }

        function pb(t, e) {
            if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === e) this.calculateInverses(); else if (this.bones.length === e.length) this.boneInverses = e.slice(0); else {
                console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
                for (var i = 0, n = this.bones.length; i < n; i++) this.boneInverses.push(new Jm)
            }
        }

        function db() {
            vg.call(this), this.type = "Bone"
        }

        function fb(t) {
            Vg.call(this), this.type = "LineBasicMaterial", this.color = new rg(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(t)
        }

        function mb(t, e, i) {
            1 === i && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), vg.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new kg, this.material = void 0 !== e ? e : new fb({color: 16777215 * Math.random()})
        }

        function gb(t, e) {
            mb.call(this, t, e), this.type = "LineSegments"
        }

        function vb(t, e) {
            mb.call(this, t, e), this.type = "LineLoop"
        }

        function yb(t) {
            Vg.call(this), this.type = "PointsMaterial", this.color = new rg(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.lights = !1, this.setValues(t)
        }

        function bb(t, e) {
            vg.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new kg, this.material = void 0 !== e ? e : new yb({color: 16777215 * Math.random()})
        }

        function xb(t, e, i, n, r, s, a, o, h) {
            jm.call(this, t, e, i, n, r, s, a, o, h), this.format = void 0 !== a ? a : hm, this.minFilter = void 0 !== s ? s : em, this.magFilter = void 0 !== r ? r : em, this.generateMipmaps = !1
        }

        function wb(t, e, i, n, r, s, a, o, h, l, c, u) {
            jm.call(this, null, s, a, o, h, l, n, r, c, u), this.image = {
                width: e,
                height: i
            }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
        }

        function _b(t, e, i, n, r, s, a, o, h) {
            jm.call(this, t, e, i, n, r, s, a, o, h), this.needsUpdate = !0
        }

        function Eb(t, e, i, n, r, s, a, o, h, l) {
            if ((l = void 0 !== l ? l : cm) !== cm && l !== um) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            void 0 === i && l === cm && (i = rm), void 0 === i && l === um && (i = om), jm.call(this, null, n, r, s, a, o, l, i, h), this.image = {
                width: t,
                height: e
            }, this.magFilter = void 0 !== a ? a : Kf, this.minFilter = void 0 !== o ? o : Kf, this.flipY = !1, this.generateMipmaps = !1
        }

        function Mb(t) {
            kg.call(this), this.type = "WireframeGeometry";
            var e, i, n, r, s, a, o, h, l, c, u = [], p = [0, 0], d = {}, f = ["a", "b", "c"];
            if (t && t.isGeometry) {
                var m = t.faces;
                for (e = 0, n = m.length; e < n; e++) {
                    var g = m[e];
                    for (i = 0; i < 3; i++) o = g[f[i]], h = g[f[(i + 1) % 3]], p[0] = Math.min(o, h), p[1] = Math.max(o, h), void 0 === d[l = p[0] + "," + p[1]] && (d[l] = {
                        index1: p[0],
                        index2: p[1]
                    })
                }
                for (l in d) a = d[l], c = t.vertices[a.index1], u.push(c.x, c.y, c.z), c = t.vertices[a.index2], u.push(c.x, c.y, c.z)
            } else if (t && t.isBufferGeometry) {
                var v, y, b, x, w, _, E;
                if (c = new _m, null !== t.index) {
                    for (v = t.attributes.position, y = t.index, 0 === (b = t.groups).length && (b = [{
                        start: 0,
                        count: y.count,
                        materialIndex: 0
                    }]), r = 0, s = b.length; r < s; ++r) for (e = w = (x = b[r]).start, n = w + x.count; e < n; e += 3) for (i = 0; i < 3; i++) o = y.getX(e + i), h = y.getX(e + (i + 1) % 3), p[0] = Math.min(o, h), p[1] = Math.max(o, h), void 0 === d[l = p[0] + "," + p[1]] && (d[l] = {
                        index1: p[0],
                        index2: p[1]
                    });
                    for (l in d) a = d[l], c.fromBufferAttribute(v, a.index1), u.push(c.x, c.y, c.z), c.fromBufferAttribute(v, a.index2), u.push(c.x, c.y, c.z)
                } else for (e = 0, n = (v = t.attributes.position).count / 3; e < n; e++) for (i = 0; i < 3; i++) _ = 3 * e + i, c.fromBufferAttribute(v, _), u.push(c.x, c.y, c.z), E = 3 * e + (i + 1) % 3, c.fromBufferAttribute(v, E), u.push(c.x, c.y, c.z)
            }
            this.addAttribute("position", new Pg(u, 3))
        }

        function Ab(t, e, i) {
            wg.call(this), this.type = "ParametricGeometry", this.parameters = {
                func: t,
                slices: e,
                stacks: i
            }, this.fromBufferGeometry(new Sb(t, e, i)), this.mergeVertices()
        }

        function Sb(t, e, i) {
            kg.call(this), this.type = "ParametricBufferGeometry", this.parameters = {func: t, slices: e, stacks: i};
            var n, r, s = [], a = [], o = [], h = [], l = 1e-5, c = new _m, u = new _m, p = new _m, d = new _m,
                f = new _m;
            t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
            var m = e + 1;
            for (n = 0; n <= i; n++) {
                var g = n / i;
                for (r = 0; r <= e; r++) {
                    var v = r / e;
                    t(v, g, u), a.push(u.x, u.y, u.z), v - l >= 0 ? (t(v - l, g, p), d.subVectors(u, p)) : (t(v + l, g, p), d.subVectors(p, u)), g - l >= 0 ? (t(v, g - l, p), f.subVectors(u, p)) : (t(v, g + l, p), f.subVectors(p, u)), c.crossVectors(d, f).normalize(), o.push(c.x, c.y, c.z), h.push(v, g)
                }
            }
            for (n = 0; n < i; n++) for (r = 0; r < e; r++) {
                var y = n * m + r, b = n * m + r + 1, x = (n + 1) * m + r + 1, w = (n + 1) * m + r;
                s.push(y, b, w), s.push(b, x, w)
            }
            this.setIndex(s), this.addAttribute("position", new Pg(a, 3)), this.addAttribute("normal", new Pg(o, 3)), this.addAttribute("uv", new Pg(h, 2))
        }

        function Tb(t, e, i, n) {
            wg.call(this), this.type = "PolyhedronGeometry", this.parameters = {
                vertices: t,
                indices: e,
                radius: i,
                detail: n
            }, this.fromBufferGeometry(new Db(t, e, i, n)), this.mergeVertices()
        }

        function Db(t, e, i, n) {
            kg.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
                vertices: t,
                indices: e,
                radius: i,
                detail: n
            }, i = i || 1;
            var r = [], s = [];

            function a(t, e, i, n) {
                var r, s, a = Math.pow(2, n), h = [];
                for (r = 0; r <= a; r++) {
                    h[r] = [];
                    var l = t.clone().lerp(i, r / a), c = e.clone().lerp(i, r / a), u = a - r;
                    for (s = 0; s <= u; s++) h[r][s] = 0 === s && r === a ? l : l.clone().lerp(c, s / u)
                }
                for (r = 0; r < a; r++) for (s = 0; s < 2 * (a - r) - 1; s++) {
                    var p = Math.floor(s / 2);
                    s % 2 == 0 ? (o(h[r][p + 1]), o(h[r + 1][p]), o(h[r][p])) : (o(h[r][p + 1]), o(h[r + 1][p + 1]), o(h[r + 1][p]))
                }
            }

            function o(t) {
                r.push(t.x, t.y, t.z)
            }

            function h(e, i) {
                var n = 3 * e;
                i.x = t[n + 0], i.y = t[n + 1], i.z = t[n + 2]
            }

            function l(t, e, i, n) {
                n < 0 && 1 === t.x && (s[e] = t.x - 1), 0 === i.x && 0 === i.z && (s[e] = n / 2 / Math.PI + .5)
            }

            function c(t) {
                return Math.atan2(t.z, -t.x)
            }

            function u(t) {
                return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z))
            }

            !function (t) {
                for (var i = new _m, n = new _m, r = new _m, s = 0; s < e.length; s += 3) h(e[s + 0], i), h(e[s + 1], n), h(e[s + 2], r), a(i, n, r, t)
            }(n = n || 0), function (t) {
                for (var e = new _m, i = 0; i < r.length; i += 3) e.x = r[i + 0], e.y = r[i + 1], e.z = r[i + 2], e.normalize().multiplyScalar(t), r[i + 0] = e.x, r[i + 1] = e.y, r[i + 2] = e.z
            }(i), function () {
                for (var t = new _m, e = 0; e < r.length; e += 3) {
                    t.x = r[e + 0], t.y = r[e + 1], t.z = r[e + 2];
                    var i = c(t) / 2 / Math.PI + .5, n = u(t) / Math.PI + .5;
                    s.push(i, 1 - n)
                }
                (function () {
                    for (var t = new _m, e = new _m, i = new _m, n = new _m, a = new xm, o = new xm, h = new xm, u = 0, p = 0; u < r.length; u += 9, p += 6) {
                        t.set(r[u + 0], r[u + 1], r[u + 2]), e.set(r[u + 3], r[u + 4], r[u + 5]), i.set(r[u + 6], r[u + 7], r[u + 8]), a.set(s[p + 0], s[p + 1]), o.set(s[p + 2], s[p + 3]), h.set(s[p + 4], s[p + 5]), n.copy(t).add(e).add(i).divideScalar(3);
                        var d = c(n);
                        l(a, p + 0, t, d), l(o, p + 2, e, d), l(h, p + 4, i, d)
                    }
                })(), function () {
                    for (var t = 0; t < s.length; t += 6) {
                        var e = s[t + 0], i = s[t + 2], n = s[t + 4], r = Math.max(e, i, n), a = Math.min(e, i, n);
                        r > .9 && a < .1 && (e < .2 && (s[t + 0] += 1), i < .2 && (s[t + 2] += 1), n < .2 && (s[t + 4] += 1))
                    }
                }()
            }(), this.addAttribute("position", new Pg(r, 3)), this.addAttribute("normal", new Pg(r.slice(), 3)), this.addAttribute("uv", new Pg(s, 2)), 0 === n ? this.computeVertexNormals() : this.normalizeNormals()
        }

        function Cb(t, e) {
            wg.call(this), this.type = "TetrahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new Pb(t, e)), this.mergeVertices()
        }

        function Pb(t, e) {
            Db.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronBufferGeometry", this.parameters = {
                radius: t,
                detail: e
            }
        }

        function Ib(t, e) {
            wg.call(this), this.type = "OctahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new Lb(t, e)), this.mergeVertices()
        }

        function Lb(t, e) {
            Db.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronBufferGeometry", this.parameters = {
                radius: t,
                detail: e
            }
        }

        function Rb(t, e) {
            wg.call(this), this.type = "IcosahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new Fb(t, e)), this.mergeVertices()
        }

        function Fb(t, e) {
            var i = (1 + Math.sqrt(5)) / 2,
                n = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1];
            Db.call(this, n, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {
                radius: t,
                detail: e
            }
        }

        function kb(t, e) {
            wg.call(this), this.type = "DodecahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new Ob(t, e)), this.mergeVertices()
        }

        function Ob(t, e) {
            var i = (1 + Math.sqrt(5)) / 2, n = 1 / i,
                r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n];
            Db.call(this, r, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
                radius: t,
                detail: e
            }
        }

        function zb(t, e, i, n, r, s) {
            wg.call(this), this.type = "TubeGeometry", this.parameters = {
                path: t,
                tubularSegments: e,
                radius: i,
                radialSegments: n,
                closed: r
            }, void 0 !== s && console.warn("THREE.TubeGeometry: taper has been removed.");
            var a = new Bb(t, e, i, n, r);
            this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals, this.fromBufferGeometry(a), this.mergeVertices()
        }

        function Bb(t, e, i, n, r) {
            kg.call(this), this.type = "TubeBufferGeometry", this.parameters = {
                path: t,
                tubularSegments: e,
                radius: i,
                radialSegments: n,
                closed: r
            }, e = e || 64, i = i || 1, n = n || 8, r = r || !1;
            var s = t.computeFrenetFrames(e, r);
            this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals;
            var a, o, h = new _m, l = new _m, c = new xm, u = new _m, p = [], d = [], f = [], m = [];

            function g(r) {
                u = t.getPointAt(r / e, u);
                var a = s.normals[r], c = s.binormals[r];
                for (o = 0; o <= n; o++) {
                    var f = o / n * Math.PI * 2, m = Math.sin(f), g = -Math.cos(f);
                    l.x = g * a.x + m * c.x, l.y = g * a.y + m * c.y, l.z = g * a.z + m * c.z, l.normalize(), d.push(l.x, l.y, l.z), h.x = u.x + i * l.x, h.y = u.y + i * l.y, h.z = u.z + i * l.z, p.push(h.x, h.y, h.z)
                }
            }

            !function () {
                for (a = 0; a < e; a++) g(a);
                g(!1 === r ? e : 0), function () {
                    for (a = 0; a <= e; a++) for (o = 0; o <= n; o++) c.x = a / e, c.y = o / n, f.push(c.x, c.y)
                }(), function () {
                    for (o = 1; o <= e; o++) for (a = 1; a <= n; a++) {
                        var t = (n + 1) * (o - 1) + (a - 1), i = (n + 1) * o + (a - 1), r = (n + 1) * o + a,
                            s = (n + 1) * (o - 1) + a;
                        m.push(t, i, s), m.push(i, r, s)
                    }
                }()
            }(), this.setIndex(m), this.addAttribute("position", new Pg(p, 3)), this.addAttribute("normal", new Pg(d, 3)), this.addAttribute("uv", new Pg(f, 2))
        }

        function Nb(t, e, i, n, r, s, a) {
            wg.call(this), this.type = "TorusKnotGeometry", this.parameters = {
                radius: t,
                tube: e,
                tubularSegments: i,
                radialSegments: n,
                p: r,
                q: s
            }, void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new jb(t, e, i, n, r, s)), this.mergeVertices()
        }

        function jb(t, e, i, n, r, s) {
            kg.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
                radius: t,
                tube: e,
                tubularSegments: i,
                radialSegments: n,
                p: r,
                q: s
            }, t = t || 1, e = e || .4, i = Math.floor(i) || 64, n = Math.floor(n) || 8, r = r || 2, s = s || 3;
            var a, o, h = [], l = [], c = [], u = [], p = new _m, d = new _m, f = new _m, m = new _m, g = new _m,
                v = new _m, y = new _m;
            for (a = 0; a <= i; ++a) {
                var b = a / i * r * Math.PI * 2;
                for (T(b, r, s, t, f), T(b + .01, r, s, t, m), v.subVectors(m, f), y.addVectors(m, f), g.crossVectors(v, y), y.crossVectors(g, v), g.normalize(), y.normalize(), o = 0; o <= n; ++o) {
                    var x = o / n * Math.PI * 2, w = -e * Math.cos(x), _ = e * Math.sin(x);
                    p.x = f.x + (w * y.x + _ * g.x), p.y = f.y + (w * y.y + _ * g.y), p.z = f.z + (w * y.z + _ * g.z), l.push(p.x, p.y, p.z), d.subVectors(p, f).normalize(), c.push(d.x, d.y, d.z), u.push(a / i), u.push(o / n)
                }
            }
            for (o = 1; o <= i; o++) for (a = 1; a <= n; a++) {
                var E = (n + 1) * (o - 1) + (a - 1), M = (n + 1) * o + (a - 1), A = (n + 1) * o + a,
                    S = (n + 1) * (o - 1) + a;
                h.push(E, M, S), h.push(M, A, S)
            }

            function T(t, e, i, n, r) {
                var s = Math.cos(t), a = Math.sin(t), o = i / e * t, h = Math.cos(o);
                r.x = n * (2 + h) * .5 * s, r.y = n * (2 + h) * a * .5, r.z = n * Math.sin(o) * .5
            }

            this.setIndex(h), this.addAttribute("position", new Pg(l, 3)), this.addAttribute("normal", new Pg(c, 3)), this.addAttribute("uv", new Pg(u, 2))
        }

        function Vb(t, e, i, n, r) {
            wg.call(this), this.type = "TorusGeometry", this.parameters = {
                radius: t,
                tube: e,
                radialSegments: i,
                tubularSegments: n,
                arc: r
            }, this.fromBufferGeometry(new Gb(t, e, i, n, r)), this.mergeVertices()
        }

        function Gb(t, e, i, n, r) {
            kg.call(this), this.type = "TorusBufferGeometry", this.parameters = {
                radius: t,
                tube: e,
                radialSegments: i,
                tubularSegments: n,
                arc: r
            }, t = t || 1, e = e || .4, i = Math.floor(i) || 8, n = Math.floor(n) || 6, r = r || 2 * Math.PI;
            var s, a, o = [], h = [], l = [], c = [], u = new _m, p = new _m, d = new _m;
            for (s = 0; s <= i; s++) for (a = 0; a <= n; a++) {
                var f = a / n * r, m = s / i * Math.PI * 2;
                p.x = (t + e * Math.cos(m)) * Math.cos(f), p.y = (t + e * Math.cos(m)) * Math.sin(f), p.z = e * Math.sin(m), h.push(p.x, p.y, p.z), u.x = t * Math.cos(f), u.y = t * Math.sin(f), d.subVectors(p, u).normalize(), l.push(d.x, d.y, d.z), c.push(a / n), c.push(s / i)
            }
            for (s = 1; s <= i; s++) for (a = 1; a <= n; a++) {
                var g = (n + 1) * s + a - 1, v = (n + 1) * (s - 1) + a - 1, y = (n + 1) * (s - 1) + a,
                    b = (n + 1) * s + a;
                o.push(g, v, b), o.push(v, y, b)
            }
            this.setIndex(o), this.addAttribute("position", new Pg(h, 3)), this.addAttribute("normal", new Pg(l, 3)), this.addAttribute("uv", new Pg(c, 2))
        }

        Object.assign(nb.prototype, {
            isFogExp2: !0, clone: function () {
                return new nb(this.color, this.density)
            }, toJSON: function () {
                return {type: "FogExp2", color: this.color.getHex(), density: this.density}
            }
        }), Object.assign(rb.prototype, {
            isFog: !0, clone: function () {
                return new rb(this.color, this.near, this.far)
            }, toJSON: function () {
                return {type: "Fog", color: this.color.getHex(), near: this.near, far: this.far}
            }
        }), sb.prototype = Object.assign(Object.create(vg.prototype), {
            constructor: sb,
            isScene: !0,
            copy: function (t, e) {
                return vg.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
            },
            toJSON: function (t) {
                var e = vg.prototype.toJSON.call(this, t);
                return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
            },
            dispose: function () {
                this.dispatchEvent({type: "dispose"})
            }
        }), Object.defineProperty(ab.prototype, "needsUpdate", {
            set: function (t) {
                !0 === t && this.version++
            }
        }), Object.assign(ab.prototype, {
            isInterleavedBuffer: !0, onUploadCallback: function () {
            }, setArray: function (t) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                return this.count = void 0 !== t ? t.length / this.stride : 0, this.array = t, this
            }, setDynamic: function (t) {
                return this.dynamic = t, this
            }, copy: function (t) {
                return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.dynamic = t.dynamic, this
            }, copyAt: function (t, e, i) {
                t *= this.stride, i *= e.stride;
                for (var n = 0, r = this.stride; n < r; n++) this.array[t + n] = e.array[i + n];
                return this
            }, set: function (t, e) {
                return void 0 === e && (e = 0), this.array.set(t, e), this
            }, clone: function () {
                return (new this.constructor).copy(this)
            }, onUpload: function (t) {
                return this.onUploadCallback = t, this
            }
        }), Object.defineProperties(ob.prototype, {
            count: {
                get: function () {
                    return this.data.count
                }
            }, array: {
                get: function () {
                    return this.data.array
                }
            }
        }), Object.assign(ob.prototype, {
            isInterleavedBufferAttribute: !0, setX: function (t, e) {
                return this.data.array[t * this.data.stride + this.offset] = e, this
            }, setY: function (t, e) {
                return this.data.array[t * this.data.stride + this.offset + 1] = e, this
            }, setZ: function (t, e) {
                return this.data.array[t * this.data.stride + this.offset + 2] = e, this
            }, setW: function (t, e) {
                return this.data.array[t * this.data.stride + this.offset + 3] = e, this
            }, getX: function (t) {
                return this.data.array[t * this.data.stride + this.offset]
            }, getY: function (t) {
                return this.data.array[t * this.data.stride + this.offset + 1]
            }, getZ: function (t) {
                return this.data.array[t * this.data.stride + this.offset + 2]
            }, getW: function (t) {
                return this.data.array[t * this.data.stride + this.offset + 3]
            }, setXY: function (t, e, i) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this
            }, setXYZ: function (t, e, i, n) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this
            }, setXYZW: function (t, e, i, n, r) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[t + 3] = r, this
            }
        }), hb.prototype = Object.create(Vg.prototype), hb.prototype.constructor = hb, hb.prototype.isSpriteMaterial = !0, hb.prototype.copy = function (t) {
            return Vg.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
        }, lb.prototype = Object.assign(Object.create(vg.prototype), {
            constructor: lb, isSprite: !0, raycast: function () {
                var t = new _m, e = new _m, i = new _m, n = new xm, r = new xm, s = new Jm, a = new _m, o = new _m,
                    h = new _m, l = new xm, c = new xm, u = new xm;

                function p(t, e, i, a, o, h) {
                    n.subVectors(t, i).addScalar(.5).multiply(a), void 0 !== o ? (r.x = h * n.x - o * n.y, r.y = o * n.x + h * n.y) : r.copy(n), t.copy(e), t.x += r.x, t.y += r.y, t.applyMatrix4(s)
                }

                return function (n, r) {
                    e.setFromMatrixScale(this.matrixWorld), s.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld), i.setFromMatrixPosition(this.modelViewMatrix);
                    var d, f, m = this.material.rotation;
                    0 !== m && (f = Math.cos(m), d = Math.sin(m));
                    var g = this.center;
                    p(a.set(-.5, -.5, 0), i, g, e, d, f), p(o.set(.5, -.5, 0), i, g, e, d, f), p(h.set(.5, .5, 0), i, g, e, d, f), l.set(0, 0), c.set(1, 0), u.set(1, 1);
                    var v = n.ray.intersectTriangle(a, o, h, !1, t);
                    if (null !== v || (p(o.set(-.5, .5, 0), i, g, e, d, f), c.set(0, 1), null !== (v = n.ray.intersectTriangle(a, h, o, !1, t)))) {
                        var y = n.ray.origin.distanceTo(t);
                        y < n.near || y > n.far || r.push({
                            distance: y,
                            point: t.clone(),
                            uv: iv.getUV(t, a, o, h, l, c, u, new xm),
                            face: null,
                            object: this
                        })
                    }
                }
            }(), clone: function () {
                return new this.constructor(this.material).copy(this)
            }, copy: function (t) {
                return vg.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this
            }
        }), cb.prototype = Object.assign(Object.create(vg.prototype), {
            constructor: cb, isLOD: !0, copy: function (t) {
                vg.prototype.copy.call(this, t, !1);
                for (var e = t.levels, i = 0, n = e.length; i < n; i++) {
                    var r = e[i];
                    this.addLevel(r.object.clone(), r.distance)
                }
                return this
            }, addLevel: function (t, e) {
                void 0 === e && (e = 0), e = Math.abs(e);
                for (var i = this.levels, n = 0; n < i.length && !(e < i[n].distance); n++) ;
                return i.splice(n, 0, {distance: e, object: t}), this.add(t), this
            }, getObjectForDistance: function (t) {
                for (var e = this.levels, i = 1, n = e.length; i < n && !(t < e[i].distance); i++) ;
                return e[i - 1].object
            }, raycast: (qy = new _m, function (t, e) {
                qy.setFromMatrixPosition(this.matrixWorld);
                var i = t.ray.origin.distanceTo(qy);
                this.getObjectForDistance(i).raycast(t, e)
            }), update: function () {
                var t = new _m, e = new _m;
                return function (i) {
                    var n = this.levels;
                    if (n.length > 1) {
                        t.setFromMatrixPosition(i.matrixWorld), e.setFromMatrixPosition(this.matrixWorld);
                        var r = t.distanceTo(e);
                        n[0].object.visible = !0;
                        for (var s = 1, a = n.length; s < a && r >= n[s].distance; s++) n[s - 1].object.visible = !1, n[s].object.visible = !0;
                        for (; s < a; s++) n[s].object.visible = !1
                    }
                }
            }(), toJSON: function (t) {
                var e = vg.prototype.toJSON.call(this, t);
                e.object.levels = [];
                for (var i = this.levels, n = 0, r = i.length; n < r; n++) {
                    var s = i[n];
                    e.object.levels.push({object: s.object.uuid, distance: s.distance})
                }
                return e
            }
        }), ub.prototype = Object.assign(Object.create(rv.prototype), {
            constructor: ub,
            isSkinnedMesh: !0,
            bind: function (t, e) {
                this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
            },
            pose: function () {
                this.skeleton.pose()
            },
            normalizeSkinWeights: function () {
                for (var t = new Vm, e = this.geometry.attributes.skinWeight, i = 0, n = e.count; i < n; i++) {
                    t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.w = e.getW(i);
                    var r = 1 / t.manhattanLength();
                    r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(i, t.x, t.y, t.z, t.w)
                }
            },
            updateMatrixWorld: function (t) {
                rv.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            },
            clone: function () {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), Object.assign(pb.prototype, {
            calculateInverses: function () {
                this.boneInverses = [];
                for (var t = 0, e = this.bones.length; t < e; t++) {
                    var i = new Jm;
                    this.bones[t] && i.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(i)
                }
            }, pose: function () {
                var t, e, i;
                for (e = 0, i = this.bones.length; e < i; e++) (t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
                for (e = 0, i = this.bones.length; e < i; e++) (t = this.bones[e]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
            }, update: (Xy = new Jm, Yy = new Jm, function () {
                for (var t = this.bones, e = this.boneInverses, i = this.boneMatrices, n = this.boneTexture, r = 0, s = t.length; r < s; r++) {
                    var a = t[r] ? t[r].matrixWorld : Yy;
                    Xy.multiplyMatrices(a, e[r]), Xy.toArray(i, 16 * r)
                }
                void 0 !== n && (n.needsUpdate = !0)
            }), clone: function () {
                return new pb(this.bones, this.boneInverses)
            }, getBoneByName: function (t) {
                for (var e = 0, i = this.bones.length; e < i; e++) {
                    var n = this.bones[e];
                    if (n.name === t) return n
                }
            }
        }), db.prototype = Object.assign(Object.create(vg.prototype), {
            constructor: db,
            isBone: !0
        }), fb.prototype = Object.create(Vg.prototype), fb.prototype.constructor = fb, fb.prototype.isLineBasicMaterial = !0, fb.prototype.copy = function (t) {
            return Vg.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
        }, mb.prototype = Object.assign(Object.create(vg.prototype), {
            constructor: mb, isLine: !0, computeLineDistances: (Zy = new _m, Jy = new _m, function () {
                var t = this.geometry;
                if (t.isBufferGeometry) if (null === t.index) {
                    for (var e = t.attributes.position, i = [0], n = 1, r = e.count; n < r; n++) Zy.fromBufferAttribute(e, n - 1), Jy.fromBufferAttribute(e, n), i[n] = i[n - 1], i[n] += Zy.distanceTo(Jy);
                    t.addAttribute("lineDistance", new Pg(i, 1))
                } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (t.isGeometry) {
                    var s = t.vertices;
                    for ((i = t.lineDistances)[0] = 0, n = 1, r = s.length; n < r; n++) i[n] = i[n - 1], i[n] += s[n - 1].distanceTo(s[n])
                }
                return this
            }), raycast: function () {
                var t = new Jm, e = new ev, i = new Xm;
                return function (n, r) {
                    var s = n.linePrecision, a = this.geometry, o = this.matrixWorld;
                    if (null === a.boundingSphere && a.computeBoundingSphere(), i.copy(a.boundingSphere), i.applyMatrix4(o), i.radius += s, !1 !== n.ray.intersectsSphere(i)) {
                        t.getInverse(o), e.copy(n.ray).applyMatrix4(t);
                        var h = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = h * h, c = new _m,
                            u = new _m, p = new _m, d = new _m, f = this && this.isLineSegments ? 2 : 1;
                        if (a.isBufferGeometry) {
                            var m = a.index, g = a.attributes.position.array;
                            if (null !== m) for (var v = m.array, y = 0, b = v.length - 1; y < b; y += f) {
                                var x = v[y], w = v[y + 1];
                                if (c.fromArray(g, 3 * x), u.fromArray(g, 3 * w), !(e.distanceSqToSegment(c, u, d, p) > l)) d.applyMatrix4(this.matrixWorld), (M = n.ray.origin.distanceTo(d)) < n.near || M > n.far || r.push({
                                    distance: M,
                                    point: p.clone().applyMatrix4(this.matrixWorld),
                                    index: y,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            } else for (y = 0, b = g.length / 3 - 1; y < b; y += f) {
                                if (c.fromArray(g, 3 * y), u.fromArray(g, 3 * y + 3), !(e.distanceSqToSegment(c, u, d, p) > l)) d.applyMatrix4(this.matrixWorld), (M = n.ray.origin.distanceTo(d)) < n.near || M > n.far || r.push({
                                    distance: M,
                                    point: p.clone().applyMatrix4(this.matrixWorld),
                                    index: y,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                        } else if (a.isGeometry) {
                            var _ = a.vertices, E = _.length;
                            for (y = 0; y < E - 1; y += f) {
                                var M;
                                if (!(e.distanceSqToSegment(_[y], _[y + 1], d, p) > l)) d.applyMatrix4(this.matrixWorld), (M = n.ray.origin.distanceTo(d)) < n.near || M > n.far || r.push({
                                    distance: M,
                                    point: p.clone().applyMatrix4(this.matrixWorld),
                                    index: y,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                        }
                    }
                }
            }(), clone: function () {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), gb.prototype = Object.assign(Object.create(mb.prototype), {
            constructor: gb,
            isLineSegments: !0,
            computeLineDistances: function () {
                var t = new _m, e = new _m;
                return function () {
                    var i = this.geometry;
                    if (i.isBufferGeometry) if (null === i.index) {
                        for (var n = i.attributes.position, r = [], s = 0, a = n.count; s < a; s += 2) t.fromBufferAttribute(n, s), e.fromBufferAttribute(n, s + 1), r[s] = 0 === s ? 0 : r[s - 1], r[s + 1] = r[s] + t.distanceTo(e);
                        i.addAttribute("lineDistance", new Pg(r, 1))
                    } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (i.isGeometry) {
                        var o = i.vertices;
                        for (r = i.lineDistances, s = 0, a = o.length; s < a; s += 2) t.copy(o[s]), e.copy(o[s + 1]), r[s] = 0 === s ? 0 : r[s - 1], r[s + 1] = r[s] + t.distanceTo(e)
                    }
                    return this
                }
            }()
        }), vb.prototype = Object.assign(Object.create(mb.prototype), {
            constructor: vb,
            isLineLoop: !0
        }), yb.prototype = Object.create(Vg.prototype), yb.prototype.constructor = yb, yb.prototype.isPointsMaterial = !0, yb.prototype.copy = function (t) {
            return Vg.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this
        }, bb.prototype = Object.assign(Object.create(vg.prototype), {
            constructor: bb, isPoints: !0, raycast: function () {
                var t = new Jm, e = new ev, i = new Xm;
                return function (n, r) {
                    var s = this, a = this.geometry, o = this.matrixWorld, h = n.params.Points.threshold;
                    if (null === a.boundingSphere && a.computeBoundingSphere(), i.copy(a.boundingSphere), i.applyMatrix4(o), i.radius += h, !1 !== n.ray.intersectsSphere(i)) {
                        t.getInverse(o), e.copy(n.ray).applyMatrix4(t);
                        var l = h / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = l * l, u = new _m,
                            p = new _m;
                        if (a.isBufferGeometry) {
                            var d = a.index, f = a.attributes.position.array;
                            if (null !== d) for (var m = d.array, g = 0, v = m.length; g < v; g++) {
                                var y = m[g];
                                u.fromArray(f, 3 * y), w(u, y)
                            } else {
                                g = 0;
                                for (var b = f.length / 3; g < b; g++) u.fromArray(f, 3 * g), w(u, g)
                            }
                        } else {
                            var x = a.vertices;
                            for (g = 0, b = x.length; g < b; g++) w(x[g], g)
                        }
                    }

                    function w(t, i) {
                        var a = e.distanceSqToPoint(t);
                        if (a < c) {
                            e.closestPointToPoint(t, p), p.applyMatrix4(o);
                            var h = n.ray.origin.distanceTo(p);
                            if (h < n.near || h > n.far) return;
                            r.push({
                                distance: h,
                                distanceToRay: Math.sqrt(a),
                                point: p.clone(),
                                index: i,
                                face: null,
                                object: s
                            })
                        }
                    }
                }
            }(), clone: function () {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), xb.prototype = Object.assign(Object.create(jm.prototype), {
            constructor: xb,
            isVideoTexture: !0,
            update: function () {
                var t = this.image;
                t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }), wb.prototype = Object.create(jm.prototype), wb.prototype.constructor = wb, wb.prototype.isCompressedTexture = !0, _b.prototype = Object.create(jm.prototype), _b.prototype.constructor = _b, _b.prototype.isCanvasTexture = !0, Eb.prototype = Object.create(jm.prototype), Eb.prototype.constructor = Eb, Eb.prototype.isDepthTexture = !0, Mb.prototype = Object.create(kg.prototype), Mb.prototype.constructor = Mb, Ab.prototype = Object.create(wg.prototype), Ab.prototype.constructor = Ab, Sb.prototype = Object.create(kg.prototype), Sb.prototype.constructor = Sb, Tb.prototype = Object.create(wg.prototype), Tb.prototype.constructor = Tb, Db.prototype = Object.create(kg.prototype), Db.prototype.constructor = Db, Cb.prototype = Object.create(wg.prototype), Cb.prototype.constructor = Cb, Pb.prototype = Object.create(Db.prototype), Pb.prototype.constructor = Pb, Ib.prototype = Object.create(wg.prototype), Ib.prototype.constructor = Ib, Lb.prototype = Object.create(Db.prototype), Lb.prototype.constructor = Lb, Rb.prototype = Object.create(wg.prototype), Rb.prototype.constructor = Rb, Fb.prototype = Object.create(Db.prototype), Fb.prototype.constructor = Fb, kb.prototype = Object.create(wg.prototype), kb.prototype.constructor = kb, Ob.prototype = Object.create(Db.prototype), Ob.prototype.constructor = Ob, zb.prototype = Object.create(wg.prototype), zb.prototype.constructor = zb, Bb.prototype = Object.create(kg.prototype), Bb.prototype.constructor = Bb, Bb.prototype.toJSON = function () {
            var t = kg.prototype.toJSON.call(this);
            return t.path = this.parameters.path.toJSON(), t
        }, Nb.prototype = Object.create(wg.prototype), Nb.prototype.constructor = Nb, jb.prototype = Object.create(kg.prototype), jb.prototype.constructor = jb, Vb.prototype = Object.create(wg.prototype), Vb.prototype.constructor = Vb, Gb.prototype = Object.create(kg.prototype), Gb.prototype.constructor = Gb;
        var Ub = function (t, e, i) {
            i = i || 2;
            var n, r, s, a, o, h, l, c = e && e.length, u = c ? e[0] * i : t.length, p = Hb(t, 0, u, i, !0), d = [];
            if (!p) return d;
            if (c && (p = function (t, e, i, n) {
                var r, s, a, o = [];
                for (r = 0, s = e.length; r < s; r++) (a = Hb(t, e[r] * n, r < s - 1 ? e[r + 1] * n : t.length, n, !1)) === a.next && (a.steiner = !0), o.push(tx(a));
                for (o.sort(Qb), r = 0; r < o.length; r++) Kb(o[r], i), i = Wb(i, i.next);
                return i
            }(t, e, p, i)), t.length > 80 * i) {
                n = s = t[0], r = a = t[1];
                for (var f = i; f < u; f += i) (o = t[f]) < n && (n = o), (h = t[f + 1]) < r && (r = h), o > s && (s = o), h > a && (a = h);
                l = 0 !== (l = Math.max(s - n, a - r)) ? 1 / l : 0
            }
            return qb(p, d, i, n, r, l), d
        };

        function Hb(t, e, i, n, r) {
            var s, a;
            if (r === function (t, e, i, n) {
                for (var r = 0, s = e, a = i - n; s < i; s += n) r += (t[a] - t[s]) * (t[s + 1] + t[a + 1]), a = s;
                return r
            }(t, e, i, n) > 0) for (s = e; s < i; s += n) a = hx(s, t[s], t[s + 1], a); else for (s = i - n; s >= e; s -= n) a = hx(s, t[s], t[s + 1], a);
            return a && rx(a, a.next) && (lx(a), a = a.next), a
        }

        function Wb(t, e) {
            if (!t) return t;
            e || (e = t);
            var i, n = t;
            do {
                if (i = !1, n.steiner || !rx(n, n.next) && 0 !== nx(n.prev, n, n.next)) n = n.next; else {
                    if (lx(n), (n = e = n.prev) === n.next) break;
                    i = !0
                }
            } while (i || n !== e);
            return e
        }

        function qb(t, e, i, n, r, s, a) {
            if (t) {
                !a && s && function (t, e, i, n) {
                    var r = t;
                    do {
                        null === r.z && (r.z = $b(r.x, r.y, e, i, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                    } while (r !== t);
                    r.prevZ.nextZ = null, r.prevZ = null, function (t) {
                        var e, i, n, r, s, a, o, h, l = 1;
                        do {
                            for (i = t, t = null, s = null, a = 0; i;) {
                                for (a++, n = i, o = 0, e = 0; e < l && (o++, n = n.nextZ); e++) ;
                                for (h = l; o > 0 || h > 0 && n;) 0 !== o && (0 === h || !n || i.z <= n.z) ? (r = i, i = i.nextZ, o--) : (r = n, n = n.nextZ, h--), s ? s.nextZ = r : t = r, r.prevZ = s, s = r;
                                i = n
                            }
                            s.nextZ = null, l *= 2
                        } while (a > 1)
                    }(r)
                }(t, n, r, s);
                for (var o, h, l = t; t.prev !== t.next;) if (o = t.prev, h = t.next, s ? Yb(t, n, r, s) : Xb(t)) e.push(o.i / i), e.push(t.i / i), e.push(h.i / i), lx(t), t = h.next, l = h.next; else if ((t = h) === l) {
                    a ? 1 === a ? qb(t = Zb(t, e, i), e, i, n, r, s, 2) : 2 === a && Jb(t, e, i, n, r, s) : qb(Wb(t), e, i, n, r, s, 1);
                    break
                }
            }
        }

        function Xb(t) {
            var e = t.prev, i = t, n = t.next;
            if (nx(e, i, n) >= 0) return !1;
            for (var r = t.next.next; r !== t.prev;) {
                if (ex(e.x, e.y, i.x, i.y, n.x, n.y, r.x, r.y) && nx(r.prev, r, r.next) >= 0) return !1;
                r = r.next
            }
            return !0
        }

        function Yb(t, e, i, n) {
            var r = t.prev, s = t, a = t.next;
            if (nx(r, s, a) >= 0) return !1;
            for (var o = r.x < s.x ? r.x < a.x ? r.x : a.x : s.x < a.x ? s.x : a.x, h = r.y < s.y ? r.y < a.y ? r.y : a.y : s.y < a.y ? s.y : a.y, l = r.x > s.x ? r.x > a.x ? r.x : a.x : s.x > a.x ? s.x : a.x, c = r.y > s.y ? r.y > a.y ? r.y : a.y : s.y > a.y ? s.y : a.y, u = $b(o, h, e, i, n), p = $b(l, c, e, i, n), d = t.nextZ; d && d.z <= p;) {
                if (d !== t.prev && d !== t.next && ex(r.x, r.y, s.x, s.y, a.x, a.y, d.x, d.y) && nx(d.prev, d, d.next) >= 0) return !1;
                d = d.nextZ
            }
            for (d = t.prevZ; d && d.z >= u;) {
                if (d !== t.prev && d !== t.next && ex(r.x, r.y, s.x, s.y, a.x, a.y, d.x, d.y) && nx(d.prev, d, d.next) >= 0) return !1;
                d = d.prevZ
            }
            return !0
        }

        function Zb(t, e, i) {
            var n = t;
            do {
                var r = n.prev, s = n.next.next;
                !rx(r, s) && sx(r, n, n.next, s) && ax(r, s) && ax(s, r) && (e.push(r.i / i), e.push(n.i / i), e.push(s.i / i), lx(n), lx(n.next), n = t = s), n = n.next
            } while (n !== t);
            return n
        }

        function Jb(t, e, i, n, r, s) {
            var a = t;
            do {
                for (var o = a.next.next; o !== a.prev;) {
                    if (a.i !== o.i && ix(a, o)) {
                        var h = ox(a, o);
                        return a = Wb(a, a.next), h = Wb(h, h.next), qb(a, e, i, n, r, s), void qb(h, e, i, n, r, s)
                    }
                    o = o.next
                }
                a = a.next
            } while (a !== t)
        }

        function Qb(t, e) {
            return t.x - e.x
        }

        function Kb(t, e) {
            if (e = function (t, e) {
                var i, n = e, r = t.x, s = t.y, a = -1 / 0;
                do {
                    if (s <= n.y && s >= n.next.y && n.next.y !== n.y) {
                        var o = n.x + (s - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                        if (o <= r && o > a) {
                            if (a = o, o === r) {
                                if (s === n.y) return n;
                                if (s === n.next.y) return n.next
                            }
                            i = n.x < n.next.x ? n : n.next
                        }
                    }
                    n = n.next
                } while (n !== e);
                if (!i) return null;
                if (r === a) return i.prev;
                var h, l = i, c = i.x, u = i.y, p = 1 / 0;
                n = i.next;
                for (; n !== l;) r >= n.x && n.x >= c && r !== n.x && ex(s < u ? r : a, s, c, u, s < u ? a : r, s, n.x, n.y) && ((h = Math.abs(s - n.y) / (r - n.x)) < p || h === p && n.x > i.x) && ax(n, t) && (i = n, p = h), n = n.next;
                return i
            }(t, e), e) {
                var i = ox(e, t);
                Wb(i, i.next)
            }
        }

        function $b(t, e, i, n, r) {
            return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
        }

        function tx(t) {
            var e = t, i = t;
            do {
                e.x < i.x && (i = e), e = e.next
            } while (e !== t);
            return i
        }

        function ex(t, e, i, n, r, s, a, o) {
            return (r - a) * (e - o) - (t - a) * (s - o) >= 0 && (t - a) * (n - o) - (i - a) * (e - o) >= 0 && (i - a) * (s - o) - (r - a) * (n - o) >= 0
        }

        function ix(t, e) {
            return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) {
                var i = t;
                do {
                    if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && sx(i, i.next, t, e)) return !0;
                    i = i.next
                } while (i !== t);
                return !1
            }(t, e) && ax(t, e) && ax(e, t) && function (t, e) {
                var i = t, n = !1, r = (t.x + e.x) / 2, s = (t.y + e.y) / 2;
                do {
                    i.y > s != i.next.y > s && i.next.y !== i.y && r < (i.next.x - i.x) * (s - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next
                } while (i !== t);
                return n
            }(t, e)
        }

        function nx(t, e, i) {
            return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
        }

        function rx(t, e) {
            return t.x === e.x && t.y === e.y
        }

        function sx(t, e, i, n) {
            return !!(rx(t, e) && rx(i, n) || rx(t, n) && rx(i, e)) || nx(t, e, i) > 0 != nx(t, e, n) > 0 && nx(i, n, t) > 0 != nx(i, n, e) > 0
        }

        function ax(t, e) {
            return nx(t.prev, t, t.next) < 0 ? nx(t, e, t.next) >= 0 && nx(t, t.prev, e) >= 0 : nx(t, e, t.prev) < 0 || nx(t, t.next, e) < 0
        }

        function ox(t, e) {
            var i = new cx(t.i, t.x, t.y), n = new cx(e.i, e.x, e.y), r = t.next, s = e.prev;
            return t.next = e, e.prev = t, i.next = r, r.prev = i, n.next = i, i.prev = n, s.next = n, n.prev = s, n
        }

        function hx(t, e, i, n) {
            var r = new cx(t, e, i);
            return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r
        }

        function lx(t) {
            t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
        }

        function cx(t, e, i) {
            this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
        }

        var ux = {
            area: function (t) {
                for (var e = t.length, i = 0, n = e - 1, r = 0; r < e; n = r++) i += t[n].x * t[r].y - t[r].x * t[n].y;
                return .5 * i
            }, isClockWise: function (t) {
                return ux.area(t) < 0
            }, triangulateShape: function (t, e) {
                var i = [], n = [], r = [];
                px(t), dx(i, t);
                var s = t.length;
                e.forEach(px);
                for (var a = 0; a < e.length; a++) n.push(s), s += e[a].length, dx(i, e[a]);
                var o = Ub(i, n);
                for (a = 0; a < o.length; a += 3) r.push(o.slice(a, a + 3));
                return r
            }
        };

        function px(t) {
            var e = t.length;
            e > 2 && t[e - 1].equals(t[0]) && t.pop()
        }

        function dx(t, e) {
            for (var i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y)
        }

        function fx(t, e) {
            wg.call(this), this.type = "ExtrudeGeometry", this.parameters = {
                shapes: t,
                options: e
            }, this.fromBufferGeometry(new mx(t, e)), this.mergeVertices()
        }

        function mx(t, e) {
            kg.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
                shapes: t,
                options: e
            }, t = Array.isArray(t) ? t : [t];
            for (var i = this, n = [], r = [], s = 0, a = t.length; s < a; s++) {
                o(t[s])
            }

            function o(t) {
                var s = [], a = void 0 !== e.curveSegments ? e.curveSegments : 12, o = void 0 !== e.steps ? e.steps : 1,
                    h = void 0 !== e.depth ? e.depth : 100, l = void 0 === e.bevelEnabled || e.bevelEnabled,
                    c = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                    u = void 0 !== e.bevelSize ? e.bevelSize : c - 2, p = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                    d = void 0 !== e.bevelSegments ? e.bevelSegments : 3, f = e.extrudePath,
                    m = void 0 !== e.UVGenerator ? e.UVGenerator : gx;
                void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), h = e.amount);
                var g, v, y, b, x, w, _, E, M = !1;
                f && (g = f.getSpacedPoints(o), M = !0, l = !1, v = f.computeFrenetFrames(o, !1), y = new _m, b = new _m, x = new _m), l || (d = 0, c = 0, u = 0, p = 0);
                var A = t.extractPoints(a), S = A.shape, T = A.holes;
                if (!ux.isClockWise(S)) for (S = S.reverse(), _ = 0, E = T.length; _ < E; _++) w = T[_], ux.isClockWise(w) && (T[_] = w.reverse());
                var D = ux.triangulateShape(S, T), C = S;
                for (_ = 0, E = T.length; _ < E; _++) w = T[_], S = S.concat(w);

                function P(t, e, i) {
                    return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(i).add(t)
                }

                var I, L, R, F, k, O, z = S.length, B = D.length;

                function N(t, e, i) {
                    var n, r, s, a = t.x - e.x, o = t.y - e.y, h = i.x - t.x, l = i.y - t.y, c = a * a + o * o,
                        u = a * l - o * h;
                    if (Math.abs(u) > Number.EPSILON) {
                        var p = Math.sqrt(c), d = Math.sqrt(h * h + l * l), f = e.x - o / p, m = e.y + a / p,
                            g = ((i.x - l / d - f) * l - (i.y + h / d - m) * h) / (a * l - o * h),
                            v = (n = f + a * g - t.x) * n + (r = m + o * g - t.y) * r;
                        if (v <= 2) return new xm(n, r);
                        s = Math.sqrt(v / 2)
                    } else {
                        var y = !1;
                        a > Number.EPSILON ? h > Number.EPSILON && (y = !0) : a < -Number.EPSILON ? h < -Number.EPSILON && (y = !0) : Math.sign(o) === Math.sign(l) && (y = !0), y ? (n = -o, r = a, s = Math.sqrt(c)) : (n = a, r = o, s = Math.sqrt(c / 2))
                    }
                    return new xm(n / s, r / s)
                }

                for (var j = [], V = 0, G = C.length, U = G - 1, H = V + 1; V < G; V++, U++, H++) U === G && (U = 0), H === G && (H = 0), j[V] = N(C[V], C[U], C[H]);
                var W, q, X = [], Y = j.concat();
                for (_ = 0, E = T.length; _ < E; _++) {
                    for (w = T[_], W = [], V = 0, U = (G = w.length) - 1, H = V + 1; V < G; V++, U++, H++) U === G && (U = 0), H === G && (H = 0), W[V] = N(w[V], w[U], w[H]);
                    X.push(W), Y = Y.concat(W)
                }
                for (I = 0; I < d; I++) {
                    for (R = I / d, F = c * Math.cos(R * Math.PI / 2), L = u * Math.sin(R * Math.PI / 2) + p, V = 0, G = C.length; V < G; V++) J((k = P(C[V], j[V], L)).x, k.y, -F);
                    for (_ = 0, E = T.length; _ < E; _++) for (w = T[_], W = X[_], V = 0, G = w.length; V < G; V++) J((k = P(w[V], W[V], L)).x, k.y, -F)
                }
                for (L = u + p, V = 0; V < z; V++) k = l ? P(S[V], Y[V], L) : S[V], M ? (b.copy(v.normals[0]).multiplyScalar(k.x), y.copy(v.binormals[0]).multiplyScalar(k.y), x.copy(g[0]).add(b).add(y), J(x.x, x.y, x.z)) : J(k.x, k.y, 0);
                for (q = 1; q <= o; q++) for (V = 0; V < z; V++) k = l ? P(S[V], Y[V], L) : S[V], M ? (b.copy(v.normals[q]).multiplyScalar(k.x), y.copy(v.binormals[q]).multiplyScalar(k.y), x.copy(g[q]).add(b).add(y), J(x.x, x.y, x.z)) : J(k.x, k.y, h / o * q);
                for (I = d - 1; I >= 0; I--) {
                    for (R = I / d, F = c * Math.cos(R * Math.PI / 2), L = u * Math.sin(R * Math.PI / 2) + p, V = 0, G = C.length; V < G; V++) J((k = P(C[V], j[V], L)).x, k.y, h + F);
                    for (_ = 0, E = T.length; _ < E; _++) for (w = T[_], W = X[_], V = 0, G = w.length; V < G; V++) k = P(w[V], W[V], L), M ? J(k.x, k.y + g[o - 1].y, g[o - 1].x + F) : J(k.x, k.y, h + F)
                }

                function Z(t, e) {
                    var i, n;
                    for (V = t.length; --V >= 0;) {
                        i = V, (n = V - 1) < 0 && (n = t.length - 1);
                        var r = 0, s = o + 2 * d;
                        for (r = 0; r < s; r++) {
                            var a = z * r, h = z * (r + 1);
                            K(e + i + a, e + n + a, e + n + h, e + i + h)
                        }
                    }
                }

                function J(t, e, i) {
                    s.push(t), s.push(e), s.push(i)
                }

                function Q(t, e, r) {
                    $(t), $(e), $(r);
                    var s = n.length / 3, a = m.generateTopUV(i, n, s - 3, s - 2, s - 1);
                    tt(a[0]), tt(a[1]), tt(a[2])
                }

                function K(t, e, r, s) {
                    $(t), $(e), $(s), $(e), $(r), $(s);
                    var a = n.length / 3, o = m.generateSideWallUV(i, n, a - 6, a - 3, a - 2, a - 1);
                    tt(o[0]), tt(o[1]), tt(o[3]), tt(o[1]), tt(o[2]), tt(o[3])
                }

                function $(t) {
                    n.push(s[3 * t + 0]), n.push(s[3 * t + 1]), n.push(s[3 * t + 2])
                }

                function tt(t) {
                    r.push(t.x), r.push(t.y)
                }

                !function () {
                    var t = n.length / 3;
                    if (l) {
                        var e = 0, r = z * e;
                        for (V = 0; V < B; V++) Q((O = D[V])[2] + r, O[1] + r, O[0] + r);
                        for (r = z * (e = o + 2 * d), V = 0; V < B; V++) Q((O = D[V])[0] + r, O[1] + r, O[2] + r)
                    } else {
                        for (V = 0; V < B; V++) Q((O = D[V])[2], O[1], O[0]);
                        for (V = 0; V < B; V++) Q((O = D[V])[0] + z * o, O[1] + z * o, O[2] + z * o)
                    }
                    i.addGroup(t, n.length / 3 - t, 0)
                }(), function () {
                    var t = n.length / 3, e = 0;
                    for (Z(C, e), e += C.length, _ = 0, E = T.length; _ < E; _++) Z(w = T[_], e), e += w.length;
                    i.addGroup(t, n.length / 3 - t, 1)
                }()
            }

            this.addAttribute("position", new Pg(n, 3)), this.addAttribute("uv", new Pg(r, 2)), this.computeVertexNormals()
        }

        fx.prototype = Object.create(wg.prototype), fx.prototype.constructor = fx, fx.prototype.toJSON = function () {
            var t = wg.prototype.toJSON.call(this);
            return vx(this.parameters.shapes, this.parameters.options, t)
        }, mx.prototype = Object.create(kg.prototype), mx.prototype.constructor = mx, mx.prototype.toJSON = function () {
            var t = kg.prototype.toJSON.call(this);
            return vx(this.parameters.shapes, this.parameters.options, t)
        };
        var gx = {
            generateTopUV: function (t, e, i, n, r) {
                var s = e[3 * i], a = e[3 * i + 1], o = e[3 * n], h = e[3 * n + 1], l = e[3 * r], c = e[3 * r + 1];
                return [new xm(s, a), new xm(o, h), new xm(l, c)]
            }, generateSideWallUV: function (t, e, i, n, r, s) {
                var a = e[3 * i], o = e[3 * i + 1], h = e[3 * i + 2], l = e[3 * n], c = e[3 * n + 1], u = e[3 * n + 2],
                    p = e[3 * r], d = e[3 * r + 1], f = e[3 * r + 2], m = e[3 * s], g = e[3 * s + 1], v = e[3 * s + 2];
                return Math.abs(o - c) < .01 ? [new xm(a, 1 - h), new xm(l, 1 - u), new xm(p, 1 - f), new xm(m, 1 - v)] : [new xm(o, 1 - h), new xm(c, 1 - u), new xm(d, 1 - f), new xm(g, 1 - v)]
            }
        };

        function vx(t, e, i) {
            if (i.shapes = [], Array.isArray(t)) for (var n = 0, r = t.length; n < r; n++) {
                var s = t[n];
                i.shapes.push(s.uuid)
            } else i.shapes.push(t.uuid);
            return void 0 !== e.extrudePath && (i.options.extrudePath = e.extrudePath.toJSON()), i
        }

        function yx(t, e) {
            wg.call(this), this.type = "TextGeometry", this.parameters = {
                text: t,
                parameters: e
            }, this.fromBufferGeometry(new bx(t, e)), this.mergeVertices()
        }

        function bx(t, e) {
            var i = (e = e || {}).font;
            if (!i || !i.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new wg;
            var n = i.generateShapes(t, e.size);
            e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), mx.call(this, n, e), this.type = "TextBufferGeometry"
        }

        function xx(t, e, i, n, r, s, a) {
            wg.call(this), this.type = "SphereGeometry", this.parameters = {
                radius: t,
                widthSegments: e,
                heightSegments: i,
                phiStart: n,
                phiLength: r,
                thetaStart: s,
                thetaLength: a
            }, this.fromBufferGeometry(new wx(t, e, i, n, r, s, a)), this.mergeVertices()
        }

        function wx(t, e, i, n, r, s, a) {
            kg.call(this), this.type = "SphereBufferGeometry", this.parameters = {
                radius: t,
                widthSegments: e,
                heightSegments: i,
                phiStart: n,
                phiLength: r,
                thetaStart: s,
                thetaLength: a
            }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), i = Math.max(2, Math.floor(i) || 6), n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI, s = void 0 !== s ? s : 0, a = void 0 !== a ? a : Math.PI;
            var o, h, l = Math.min(s + a, Math.PI), c = 0, u = [], p = new _m, d = new _m, f = [], m = [], g = [],
                v = [];
            for (h = 0; h <= i; h++) {
                var y = [], b = h / i, x = 0;
                for (0 == h && 0 == s ? x = .5 / e : h == i && l == Math.PI && (x = -.5 / e), o = 0; o <= e; o++) {
                    var w = o / e;
                    p.x = -t * Math.cos(n + w * r) * Math.sin(s + b * a), p.y = t * Math.cos(s + b * a), p.z = t * Math.sin(n + w * r) * Math.sin(s + b * a), m.push(p.x, p.y, p.z), d.copy(p).normalize(), g.push(d.x, d.y, d.z), v.push(w + x, 1 - b), y.push(c++)
                }
                u.push(y)
            }
            for (h = 0; h < i; h++) for (o = 0; o < e; o++) {
                var _ = u[h][o + 1], E = u[h][o], M = u[h + 1][o], A = u[h + 1][o + 1];
                (0 !== h || s > 0) && f.push(_, E, A), (h !== i - 1 || l < Math.PI) && f.push(E, M, A)
            }
            this.setIndex(f), this.addAttribute("position", new Pg(m, 3)), this.addAttribute("normal", new Pg(g, 3)), this.addAttribute("uv", new Pg(v, 2))
        }

        function _x(t, e, i, n, r, s) {
            wg.call(this), this.type = "RingGeometry", this.parameters = {
                innerRadius: t,
                outerRadius: e,
                thetaSegments: i,
                phiSegments: n,
                thetaStart: r,
                thetaLength: s
            }, this.fromBufferGeometry(new Ex(t, e, i, n, r, s)), this.mergeVertices()
        }

        function Ex(t, e, i, n, r, s) {
            kg.call(this), this.type = "RingBufferGeometry", this.parameters = {
                innerRadius: t,
                outerRadius: e,
                thetaSegments: i,
                phiSegments: n,
                thetaStart: r,
                thetaLength: s
            }, t = t || .5, e = e || 1, r = void 0 !== r ? r : 0, s = void 0 !== s ? s : 2 * Math.PI, i = void 0 !== i ? Math.max(3, i) : 8;
            var a, o, h, l = [], c = [], u = [], p = [], d = t, f = (e - t) / (n = void 0 !== n ? Math.max(1, n) : 1),
                m = new _m, g = new xm;
            for (o = 0; o <= n; o++) {
                for (h = 0; h <= i; h++) a = r + h / i * s, m.x = d * Math.cos(a), m.y = d * Math.sin(a), c.push(m.x, m.y, m.z), u.push(0, 0, 1), g.x = (m.x / e + 1) / 2, g.y = (m.y / e + 1) / 2, p.push(g.x, g.y);
                d += f
            }
            for (o = 0; o < n; o++) {
                var v = o * (i + 1);
                for (h = 0; h < i; h++) {
                    var y = a = h + v, b = a + i + 1, x = a + i + 2, w = a + 1;
                    l.push(y, b, w), l.push(b, x, w)
                }
            }
            this.setIndex(l), this.addAttribute("position", new Pg(c, 3)), this.addAttribute("normal", new Pg(u, 3)), this.addAttribute("uv", new Pg(p, 2))
        }

        function Mx(t, e, i, n) {
            wg.call(this), this.type = "LatheGeometry", this.parameters = {
                points: t,
                segments: e,
                phiStart: i,
                phiLength: n
            }, this.fromBufferGeometry(new Ax(t, e, i, n)), this.mergeVertices()
        }

        function Ax(t, e, i, n) {
            kg.call(this), this.type = "LatheBufferGeometry", this.parameters = {
                points: t,
                segments: e,
                phiStart: i,
                phiLength: n
            }, e = Math.floor(e) || 12, i = i || 0, n = n || 2 * Math.PI, n = bm.clamp(n, 0, 2 * Math.PI);
            var r, s, a, o = [], h = [], l = [], c = 1 / e, u = new _m, p = new xm;
            for (s = 0; s <= e; s++) {
                var d = i + s * c * n, f = Math.sin(d), m = Math.cos(d);
                for (a = 0; a <= t.length - 1; a++) u.x = t[a].x * f, u.y = t[a].y, u.z = t[a].x * m, h.push(u.x, u.y, u.z), p.x = s / e, p.y = a / (t.length - 1), l.push(p.x, p.y)
            }
            for (s = 0; s < e; s++) for (a = 0; a < t.length - 1; a++) {
                var g = r = a + s * t.length, v = r + t.length, y = r + t.length + 1, b = r + 1;
                o.push(g, v, b), o.push(v, y, b)
            }
            if (this.setIndex(o), this.addAttribute("position", new Pg(h, 3)), this.addAttribute("uv", new Pg(l, 2)), this.computeVertexNormals(), n === 2 * Math.PI) {
                var x = this.attributes.normal.array, w = new _m, _ = new _m, E = new _m;
                for (r = e * t.length * 3, s = 0, a = 0; s < t.length; s++, a += 3) w.x = x[a + 0], w.y = x[a + 1], w.z = x[a + 2], _.x = x[r + a + 0], _.y = x[r + a + 1], _.z = x[r + a + 2], E.addVectors(w, _).normalize(), x[a + 0] = x[r + a + 0] = E.x, x[a + 1] = x[r + a + 1] = E.y, x[a + 2] = x[r + a + 2] = E.z
            }
        }

        function Sx(t, e) {
            wg.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = {
                shapes: t,
                curveSegments: e
            }, this.fromBufferGeometry(new Tx(t, e)), this.mergeVertices()
        }

        function Tx(t, e) {
            kg.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
                shapes: t,
                curveSegments: e
            }, e = e || 12;
            var i = [], n = [], r = [], s = [], a = 0, o = 0;
            if (!1 === Array.isArray(t)) l(t); else for (var h = 0; h < t.length; h++) l(t[h]), this.addGroup(a, o, h), a += o, o = 0;

            function l(t) {
                var a, h, l, c = n.length / 3, u = t.extractPoints(e), p = u.shape, d = u.holes;
                for (!1 === ux.isClockWise(p) && (p = p.reverse()), a = 0, h = d.length; a < h; a++) l = d[a], !0 === ux.isClockWise(l) && (d[a] = l.reverse());
                var f = ux.triangulateShape(p, d);
                for (a = 0, h = d.length; a < h; a++) l = d[a], p = p.concat(l);
                for (a = 0, h = p.length; a < h; a++) {
                    var m = p[a];
                    n.push(m.x, m.y, 0), r.push(0, 0, 1), s.push(m.x, m.y)
                }
                for (a = 0, h = f.length; a < h; a++) {
                    var g = f[a], v = g[0] + c, y = g[1] + c, b = g[2] + c;
                    i.push(v, y, b), o += 3
                }
            }

            this.setIndex(i), this.addAttribute("position", new Pg(n, 3)), this.addAttribute("normal", new Pg(r, 3)), this.addAttribute("uv", new Pg(s, 2))
        }

        function Dx(t, e) {
            if (e.shapes = [], Array.isArray(t)) for (var i = 0, n = t.length; i < n; i++) {
                var r = t[i];
                e.shapes.push(r.uuid)
            } else e.shapes.push(t.uuid);
            return e
        }

        function Cx(t, e) {
            kg.call(this), this.type = "EdgesGeometry", this.parameters = {thresholdAngle: e}, e = void 0 !== e ? e : 1;
            var i, n, r, s, a = [], o = Math.cos(bm.DEG2RAD * e), h = [0, 0], l = {}, c = ["a", "b", "c"];
            t.isBufferGeometry ? (s = new wg).fromBufferGeometry(t) : s = t.clone(), s.mergeVertices(), s.computeFaceNormals();
            for (var u = s.vertices, p = s.faces, d = 0, f = p.length; d < f; d++) for (var m = p[d], g = 0; g < 3; g++) i = m[c[g]], n = m[c[(g + 1) % 3]], h[0] = Math.min(i, n), h[1] = Math.max(i, n), void 0 === l[r = h[0] + "," + h[1]] ? l[r] = {
                index1: h[0],
                index2: h[1],
                face1: d,
                face2: void 0
            } : l[r].face2 = d;
            for (r in l) {
                var v = l[r];
                if (void 0 === v.face2 || p[v.face1].normal.dot(p[v.face2].normal) <= o) {
                    var y = u[v.index1];
                    a.push(y.x, y.y, y.z), y = u[v.index2], a.push(y.x, y.y, y.z)
                }
            }
            this.addAttribute("position", new Pg(a, 3))
        }

        function Px(t, e, i, n, r, s, a, o) {
            wg.call(this), this.type = "CylinderGeometry", this.parameters = {
                radiusTop: t,
                radiusBottom: e,
                height: i,
                radialSegments: n,
                heightSegments: r,
                openEnded: s,
                thetaStart: a,
                thetaLength: o
            }, this.fromBufferGeometry(new Ix(t, e, i, n, r, s, a, o)), this.mergeVertices()
        }

        function Ix(t, e, i, n, r, s, a, o) {
            kg.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
                radiusTop: t,
                radiusBottom: e,
                height: i,
                radialSegments: n,
                heightSegments: r,
                openEnded: s,
                thetaStart: a,
                thetaLength: o
            };
            var h = this;
            t = void 0 !== t ? t : 1, e = void 0 !== e ? e : 1, i = i || 1, n = Math.floor(n) || 8, r = Math.floor(r) || 1, s = void 0 !== s && s, a = void 0 !== a ? a : 0, o = void 0 !== o ? o : 2 * Math.PI;
            var l = [], c = [], u = [], p = [], d = 0, f = [], m = i / 2, g = 0;

            function v(i) {
                var r, s, f, v = new xm, y = new _m, b = 0, x = !0 === i ? t : e, w = !0 === i ? 1 : -1;
                for (s = d, r = 1; r <= n; r++) c.push(0, m * w, 0), u.push(0, w, 0), p.push(.5, .5), d++;
                for (f = d, r = 0; r <= n; r++) {
                    var _ = r / n * o + a, E = Math.cos(_), M = Math.sin(_);
                    y.x = x * M, y.y = m * w, y.z = x * E, c.push(y.x, y.y, y.z), u.push(0, w, 0), v.x = .5 * E + .5, v.y = .5 * M * w + .5, p.push(v.x, v.y), d++
                }
                for (r = 0; r < n; r++) {
                    var A = s + r, S = f + r;
                    !0 === i ? l.push(S, S + 1, A) : l.push(S + 1, S, A), b += 3
                }
                h.addGroup(g, b, !0 === i ? 1 : 2), g += b
            }

            !function () {
                var s, v, y = new _m, b = new _m, x = 0, w = (e - t) / i;
                for (v = 0; v <= r; v++) {
                    var _ = [], E = v / r, M = E * (e - t) + t;
                    for (s = 0; s <= n; s++) {
                        var A = s / n, S = A * o + a, T = Math.sin(S), D = Math.cos(S);
                        b.x = M * T, b.y = -E * i + m, b.z = M * D, c.push(b.x, b.y, b.z), y.set(T, w, D).normalize(), u.push(y.x, y.y, y.z), p.push(A, 1 - E), _.push(d++)
                    }
                    f.push(_)
                }
                for (s = 0; s < n; s++) for (v = 0; v < r; v++) {
                    var C = f[v][s], P = f[v + 1][s], I = f[v + 1][s + 1], L = f[v][s + 1];
                    l.push(C, P, L), l.push(P, I, L), x += 6
                }
                h.addGroup(g, x, 0), g += x
            }(), !1 === s && (t > 0 && v(!0), e > 0 && v(!1)), this.setIndex(l), this.addAttribute("position", new Pg(c, 3)), this.addAttribute("normal", new Pg(u, 3)), this.addAttribute("uv", new Pg(p, 2))
        }

        function Lx(t, e, i, n, r, s, a) {
            Px.call(this, 0, t, e, i, n, r, s, a), this.type = "ConeGeometry", this.parameters = {
                radius: t,
                height: e,
                radialSegments: i,
                heightSegments: n,
                openEnded: r,
                thetaStart: s,
                thetaLength: a
            }
        }

        function Rx(t, e, i, n, r, s, a) {
            Ix.call(this, 0, t, e, i, n, r, s, a), this.type = "ConeBufferGeometry", this.parameters = {
                radius: t,
                height: e,
                radialSegments: i,
                heightSegments: n,
                openEnded: r,
                thetaStart: s,
                thetaLength: a
            }
        }

        function Fx(t, e, i, n) {
            wg.call(this), this.type = "CircleGeometry", this.parameters = {
                radius: t,
                segments: e,
                thetaStart: i,
                thetaLength: n
            }, this.fromBufferGeometry(new kx(t, e, i, n)), this.mergeVertices()
        }

        function kx(t, e, i, n) {
            kg.call(this), this.type = "CircleBufferGeometry", this.parameters = {
                radius: t,
                segments: e,
                thetaStart: i,
                thetaLength: n
            }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, i = void 0 !== i ? i : 0, n = void 0 !== n ? n : 2 * Math.PI;
            var r, s, a = [], o = [], h = [], l = [], c = new _m, u = new xm;
            for (o.push(0, 0, 0), h.push(0, 0, 1), l.push(.5, .5), s = 0, r = 3; s <= e; s++, r += 3) {
                var p = i + s / e * n;
                c.x = t * Math.cos(p), c.y = t * Math.sin(p), o.push(c.x, c.y, c.z), h.push(0, 0, 1), u.x = (o[r] / t + 1) / 2, u.y = (o[r + 1] / t + 1) / 2, l.push(u.x, u.y)
            }
            for (r = 1; r <= e; r++) a.push(r, r + 1, 0);
            this.setIndex(a), this.addAttribute("position", new Pg(o, 3)), this.addAttribute("normal", new Pg(h, 3)), this.addAttribute("uv", new Pg(l, 2))
        }

        yx.prototype = Object.create(wg.prototype), yx.prototype.constructor = yx, bx.prototype = Object.create(mx.prototype), bx.prototype.constructor = bx, xx.prototype = Object.create(wg.prototype), xx.prototype.constructor = xx, wx.prototype = Object.create(kg.prototype), wx.prototype.constructor = wx, _x.prototype = Object.create(wg.prototype), _x.prototype.constructor = _x, Ex.prototype = Object.create(kg.prototype), Ex.prototype.constructor = Ex, Mx.prototype = Object.create(wg.prototype), Mx.prototype.constructor = Mx, Ax.prototype = Object.create(kg.prototype), Ax.prototype.constructor = Ax, Sx.prototype = Object.create(wg.prototype), Sx.prototype.constructor = Sx, Sx.prototype.toJSON = function () {
            var t = wg.prototype.toJSON.call(this);
            return Dx(this.parameters.shapes, t)
        }, Tx.prototype = Object.create(kg.prototype), Tx.prototype.constructor = Tx, Tx.prototype.toJSON = function () {
            var t = kg.prototype.toJSON.call(this);
            return Dx(this.parameters.shapes, t)
        }, Cx.prototype = Object.create(kg.prototype), Cx.prototype.constructor = Cx, Px.prototype = Object.create(wg.prototype), Px.prototype.constructor = Px, Ix.prototype = Object.create(kg.prototype), Ix.prototype.constructor = Ix, Lx.prototype = Object.create(Px.prototype), Lx.prototype.constructor = Lx, Rx.prototype = Object.create(Ix.prototype), Rx.prototype.constructor = Rx, Fx.prototype = Object.create(wg.prototype), Fx.prototype.constructor = Fx, kx.prototype = Object.create(kg.prototype), kx.prototype.constructor = kx;
        var Ox = Object.freeze({
            WireframeGeometry: Mb,
            ParametricGeometry: Ab,
            ParametricBufferGeometry: Sb,
            TetrahedronGeometry: Cb,
            TetrahedronBufferGeometry: Pb,
            OctahedronGeometry: Ib,
            OctahedronBufferGeometry: Lb,
            IcosahedronGeometry: Rb,
            IcosahedronBufferGeometry: Fb,
            DodecahedronGeometry: kb,
            DodecahedronBufferGeometry: Ob,
            PolyhedronGeometry: Tb,
            PolyhedronBufferGeometry: Db,
            TubeGeometry: zb,
            TubeBufferGeometry: Bb,
            TorusKnotGeometry: Nb,
            TorusKnotBufferGeometry: jb,
            TorusGeometry: Vb,
            TorusBufferGeometry: Gb,
            TextGeometry: yx,
            TextBufferGeometry: bx,
            SphereGeometry: xx,
            SphereBufferGeometry: wx,
            RingGeometry: _x,
            RingBufferGeometry: Ex,
            PlaneGeometry: Bg,
            PlaneBufferGeometry: Ng,
            LatheGeometry: Mx,
            LatheBufferGeometry: Ax,
            ShapeGeometry: Sx,
            ShapeBufferGeometry: Tx,
            ExtrudeGeometry: fx,
            ExtrudeBufferGeometry: mx,
            EdgesGeometry: Cx,
            ConeGeometry: Lx,
            ConeBufferGeometry: Rx,
            CylinderGeometry: Px,
            CylinderBufferGeometry: Ix,
            CircleGeometry: Fx,
            CircleBufferGeometry: kx,
            BoxGeometry: Og,
            BoxBufferGeometry: zg
        });

        function zx(t) {
            Vg.call(this), this.type = "ShadowMaterial", this.color = new rg(0), this.transparent = !0, this.setValues(t)
        }

        function Bx(t) {
            tv.call(this, t), this.type = "RawShaderMaterial"
        }

        function Nx(t) {
            Vg.call(this), this.defines = {STANDARD: ""}, this.type = "MeshStandardMaterial", this.color = new rg(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new rg(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new xm(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
        }

        function jx(t) {
            Nx.call(this), this.defines = {PHYSICAL: ""}, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(t)
        }

        function Vx(t) {
            Vg.call(this), this.type = "MeshPhongMaterial", this.color = new rg(16777215), this.specular = new rg(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new rg(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new xm(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
        }

        function Gx(t) {
            Vx.call(this), this.defines = {TOON: ""}, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t)
        }

        function Ux(t) {
            Vg.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new xm(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
        }

        function Hx(t) {
            Vg.call(this), this.type = "MeshLambertMaterial", this.color = new rg(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new rg(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
        }

        function Wx(t) {
            Vg.call(this), this.defines = {MATCAP: ""}, this.type = "MeshMatcapMaterial", this.color = new rg(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new xm(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.lights = !1, this.setValues(t)
        }

        function qx(t) {
            fb.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
        }

        zx.prototype = Object.create(Vg.prototype), zx.prototype.constructor = zx, zx.prototype.isShadowMaterial = !0, zx.prototype.copy = function (t) {
            return Vg.prototype.copy.call(this, t), this.color.copy(t.color), this
        }, Bx.prototype = Object.create(tv.prototype), Bx.prototype.constructor = Bx, Bx.prototype.isRawShaderMaterial = !0, Nx.prototype = Object.create(Vg.prototype), Nx.prototype.constructor = Nx, Nx.prototype.isMeshStandardMaterial = !0, Nx.prototype.copy = function (t) {
            return Vg.prototype.copy.call(this, t), this.defines = {STANDARD: ""}, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, jx.prototype = Object.create(Nx.prototype), jx.prototype.constructor = jx, jx.prototype.isMeshPhysicalMaterial = !0, jx.prototype.copy = function (t) {
            return Nx.prototype.copy.call(this, t), this.defines = {PHYSICAL: ""}, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this.clearCoatRoughness = t.clearCoatRoughness, this
        }, Vx.prototype = Object.create(Vg.prototype), Vx.prototype.constructor = Vx, Vx.prototype.isMeshPhongMaterial = !0, Vx.prototype.copy = function (t) {
            return Vg.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, Gx.prototype = Object.create(Vx.prototype), Gx.prototype.constructor = Gx, Gx.prototype.isMeshToonMaterial = !0, Gx.prototype.copy = function (t) {
            return Vx.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this
        }, Ux.prototype = Object.create(Vg.prototype), Ux.prototype.constructor = Ux, Ux.prototype.isMeshNormalMaterial = !0, Ux.prototype.copy = function (t) {
            return Vg.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, Hx.prototype = Object.create(Vg.prototype), Hx.prototype.constructor = Hx, Hx.prototype.isMeshLambertMaterial = !0, Hx.prototype.copy = function (t) {
            return Vg.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, Wx.prototype = Object.create(Vg.prototype), Wx.prototype.constructor = Wx, Wx.prototype.isMeshMatcapMaterial = !0, Wx.prototype.copy = function (t) {
            return Vg.prototype.copy.call(this, t), this.defines = {MATCAP: ""}, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, qx.prototype = Object.create(fb.prototype), qx.prototype.constructor = qx, qx.prototype.isLineDashedMaterial = !0, qx.prototype.copy = function (t) {
            return fb.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
        };
        var Xx = Object.freeze({
            ShadowMaterial: zx,
            SpriteMaterial: hb,
            RawShaderMaterial: Bx,
            ShaderMaterial: tv,
            PointsMaterial: yb,
            MeshPhysicalMaterial: jx,
            MeshStandardMaterial: Nx,
            MeshPhongMaterial: Vx,
            MeshToonMaterial: Gx,
            MeshNormalMaterial: Ux,
            MeshLambertMaterial: Hx,
            MeshDepthMaterial: ky,
            MeshDistanceMaterial: Oy,
            MeshBasicMaterial: nv,
            MeshMatcapMaterial: Wx,
            LineDashedMaterial: qx,
            LineBasicMaterial: fb,
            Material: Vg
        }), Yx = {
            arraySlice: function (t, e, i) {
                return Yx.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length)) : t.slice(e, i)
            }, convertArray: function (t, e, i) {
                return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
            }, isTypedArray: function (t) {
                return ArrayBuffer.isView(t) && !(t instanceof DataView)
            }, getKeyframeOrder: function (t) {
                for (var e = t.length, i = new Array(e), n = 0; n !== e; ++n) i[n] = n;
                return i.sort((function (e, i) {
                    return t[e] - t[i]
                })), i
            }, sortedArray: function (t, e, i) {
                for (var n = t.length, r = new t.constructor(n), s = 0, a = 0; a !== n; ++s) for (var o = i[s] * e, h = 0; h !== e; ++h) r[a++] = t[o + h];
                return r
            }, flattenJSON: function (t, e, i, n) {
                for (var r = 1, s = t[0]; void 0 !== s && void 0 === s[n];) s = t[r++];
                if (void 0 !== s) {
                    var a = s[n];
                    if (void 0 !== a) if (Array.isArray(a)) do {
                        void 0 !== (a = s[n]) && (e.push(s.time), i.push.apply(i, a)), s = t[r++]
                    } while (void 0 !== s); else if (void 0 !== a.toArray) do {
                        void 0 !== (a = s[n]) && (e.push(s.time), a.toArray(i, i.length)), s = t[r++]
                    } while (void 0 !== s); else do {
                        void 0 !== (a = s[n]) && (e.push(s.time), i.push(a)), s = t[r++]
                    } while (void 0 !== s)
                }
            }
        };

        function Zx(t, e, i, n) {
            this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new e.constructor(i), this.sampleValues = e, this.valueSize = i
        }

        function Jx(t, e, i, n) {
            Zx.call(this, t, e, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
        }

        function Qx(t, e, i, n) {
            Zx.call(this, t, e, i, n)
        }

        function Kx(t, e, i, n) {
            Zx.call(this, t, e, i, n)
        }

        function $x(t, e, i, n) {
            if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
            this.name = t, this.times = Yx.convertArray(e, this.TimeBufferType), this.values = Yx.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation)
        }

        function tw(t, e, i) {
            $x.call(this, t, e, i)
        }

        function ew(t, e, i, n) {
            $x.call(this, t, e, i, n)
        }

        function iw(t, e, i, n) {
            $x.call(this, t, e, i, n)
        }

        function nw(t, e, i, n) {
            Zx.call(this, t, e, i, n)
        }

        function rw(t, e, i, n) {
            $x.call(this, t, e, i, n)
        }

        function sw(t, e, i, n) {
            $x.call(this, t, e, i, n)
        }

        function aw(t, e, i, n) {
            $x.call(this, t, e, i, n)
        }

        function ow(t, e, i) {
            this.name = t, this.tracks = i, this.duration = void 0 !== e ? e : -1, this.uuid = bm.generateUUID(), this.duration < 0 && this.resetDuration()
        }

        function hw(t) {
            if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            var e = function (t) {
                switch (t.toLowerCase()) {
                    case"scalar":
                    case"double":
                    case"float":
                    case"number":
                    case"integer":
                        return iw;
                    case"vector":
                    case"vector2":
                    case"vector3":
                    case"vector4":
                        return aw;
                    case"color":
                        return ew;
                    case"quaternion":
                        return rw;
                    case"bool":
                    case"boolean":
                        return tw;
                    case"string":
                        return sw
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
            }(t.type);
            if (void 0 === t.times) {
                var i = [], n = [];
                Yx.flattenJSON(t.keys, i, n, "value"), t.times = i, t.values = n
            }
            return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
        }

        Object.assign(Zx.prototype, {
            evaluate: function (t) {
                var e = this.parameterPositions, i = this._cachedIndex, n = e[i], r = e[i - 1];
                t:{
                    e:{
                        var s;
                        i:{
                            n:if (!(t < n)) {
                                for (var a = i + 2; ;) {
                                    if (void 0 === n) {
                                        if (t < r) break n;
                                        return i = e.length, this._cachedIndex = i, this.afterEnd_(i - 1, t, r)
                                    }
                                    if (i === a) break;
                                    if (r = n, t < (n = e[++i])) break e
                                }
                                s = e.length;
                                break i
                            }
                            if (t >= r) break t;
                            var o = e[1];
                            t < o && (i = 2, r = o);
                            for (a = i - 2; ;) {
                                if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, n);
                                if (i === a) break;
                                if (n = r, t >= (r = e[--i - 1])) break e
                            }
                            s = i, i = 0
                        }
                        for (; i < s;) {
                            var h = i + s >>> 1;
                            t < e[h] ? s = h : i = h + 1
                        }
                        if (n = e[i], void 0 === (r = e[i - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, n);
                        if (void 0 === n) return i = e.length, this._cachedIndex = i, this.afterEnd_(i - 1, r, t)
                    }
                    this._cachedIndex = i, this.intervalChanged_(i, r, n)
                }
                return this.interpolate_(i, r, t, n)
            }, settings: null, DefaultSettings_: {}, getSettings_: function () {
                return this.settings || this.DefaultSettings_
            }, copySampleValue_: function (t) {
                for (var e = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = t * n, s = 0; s !== n; ++s) e[s] = i[r + s];
                return e
            }, interpolate_: function () {
                throw new Error("call to abstract method")
            }, intervalChanged_: function () {
            }
        }), Object.assign(Zx.prototype, {
            beforeStart_: Zx.prototype.copySampleValue_,
            afterEnd_: Zx.prototype.copySampleValue_
        }), Jx.prototype = Object.assign(Object.create(Zx.prototype), {
            constructor: Jx,
            DefaultSettings_: {endingStart: mm, endingEnd: mm},
            intervalChanged_: function (t, e, i) {
                var n = this.parameterPositions, r = t - 2, s = t + 1, a = n[r], o = n[s];
                if (void 0 === a) switch (this.getSettings_().endingStart) {
                    case gm:
                        r = t, a = 2 * e - i;
                        break;
                    case vm:
                        a = e + n[r = n.length - 2] - n[r + 1];
                        break;
                    default:
                        r = t, a = i
                }
                if (void 0 === o) switch (this.getSettings_().endingEnd) {
                    case gm:
                        s = t, o = 2 * i - e;
                        break;
                    case vm:
                        s = 1, o = i + n[1] - n[0];
                        break;
                    default:
                        s = t - 1, o = e
                }
                var h = .5 * (i - e), l = this.valueSize;
                this._weightPrev = h / (e - a), this._weightNext = h / (o - i), this._offsetPrev = r * l, this._offsetNext = s * l
            },
            interpolate_: function (t, e, i, n) {
                for (var r = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = t * a, h = o - a, l = this._offsetPrev, c = this._offsetNext, u = this._weightPrev, p = this._weightNext, d = (i - e) / (n - e), f = d * d, m = f * d, g = -u * m + 2 * u * f - u * d, v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * d + 1, y = (-1 - p) * m + (1.5 + p) * f + .5 * d, b = p * m - p * f, x = 0; x !== a; ++x) r[x] = g * s[l + x] + v * s[h + x] + y * s[o + x] + b * s[c + x];
                return r
            }
        }), Qx.prototype = Object.assign(Object.create(Zx.prototype), {
            constructor: Qx,
            interpolate_: function (t, e, i, n) {
                for (var r = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = t * a, h = o - a, l = (i - e) / (n - e), c = 1 - l, u = 0; u !== a; ++u) r[u] = s[h + u] * c + s[o + u] * l;
                return r
            }
        }), Kx.prototype = Object.assign(Object.create(Zx.prototype), {
            constructor: Kx, interpolate_: function (t) {
                return this.copySampleValue_(t - 1)
            }
        }), Object.assign($x, {
            toJSON: function (t) {
                var e, i = t.constructor;
                if (void 0 !== i.toJSON) e = i.toJSON(t); else {
                    e = {
                        name: t.name,
                        times: Yx.convertArray(t.times, Array),
                        values: Yx.convertArray(t.values, Array)
                    };
                    var n = t.getInterpolation();
                    n !== t.DefaultInterpolation && (e.interpolation = n)
                }
                return e.type = t.ValueTypeName, e
            }
        }), Object.assign($x.prototype, {
            constructor: $x,
            TimeBufferType: Float32Array,
            ValueBufferType: Float32Array,
            DefaultInterpolation: dm,
            InterpolantFactoryMethodDiscrete: function (t) {
                return new Kx(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodLinear: function (t) {
                return new Qx(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodSmooth: function (t) {
                return new Jx(this.times, this.values, this.getValueSize(), t)
            },
            setInterpolation: function (t) {
                var e;
                switch (t) {
                    case pm:
                        e = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case dm:
                        e = this.InterpolantFactoryMethodLinear;
                        break;
                    case fm:
                        e = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === e) {
                    var i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (t === this.DefaultInterpolation) throw new Error(i);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", i), this
                }
                return this.createInterpolant = e, this
            },
            getInterpolation: function () {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return pm;
                    case this.InterpolantFactoryMethodLinear:
                        return dm;
                    case this.InterpolantFactoryMethodSmooth:
                        return fm
                }
            },
            getValueSize: function () {
                return this.values.length / this.times.length
            },
            shift: function (t) {
                if (0 !== t) for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] += t;
                return this
            },
            scale: function (t) {
                if (1 !== t) for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] *= t;
                return this
            },
            trim: function (t, e) {
                for (var i = this.times, n = i.length, r = 0, s = n - 1; r !== n && i[r] < t;) ++r;
                for (; -1 !== s && i[s] > e;) --s;
                if (++s, 0 !== r || s !== n) {
                    r >= s && (r = (s = Math.max(s, 1)) - 1);
                    var a = this.getValueSize();
                    this.times = Yx.arraySlice(i, r, s), this.values = Yx.arraySlice(this.values, r * a, s * a)
                }
                return this
            },
            validate: function () {
                var t = !0, e = this.getValueSize();
                e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                var i = this.times, n = this.values, r = i.length;
                0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                for (var s = null, a = 0; a !== r; a++) {
                    var o = i[a];
                    if ("number" == typeof o && isNaN(o)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, o), t = !1;
                        break
                    }
                    if (null !== s && s > o) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, o, s), t = !1;
                        break
                    }
                    s = o
                }
                if (void 0 !== n && Yx.isTypedArray(n)) {
                    a = 0;
                    for (var h = n.length; a !== h; ++a) {
                        var l = n[a];
                        if (isNaN(l)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, l), t = !1;
                            break
                        }
                    }
                }
                return t
            },
            optimize: function () {
                for (var t = this.times, e = this.values, i = this.getValueSize(), n = this.getInterpolation() === fm, r = 1, s = t.length - 1, a = 1; a < s; ++a) {
                    var o = !1, h = t[a];
                    if (h !== t[a + 1] && (1 !== a || h !== h[0])) if (n) o = !0; else for (var l = a * i, c = l - i, u = l + i, p = 0; p !== i; ++p) {
                        var d = e[l + p];
                        if (d !== e[c + p] || d !== e[u + p]) {
                            o = !0;
                            break
                        }
                    }
                    if (o) {
                        if (a !== r) {
                            t[r] = t[a];
                            var f = a * i, m = r * i;
                            for (p = 0; p !== i; ++p) e[m + p] = e[f + p]
                        }
                        ++r
                    }
                }
                if (s > 0) {
                    t[r] = t[s];
                    for (f = s * i, m = r * i, p = 0; p !== i; ++p) e[m + p] = e[f + p];
                    ++r
                }
                return r !== t.length && (this.times = Yx.arraySlice(t, 0, r), this.values = Yx.arraySlice(e, 0, r * i)), this
            },
            clone: function () {
                var t = Yx.arraySlice(this.times, 0), e = Yx.arraySlice(this.values, 0),
                    i = new (0, this.constructor)(this.name, t, e);
                return i.createInterpolant = this.createInterpolant, i
            }
        }), tw.prototype = Object.assign(Object.create($x.prototype), {
            constructor: tw,
            ValueTypeName: "bool",
            ValueBufferType: Array,
            DefaultInterpolation: pm,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), ew.prototype = Object.assign(Object.create($x.prototype), {
            constructor: ew,
            ValueTypeName: "color"
        }), iw.prototype = Object.assign(Object.create($x.prototype), {
            constructor: iw,
            ValueTypeName: "number"
        }), nw.prototype = Object.assign(Object.create(Zx.prototype), {
            constructor: nw,
            interpolate_: function (t, e, i, n) {
                for (var r = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = t * a, h = (i - e) / (n - e), l = o + a; o !== l; o += 4) wm.slerpFlat(r, 0, s, o - a, s, o, h);
                return r
            }
        }), rw.prototype = Object.assign(Object.create($x.prototype), {
            constructor: rw,
            ValueTypeName: "quaternion",
            DefaultInterpolation: dm,
            InterpolantFactoryMethodLinear: function (t) {
                return new nw(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodSmooth: void 0
        }), sw.prototype = Object.assign(Object.create($x.prototype), {
            constructor: sw,
            ValueTypeName: "string",
            ValueBufferType: Array,
            DefaultInterpolation: pm,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), aw.prototype = Object.assign(Object.create($x.prototype), {
            constructor: aw,
            ValueTypeName: "vector"
        }), Object.assign(ow, {
            parse: function (t) {
                for (var e = [], i = t.tracks, n = 1 / (t.fps || 1), r = 0, s = i.length; r !== s; ++r) e.push(hw(i[r]).scale(n));
                return new ow(t.name, t.duration, e)
            }, toJSON: function (t) {
                for (var e = [], i = t.tracks, n = {
                    name: t.name,
                    duration: t.duration,
                    tracks: e,
                    uuid: t.uuid
                }, r = 0, s = i.length; r !== s; ++r) e.push($x.toJSON(i[r]));
                return n
            }, CreateFromMorphTargetSequence: function (t, e, i, n) {
                for (var r = e.length, s = [], a = 0; a < r; a++) {
                    var o = [], h = [];
                    o.push((a + r - 1) % r, a, (a + 1) % r), h.push(0, 1, 0);
                    var l = Yx.getKeyframeOrder(o);
                    o = Yx.sortedArray(o, 1, l), h = Yx.sortedArray(h, 1, l), n || 0 !== o[0] || (o.push(r), h.push(h[0])), s.push(new iw(".morphTargetInfluences[" + e[a].name + "]", o, h).scale(1 / i))
                }
                return new ow(t, -1, s)
            }, findByName: function (t, e) {
                var i = t;
                if (!Array.isArray(t)) {
                    var n = t;
                    i = n.geometry && n.geometry.animations || n.animations
                }
                for (var r = 0; r < i.length; r++) if (i[r].name === e) return i[r];
                return null
            }, CreateClipsFromMorphTargetSequences: function (t, e, i) {
                for (var n = {}, r = /^([\w-]*?)([\d]+)$/, s = 0, a = t.length; s < a; s++) {
                    var o = t[s], h = o.name.match(r);
                    if (h && h.length > 1) {
                        var l = n[u = h[1]];
                        l || (n[u] = l = []), l.push(o)
                    }
                }
                var c = [];
                for (var u in n) c.push(ow.CreateFromMorphTargetSequence(u, n[u], e, i));
                return c
            }, parseAnimation: function (t, e) {
                if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                for (var i = function (t, e, i, n, r) {
                    if (0 !== i.length) {
                        var s = [], a = [];
                        Yx.flattenJSON(i, s, a, n), 0 !== s.length && r.push(new t(e, s, a))
                    }
                }, n = [], r = t.name || "default", s = t.length || -1, a = t.fps || 30, o = t.hierarchy || [], h = 0; h < o.length; h++) {
                    var l = o[h].keys;
                    if (l && 0 !== l.length) if (l[0].morphTargets) {
                        for (var c = {}, u = 0; u < l.length; u++) if (l[u].morphTargets) for (var p = 0; p < l[u].morphTargets.length; p++) c[l[u].morphTargets[p]] = -1;
                        for (var d in c) {
                            var f = [], m = [];
                            for (p = 0; p !== l[u].morphTargets.length; ++p) {
                                var g = l[u];
                                f.push(g.time), m.push(g.morphTarget === d ? 1 : 0)
                            }
                            n.push(new iw(".morphTargetInfluence[" + d + "]", f, m))
                        }
                        s = c.length * (a || 1)
                    } else {
                        var v = ".bones[" + e[h].name + "]";
                        i(aw, v + ".position", l, "pos", n), i(rw, v + ".quaternion", l, "rot", n), i(aw, v + ".scale", l, "scl", n)
                    }
                }
                return 0 === n.length ? null : new ow(r, s, n)
            }
        }), Object.assign(ow.prototype, {
            resetDuration: function () {
                for (var t = 0, e = 0, i = this.tracks.length; e !== i; ++e) {
                    var n = this.tracks[e];
                    t = Math.max(t, n.times[n.times.length - 1])
                }
                return this.duration = t, this
            }, trim: function () {
                for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                return this
            }, validate: function () {
                for (var t = !0, e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                return t
            }, optimize: function () {
                for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                return this
            }, clone: function () {
                for (var t = [], e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
                return new ow(this.name, this.duration, t)
            }
        });
        var lw = {
            enabled: !1, files: {}, add: function (t, e) {
                !1 !== this.enabled && (this.files[t] = e)
            }, get: function (t) {
                if (!1 !== this.enabled) return this.files[t]
            }, remove: function (t) {
                delete this.files[t]
            }, clear: function () {
                this.files = {}
            }
        };

        function cw(t, e, i) {
            var n = this, r = !1, s = 0, a = 0, o = void 0;
            this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function (t) {
                a++, !1 === r && void 0 !== n.onStart && n.onStart(t, s, a), r = !0
            }, this.itemEnd = function (t) {
                s++, void 0 !== n.onProgress && n.onProgress(t, s, a), s === a && (r = !1, void 0 !== n.onLoad && n.onLoad())
            }, this.itemError = function (t) {
                void 0 !== n.onError && n.onError(t)
            }, this.resolveURL = function (t) {
                return o ? o(t) : t
            }, this.setURLModifier = function (t) {
                return o = t, this
            }
        }

        var uw = new cw, pw = {};

        function dw(t) {
            this.manager = void 0 !== t ? t : uw
        }

        function fw(t) {
            this.manager = void 0 !== t ? t : uw, this._parser = null
        }

        function mw(t) {
            this.manager = void 0 !== t ? t : uw
        }

        function gw(t) {
            this.manager = void 0 !== t ? t : uw
        }

        function vw(t) {
            this.manager = void 0 !== t ? t : uw
        }

        function yw() {
            this.type = "Curve", this.arcLengthDivisions = 200
        }

        function bw(t, e, i, n, r, s, a, o) {
            yw.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = i || 1, this.yRadius = n || 1, this.aStartAngle = r || 0, this.aEndAngle = s || 2 * Math.PI, this.aClockwise = a || !1, this.aRotation = o || 0
        }

        function xw(t, e, i, n, r, s) {
            bw.call(this, t, e, i, i, n, r, s), this.type = "ArcCurve"
        }

        function ww() {
            var t = 0, e = 0, i = 0, n = 0;

            function r(r, s, a, o) {
                t = r, e = a, i = -3 * r + 3 * s - 2 * a - o, n = 2 * r - 2 * s + a + o
            }

            return {
                initCatmullRom: function (t, e, i, n, s) {
                    r(e, i, s * (i - t), s * (n - e))
                }, initNonuniformCatmullRom: function (t, e, i, n, s, a, o) {
                    var h = (e - t) / s - (i - t) / (s + a) + (i - e) / a,
                        l = (i - e) / a - (n - e) / (a + o) + (n - i) / o;
                    r(e, i, h *= a, l *= a)
                }, calc: function (r) {
                    var s = r * r;
                    return t + e * r + i * s + n * (s * r)
                }
            }
        }

        Object.assign(dw.prototype, {
            load: function (t, e, i, n) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                var r = this, s = lw.get(t);
                if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function () {
                    e && e(s), r.manager.itemEnd(t)
                }), 0), s;
                if (void 0 === pw[t]) {
                    var a = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                    if (a) {
                        var o = a[1], h = !!a[2], l = a[3];
                        l = decodeURIComponent(l), h && (l = atob(l));
                        try {
                            var c, u = (this.responseType || "").toLowerCase();
                            switch (u) {
                                case"arraybuffer":
                                case"blob":
                                    for (var p = new Uint8Array(l.length), d = 0; d < l.length; d++) p[d] = l.charCodeAt(d);
                                    c = "blob" === u ? new Blob([p.buffer], {type: o}) : p.buffer;
                                    break;
                                case"document":
                                    var f = new DOMParser;
                                    c = f.parseFromString(l, o);
                                    break;
                                case"json":
                                    c = JSON.parse(l);
                                    break;
                                default:
                                    c = l
                            }
                            setTimeout((function () {
                                e && e(c), r.manager.itemEnd(t)
                            }), 0)
                        } catch (e) {
                            setTimeout((function () {
                                n && n(e), r.manager.itemError(t), r.manager.itemEnd(t)
                            }), 0)
                        }
                    } else {
                        pw[t] = [], pw[t].push({onLoad: e, onProgress: i, onError: n});
                        var m = new XMLHttpRequest;
                        for (var g in m.open("GET", t, !0), m.addEventListener("load", (function (e) {
                            var i = this.response;
                            lw.add(t, i);
                            var n = pw[t];
                            if (delete pw[t], 200 === this.status || 0 === this.status) {
                                0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                                for (var s = 0, a = n.length; s < a; s++) {
                                    (o = n[s]).onLoad && o.onLoad(i)
                                }
                                r.manager.itemEnd(t)
                            } else {
                                for (s = 0, a = n.length; s < a; s++) {
                                    var o;
                                    (o = n[s]).onError && o.onError(e)
                                }
                                r.manager.itemError(t), r.manager.itemEnd(t)
                            }
                        }), !1), m.addEventListener("progress", (function (e) {
                            for (var i = pw[t], n = 0, r = i.length; n < r; n++) {
                                var s = i[n];
                                s.onProgress && s.onProgress(e)
                            }
                        }), !1), m.addEventListener("error", (function (e) {
                            var i = pw[t];
                            delete pw[t];
                            for (var n = 0, s = i.length; n < s; n++) {
                                var a = i[n];
                                a.onError && a.onError(e)
                            }
                            r.manager.itemError(t), r.manager.itemEnd(t)
                        }), !1), m.addEventListener("abort", (function (e) {
                            var i = pw[t];
                            delete pw[t];
                            for (var n = 0, s = i.length; n < s; n++) {
                                var a = i[n];
                                a.onError && a.onError(e)
                            }
                            r.manager.itemError(t), r.manager.itemEnd(t)
                        }), !1), void 0 !== this.responseType && (m.responseType = this.responseType), void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials), m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) m.setRequestHeader(g, this.requestHeader[g]);
                        m.send(null)
                    }
                    return r.manager.itemStart(t), m
                }
                pw[t].push({onLoad: e, onProgress: i, onError: n})
            }, setPath: function (t) {
                return this.path = t, this
            }, setResponseType: function (t) {
                return this.responseType = t, this
            }, setWithCredentials: function (t) {
                return this.withCredentials = t, this
            }, setMimeType: function (t) {
                return this.mimeType = t, this
            }, setRequestHeader: function (t) {
                return this.requestHeader = t, this
            }
        }), Object.assign(function (t) {
            this.manager = void 0 !== t ? t : uw
        }.prototype, {
            load: function (t, e, i, n) {
                var r = this, s = new dw(r.manager);
                s.setPath(r.path), s.load(t, (function (t) {
                    e(r.parse(JSON.parse(t)))
                }), i, n)
            }, parse: function (t) {
                for (var e = [], i = 0; i < t.length; i++) {
                    var n = ow.parse(t[i]);
                    e.push(n)
                }
                return e
            }, setPath: function (t) {
                return this.path = t, this
            }
        }), Object.assign(function (t) {
            this.manager = void 0 !== t ? t : uw, this._parser = null
        }.prototype, {
            load: function (t, e, i, n) {
                var r = this, s = [], a = new wb;
                a.image = s;
                var o = new dw(this.manager);

                function h(h) {
                    o.load(t[h], (function (t) {
                        var i = r._parser(t, !0);
                        s[h] = {
                            width: i.width,
                            height: i.height,
                            format: i.format,
                            mipmaps: i.mipmaps
                        }, 6 === (l += 1) && (1 === i.mipmapCount && (a.minFilter = em), a.format = i.format, a.needsUpdate = !0, e && e(a))
                    }), i, n)
                }

                if (o.setPath(this.path), o.setResponseType("arraybuffer"), Array.isArray(t)) for (var l = 0, c = 0, u = t.length; c < u; ++c) h(c); else o.load(t, (function (t) {
                    var i = r._parser(t, !0);
                    if (i.isCubemap) for (var n = i.mipmaps.length / i.mipmapCount, o = 0; o < n; o++) {
                        s[o] = {mipmaps: []};
                        for (var h = 0; h < i.mipmapCount; h++) s[o].mipmaps.push(i.mipmaps[o * i.mipmapCount + h]), s[o].format = i.format, s[o].width = i.width, s[o].height = i.height
                    } else a.image.width = i.width, a.image.height = i.height, a.mipmaps = i.mipmaps;
                    1 === i.mipmapCount && (a.minFilter = em), a.format = i.format, a.needsUpdate = !0, e && e(a)
                }), i, n);
                return a
            }, setPath: function (t) {
                return this.path = t, this
            }
        }), Object.assign(fw.prototype, {
            load: function (t, e, i, n) {
                var r = this, s = new Wm, a = new dw(this.manager);
                return a.setResponseType("arraybuffer"), a.setPath(this.path), a.load(t, (function (t) {
                    var i = r._parser(t);
                    i && (void 0 !== i.image ? s.image = i.image : void 0 !== i.data && (s.image.width = i.width, s.image.height = i.height, s.image.data = i.data), s.wrapS = void 0 !== i.wrapS ? i.wrapS : Jf, s.wrapT = void 0 !== i.wrapT ? i.wrapT : Jf, s.magFilter = void 0 !== i.magFilter ? i.magFilter : em, s.minFilter = void 0 !== i.minFilter ? i.minFilter : im, s.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1, void 0 !== i.format && (s.format = i.format), void 0 !== i.type && (s.type = i.type), void 0 !== i.mipmaps && (s.mipmaps = i.mipmaps), 1 === i.mipmapCount && (s.minFilter = em), s.needsUpdate = !0, e && e(s, i))
                }), i, n), s
            }, setPath: function (t) {
                return this.path = t, this
            }
        }), Object.assign(mw.prototype, {
            crossOrigin: "anonymous", load: function (t, e, i, n) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                var r = this, s = lw.get(t);
                if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function () {
                    e && e(s), r.manager.itemEnd(t)
                }), 0), s;
                var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

                function o() {
                    a.removeEventListener("load", o, !1), a.removeEventListener("error", h, !1), lw.add(t, this), e && e(this), r.manager.itemEnd(t)
                }

                function h(e) {
                    a.removeEventListener("load", o, !1), a.removeEventListener("error", h, !1), n && n(e), r.manager.itemError(t), r.manager.itemEnd(t)
                }

                return a.addEventListener("load", o, !1), a.addEventListener("error", h, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(t), a.src = t, a
            }, setCrossOrigin: function (t) {
                return this.crossOrigin = t, this
            }, setPath: function (t) {
                return this.path = t, this
            }
        }), Object.assign(gw.prototype, {
            crossOrigin: "anonymous", load: function (t, e, i, n) {
                var r = new gv, s = new mw(this.manager);
                s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
                var a = 0;

                function o(i) {
                    s.load(t[i], (function (t) {
                        r.images[i] = t, 6 === ++a && (r.needsUpdate = !0, e && e(r))
                    }), void 0, n)
                }

                for (var h = 0; h < t.length; ++h) o(h);
                return r
            }, setCrossOrigin: function (t) {
                return this.crossOrigin = t, this
            }, setPath: function (t) {
                return this.path = t, this
            }
        }), Object.assign(vw.prototype, {
            crossOrigin: "anonymous", load: function (t, e, i, n) {
                var r = new jm, s = new mw(this.manager);
                return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(t, (function (i) {
                    r.image = i;
                    var n = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                    r.format = n ? hm : lm, r.needsUpdate = !0, void 0 !== e && e(r)
                }), i, n), r
            }, setCrossOrigin: function (t) {
                return this.crossOrigin = t, this
            }, setPath: function (t) {
                return this.path = t, this
            }
        }), Object.assign(yw.prototype, {
            getPoint: function () {
                return console.warn("THREE.Curve: .getPoint() not implemented."), null
            }, getPointAt: function (t, e) {
                var i = this.getUtoTmapping(t);
                return this.getPoint(i, e)
            }, getPoints: function (t) {
                void 0 === t && (t = 5);
                for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                return e
            }, getSpacedPoints: function (t) {
                void 0 === t && (t = 5);
                for (var e = [], i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
                return e
            }, getLength: function () {
                var t = this.getLengths();
                return t[t.length - 1]
            }, getLengths: function (t) {
                if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                this.needsUpdate = !1;
                var e, i, n = [], r = this.getPoint(0), s = 0;
                for (n.push(0), i = 1; i <= t; i++) s += (e = this.getPoint(i / t)).distanceTo(r), n.push(s), r = e;
                return this.cacheArcLengths = n, n
            }, updateArcLengths: function () {
                this.needsUpdate = !0, this.getLengths()
            }, getUtoTmapping: function (t, e) {
                var i, n = this.getLengths(), r = 0, s = n.length;
                i = e || t * n[s - 1];
                for (var a, o = 0, h = s - 1; o <= h;) if ((a = n[r = Math.floor(o + (h - o) / 2)] - i) < 0) o = r + 1; else {
                    if (!(a > 0)) {
                        h = r;
                        break
                    }
                    h = r - 1
                }
                if (n[r = h] === i) return r / (s - 1);
                var l = n[r];
                return (r + (i - l) / (n[r + 1] - l)) / (s - 1)
            }, getTangent: function (t) {
                var e = 1e-4, i = t - e, n = t + e;
                i < 0 && (i = 0), n > 1 && (n = 1);
                var r = this.getPoint(i);
                return this.getPoint(n).clone().sub(r).normalize()
            }, getTangentAt: function (t) {
                var e = this.getUtoTmapping(t);
                return this.getTangent(e)
            }, computeFrenetFrames: function (t, e) {
                var i, n, r, s = new _m, a = [], o = [], h = [], l = new _m, c = new Jm;
                for (i = 0; i <= t; i++) n = i / t, a[i] = this.getTangentAt(n), a[i].normalize();
                o[0] = new _m, h[0] = new _m;
                var u = Number.MAX_VALUE, p = Math.abs(a[0].x), d = Math.abs(a[0].y), f = Math.abs(a[0].z);
                for (p <= u && (u = p, s.set(1, 0, 0)), d <= u && (u = d, s.set(0, 1, 0)), f <= u && s.set(0, 0, 1), l.crossVectors(a[0], s).normalize(), o[0].crossVectors(a[0], l), h[0].crossVectors(a[0], o[0]), i = 1; i <= t; i++) o[i] = o[i - 1].clone(), h[i] = h[i - 1].clone(), l.crossVectors(a[i - 1], a[i]), l.length() > Number.EPSILON && (l.normalize(), r = Math.acos(bm.clamp(a[i - 1].dot(a[i]), -1, 1)), o[i].applyMatrix4(c.makeRotationAxis(l, r))), h[i].crossVectors(a[i], o[i]);
                if (!0 === e) for (r = Math.acos(bm.clamp(o[0].dot(o[t]), -1, 1)), r /= t, a[0].dot(l.crossVectors(o[0], o[t])) > 0 && (r = -r), i = 1; i <= t; i++) o[i].applyMatrix4(c.makeRotationAxis(a[i], r * i)), h[i].crossVectors(a[i], o[i]);
                return {tangents: a, normals: o, binormals: h}
            }, clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                return this.arcLengthDivisions = t.arcLengthDivisions, this
            }, toJSON: function () {
                var t = {metadata: {version: 4.5, type: "Curve", generator: "Curve.toJSON"}};
                return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
            }, fromJSON: function (t) {
                return this.arcLengthDivisions = t.arcLengthDivisions, this
            }
        }), bw.prototype = Object.create(yw.prototype), bw.prototype.constructor = bw, bw.prototype.isEllipseCurve = !0, bw.prototype.getPoint = function (t, e) {
            for (var i = e || new xm, n = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, s = Math.abs(r) < Number.EPSILON; r < 0;) r += n;
            for (; r > n;) r -= n;
            r < Number.EPSILON && (r = s ? 0 : n), !0 !== this.aClockwise || s || (r === n ? r = -n : r -= n);
            var a = this.aStartAngle + t * r, o = this.aX + this.xRadius * Math.cos(a),
                h = this.aY + this.yRadius * Math.sin(a);
            if (0 !== this.aRotation) {
                var l = Math.cos(this.aRotation), c = Math.sin(this.aRotation), u = o - this.aX, p = h - this.aY;
                o = u * l - p * c + this.aX, h = u * c + p * l + this.aY
            }
            return i.set(o, h)
        }, bw.prototype.copy = function (t) {
            return yw.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
        }, bw.prototype.toJSON = function () {
            var t = yw.prototype.toJSON.call(this);
            return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
        }, bw.prototype.fromJSON = function (t) {
            return yw.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
        }, xw.prototype = Object.create(bw.prototype), xw.prototype.constructor = xw, xw.prototype.isArcCurve = !0;
        var _w = new _m, Ew = new ww, Mw = new ww, Aw = new ww;

        function Sw(t, e, i, n) {
            yw.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = i || "centripetal", this.tension = n || .5
        }

        function Tw(t, e, i, n, r) {
            var s = .5 * (n - e), a = .5 * (r - i), o = t * t;
            return (2 * i - 2 * n + s + a) * (t * o) + (-3 * i + 3 * n - 2 * s - a) * o + s * t + i
        }

        function Dw(t, e, i, n) {
            return function (t, e) {
                var i = 1 - t;
                return i * i * e
            }(t, e) + function (t, e) {
                return 2 * (1 - t) * t * e
            }(t, i) + function (t, e) {
                return t * t * e
            }(t, n)
        }

        function Cw(t, e, i, n, r) {
            return function (t, e) {
                var i = 1 - t;
                return i * i * i * e
            }(t, e) + function (t, e) {
                var i = 1 - t;
                return 3 * i * i * t * e
            }(t, i) + function (t, e) {
                return 3 * (1 - t) * t * t * e
            }(t, n) + function (t, e) {
                return t * t * t * e
            }(t, r)
        }

        function Pw(t, e, i, n) {
            yw.call(this), this.type = "CubicBezierCurve", this.v0 = t || new xm, this.v1 = e || new xm, this.v2 = i || new xm, this.v3 = n || new xm
        }

        function Iw(t, e, i, n) {
            yw.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new _m, this.v1 = e || new _m, this.v2 = i || new _m, this.v3 = n || new _m
        }

        function Lw(t, e) {
            yw.call(this), this.type = "LineCurve", this.v1 = t || new xm, this.v2 = e || new xm
        }

        function Rw(t, e) {
            yw.call(this), this.type = "LineCurve3", this.v1 = t || new _m, this.v2 = e || new _m
        }

        function Fw(t, e, i) {
            yw.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new xm, this.v1 = e || new xm, this.v2 = i || new xm
        }

        function kw(t, e, i) {
            yw.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new _m, this.v1 = e || new _m, this.v2 = i || new _m
        }

        function Ow(t) {
            yw.call(this), this.type = "SplineCurve", this.points = t || []
        }

        Sw.prototype = Object.create(yw.prototype), Sw.prototype.constructor = Sw, Sw.prototype.isCatmullRomCurve3 = !0, Sw.prototype.getPoint = function (t, e) {
            var i, n, r, s, a = e || new _m, o = this.points, h = o.length, l = (h - (this.closed ? 0 : 1)) * t,
                c = Math.floor(l), u = l - c;
            if (this.closed ? c += c > 0 ? 0 : (Math.floor(Math.abs(c) / h) + 1) * h : 0 === u && c === h - 1 && (c = h - 2, u = 1), this.closed || c > 0 ? i = o[(c - 1) % h] : (_w.subVectors(o[0], o[1]).add(o[0]), i = _w), n = o[c % h], r = o[(c + 1) % h], this.closed || c + 2 < h ? s = o[(c + 2) % h] : (_w.subVectors(o[h - 1], o[h - 2]).add(o[h - 1]), s = _w), "centripetal" === this.curveType || "chordal" === this.curveType) {
                var p = "chordal" === this.curveType ? .5 : .25, d = Math.pow(i.distanceToSquared(n), p),
                    f = Math.pow(n.distanceToSquared(r), p), m = Math.pow(r.distanceToSquared(s), p);
                f < 1e-4 && (f = 1), d < 1e-4 && (d = f), m < 1e-4 && (m = f), Ew.initNonuniformCatmullRom(i.x, n.x, r.x, s.x, d, f, m), Mw.initNonuniformCatmullRom(i.y, n.y, r.y, s.y, d, f, m), Aw.initNonuniformCatmullRom(i.z, n.z, r.z, s.z, d, f, m)
            } else "catmullrom" === this.curveType && (Ew.initCatmullRom(i.x, n.x, r.x, s.x, this.tension), Mw.initCatmullRom(i.y, n.y, r.y, s.y, this.tension), Aw.initCatmullRom(i.z, n.z, r.z, s.z, this.tension));
            return a.set(Ew.calc(u), Mw.calc(u), Aw.calc(u)), a
        }, Sw.prototype.copy = function (t) {
            yw.prototype.copy.call(this, t), this.points = [];
            for (var e = 0, i = t.points.length; e < i; e++) {
                var n = t.points[e];
                this.points.push(n.clone())
            }
            return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
        }, Sw.prototype.toJSON = function () {
            var t = yw.prototype.toJSON.call(this);
            t.points = [];
            for (var e = 0, i = this.points.length; e < i; e++) {
                var n = this.points[e];
                t.points.push(n.toArray())
            }
            return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
        }, Sw.prototype.fromJSON = function (t) {
            yw.prototype.fromJSON.call(this, t), this.points = [];
            for (var e = 0, i = t.points.length; e < i; e++) {
                var n = t.points[e];
                this.points.push((new _m).fromArray(n))
            }
            return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
        }, Pw.prototype = Object.create(yw.prototype), Pw.prototype.constructor = Pw, Pw.prototype.isCubicBezierCurve = !0, Pw.prototype.getPoint = function (t, e) {
            var i = e || new xm, n = this.v0, r = this.v1, s = this.v2, a = this.v3;
            return i.set(Cw(t, n.x, r.x, s.x, a.x), Cw(t, n.y, r.y, s.y, a.y)), i
        }, Pw.prototype.copy = function (t) {
            return yw.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
        }, Pw.prototype.toJSON = function () {
            var t = yw.prototype.toJSON.call(this);
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
        }, Pw.prototype.fromJSON = function (t) {
            return yw.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
        }, Iw.prototype = Object.create(yw.prototype), Iw.prototype.constructor = Iw, Iw.prototype.isCubicBezierCurve3 = !0, Iw.prototype.getPoint = function (t, e) {
            var i = e || new _m, n = this.v0, r = this.v1, s = this.v2, a = this.v3;
            return i.set(Cw(t, n.x, r.x, s.x, a.x), Cw(t, n.y, r.y, s.y, a.y), Cw(t, n.z, r.z, s.z, a.z)), i
        }, Iw.prototype.copy = function (t) {
            return yw.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
        }, Iw.prototype.toJSON = function () {
            var t = yw.prototype.toJSON.call(this);
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
        }, Iw.prototype.fromJSON = function (t) {
            return yw.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
        }, Lw.prototype = Object.create(yw.prototype), Lw.prototype.constructor = Lw, Lw.prototype.isLineCurve = !0, Lw.prototype.getPoint = function (t, e) {
            var i = e || new xm;
            return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i
        }, Lw.prototype.getPointAt = function (t, e) {
            return this.getPoint(t, e)
        }, Lw.prototype.getTangent = function () {
            return this.v2.clone().sub(this.v1).normalize()
        }, Lw.prototype.copy = function (t) {
            return yw.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, Lw.prototype.toJSON = function () {
            var t = yw.prototype.toJSON.call(this);
            return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }, Lw.prototype.fromJSON = function (t) {
            return yw.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }, Rw.prototype = Object.create(yw.prototype), Rw.prototype.constructor = Rw, Rw.prototype.isLineCurve3 = !0, Rw.prototype.getPoint = function (t, e) {
            var i = e || new _m;
            return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i
        }, Rw.prototype.getPointAt = function (t, e) {
            return this.getPoint(t, e)
        }, Rw.prototype.copy = function (t) {
            return yw.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, Rw.prototype.toJSON = function () {
            var t = yw.prototype.toJSON.call(this);
            return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }, Rw.prototype.fromJSON = function (t) {
            return yw.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }, Fw.prototype = Object.create(yw.prototype), Fw.prototype.constructor = Fw, Fw.prototype.isQuadraticBezierCurve = !0, Fw.prototype.getPoint = function (t, e) {
            var i = e || new xm, n = this.v0, r = this.v1, s = this.v2;
            return i.set(Dw(t, n.x, r.x, s.x), Dw(t, n.y, r.y, s.y)), i
        }, Fw.prototype.copy = function (t) {
            return yw.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, Fw.prototype.toJSON = function () {
            var t = yw.prototype.toJSON.call(this);
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }, Fw.prototype.fromJSON = function (t) {
            return yw.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }, kw.prototype = Object.create(yw.prototype), kw.prototype.constructor = kw, kw.prototype.isQuadraticBezierCurve3 = !0, kw.prototype.getPoint = function (t, e) {
            var i = e || new _m, n = this.v0, r = this.v1, s = this.v2;
            return i.set(Dw(t, n.x, r.x, s.x), Dw(t, n.y, r.y, s.y), Dw(t, n.z, r.z, s.z)), i
        }, kw.prototype.copy = function (t) {
            return yw.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, kw.prototype.toJSON = function () {
            var t = yw.prototype.toJSON.call(this);
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }, kw.prototype.fromJSON = function (t) {
            return yw.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }, Ow.prototype = Object.create(yw.prototype), Ow.prototype.constructor = Ow, Ow.prototype.isSplineCurve = !0, Ow.prototype.getPoint = function (t, e) {
            var i = e || new xm, n = this.points, r = (n.length - 1) * t, s = Math.floor(r), a = r - s,
                o = n[0 === s ? s : s - 1], h = n[s], l = n[s > n.length - 2 ? n.length - 1 : s + 1],
                c = n[s > n.length - 3 ? n.length - 1 : s + 2];
            return i.set(Tw(a, o.x, h.x, l.x, c.x), Tw(a, o.y, h.y, l.y, c.y)), i
        }, Ow.prototype.copy = function (t) {
            yw.prototype.copy.call(this, t), this.points = [];
            for (var e = 0, i = t.points.length; e < i; e++) {
                var n = t.points[e];
                this.points.push(n.clone())
            }
            return this
        }, Ow.prototype.toJSON = function () {
            var t = yw.prototype.toJSON.call(this);
            t.points = [];
            for (var e = 0, i = this.points.length; e < i; e++) {
                var n = this.points[e];
                t.points.push(n.toArray())
            }
            return t
        }, Ow.prototype.fromJSON = function (t) {
            yw.prototype.fromJSON.call(this, t), this.points = [];
            for (var e = 0, i = t.points.length; e < i; e++) {
                var n = t.points[e];
                this.points.push((new xm).fromArray(n))
            }
            return this
        };
        var zw = Object.freeze({
            ArcCurve: xw,
            CatmullRomCurve3: Sw,
            CubicBezierCurve: Pw,
            CubicBezierCurve3: Iw,
            EllipseCurve: bw,
            LineCurve: Lw,
            LineCurve3: Rw,
            QuadraticBezierCurve: Fw,
            QuadraticBezierCurve3: kw,
            SplineCurve: Ow
        });

        function Bw() {
            yw.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
        }

        function Nw(t) {
            Bw.call(this), this.type = "Path", this.currentPoint = new xm, t && this.setFromPoints(t)
        }

        function jw(t) {
            Nw.call(this, t), this.uuid = bm.generateUUID(), this.type = "Shape", this.holes = []
        }

        function Vw(t, e) {
            vg.call(this), this.type = "Light", this.color = new rg(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0
        }

        function Gw(t, e, i) {
            Vw.call(this, t, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(vg.DefaultUp), this.updateMatrix(), this.groundColor = new rg(e)
        }

        function Uw(t) {
            this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new xm(512, 512), this.map = null, this.matrix = new Jm
        }

        function Hw() {
            Uw.call(this, new Uy(50, 1, .5, 500))
        }

        function Ww(t, e, i, n, r, s) {
            Vw.call(this, t, e), this.type = "SpotLight", this.position.copy(vg.DefaultUp), this.updateMatrix(), this.target = new vg, Object.defineProperty(this, "power", {
                get: function () {
                    return this.intensity * Math.PI
                }, set: function (t) {
                    this.intensity = t / Math.PI
                }
            }), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== s ? s : 1, this.shadow = new Hw
        }

        function qw(t, e, i, n) {
            Vw.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
                get: function () {
                    return 4 * this.intensity * Math.PI
                }, set: function (t) {
                    this.intensity = t / (4 * Math.PI)
                }
            }), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== n ? n : 1, this.shadow = new Uw(new Uy(90, 1, .5, 500))
        }

        function Xw(t, e, i, n, r, s) {
            Gy.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== i ? i : 1, this.bottom = void 0 !== n ? n : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== s ? s : 2e3, this.updateProjectionMatrix()
        }

        function Yw() {
            Uw.call(this, new Xw(-5, 5, 5, -5, .5, 500))
        }

        function Zw(t, e) {
            Vw.call(this, t, e), this.type = "DirectionalLight", this.position.copy(vg.DefaultUp), this.updateMatrix(), this.target = new vg, this.shadow = new Yw
        }

        function Jw(t, e) {
            Vw.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0
        }

        function Qw(t, e, i, n) {
            Vw.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== i ? i : 10, this.height = void 0 !== n ? n : 10
        }

        function Kw(t) {
            this.manager = void 0 !== t ? t : uw, this.textures = {}
        }

        Bw.prototype = Object.assign(Object.create(yw.prototype), {
            constructor: Bw, add: function (t) {
                this.curves.push(t)
            }, closePath: function () {
                var t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1);
                t.equals(e) || this.curves.push(new Lw(e, t))
            }, getPoint: function (t) {
                for (var e = t * this.getLength(), i = this.getCurveLengths(), n = 0; n < i.length;) {
                    if (i[n] >= e) {
                        var r = i[n] - e, s = this.curves[n], a = s.getLength(), o = 0 === a ? 0 : 1 - r / a;
                        return s.getPointAt(o)
                    }
                    n++
                }
                return null
            }, getLength: function () {
                var t = this.getCurveLengths();
                return t[t.length - 1]
            }, updateArcLengths: function () {
                this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
            }, getCurveLengths: function () {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                for (var t = [], e = 0, i = 0, n = this.curves.length; i < n; i++) e += this.curves[i].getLength(), t.push(e);
                return this.cacheLengths = t, t
            }, getSpacedPoints: function (t) {
                void 0 === t && (t = 40);
                for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                return this.autoClose && e.push(e[0]), e
            }, getPoints: function (t) {
                t = t || 12;
                for (var e, i = [], n = 0, r = this.curves; n < r.length; n++) for (var s = r[n], a = s && s.isEllipseCurve ? 2 * t : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? t * s.points.length : t, o = s.getPoints(a), h = 0; h < o.length; h++) {
                    var l = o[h];
                    e && e.equals(l) || (i.push(l), e = l)
                }
                return this.autoClose && i.length > 1 && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i
            }, copy: function (t) {
                yw.prototype.copy.call(this, t), this.curves = [];
                for (var e = 0, i = t.curves.length; e < i; e++) {
                    var n = t.curves[e];
                    this.curves.push(n.clone())
                }
                return this.autoClose = t.autoClose, this
            }, toJSON: function () {
                var t = yw.prototype.toJSON.call(this);
                t.autoClose = this.autoClose, t.curves = [];
                for (var e = 0, i = this.curves.length; e < i; e++) {
                    var n = this.curves[e];
                    t.curves.push(n.toJSON())
                }
                return t
            }, fromJSON: function (t) {
                yw.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
                for (var e = 0, i = t.curves.length; e < i; e++) {
                    var n = t.curves[e];
                    this.curves.push((new zw[n.type]).fromJSON(n))
                }
                return this
            }
        }), Nw.prototype = Object.assign(Object.create(Bw.prototype), {
            constructor: Nw, setFromPoints: function (t) {
                this.moveTo(t[0].x, t[0].y);
                for (var e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y)
            }, moveTo: function (t, e) {
                this.currentPoint.set(t, e)
            }, lineTo: function (t, e) {
                var i = new Lw(this.currentPoint.clone(), new xm(t, e));
                this.curves.push(i), this.currentPoint.set(t, e)
            }, quadraticCurveTo: function (t, e, i, n) {
                var r = new Fw(this.currentPoint.clone(), new xm(t, e), new xm(i, n));
                this.curves.push(r), this.currentPoint.set(i, n)
            }, bezierCurveTo: function (t, e, i, n, r, s) {
                var a = new Pw(this.currentPoint.clone(), new xm(t, e), new xm(i, n), new xm(r, s));
                this.curves.push(a), this.currentPoint.set(r, s)
            }, splineThru: function (t) {
                var e = new Ow([this.currentPoint.clone()].concat(t));
                this.curves.push(e), this.currentPoint.copy(t[t.length - 1])
            }, arc: function (t, e, i, n, r, s) {
                var a = this.currentPoint.x, o = this.currentPoint.y;
                this.absarc(t + a, e + o, i, n, r, s)
            }, absarc: function (t, e, i, n, r, s) {
                this.absellipse(t, e, i, i, n, r, s)
            }, ellipse: function (t, e, i, n, r, s, a, o) {
                var h = this.currentPoint.x, l = this.currentPoint.y;
                this.absellipse(t + h, e + l, i, n, r, s, a, o)
            }, absellipse: function (t, e, i, n, r, s, a, o) {
                var h = new bw(t, e, i, n, r, s, a, o);
                if (this.curves.length > 0) {
                    var l = h.getPoint(0);
                    l.equals(this.currentPoint) || this.lineTo(l.x, l.y)
                }
                this.curves.push(h);
                var c = h.getPoint(1);
                this.currentPoint.copy(c)
            }, copy: function (t) {
                return Bw.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this
            }, toJSON: function () {
                var t = Bw.prototype.toJSON.call(this);
                return t.currentPoint = this.currentPoint.toArray(), t
            }, fromJSON: function (t) {
                return Bw.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this
            }
        }), jw.prototype = Object.assign(Object.create(Nw.prototype), {
            constructor: jw, getPointsHoles: function (t) {
                for (var e = [], i = 0, n = this.holes.length; i < n; i++) e[i] = this.holes[i].getPoints(t);
                return e
            }, extractPoints: function (t) {
                return {shape: this.getPoints(t), holes: this.getPointsHoles(t)}
            }, copy: function (t) {
                Nw.prototype.copy.call(this, t), this.holes = [];
                for (var e = 0, i = t.holes.length; e < i; e++) {
                    var n = t.holes[e];
                    this.holes.push(n.clone())
                }
                return this
            }, toJSON: function () {
                var t = Nw.prototype.toJSON.call(this);
                t.uuid = this.uuid, t.holes = [];
                for (var e = 0, i = this.holes.length; e < i; e++) {
                    var n = this.holes[e];
                    t.holes.push(n.toJSON())
                }
                return t
            }, fromJSON: function (t) {
                Nw.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
                for (var e = 0, i = t.holes.length; e < i; e++) {
                    var n = t.holes[e];
                    this.holes.push((new Nw).fromJSON(n))
                }
                return this
            }
        }), Vw.prototype = Object.assign(Object.create(vg.prototype), {
            constructor: Vw,
            isLight: !0,
            copy: function (t) {
                return vg.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this
            },
            toJSON: function (t) {
                var e = vg.prototype.toJSON.call(this, t);
                return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
            }
        }), Gw.prototype = Object.assign(Object.create(Vw.prototype), {
            constructor: Gw,
            isHemisphereLight: !0,
            copy: function (t) {
                return Vw.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
            }
        }), Object.assign(Uw.prototype, {
            copy: function (t) {
                return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
            }, clone: function () {
                return (new this.constructor).copy(this)
            }, toJSON: function () {
                var t = {};
                return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
            }
        }), Hw.prototype = Object.assign(Object.create(Uw.prototype), {
            constructor: Hw,
            isSpotLightShadow: !0,
            update: function (t) {
                var e = this.camera, i = 2 * bm.RAD2DEG * t.angle, n = this.mapSize.width / this.mapSize.height,
                    r = t.distance || e.far;
                i === e.fov && n === e.aspect && r === e.far || (e.fov = i, e.aspect = n, e.far = r, e.updateProjectionMatrix())
            }
        }), Ww.prototype = Object.assign(Object.create(Vw.prototype), {
            constructor: Ww,
            isSpotLight: !0,
            copy: function (t) {
                return Vw.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }), qw.prototype = Object.assign(Object.create(Vw.prototype), {
            constructor: qw,
            isPointLight: !0,
            copy: function (t) {
                return Vw.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
            }
        }), Xw.prototype = Object.assign(Object.create(Gy.prototype), {
            constructor: Xw, isOrthographicCamera: !0, copy: function (t, e) {
                return Gy.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
            }, setViewOffset: function (t, e, i, n, r, s) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
            }, clearViewOffset: function () {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            }, updateProjectionMatrix: function () {
                var t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom),
                    i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2, r = i - t, s = i + t, a = n + e,
                    o = n - e;
                if (null !== this.view && this.view.enabled) {
                    var h = this.zoom / (this.view.width / this.view.fullWidth),
                        l = this.zoom / (this.view.height / this.view.fullHeight),
                        c = (this.right - this.left) / this.view.width, u = (this.top - this.bottom) / this.view.height;
                    s = (r += c * (this.view.offsetX / h)) + c * (this.view.width / h), o = (a -= u * (this.view.offsetY / l)) - u * (this.view.height / l)
                }
                this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
            }, toJSON: function (t) {
                var e = vg.prototype.toJSON.call(this, t);
                return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
            }
        }), Yw.prototype = Object.assign(Object.create(Uw.prototype), {constructor: Yw}), Zw.prototype = Object.assign(Object.create(Vw.prototype), {
            constructor: Zw,
            isDirectionalLight: !0,
            copy: function (t) {
                return Vw.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }), Jw.prototype = Object.assign(Object.create(Vw.prototype), {
            constructor: Jw,
            isAmbientLight: !0
        }), Qw.prototype = Object.assign(Object.create(Vw.prototype), {
            constructor: Qw,
            isRectAreaLight: !0,
            copy: function (t) {
                return Vw.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this
            },
            toJSON: function (t) {
                var e = Vw.prototype.toJSON.call(this, t);
                return e.object.width = this.width, e.object.height = this.height, e
            }
        }), Object.assign(Kw.prototype, {
            load: function (t, e, i, n) {
                var r = this, s = new dw(r.manager);
                s.setPath(r.path), s.load(t, (function (t) {
                    e(r.parse(JSON.parse(t)))
                }), i, n)
            }, parse: function (t) {
                var e = this.textures;

                function i(t) {
                    return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t]
                }

                var n = new Xx[t.type];
                if (void 0 !== t.uuid && (n.uuid = t.uuid), void 0 !== t.name && (n.name = t.name), void 0 !== t.color && n.color.setHex(t.color), void 0 !== t.roughness && (n.roughness = t.roughness), void 0 !== t.metalness && (n.metalness = t.metalness), void 0 !== t.emissive && n.emissive.setHex(t.emissive), void 0 !== t.specular && n.specular.setHex(t.specular), void 0 !== t.shininess && (n.shininess = t.shininess), void 0 !== t.clearCoat && (n.clearCoat = t.clearCoat), void 0 !== t.clearCoatRoughness && (n.clearCoatRoughness = t.clearCoatRoughness), void 0 !== t.vertexColors && (n.vertexColors = t.vertexColors), void 0 !== t.fog && (n.fog = t.fog), void 0 !== t.flatShading && (n.flatShading = t.flatShading), void 0 !== t.blending && (n.blending = t.blending), void 0 !== t.combine && (n.combine = t.combine), void 0 !== t.side && (n.side = t.side), void 0 !== t.opacity && (n.opacity = t.opacity), void 0 !== t.transparent && (n.transparent = t.transparent), void 0 !== t.alphaTest && (n.alphaTest = t.alphaTest), void 0 !== t.depthTest && (n.depthTest = t.depthTest), void 0 !== t.depthWrite && (n.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (n.colorWrite = t.colorWrite), void 0 !== t.wireframe && (n.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (n.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (n.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (n.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (n.rotation = t.rotation), 1 !== t.linewidth && (n.linewidth = t.linewidth), void 0 !== t.dashSize && (n.dashSize = t.dashSize), void 0 !== t.gapSize && (n.gapSize = t.gapSize), void 0 !== t.scale && (n.scale = t.scale), void 0 !== t.polygonOffset && (n.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (n.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (n.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (n.skinning = t.skinning), void 0 !== t.morphTargets && (n.morphTargets = t.morphTargets), void 0 !== t.dithering && (n.dithering = t.dithering), void 0 !== t.visible && (n.visible = t.visible), void 0 !== t.userData && (n.userData = t.userData), void 0 !== t.uniforms) for (var r in t.uniforms) {
                    var s = t.uniforms[r];
                    switch (n.uniforms[r] = {}, s.type) {
                        case"t":
                            n.uniforms[r].value = i(s.value);
                            break;
                        case"c":
                            n.uniforms[r].value = (new rg).setHex(s.value);
                            break;
                        case"v2":
                            n.uniforms[r].value = (new xm).fromArray(s.value);
                            break;
                        case"v3":
                            n.uniforms[r].value = (new _m).fromArray(s.value);
                            break;
                        case"v4":
                            n.uniforms[r].value = (new Vm).fromArray(s.value);
                            break;
                        case"m3":
                            n.uniforms[r].value = (new Em).fromArray(s.value);
                        case"m4":
                            n.uniforms[r].value = (new Jm).fromArray(s.value);
                            break;
                        default:
                            n.uniforms[r].value = s.value
                    }
                }
                if (void 0 !== t.defines && (n.defines = t.defines), void 0 !== t.vertexShader && (n.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (n.fragmentShader = t.fragmentShader), void 0 !== t.extensions) for (var a in t.extensions) n.extensions[a] = t.extensions[a];
                if (void 0 !== t.shading && (n.flatShading = 1 === t.shading), void 0 !== t.size && (n.size = t.size), void 0 !== t.sizeAttenuation && (n.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (n.map = i(t.map)), void 0 !== t.matcap && (n.matcap = i(t.matcap)), void 0 !== t.alphaMap && (n.alphaMap = i(t.alphaMap), n.transparent = !0), void 0 !== t.bumpMap && (n.bumpMap = i(t.bumpMap)), void 0 !== t.bumpScale && (n.bumpScale = t.bumpScale), void 0 !== t.normalMap && (n.normalMap = i(t.normalMap)), void 0 !== t.normalMapType && (n.normalMapType = t.normalMapType), void 0 !== t.normalScale) {
                    var o = t.normalScale;
                    !1 === Array.isArray(o) && (o = [o, o]), n.normalScale = (new xm).fromArray(o)
                }
                return void 0 !== t.displacementMap && (n.displacementMap = i(t.displacementMap)), void 0 !== t.displacementScale && (n.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (n.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (n.roughnessMap = i(t.roughnessMap)), void 0 !== t.metalnessMap && (n.metalnessMap = i(t.metalnessMap)), void 0 !== t.emissiveMap && (n.emissiveMap = i(t.emissiveMap)), void 0 !== t.emissiveIntensity && (n.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (n.specularMap = i(t.specularMap)), void 0 !== t.envMap && (n.envMap = i(t.envMap)), void 0 !== t.envMapIntensity && (n.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (n.reflectivity = t.reflectivity), void 0 !== t.lightMap && (n.lightMap = i(t.lightMap)), void 0 !== t.lightMapIntensity && (n.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (n.aoMap = i(t.aoMap)), void 0 !== t.aoMapIntensity && (n.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (n.gradientMap = i(t.gradientMap)), n
            }, setPath: function (t) {
                return this.path = t, this
            }, setTextures: function (t) {
                return this.textures = t, this
            }
        });
        var $w = function (t) {
            var e = t.lastIndexOf("/");
            return -1 === e ? "./" : t.substr(0, e + 1)
        };

        function t_() {
            kg.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
        }

        function e_(t, e, i, n) {
            "number" == typeof i && (n = i, i = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), _g.call(this, t, e, i), this.meshPerAttribute = n || 1
        }

        function i_(t) {
            this.manager = void 0 !== t ? t : uw
        }

        t_.prototype = Object.assign(Object.create(kg.prototype), {
            constructor: t_,
            isInstancedBufferGeometry: !0,
            copy: function (t) {
                return kg.prototype.copy.call(this, t), this.maxInstancedCount = t.maxInstancedCount, this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            toJSON: function () {
                var t = kg.prototype.toJSON.call(this);
                return t.maxInstancedCount = this.maxInstancedCount, t.isInstancedBufferGeometry = !0, t
            }
        }), e_.prototype = Object.assign(Object.create(_g.prototype), {
            constructor: e_,
            isInstancedBufferAttribute: !0,
            copy: function (t) {
                return _g.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
            },
            toJSON: function () {
                var t = _g.prototype.toJSON.call(this);
                return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
            }
        }), Object.assign(i_.prototype, {
            load: function (t, e, i, n) {
                var r = this, s = new dw(r.manager);
                s.setPath(r.path), s.load(t, (function (t) {
                    e(r.parse(JSON.parse(t)))
                }), i, n)
            }, parse: function (t) {
                var e = t.isInstancedBufferGeometry ? new t_ : new kg, i = t.data.index;
                if (void 0 !== i) {
                    var n = new n_[i.type](i.array);
                    e.setIndex(new _g(n, 1))
                }
                var r = t.data.attributes;
                for (var s in r) {
                    var a = r[s],
                        o = (n = new n_[a.type](a.array), new (a.isInstancedBufferAttribute ? e_ : _g)(n, a.itemSize, a.normalized));
                    void 0 !== a.name && (o.name = a.name), e.addAttribute(s, o)
                }
                var h = t.data.morphAttributes;
                if (h) for (var s in h) {
                    for (var l = h[s], c = [], u = 0, p = l.length; u < p; u++) {
                        a = l[u], o = new _g(n = new n_[a.type](a.array), a.itemSize, a.normalized);
                        void 0 !== a.name && (o.name = a.name), c.push(o)
                    }
                    e.morphAttributes[s] = c
                }
                var d = t.data.groups || t.data.drawcalls || t.data.offsets;
                if (void 0 !== d) {
                    u = 0;
                    for (var f = d.length; u !== f; ++u) {
                        var m = d[u];
                        e.addGroup(m.start, m.count, m.materialIndex)
                    }
                }
                var g = t.data.boundingSphere;
                if (void 0 !== g) {
                    var v = new _m;
                    void 0 !== g.center && v.fromArray(g.center), e.boundingSphere = new Xm(v, g.radius)
                }
                return t.name && (e.name = t.name), t.userData && (e.userData = t.userData), e
            }, setPath: function (t) {
                return this.path = t, this
            }
        });
        var n_ = {
            Int8Array,
            Uint8Array,
            Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
            Int16Array,
            Uint16Array,
            Int32Array,
            Uint32Array,
            Float32Array,
            Float64Array
        };

        function r_(t) {
            this.manager = void 0 !== t ? t : uw, this.resourcePath = ""
        }

        Object.assign(r_.prototype, {
            crossOrigin: "anonymous", load: function (t, e, i, n) {
                var r = this, s = void 0 === this.path ? $w(t) : this.path;
                this.resourcePath = this.resourcePath || s;
                var a = new dw(r.manager);
                a.setPath(this.path), a.load(t, (function (i) {
                    var s = null;
                    try {
                        s = JSON.parse(i)
                    } catch (e) {
                        return void 0 !== n && n(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
                    }
                    var a = s.metadata;
                    void 0 !== a && void 0 !== a.type && "geometry" !== a.type.toLowerCase() ? r.parse(s, e) : console.error("THREE.ObjectLoader: Can't load " + t)
                }), i, n)
            }, setPath: function (t) {
                return this.path = t, this
            }, setResourcePath: function (t) {
                return this.resourcePath = t, this
            }, setCrossOrigin: function (t) {
                return this.crossOrigin = t, this
            }, parse: function (t, e) {
                var i = this.parseShape(t.shapes), n = this.parseGeometries(t.geometries, i),
                    r = this.parseImages(t.images, (function () {
                        void 0 !== e && e(o)
                    })), s = this.parseTextures(t.textures, r), a = this.parseMaterials(t.materials, s),
                    o = this.parseObject(t.object, n, a);
                return t.animations && (o.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(o), o
            }, parseShape: function (t) {
                var e = {};
                if (void 0 !== t) for (var i = 0, n = t.length; i < n; i++) {
                    var r = (new jw).fromJSON(t[i]);
                    e[r.uuid] = r
                }
                return e
            }, parseGeometries: function (t, e) {
                var i = {};
                if (void 0 !== t) for (var n = new i_, r = 0, s = t.length; r < s; r++) {
                    var a, o = t[r];
                    switch (o.type) {
                        case"PlaneGeometry":
                        case"PlaneBufferGeometry":
                            a = new Ox[o.type](o.width, o.height, o.widthSegments, o.heightSegments);
                            break;
                        case"BoxGeometry":
                        case"BoxBufferGeometry":
                        case"CubeGeometry":
                            a = new Ox[o.type](o.width, o.height, o.depth, o.widthSegments, o.heightSegments, o.depthSegments);
                            break;
                        case"CircleGeometry":
                        case"CircleBufferGeometry":
                            a = new Ox[o.type](o.radius, o.segments, o.thetaStart, o.thetaLength);
                            break;
                        case"CylinderGeometry":
                        case"CylinderBufferGeometry":
                            a = new Ox[o.type](o.radiusTop, o.radiusBottom, o.height, o.radialSegments, o.heightSegments, o.openEnded, o.thetaStart, o.thetaLength);
                            break;
                        case"ConeGeometry":
                        case"ConeBufferGeometry":
                            a = new Ox[o.type](o.radius, o.height, o.radialSegments, o.heightSegments, o.openEnded, o.thetaStart, o.thetaLength);
                            break;
                        case"SphereGeometry":
                        case"SphereBufferGeometry":
                            a = new Ox[o.type](o.radius, o.widthSegments, o.heightSegments, o.phiStart, o.phiLength, o.thetaStart, o.thetaLength);
                            break;
                        case"DodecahedronGeometry":
                        case"DodecahedronBufferGeometry":
                        case"IcosahedronGeometry":
                        case"IcosahedronBufferGeometry":
                        case"OctahedronGeometry":
                        case"OctahedronBufferGeometry":
                        case"TetrahedronGeometry":
                        case"TetrahedronBufferGeometry":
                            a = new Ox[o.type](o.radius, o.detail);
                            break;
                        case"RingGeometry":
                        case"RingBufferGeometry":
                            a = new Ox[o.type](o.innerRadius, o.outerRadius, o.thetaSegments, o.phiSegments, o.thetaStart, o.thetaLength);
                            break;
                        case"TorusGeometry":
                        case"TorusBufferGeometry":
                            a = new Ox[o.type](o.radius, o.tube, o.radialSegments, o.tubularSegments, o.arc);
                            break;
                        case"TorusKnotGeometry":
                        case"TorusKnotBufferGeometry":
                            a = new Ox[o.type](o.radius, o.tube, o.tubularSegments, o.radialSegments, o.p, o.q);
                            break;
                        case"TubeGeometry":
                        case"TubeBufferGeometry":
                            a = new Ox[o.type]((new zw[o.path.type]).fromJSON(o.path), o.tubularSegments, o.radius, o.radialSegments, o.closed);
                            break;
                        case"LatheGeometry":
                        case"LatheBufferGeometry":
                            a = new Ox[o.type](o.points, o.segments, o.phiStart, o.phiLength);
                            break;
                        case"PolyhedronGeometry":
                        case"PolyhedronBufferGeometry":
                            a = new Ox[o.type](o.vertices, o.indices, o.radius, o.details);
                            break;
                        case"ShapeGeometry":
                        case"ShapeBufferGeometry":
                            for (var h = [], l = 0, c = o.shapes.length; l < c; l++) {
                                var u = e[o.shapes[l]];
                                h.push(u)
                            }
                            a = new Ox[o.type](h, o.curveSegments);
                            break;
                        case"ExtrudeGeometry":
                        case"ExtrudeBufferGeometry":
                            for (h = [], l = 0, c = o.shapes.length; l < c; l++) {
                                u = e[o.shapes[l]];
                                h.push(u)
                            }
                            var p = o.options.extrudePath;
                            void 0 !== p && (o.options.extrudePath = (new zw[p.type]).fromJSON(p)), a = new Ox[o.type](h, o.options);
                            break;
                        case"BufferGeometry":
                        case"InstancedBufferGeometry":
                            a = n.parse(o);
                            break;
                        case"Geometry":
                            if ("THREE" in window && "LegacyJSONLoader" in THREE) a = (new THREE.LegacyJSONLoader).parse(o, this.resourcePath).geometry; else console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                            break;
                        default:
                            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + o.type + '"');
                            continue
                    }
                    a.uuid = o.uuid, void 0 !== o.name && (a.name = o.name), !0 === a.isBufferGeometry && void 0 !== o.userData && (a.userData = o.userData), i[o.uuid] = a
                }
                return i
            }, parseMaterials: function (t, e) {
                var i = {}, n = {};
                if (void 0 !== t) {
                    var r = new Kw;
                    r.setTextures(e);
                    for (var s = 0, a = t.length; s < a; s++) {
                        var o = t[s];
                        if ("MultiMaterial" === o.type) {
                            for (var h = [], l = 0; l < o.materials.length; l++) {
                                var c = o.materials[l];
                                void 0 === i[c.uuid] && (i[c.uuid] = r.parse(c)), h.push(i[c.uuid])
                            }
                            n[o.uuid] = h
                        } else void 0 === i[o.uuid] && (i[o.uuid] = r.parse(o)), n[o.uuid] = i[o.uuid]
                    }
                }
                return n
            }, parseAnimations: function (t) {
                for (var e = [], i = 0; i < t.length; i++) {
                    var n = t[i], r = ow.parse(n);
                    void 0 !== n.uuid && (r.uuid = n.uuid), e.push(r)
                }
                return e
            }, parseImages: function (t, e) {
                var i = this, n = {};

                function r(t) {
                    return i.manager.itemStart(t), s.load(t, (function () {
                        i.manager.itemEnd(t)
                    }), void 0, (function () {
                        i.manager.itemError(t), i.manager.itemEnd(t)
                    }))
                }

                if (void 0 !== t && t.length > 0) {
                    var s = new mw(new cw(e));
                    s.setCrossOrigin(this.crossOrigin);
                    for (var a = 0, o = t.length; a < o; a++) {
                        var h = t[a], l = h.url;
                        if (Array.isArray(l)) {
                            n[h.uuid] = [];
                            for (var c = 0, u = l.length; c < u; c++) {
                                var p = l[c], d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p) ? p : i.resourcePath + p;
                                n[h.uuid].push(r(d))
                            }
                        } else {
                            d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h.url) ? h.url : i.resourcePath + h.url;
                            n[h.uuid] = r(d)
                        }
                    }
                }
                return n
            }, parseTextures: function (t, e) {
                function i(t, e) {
                    return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t])
                }

                var n = {};
                if (void 0 !== t) for (var r = 0, s = t.length; r < s; r++) {
                    var a, o = t[r];
                    void 0 === o.image && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid), void 0 === e[o.image] && console.warn("THREE.ObjectLoader: Undefined image", o.image), (a = Array.isArray(e[o.image]) ? new gv(e[o.image]) : new jm(e[o.image])).needsUpdate = !0, a.uuid = o.uuid, void 0 !== o.name && (a.name = o.name), void 0 !== o.mapping && (a.mapping = i(o.mapping, c_)), void 0 !== o.offset && a.offset.fromArray(o.offset), void 0 !== o.repeat && a.repeat.fromArray(o.repeat), void 0 !== o.center && a.center.fromArray(o.center), void 0 !== o.rotation && (a.rotation = o.rotation), void 0 !== o.wrap && (a.wrapS = i(o.wrap[0], u_), a.wrapT = i(o.wrap[1], u_)), void 0 !== o.format && (a.format = o.format), void 0 !== o.type && (a.type = o.type), void 0 !== o.encoding && (a.encoding = o.encoding), void 0 !== o.minFilter && (a.minFilter = i(o.minFilter, p_)), void 0 !== o.magFilter && (a.magFilter = i(o.magFilter, p_)), void 0 !== o.anisotropy && (a.anisotropy = o.anisotropy), void 0 !== o.flipY && (a.flipY = o.flipY), void 0 !== o.premultiplyAlpha && (a.premultiplyAlpha = o.premultiplyAlpha), void 0 !== o.unpackAlignment && (a.unpackAlignment = o.unpackAlignment), n[o.uuid] = a
                }
                return n
            }, parseObject: function (t, e, i) {
                var n;

                function r(t) {
                    return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t]
                }

                function s(t) {
                    if (void 0 !== t) {
                        if (Array.isArray(t)) {
                            for (var e = [], n = 0, r = t.length; n < r; n++) {
                                var s = t[n];
                                void 0 === i[s] && console.warn("THREE.ObjectLoader: Undefined material", s), e.push(i[s])
                            }
                            return e
                        }
                        return void 0 === i[t] && console.warn("THREE.ObjectLoader: Undefined material", t), i[t]
                    }
                }

                switch (t.type) {
                    case"Scene":
                        n = new sb, void 0 !== t.background && Number.isInteger(t.background) && (n.background = new rg(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? n.fog = new rb(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (n.fog = new nb(t.fog.color, t.fog.density)));
                        break;
                    case"PerspectiveCamera":
                        n = new Uy(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (n.focus = t.focus), void 0 !== t.zoom && (n.zoom = t.zoom), void 0 !== t.filmGauge && (n.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (n.filmOffset = t.filmOffset), void 0 !== t.view && (n.view = Object.assign({}, t.view));
                        break;
                    case"OrthographicCamera":
                        n = new Xw(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (n.zoom = t.zoom), void 0 !== t.view && (n.view = Object.assign({}, t.view));
                        break;
                    case"AmbientLight":
                        n = new Jw(t.color, t.intensity);
                        break;
                    case"DirectionalLight":
                        n = new Zw(t.color, t.intensity);
                        break;
                    case"PointLight":
                        n = new qw(t.color, t.intensity, t.distance, t.decay);
                        break;
                    case"RectAreaLight":
                        n = new Qw(t.color, t.intensity, t.width, t.height);
                        break;
                    case"SpotLight":
                        n = new Ww(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                        break;
                    case"HemisphereLight":
                        n = new Gw(t.color, t.groundColor, t.intensity);
                        break;
                    case"SkinnedMesh":
                        console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                    case"Mesh":
                        var a = r(t.geometry), o = s(t.material);
                        n = a.bones && a.bones.length > 0 ? new ub(a, o) : new rv(a, o), void 0 !== t.drawMode && n.setDrawMode(t.drawMode);
                        break;
                    case"LOD":
                        n = new cb;
                        break;
                    case"Line":
                        n = new mb(r(t.geometry), s(t.material), t.mode);
                        break;
                    case"LineLoop":
                        n = new vb(r(t.geometry), s(t.material));
                        break;
                    case"LineSegments":
                        n = new gb(r(t.geometry), s(t.material));
                        break;
                    case"PointCloud":
                    case"Points":
                        n = new bb(r(t.geometry), s(t.material));
                        break;
                    case"Sprite":
                        n = new lb(s(t.material));
                        break;
                    case"Group":
                        n = new Vy;
                        break;
                    default:
                        n = new vg
                }
                if (n.uuid = t.uuid, void 0 !== t.name && (n.name = t.name), void 0 !== t.matrix ? (n.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (n.matrixAutoUpdate = t.matrixAutoUpdate), n.matrixAutoUpdate && n.matrix.decompose(n.position, n.quaternion, n.scale)) : (void 0 !== t.position && n.position.fromArray(t.position), void 0 !== t.rotation && n.rotation.fromArray(t.rotation), void 0 !== t.quaternion && n.quaternion.fromArray(t.quaternion), void 0 !== t.scale && n.scale.fromArray(t.scale)), void 0 !== t.castShadow && (n.castShadow = t.castShadow), void 0 !== t.receiveShadow && (n.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (n.shadow.bias = t.shadow.bias), void 0 !== t.shadow.radius && (n.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && n.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (n.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (n.visible = t.visible), void 0 !== t.frustumCulled && (n.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (n.renderOrder = t.renderOrder), void 0 !== t.userData && (n.userData = t.userData), void 0 !== t.layers && (n.layers.mask = t.layers), void 0 !== t.children) for (var h = t.children, l = 0; l < h.length; l++) n.add(this.parseObject(h[l], e, i));
                if ("LOD" === t.type) for (var c = t.levels, u = 0; u < c.length; u++) {
                    var p = c[u], d = n.getObjectByProperty("uuid", p.object);
                    void 0 !== d && n.addLevel(d, p.distance)
                }
                return n
            }
        });
        var s_, a_, o_, h_, l_, c_ = {
            UVMapping: 300,
            CubeReflectionMapping: 301,
            CubeRefractionMapping: 302,
            EquirectangularReflectionMapping: 303,
            EquirectangularRefractionMapping: 304,
            SphericalReflectionMapping: 305,
            CubeUVReflectionMapping: 306,
            CubeUVRefractionMapping: 307
        }, u_ = {RepeatWrapping: Zf, ClampToEdgeWrapping: Jf, MirroredRepeatWrapping: Qf}, p_ = {
            NearestFilter: Kf,
            NearestMipMapNearestFilter: $f,
            NearestMipMapLinearFilter: tm,
            LinearFilter: em,
            LinearMipMapNearestFilter: 1007,
            LinearMipMapLinearFilter: im
        };

        function d_(t) {
            "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = void 0 !== t ? t : uw, this.options = void 0
        }

        function f_() {
            this.type = "ShapePath", this.color = new rg, this.subPaths = [], this.currentPath = null
        }

        function m_(t) {
            this.type = "Font", this.data = t
        }

        function g_(t, e, i, n, r) {
            var s = r.glyphs[t] || r.glyphs["?"];
            if (s) {
                var a, o, h, l, c, u, p, d, f = new f_;
                if (s.o) for (var m = s._cachedOutline || (s._cachedOutline = s.o.split(" ")), g = 0, v = m.length; g < v;) {
                    switch (m[g++]) {
                        case"m":
                            a = m[g++] * e + i, o = m[g++] * e + n, f.moveTo(a, o);
                            break;
                        case"l":
                            a = m[g++] * e + i, o = m[g++] * e + n, f.lineTo(a, o);
                            break;
                        case"q":
                            h = m[g++] * e + i, l = m[g++] * e + n, c = m[g++] * e + i, u = m[g++] * e + n, f.quadraticCurveTo(c, u, h, l);
                            break;
                        case"b":
                            h = m[g++] * e + i, l = m[g++] * e + n, c = m[g++] * e + i, u = m[g++] * e + n, p = m[g++] * e + i, d = m[g++] * e + n, f.bezierCurveTo(c, u, p, d, h, l)
                    }
                }
                return {offsetX: s.ha * e, path: f}
            }
        }

        function v_() {
        }

        d_.prototype = {
            constructor: d_, setOptions: function (t) {
                return this.options = t, this
            }, load: function (t, e, i, n) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                var r = this, s = lw.get(t);
                if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function () {
                    e && e(s), r.manager.itemEnd(t)
                }), 0), s;
                fetch(t).then((function (t) {
                    return t.blob()
                })).then((function (t) {
                    return void 0 === r.options ? createImageBitmap(t) : createImageBitmap(t, r.options)
                })).then((function (i) {
                    lw.add(t, i), e && e(i), r.manager.itemEnd(t)
                })).catch((function (e) {
                    n && n(e), r.manager.itemError(t), r.manager.itemEnd(t)
                })), r.manager.itemStart(t)
            }, setCrossOrigin: function () {
                return this
            }, setPath: function (t) {
                return this.path = t, this
            }
        }, Object.assign(f_.prototype, {
            moveTo: function (t, e) {
                this.currentPath = new Nw, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e)
            }, lineTo: function (t, e) {
                this.currentPath.lineTo(t, e)
            }, quadraticCurveTo: function (t, e, i, n) {
                this.currentPath.quadraticCurveTo(t, e, i, n)
            }, bezierCurveTo: function (t, e, i, n, r, s) {
                this.currentPath.bezierCurveTo(t, e, i, n, r, s)
            }, splineThru: function (t) {
                this.currentPath.splineThru(t)
            }, toShapes: function (t, e) {
                function i(t) {
                    for (var e = [], i = 0, n = t.length; i < n; i++) {
                        var r = t[i], s = new jw;
                        s.curves = r.curves, e.push(s)
                    }
                    return e
                }

                function n(t, e) {
                    for (var i = e.length, n = !1, r = i - 1, s = 0; s < i; r = s++) {
                        var a = e[r], o = e[s], h = o.x - a.x, l = o.y - a.y;
                        if (Math.abs(l) > Number.EPSILON) {
                            if (l < 0 && (a = e[s], h = -h, o = e[r], l = -l), t.y < a.y || t.y > o.y) continue;
                            if (t.y === a.y) {
                                if (t.x === a.x) return !0
                            } else {
                                var c = l * (t.x - a.x) - h * (t.y - a.y);
                                if (0 === c) return !0;
                                if (c < 0) continue;
                                n = !n
                            }
                        } else {
                            if (t.y !== a.y) continue;
                            if (o.x <= t.x && t.x <= a.x || a.x <= t.x && t.x <= o.x) return !0
                        }
                    }
                    return n
                }

                var r = ux.isClockWise, s = this.subPaths;
                if (0 === s.length) return [];
                if (!0 === e) return i(s);
                var a, o, h, l = [];
                if (1 === s.length) return o = s[0], (h = new jw).curves = o.curves, l.push(h), l;
                var c = !r(s[0].getPoints());
                c = t ? !c : c;
                var u, p, d = [], f = [], m = [], g = 0;
                f[g] = void 0, m[g] = [];
                for (var v = 0, y = s.length; v < y; v++) a = r(u = (o = s[v]).getPoints()), (a = t ? !a : a) ? (!c && f[g] && g++, f[g] = {
                    s: new jw,
                    p: u
                }, f[g].s.curves = o.curves, c && g++, m[g] = []) : m[g].push({h: o, p: u[0]});
                if (!f[0]) return i(s);
                if (f.length > 1) {
                    for (var b = !1, x = [], w = 0, _ = f.length; w < _; w++) d[w] = [];
                    for (w = 0, _ = f.length; w < _; w++) for (var E = m[w], M = 0; M < E.length; M++) {
                        for (var A = E[M], S = !0, T = 0; T < f.length; T++) n(A.p, f[T].p) && (w !== T && x.push({
                            froms: w,
                            tos: T,
                            hole: M
                        }), S ? (S = !1, d[T].push(A)) : b = !0);
                        S && d[w].push(A)
                    }
                    x.length > 0 && (b || (m = d))
                }
                v = 0;
                for (var D = f.length; v < D; v++) {
                    h = f[v].s, l.push(h);
                    for (var C = 0, P = (p = m[v]).length; C < P; C++) h.holes.push(p[C].h)
                }
                return l
            }
        }), Object.assign(m_.prototype, {
            isFont: !0, generateShapes: function (t, e) {
                void 0 === e && (e = 100);
                for (var i = [], n = function (t, e, i) {
                    for (var n = Array.from ? Array.from(t) : String(t).split(""), r = e / i.resolution, s = (i.boundingBox.yMax - i.boundingBox.yMin + i.underlineThickness) * r, a = [], o = 0, h = 0, l = 0; l < n.length; l++) {
                        var c = n[l];
                        if ("\n" === c) o = 0, h -= s; else {
                            var u = g_(c, r, o, h, i);
                            o += u.offsetX, a.push(u.path)
                        }
                    }
                    return a
                }(t, e, this.data), r = 0, s = n.length; r < s; r++) Array.prototype.push.apply(i, n[r].toShapes());
                return i
            }
        }), Object.assign(function (t) {
            this.manager = void 0 !== t ? t : uw
        }.prototype, {
            load: function (t, e, i, n) {
                var r = this, s = new dw(this.manager);
                s.setPath(this.path), s.load(t, (function (t) {
                    var i;
                    try {
                        i = JSON.parse(t)
                    } catch (e) {
                        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), i = JSON.parse(t.substring(65, t.length - 2))
                    }
                    var n = r.parse(i);
                    e && e(n)
                }), i, n)
            }, parse: function (t) {
                return new m_(t)
            }, setPath: function (t) {
                return this.path = t, this
            }
        }), v_.Handlers = {
            handlers: [], add: function (t, e) {
                this.handlers.push(t, e)
            }, get: function (t) {
                for (var e = this.handlers, i = 0, n = e.length; i < n; i += 2) {
                    var r = e[i], s = e[i + 1];
                    if (r.test(t)) return s
                }
                return null
            }
        }, Object.assign(v_.prototype, {
            crossOrigin: "anonymous",
            onLoadStart: function () {
            },
            onLoadProgress: function () {
            },
            onLoadComplete: function () {
            },
            initMaterials: function (t, e, i) {
                for (var n = [], r = 0; r < t.length; ++r) n[r] = this.createMaterial(t[r], e, i);
                return n
            },
            createMaterial: (s_ = {
                NoBlending: 0,
                NormalBlending: 1,
                AdditiveBlending: 2,
                SubtractiveBlending: 3,
                MultiplyBlending: 4,
                CustomBlending: 5
            }, a_ = new rg, o_ = new vw, h_ = new Kw, function (t, e, i) {
                var n = {};

                function r(t, r, s, a, o) {
                    var h, l = e + t, c = v_.Handlers.get(l);
                    null !== c ? h = c.load(l) : (o_.setCrossOrigin(i), h = o_.load(l)), void 0 !== r && (h.repeat.fromArray(r), 1 !== r[0] && (h.wrapS = Zf), 1 !== r[1] && (h.wrapT = Zf)), void 0 !== s && h.offset.fromArray(s), void 0 !== a && ("repeat" === a[0] && (h.wrapS = Zf), "mirror" === a[0] && (h.wrapS = Qf), "repeat" === a[1] && (h.wrapT = Zf), "mirror" === a[1] && (h.wrapT = Qf)), void 0 !== o && (h.anisotropy = o);
                    var u = bm.generateUUID();
                    return n[u] = h, u
                }

                var s = {uuid: bm.generateUUID(), type: "MeshLambertMaterial"};
                for (var a in t) {
                    var o = t[a];
                    switch (a) {
                        case"DbgColor":
                        case"DbgIndex":
                        case"opticalDensity":
                        case"illumination":
                        case"mapDiffuseRepeat":
                        case"mapDiffuseOffset":
                        case"mapDiffuseWrap":
                        case"mapDiffuseAnisotropy":
                        case"mapEmissiveRepeat":
                        case"mapEmissiveOffset":
                        case"mapEmissiveWrap":
                        case"mapEmissiveAnisotropy":
                        case"mapLightRepeat":
                        case"mapLightOffset":
                        case"mapLightWrap":
                        case"mapLightAnisotropy":
                        case"mapAORepeat":
                        case"mapAOOffset":
                        case"mapAOWrap":
                        case"mapAOAnisotropy":
                        case"mapBumpRepeat":
                        case"mapBumpOffset":
                        case"mapBumpWrap":
                        case"mapBumpAnisotropy":
                        case"mapNormalRepeat":
                        case"mapNormalOffset":
                        case"mapNormalWrap":
                        case"mapNormalAnisotropy":
                        case"mapSpecularRepeat":
                        case"mapSpecularOffset":
                        case"mapSpecularWrap":
                        case"mapSpecularAnisotropy":
                        case"mapMetalnessRepeat":
                        case"mapMetalnessOffset":
                        case"mapMetalnessWrap":
                        case"mapMetalnessAnisotropy":
                        case"mapRoughnessRepeat":
                        case"mapRoughnessOffset":
                        case"mapRoughnessWrap":
                        case"mapRoughnessAnisotropy":
                        case"mapAlphaRepeat":
                        case"mapAlphaOffset":
                        case"mapAlphaWrap":
                        case"mapAlphaAnisotropy":
                            break;
                        case"DbgName":
                            s.name = o;
                            break;
                        case"blending":
                            s.blending = s_[o];
                            break;
                        case"colorAmbient":
                        case"mapAmbient":
                            console.warn("THREE.Loader.createMaterial:", a, "is no longer supported.");
                            break;
                        case"colorDiffuse":
                            s.color = a_.fromArray(o).getHex();
                            break;
                        case"colorSpecular":
                            s.specular = a_.fromArray(o).getHex();
                            break;
                        case"colorEmissive":
                            s.emissive = a_.fromArray(o).getHex();
                            break;
                        case"specularCoef":
                            s.shininess = o;
                            break;
                        case"shading":
                            "basic" === o.toLowerCase() && (s.type = "MeshBasicMaterial"), "phong" === o.toLowerCase() && (s.type = "MeshPhongMaterial"), "standard" === o.toLowerCase() && (s.type = "MeshStandardMaterial");
                            break;
                        case"mapDiffuse":
                            s.map = r(o, t.mapDiffuseRepeat, t.mapDiffuseOffset, t.mapDiffuseWrap, t.mapDiffuseAnisotropy);
                            break;
                        case"mapEmissive":
                            s.emissiveMap = r(o, t.mapEmissiveRepeat, t.mapEmissiveOffset, t.mapEmissiveWrap, t.mapEmissiveAnisotropy);
                            break;
                        case"mapLight":
                            s.lightMap = r(o, t.mapLightRepeat, t.mapLightOffset, t.mapLightWrap, t.mapLightAnisotropy);
                            break;
                        case"mapAO":
                            s.aoMap = r(o, t.mapAORepeat, t.mapAOOffset, t.mapAOWrap, t.mapAOAnisotropy);
                            break;
                        case"mapBump":
                            s.bumpMap = r(o, t.mapBumpRepeat, t.mapBumpOffset, t.mapBumpWrap, t.mapBumpAnisotropy);
                            break;
                        case"mapBumpScale":
                            s.bumpScale = o;
                            break;
                        case"mapNormal":
                            s.normalMap = r(o, t.mapNormalRepeat, t.mapNormalOffset, t.mapNormalWrap, t.mapNormalAnisotropy);
                            break;
                        case"mapNormalFactor":
                            s.normalScale = o;
                            break;
                        case"mapSpecular":
                            s.specularMap = r(o, t.mapSpecularRepeat, t.mapSpecularOffset, t.mapSpecularWrap, t.mapSpecularAnisotropy);
                            break;
                        case"mapMetalness":
                            s.metalnessMap = r(o, t.mapMetalnessRepeat, t.mapMetalnessOffset, t.mapMetalnessWrap, t.mapMetalnessAnisotropy);
                            break;
                        case"mapRoughness":
                            s.roughnessMap = r(o, t.mapRoughnessRepeat, t.mapRoughnessOffset, t.mapRoughnessWrap, t.mapRoughnessAnisotropy);
                            break;
                        case"mapAlpha":
                            s.alphaMap = r(o, t.mapAlphaRepeat, t.mapAlphaOffset, t.mapAlphaWrap, t.mapAlphaAnisotropy);
                            break;
                        case"flipSided":
                            s.side = 1;
                            break;
                        case"doubleSided":
                            s.side = 2;
                            break;
                        case"transparency":
                            console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), s.opacity = o;
                            break;
                        case"depthTest":
                        case"depthWrite":
                        case"colorWrite":
                        case"opacity":
                        case"reflectivity":
                        case"transparent":
                        case"visible":
                        case"wireframe":
                            s[a] = o;
                            break;
                        case"vertexColors":
                            !0 === o && (s.vertexColors = 2), "face" === o && (s.vertexColors = 1);
                            break;
                        default:
                            console.error("THREE.Loader.createMaterial: Unsupported", a, o)
                    }
                }
                return "MeshBasicMaterial" === s.type && delete s.emissive, "MeshPhongMaterial" !== s.type && delete s.specular, s.opacity < 1 && (s.transparent = !0), h_.setTextures(n), h_.parse(s)
            })
        });
        var y_ = function () {
            return void 0 === l_ && (l_ = new (window.AudioContext || window.webkitAudioContext)), l_
        };

        function b_(t) {
            this.manager = void 0 !== t ? t : uw
        }

        function x_() {
            this.coefficients = [];
            for (var t = 0; t < 9; t++) this.coefficients.push(new _m)
        }

        function w_(t, e) {
            Vw.call(this, void 0, e), this.sh = void 0 !== t ? t : new x_
        }

        function __(t, e, i) {
            w_.call(this, void 0, i);
            var n = (new rg).set(t), r = (new rg).set(e), s = new _m(n.r, n.g, n.b), a = new _m(r.r, r.g, r.b),
                o = Math.sqrt(Math.PI), h = o * Math.sqrt(.75);
            this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o), this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(h)
        }

        function E_(t, e) {
            w_.call(this, void 0, e);
            var i = (new rg).set(t);
            this.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI))
        }

        function M_() {
            this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Uy, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Uy, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
        }

        Object.assign(b_.prototype, {
            load: function (t, e, i, n) {
                var r = new dw(this.manager);
                r.setResponseType("arraybuffer"), r.setPath(this.path), r.load(t, (function (t) {
                    var i = t.slice(0);
                    y_().decodeAudioData(i, (function (t) {
                        e(t)
                    }))
                }), i, n)
            }, setPath: function (t) {
                return this.path = t, this
            }
        }), Object.assign(x_.prototype, {
            isSphericalHarmonics3: !0, set: function (t) {
                for (var e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
                return this
            }, zero: function () {
                for (var t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
                return this
            }, getAt: function (t, e) {
                var i = t.x, n = t.y, r = t.z, s = this.coefficients;
                return e = .282095 * s[0], e += .488603 * s[1] * n, e += .488603 * s[2] * r, e += .488603 * s[3] * i, e += 1.092548 * s[4] * (i * n), e += 1.092548 * s[5] * (n * r), e += .315392 * s[6] * (3 * r * r - 1), e += 1.092548 * s[7] * (i * r), e += .546274 * s[8] * (i * i - n * n)
            }, getIrradianceAt: function (t, e) {
                var i = t.x, n = t.y, r = t.z, s = this.coefficients;
                return e = .886227 * s[0], e += 2 * s[1] * .511664 * n, e += 2 * s[2] * .511664 * r, e += 2 * s[3] * .511664 * i, e += 2 * s[4] * .429043 * i * n, e += 2 * s[5] * .429043 * n * r, e += s[6] * (.743125 * r * r - .247708), e += 2 * s[7] * .429043 * i * r, e += .429043 * s[8] * (i * i - n * n)
            }, add: function (t) {
                for (var e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
                return this
            }, scale: function (t) {
                for (var e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
                return this
            }, lerp: function (t, e) {
                for (var i = 0; i < 9; i++) this.coefficients[i].lerp(t.coefficients[i], e);
                return this
            }, equals: function (t) {
                for (var e = 0; e < 9; e++) if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
                return !0
            }, copy: function (t) {
                return this.set(t.coefficients)
            }, clone: function () {
                return (new this.constructor).copy(this)
            }, fromArray: function (t) {
                for (var e = this.coefficients, i = 0; i < 9; i++) e[i].fromArray(t, 3 * i);
                return this
            }, toArray: function () {
                for (var t = [], e = this.coefficients, i = 0; i < 9; i++) e[i].toArray(t, 3 * i);
                return t
            }
        }), Object.assign(x_, {
            getBasisAt: function (t, e) {
                var i = t.x, n = t.y, r = t.z;
                e[0] = .282095, e[1] = .488603 * n, e[2] = .488603 * r, e[3] = .488603 * i, e[4] = 1.092548 * i * n, e[5] = 1.092548 * n * r, e[6] = .315392 * (3 * r * r - 1), e[7] = 1.092548 * i * r, e[8] = .546274 * (i * i - n * n)
            }
        }), w_.prototype = Object.assign(Object.create(Vw.prototype), {
            constructor: w_,
            isLightProbe: !0,
            copy: function (t) {
                return Vw.prototype.copy.call(this, t), this.sh.copy(t.sh), this.intensity = t.intensity, this
            },
            toJSON: function (t) {
                return Vw.prototype.toJSON.call(this, t)
            }
        }), __.prototype = Object.assign(Object.create(w_.prototype), {
            constructor: __,
            isHemisphereLightProbe: !0,
            copy: function (t) {
                return w_.prototype.copy.call(this, t), this
            },
            toJSON: function (t) {
                return w_.prototype.toJSON.call(this, t)
            }
        }), E_.prototype = Object.assign(Object.create(w_.prototype), {
            constructor: E_,
            isAmbientLightProbe: !0,
            copy: function (t) {
                return w_.prototype.copy.call(this, t), this
            },
            toJSON: function (t) {
                return w_.prototype.toJSON.call(this, t)
            }
        }), Object.assign(M_.prototype, {
            update: function () {
                var t, e, i, n, r, s, a, o, h = new Jm, l = new Jm;
                return function (c) {
                    if (t !== this || e !== c.focus || i !== c.fov || n !== c.aspect * this.aspect || r !== c.near || s !== c.far || a !== c.zoom || o !== this.eyeSep) {
                        t = this, e = c.focus, i = c.fov, n = c.aspect * this.aspect, r = c.near, s = c.far, a = c.zoom;
                        var u, p, d = c.projectionMatrix.clone(), f = (o = this.eyeSep / 2) * r / e,
                            m = r * Math.tan(bm.DEG2RAD * i * .5) / a;
                        l.elements[12] = -o, h.elements[12] = o, u = -m * n + f, p = m * n + f, d.elements[0] = 2 * r / (p - u), d.elements[8] = (p + u) / (p - u), this.cameraL.projectionMatrix.copy(d), u = -m * n - f, p = m * n - f, d.elements[0] = 2 * r / (p - u), d.elements[8] = (p + u) / (p - u), this.cameraR.projectionMatrix.copy(d)
                    }
                    this.cameraL.matrixWorld.copy(c.matrixWorld).multiply(l), this.cameraR.matrixWorld.copy(c.matrixWorld).multiply(h)
                }
            }()
        });
        var A_ = 90;

        function S_(t, e, i, n) {
            vg.call(this), this.type = "CubeCamera";
            var r = new Uy(A_, 1, t, e);
            r.up.set(0, -1, 0), r.lookAt(new _m(1, 0, 0)), this.add(r);
            var s = new Uy(A_, 1, t, e);
            s.up.set(0, -1, 0), s.lookAt(new _m(-1, 0, 0)), this.add(s);
            var a = new Uy(A_, 1, t, e);
            a.up.set(0, 0, 1), a.lookAt(new _m(0, 1, 0)), this.add(a);
            var o = new Uy(A_, 1, t, e);
            o.up.set(0, 0, -1), o.lookAt(new _m(0, -1, 0)), this.add(o);
            var h = new Uy(A_, 1, t, e);
            h.up.set(0, -1, 0), h.lookAt(new _m(0, 0, 1)), this.add(h);
            var l = new Uy(A_, 1, t, e);
            l.up.set(0, -1, 0), l.lookAt(new _m(0, 0, -1)), this.add(l), n = n || {
                format: hm,
                magFilter: em,
                minFilter: em
            }, this.renderTarget = new Hm(i, i, n), this.renderTarget.texture.name = "CubeCamera", this.update = function (t, e) {
                null === this.parent && this.updateMatrixWorld();
                var i = t.getRenderTarget(), n = this.renderTarget, c = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, r), t.setRenderTarget(n, 1), t.render(e, s), t.setRenderTarget(n, 2), t.render(e, a), t.setRenderTarget(n, 3), t.render(e, o), t.setRenderTarget(n, 4), t.render(e, h), n.texture.generateMipmaps = c, t.setRenderTarget(n, 5), t.render(e, l), t.setRenderTarget(i)
            }, this.clear = function (t, e, i, n) {
                for (var r = t.getRenderTarget(), s = this.renderTarget, a = 0; a < 6; a++) t.setRenderTarget(s, a), t.clear(e, i, n);
                t.setRenderTarget(r)
            }
        }

        function T_(t) {
            this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
        }

        function D_() {
            vg.call(this), this.type = "AudioListener", this.context = y_(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0
        }

        function C_(t) {
            vg.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.startTime = 0, this.offset = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
        }

        function P_(t) {
            C_.call(this, t), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
        }

        function I_(t, e) {
            this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
        }

        function L_(t, e, i) {
            this.binding = t, this.valueSize = i;
            var n, r = Float64Array;
            switch (e) {
                case"quaternion":
                    n = this._slerp;
                    break;
                case"string":
                case"bool":
                    r = Array, n = this._select;
                    break;
                default:
                    n = this._lerp
            }
            this.buffer = new r(4 * i), this._mixBufferRegion = n, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
        }

        S_.prototype = Object.create(vg.prototype), S_.prototype.constructor = S_, Object.assign(T_.prototype, {
            start: function () {
                this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
            }, stop: function () {
                this.getElapsedTime(), this.running = !1, this.autoStart = !1
            }, getElapsedTime: function () {
                return this.getDelta(), this.elapsedTime
            }, getDelta: function () {
                var t = 0;
                if (this.autoStart && !this.running) return this.start(), 0;
                if (this.running) {
                    var e = ("undefined" == typeof performance ? Date : performance).now();
                    t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                }
                return t
            }
        }), D_.prototype = Object.assign(Object.create(vg.prototype), {
            constructor: D_, getInput: function () {
                return this.gain
            }, removeFilter: function () {
                return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
            }, getFilter: function () {
                return this.filter
            }, setFilter: function (t) {
                return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
            }, getMasterVolume: function () {
                return this.gain.gain.value
            }, setMasterVolume: function (t) {
                return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
            }, updateMatrixWorld: function () {
                var t = new _m, e = new wm, i = new _m, n = new _m, r = new T_;
                return function (s) {
                    vg.prototype.updateMatrixWorld.call(this, s);
                    var a = this.context.listener, o = this.up;
                    if (this.timeDelta = r.getDelta(), this.matrixWorld.decompose(t, e, i), n.set(0, 0, -1).applyQuaternion(e), a.positionX) {
                        var h = this.context.currentTime + this.timeDelta;
                        a.positionX.linearRampToValueAtTime(t.x, h), a.positionY.linearRampToValueAtTime(t.y, h), a.positionZ.linearRampToValueAtTime(t.z, h), a.forwardX.linearRampToValueAtTime(n.x, h), a.forwardY.linearRampToValueAtTime(n.y, h), a.forwardZ.linearRampToValueAtTime(n.z, h), a.upX.linearRampToValueAtTime(o.x, h), a.upY.linearRampToValueAtTime(o.y, h), a.upZ.linearRampToValueAtTime(o.z, h)
                    } else a.setPosition(t.x, t.y, t.z), a.setOrientation(n.x, n.y, n.z, o.x, o.y, o.z)
                }
            }()
        }), C_.prototype = Object.assign(Object.create(vg.prototype), {
            constructor: C_, getOutput: function () {
                return this.gain
            }, setNodeSource: function (t) {
                return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
            }, setMediaElementSource: function (t) {
                return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
            }, setBuffer: function (t) {
                return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
            }, play: function () {
                if (!0 !== this.isPlaying) {
                    if (!1 !== this.hasPlaybackControl) {
                        var t = this.context.createBufferSource();
                        return t.buffer = this.buffer, t.loop = this.loop, t.onended = this.onEnded.bind(this), this.startTime = this.context.currentTime, t.start(this.startTime, this.offset), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                    }
                    console.warn("THREE.Audio: this Audio has no playback control.")
                } else console.warn("THREE.Audio: Audio is already playing.")
            }, pause: function () {
                if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }, stop: function () {
                if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }, connect: function () {
                if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else this.source.connect(this.getOutput());
                return this
            }, disconnect: function () {
                if (this.filters.length > 0) {
                    this.source.disconnect(this.filters[0]);
                    for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else this.source.disconnect(this.getOutput());
                return this
            }, getFilters: function () {
                return this.filters
            }, setFilters: function (t) {
                return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this
            }, setDetune: function (t) {
                if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
            }, getDetune: function () {
                return this.detune
            }, getFilter: function () {
                return this.getFilters()[0]
            }, setFilter: function (t) {
                return this.setFilters(t ? [t] : [])
            }, setPlaybackRate: function (t) {
                if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }, getPlaybackRate: function () {
                return this.playbackRate
            }, onEnded: function () {
                this.isPlaying = !1
            }, getLoop: function () {
                return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
            }, setLoop: function (t) {
                if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }, getVolume: function () {
                return this.gain.gain.value
            }, setVolume: function (t) {
                return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
            }
        }), P_.prototype = Object.assign(Object.create(C_.prototype), {
            constructor: P_, getOutput: function () {
                return this.panner
            }, getRefDistance: function () {
                return this.panner.refDistance
            }, setRefDistance: function (t) {
                return this.panner.refDistance = t, this
            }, getRolloffFactor: function () {
                return this.panner.rolloffFactor
            }, setRolloffFactor: function (t) {
                return this.panner.rolloffFactor = t, this
            }, getDistanceModel: function () {
                return this.panner.distanceModel
            }, setDistanceModel: function (t) {
                return this.panner.distanceModel = t, this
            }, getMaxDistance: function () {
                return this.panner.maxDistance
            }, setMaxDistance: function (t) {
                return this.panner.maxDistance = t, this
            }, setDirectionalCone: function (t, e, i) {
                return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = i, this
            }, updateMatrixWorld: function () {
                var t = new _m, e = new wm, i = new _m, n = new _m;
                return function (r) {
                    if (vg.prototype.updateMatrixWorld.call(this, r), !0 !== this.hasPlaybackControl || !1 !== this.isPlaying) {
                        this.matrixWorld.decompose(t, e, i), n.set(0, 0, 1).applyQuaternion(e);
                        var s = this.panner;
                        if (s.positionX) {
                            var a = this.context.currentTime + this.listener.timeDelta;
                            s.positionX.linearRampToValueAtTime(t.x, a), s.positionY.linearRampToValueAtTime(t.y, a), s.positionZ.linearRampToValueAtTime(t.z, a), s.orientationX.linearRampToValueAtTime(n.x, a), s.orientationY.linearRampToValueAtTime(n.y, a), s.orientationZ.linearRampToValueAtTime(n.z, a)
                        } else s.setPosition(t.x, t.y, t.z), s.setOrientation(n.x, n.y, n.z)
                    }
                }
            }()
        }), Object.assign(I_.prototype, {
            getFrequencyData: function () {
                return this.analyser.getByteFrequencyData(this.data), this.data
            }, getAverageFrequency: function () {
                for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++) t += e[i];
                return t / e.length
            }
        }), Object.assign(L_.prototype, {
            accumulate: function (t, e) {
                var i = this.buffer, n = this.valueSize, r = t * n + n, s = this.cumulativeWeight;
                if (0 === s) {
                    for (var a = 0; a !== n; ++a) i[r + a] = i[a];
                    s = e
                } else {
                    var o = e / (s += e);
                    this._mixBufferRegion(i, r, 0, o, n)
                }
                this.cumulativeWeight = s
            }, apply: function (t) {
                var e = this.valueSize, i = this.buffer, n = t * e + e, r = this.cumulativeWeight, s = this.binding;
                if (this.cumulativeWeight = 0, r < 1) {
                    var a = 3 * e;
                    this._mixBufferRegion(i, n, a, 1 - r, e)
                }
                for (var o = e, h = e + e; o !== h; ++o) if (i[o] !== i[o + e]) {
                    s.setValue(i, n);
                    break
                }
            }, saveOriginalState: function () {
                var t = this.binding, e = this.buffer, i = this.valueSize, n = 3 * i;
                t.getValue(e, n);
                for (var r = i, s = n; r !== s; ++r) e[r] = e[n + r % i];
                this.cumulativeWeight = 0
            }, restoreOriginalState: function () {
                var t = 3 * this.valueSize;
                this.binding.setValue(this.buffer, t)
            }, _select: function (t, e, i, n, r) {
                if (n >= .5) for (var s = 0; s !== r; ++s) t[e + s] = t[i + s]
            }, _slerp: function (t, e, i, n) {
                wm.slerpFlat(t, e, t, e, t, i, n)
            }, _lerp: function (t, e, i, n, r) {
                for (var s = 1 - n, a = 0; a !== r; ++a) {
                    var o = e + a;
                    t[o] = t[o] * s + t[i + a] * n
                }
            }
        });
        var R_, F_, k_, O_, z_, B_, N_, j_, V_, G_, U_, H_, W_, q_, X_, Y_ = "\\[\\]\\.:\\/";

        function Z_(t, e, i) {
            var n = i || J_.parseTrackName(e);
            this._targetGroup = t, this._bindings = t.subscribe_(e, n)
        }

        function J_(t, e, i) {
            this.path = e, this.parsedPath = i || J_.parseTrackName(e), this.node = J_.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
        }

        function Q_(t, e, i) {
            this._mixer = t, this._clip = e, this._localRoot = i || null;
            for (var n = e.tracks, r = n.length, s = new Array(r), a = {
                endingStart: mm,
                endingEnd: mm
            }, o = 0; o !== r; ++o) {
                var h = n[o].createInterpolant(null);
                s[o] = h, h.settings = a
            }
            this._interpolantSettings = a, this._interpolants = s, this._propertyBindings = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
        }

        function K_(t) {
            this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
        }

        function $_(t) {
            "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
        }

        function tE(t, e, i) {
            ab.call(this, t, e), this.meshPerAttribute = i || 1
        }

        function eE(t, e, i, n) {
            this.ray = new ev(t, e), this.near = i || 0, this.far = n || 1 / 0, this.params = {
                Mesh: {},
                Line: {},
                LOD: {},
                Points: {threshold: 1},
                Sprite: {}
            }, Object.defineProperties(this.params, {
                PointCloud: {
                    get: function () {
                        return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                    }
                }
            })
        }

        function iE(t, e) {
            return t.distance - e.distance
        }

        function nE(t, e, i, n) {
            if (!1 !== t.visible && (t.raycast(e, i), !0 === n)) for (var r = t.children, s = 0, a = r.length; s < a; s++) nE(r[s], e, i, !0)
        }

        function rE(t, e) {
            this.min = void 0 !== t ? t : new xm(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new xm(-1 / 0, -1 / 0)
        }

        function sE(t, e) {
            this.start = void 0 !== t ? t : new _m, this.end = void 0 !== e ? e : new _m
        }

        function aE(t) {
            vg.call(this), this.material = t, this.render = function () {
            }
        }

        function oE(t, e, i, n) {
            this.object = t, this.size = void 0 !== e ? e : 1;
            var r = void 0 !== i ? i : 16711680, s = void 0 !== n ? n : 1, a = 0, o = this.object.geometry;
            o && o.isGeometry ? a = 3 * o.faces.length : o && o.isBufferGeometry && (a = o.attributes.normal.count);
            var h = new kg, l = new Pg(2 * a * 3, 3);
            h.addAttribute("position", l), gb.call(this, h, new fb({
                color: r,
                linewidth: s
            })), this.matrixAutoUpdate = !1, this.update()
        }

        function hE(t, e) {
            vg.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
            for (var i = new kg, n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], r = 0, s = 1; r < 32; r++, s++) {
                var a = r / 32 * Math.PI * 2, o = s / 32 * Math.PI * 2;
                n.push(Math.cos(a), Math.sin(a), 1, Math.cos(o), Math.sin(o), 1)
            }
            i.addAttribute("position", new Pg(n, 3));
            var h = new fb({fog: !1});
            this.cone = new gb(i, h), this.add(this.cone), this.update()
        }

        function lE(t) {
            var e = [];
            t && t.isBone && e.push(t);
            for (var i = 0; i < t.children.length; i++) e.push.apply(e, lE(t.children[i]));
            return e
        }

        function cE(t) {
            for (var e = lE(t), i = new kg, n = [], r = [], s = new rg(0, 0, 1), a = new rg(0, 1, 0), o = 0; o < e.length; o++) {
                var h = e[o];
                h.parent && h.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(a.r, a.g, a.b))
            }
            i.addAttribute("position", new Pg(n, 3)), i.addAttribute("color", new Pg(r, 3));
            var l = new fb({vertexColors: 2, depthTest: !1, depthWrite: !1, transparent: !0});
            gb.call(this, i, l), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
        }

        function uE(t, e, i) {
            this.light = t, this.light.updateMatrixWorld(), this.color = i;
            var n = new wx(e, 4, 2), r = new nv({wireframe: !0, fog: !1});
            rv.call(this, n, r), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
        }

        function pE(t, e) {
            this.type = "RectAreaLightHelper", this.light = t, this.color = e;
            var i = new kg;
            i.addAttribute("position", new Pg([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), i.computeBoundingSphere();
            var n = new fb({fog: !1});
            mb.call(this, i, n);
            var r = new kg;
            r.addAttribute("position", new Pg([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), r.computeBoundingSphere(), this.add(new rv(r, new nv({
                side: 1,
                fog: !1
            }))), this.update()
        }

        function dE(t, e, i) {
            vg.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i;
            var n = new Lb(e);
            n.rotateY(.5 * Math.PI), this.material = new nv({
                wireframe: !0,
                fog: !1
            }), void 0 === this.color && (this.material.vertexColors = 2);
            var r = n.getAttribute("position"), s = new Float32Array(3 * r.count);
            n.addAttribute("color", new _g(s, 3)), this.add(new rv(n, this.material)), this.update()
        }

        function fE(t, e) {
            this.lightProbe = t, this.size = e;
            var i = {GAMMA_OUTPUT: ""}, n = new tv({
                defines: i,
                uniforms: {sh: {value: this.lightProbe.sh.coefficients}, intensity: {value: this.lightProbe.intensity}},
                vertexShader: ["varying vec3 vNormal;", "void main() {", "\tvNormal = normalize( normalMatrix * normal );", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
                fragmentShader: ["#define RECIPROCAL_PI 0.318309886", "vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {", "\t// matrix is assumed to be orthogonal", "\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );", "}", "vec3 linearToOutput( in vec3 a ) {", "\t#ifdef GAMMA_OUTPUT", "\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );", "\t#else", "\t\treturn a;", "\t#endif", "}", "// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf", "vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {", "\t// normal is assumed to have unit length", "\tfloat x = normal.x, y = normal.y, z = normal.z;", "\t// band 0", "\tvec3 result = shCoefficients[ 0 ] * 0.886227;", "\t// band 1", "\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;", "\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;", "\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;", "\t// band 2", "\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;", "\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;", "\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );", "\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;", "\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );", "\treturn result;", "}", "uniform vec3 sh[ 9 ]; // sh coefficients", "uniform float intensity; // light probe intensity", "varying vec3 vNormal;", "void main() {", "\tvec3 normal = normalize( vNormal );", "\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );", "\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );", "\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;", "\toutgoingLight = linearToOutput( outgoingLight );", "\tgl_FragColor = vec4( outgoingLight, 1.0 );", "}"].join("\n")
            }), r = new wx(1, 32, 16);
            rv.call(this, r, n), this.onBeforeRender()
        }

        function mE(t, e, i, n) {
            t = t || 10, e = e || 10, i = new rg(void 0 !== i ? i : 4473924), n = new rg(void 0 !== n ? n : 8947848);
            for (var r = e / 2, s = t / e, a = t / 2, o = [], h = [], l = 0, c = 0, u = -a; l <= e; l++, u += s) {
                o.push(-a, 0, u, a, 0, u), o.push(u, 0, -a, u, 0, a);
                var p = l === r ? i : n;
                p.toArray(h, c), c += 3, p.toArray(h, c), c += 3, p.toArray(h, c), c += 3, p.toArray(h, c), c += 3
            }
            var d = new kg;
            d.addAttribute("position", new Pg(o, 3)), d.addAttribute("color", new Pg(h, 3));
            var f = new fb({vertexColors: 2});
            gb.call(this, d, f)
        }

        function gE(t, e, i, n, r, s) {
            t = t || 10, e = e || 16, i = i || 8, n = n || 64, r = new rg(void 0 !== r ? r : 4473924), s = new rg(void 0 !== s ? s : 8947848);
            var a, o, h, l, c, u, p, d = [], f = [];
            for (l = 0; l <= e; l++) h = l / e * (2 * Math.PI), a = Math.sin(h) * t, o = Math.cos(h) * t, d.push(0, 0, 0), d.push(a, 0, o), p = 1 & l ? r : s, f.push(p.r, p.g, p.b), f.push(p.r, p.g, p.b);
            for (l = 0; l <= i; l++) for (p = 1 & l ? r : s, u = t - t / i * l, c = 0; c < n; c++) h = c / n * (2 * Math.PI), a = Math.sin(h) * u, o = Math.cos(h) * u, d.push(a, 0, o), f.push(p.r, p.g, p.b), h = (c + 1) / n * (2 * Math.PI), a = Math.sin(h) * u, o = Math.cos(h) * u, d.push(a, 0, o), f.push(p.r, p.g, p.b);
            var m = new kg;
            m.addAttribute("position", new Pg(d, 3)), m.addAttribute("color", new Pg(f, 3));
            var g = new fb({vertexColors: 2});
            gb.call(this, m, g)
        }

        function vE(t, e, i, n) {
            this.audio = t, this.range = e || 1, this.divisionsInnerAngle = i || 16, this.divisionsOuterAngle = n || 2;
            var r = new kg, s = this.divisionsInnerAngle + 2 * this.divisionsOuterAngle,
                a = new Float32Array(3 * (3 * s + 3));
            r.addAttribute("position", new _g(a, 3));
            var o = new fb({color: 65280}), h = new fb({color: 16776960});
            mb.call(this, r, [h, o]), this.update()
        }

        function yE(t, e, i, n) {
            this.object = t, this.size = void 0 !== e ? e : 1;
            var r = void 0 !== i ? i : 16776960, s = void 0 !== n ? n : 1, a = 0, o = this.object.geometry;
            o && o.isGeometry ? a = o.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
            var h = new kg, l = new Pg(2 * a * 3, 3);
            h.addAttribute("position", l), gb.call(this, h, new fb({
                color: r,
                linewidth: s
            })), this.matrixAutoUpdate = !1, this.update()
        }

        function bE(t, e, i) {
            vg.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, void 0 === e && (e = 1);
            var n = new kg;
            n.addAttribute("position", new Pg([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
            var r = new fb({fog: !1});
            this.lightPlane = new mb(n, r), this.add(this.lightPlane), (n = new kg).addAttribute("position", new Pg([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new mb(n, r), this.add(this.targetLine), this.update()
        }

        function xE(t) {
            var e = new kg, i = new fb({color: 16777215, vertexColors: 1}), n = [], r = [], s = {},
                a = new rg(16755200), o = new rg(16711680), h = new rg(43775), l = new rg(16777215),
                c = new rg(3355443);

            function u(t, e, i) {
                p(t, i), p(e, i)
            }

            function p(t, e) {
                n.push(0, 0, 0), r.push(e.r, e.g, e.b), void 0 === s[t] && (s[t] = []), s[t].push(n.length / 3 - 1)
            }

            u("n1", "n2", a), u("n2", "n4", a), u("n4", "n3", a), u("n3", "n1", a), u("f1", "f2", a), u("f2", "f4", a), u("f4", "f3", a), u("f3", "f1", a), u("n1", "f1", a), u("n2", "f2", a), u("n3", "f3", a), u("n4", "f4", a), u("p", "n1", o), u("p", "n2", o), u("p", "n3", o), u("p", "n4", o), u("u1", "u2", h), u("u2", "u3", h), u("u3", "u1", h), u("c", "t", l), u("p", "c", c), u("cn1", "cn2", c), u("cn3", "cn4", c), u("cf1", "cf2", c), u("cf3", "cf4", c), e.addAttribute("position", new Pg(n, 3)), e.addAttribute("color", new Pg(r, 3)), gb.call(this, e, i), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update()
        }

        function wE(t, e) {
            this.object = t, void 0 === e && (e = 16776960);
            var i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                n = new Float32Array(24), r = new kg;
            r.setIndex(new _g(i, 1)), r.addAttribute("position", new _g(n, 3)), gb.call(this, r, new fb({color: e})), this.matrixAutoUpdate = !1, this.update()
        }

        function _E(t, e) {
            this.type = "Box3Helper", this.box = t;
            var i = void 0 !== e ? e : 16776960,
                n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                r = new kg;
            r.setIndex(new _g(n, 1)), r.addAttribute("position", new Pg([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), gb.call(this, r, new fb({color: i})), this.geometry.computeBoundingSphere()
        }

        function EE(t, e, i) {
            this.type = "PlaneHelper", this.plane = t, this.size = void 0 === e ? 1 : e;
            var n = void 0 !== i ? i : 16776960, r = new kg;
            r.addAttribute("position", new Pg([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), mb.call(this, r, new fb({color: n}));
            var s = new kg;
            s.addAttribute("position", new Pg([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), s.computeBoundingSphere(), this.add(new rv(s, new nv({
                color: n,
                opacity: .2,
                transparent: !0,
                depthWrite: !1
            })))
        }

        function ME(t, e, i, n, r, s) {
            vg.call(this), void 0 === t && (t = new _m(0, 0, 1)), void 0 === e && (e = new _m(0, 0, 0)), void 0 === i && (i = 1), void 0 === n && (n = 16776960), void 0 === r && (r = .2 * i), void 0 === s && (s = .2 * r), void 0 === H_ && ((H_ = new kg).addAttribute("position", new Pg([0, 0, 0, 0, 1, 0], 3)), (W_ = new Ix(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(e), this.line = new mb(H_, new fb({color: n})), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new rv(W_, new nv({color: n})), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(i, r, s)
        }

        function AE(t) {
            var e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t], i = new kg;
            i.addAttribute("position", new Pg(e, 3)), i.addAttribute("color", new Pg([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
            var n = new fb({vertexColors: 2});
            gb.call(this, i, n)
        }

        Object.assign(Z_.prototype, {
            getValue: function (t, e) {
                this.bind();
                var i = this._targetGroup.nCachedObjects_, n = this._bindings[i];
                void 0 !== n && n.getValue(t, e)
            }, setValue: function (t, e) {
                for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(t, e)
            }, bind: function () {
                for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].bind()
            }, unbind: function () {
                for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].unbind()
            }
        }), Object.assign(J_, {
            Composite: Z_,
            create: function (t, e, i) {
                return t && t.isAnimationObjectGroup ? new J_.Composite(t, e, i) : new J_(t, e, i)
            },
            sanitizeNodeName: (V_ = new RegExp("[\\[\\]\\.:\\/]", "g"), function (t) {
                return t.replace(/\s/g, "_").replace(V_, "")
            }),
            parseTrackName: (R_ = "[^\\[\\]\\.:\\/]", F_ = "[^" + Y_.replace("\\.", "") + "]", k_ = /((?:WC+[\/:])*)/.source.replace("WC", R_), O_ = /(WCOD+)?/.source.replace("WCOD", F_), z_ = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", R_), B_ = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", R_), N_ = new RegExp("^" + k_ + O_ + z_ + B_ + "$"), j_ = ["material", "materials", "bones"], function (t) {
                var e = N_.exec(t);
                if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                var i = {nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6]},
                    n = i.nodeName && i.nodeName.lastIndexOf(".");
                if (void 0 !== n && -1 !== n) {
                    var r = i.nodeName.substring(n + 1);
                    -1 !== j_.indexOf(r) && (i.nodeName = i.nodeName.substring(0, n), i.objectName = r)
                }
                if (null === i.propertyName || 0 === i.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                return i
            }),
            findNode: function (t, e) {
                if (!e || "" === e || "root" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                if (t.skeleton) {
                    var i = t.skeleton.getBoneByName(e);
                    if (void 0 !== i) return i
                }
                if (t.children) {
                    var n = function (t) {
                        for (var i = 0; i < t.length; i++) {
                            var r = t[i];
                            if (r.name === e || r.uuid === e) return r;
                            var s = n(r.children);
                            if (s) return s
                        }
                        return null
                    }, r = n(t.children);
                    if (r) return r
                }
                return null
            }
        }), Object.assign(J_.prototype, {
            _getValue_unavailable: function () {
            },
            _setValue_unavailable: function () {
            },
            BindingType: {Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3},
            Versioning: {None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2},
            GetterByBindingType: [function (t, e) {
                t[e] = this.node[this.propertyName]
            }, function (t, e) {
                for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) t[e++] = i[n]
            }, function (t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
            }, function (t, e) {
                this.resolvedProperty.toArray(t, e)
            }],
            SetterByBindingTypeAndVersioning: [[function (t, e) {
                this.targetObject[this.propertyName] = t[e]
            }, function (t, e) {
                this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
            }, function (t, e) {
                this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }], [function (t, e) {
                for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++]
            }, function (t, e) {
                for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                this.targetObject.needsUpdate = !0
            }, function (t, e) {
                for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }], [function (t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e]
            }, function (t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
            }, function (t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }], [function (t, e) {
                this.resolvedProperty.fromArray(t, e)
            }, function (t, e) {
                this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
            }, function (t, e) {
                this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
            }]],
            getValue: function (t, e) {
                this.bind(), this.getValue(t, e)
            },
            setValue: function (t, e) {
                this.bind(), this.setValue(t, e)
            },
            bind: function () {
                var t = this.node, e = this.parsedPath, i = e.objectName, n = e.propertyName, r = e.propertyIndex;
                if (t || (t = J_.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) {
                    if (i) {
                        var s = e.objectIndex;
                        switch (i) {
                            case"materials":
                                if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                t = t.material.materials;
                                break;
                            case"bones":
                                if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                t = t.skeleton.bones;
                                for (var a = 0; a < t.length; a++) if (t[a].name === s) {
                                    s = a;
                                    break
                                }
                                break;
                            default:
                                if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                t = t[i]
                        }
                        if (void 0 !== s) {
                            if (void 0 === t[s]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                            t = t[s]
                        }
                    }
                    var o = t[n];
                    if (void 0 !== o) {
                        var h = this.Versioning.None;
                        this.targetObject = t, void 0 !== t.needsUpdate ? h = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (h = this.Versioning.MatrixWorldNeedsUpdate);
                        var l = this.BindingType.Direct;
                        if (void 0 !== r) {
                            if ("morphTargetInfluences" === n) {
                                if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                if (t.geometry.isBufferGeometry) {
                                    if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                    for (a = 0; a < this.node.geometry.morphAttributes.position.length; a++) if (t.geometry.morphAttributes.position[a].name === r) {
                                        r = a;
                                        break
                                    }
                                } else {
                                    if (!t.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                    for (a = 0; a < this.node.geometry.morphTargets.length; a++) if (t.geometry.morphTargets[a].name === r) {
                                        r = a;
                                        break
                                    }
                                }
                            }
                            l = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r
                        } else void 0 !== o.fromArray && void 0 !== o.toArray ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = n;
                        this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][h]
                    } else {
                        var c = e.nodeName;
                        console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + n + " but it wasn't found.", t)
                    }
                } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
            },
            unbind: function () {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }), Object.assign(J_.prototype, {
            _getValue_unbound: J_.prototype.getValue,
            _setValue_unbound: J_.prototype.setValue
        }), Object.assign(function () {
            this.uuid = bm.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
            var t = {};
            this._indicesByUUID = t;
            for (var e = 0, i = arguments.length; e !== i; ++e) t[arguments[e].uuid] = e;
            this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
            var n = this;
            this.stats = {
                objects: {
                    get total() {
                        return n._objects.length
                    }, get inUse() {
                        return this.total - n.nCachedObjects_
                    }
                }, get bindingsPerObject() {
                    return n._bindings.length
                }
            }
        }.prototype, {
            isAnimationObjectGroup: !0, add: function () {
                for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._paths, s = this._parsedPaths, a = this._bindings, o = a.length, h = void 0, l = 0, c = arguments.length; l !== c; ++l) {
                    var u = arguments[l], p = u.uuid, d = n[p];
                    if (void 0 === d) {
                        d = e++, n[p] = d, t.push(u);
                        for (var f = 0, m = o; f !== m; ++f) a[f].push(new J_(u, r[f], s[f]))
                    } else if (d < i) {
                        h = t[d];
                        var g = --i, v = t[g];
                        n[v.uuid] = d, t[d] = v, n[p] = g, t[g] = u;
                        for (f = 0, m = o; f !== m; ++f) {
                            var y = a[f], b = y[g], x = y[d];
                            y[d] = b, void 0 === x && (x = new J_(u, r[f], s[f])), y[g] = x
                        }
                    } else t[d] !== h && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                }
                this.nCachedObjects_ = i
            }, remove: function () {
                for (var t = this._objects, e = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, r = n.length, s = 0, a = arguments.length; s !== a; ++s) {
                    var o = arguments[s], h = o.uuid, l = i[h];
                    if (void 0 !== l && l >= e) {
                        var c = e++, u = t[c];
                        i[u.uuid] = l, t[l] = u, i[h] = c, t[c] = o;
                        for (var p = 0, d = r; p !== d; ++p) {
                            var f = n[p], m = f[c], g = f[l];
                            f[l] = m, f[c] = g
                        }
                    }
                }
                this.nCachedObjects_ = e
            }, uncache: function () {
                for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, s = r.length, a = 0, o = arguments.length; a !== o; ++a) {
                    var h = arguments[a], l = h.uuid, c = n[l];
                    if (void 0 !== c) if (delete n[l], c < i) {
                        var u = --i, p = t[u], d = t[y = --e];
                        n[p.uuid] = c, t[c] = p, n[d.uuid] = u, t[u] = d, t.pop();
                        for (var f = 0, m = s; f !== m; ++f) {
                            var g = (b = r[f])[u], v = b[y];
                            b[c] = g, b[u] = v, b.pop()
                        }
                    } else {
                        var y;
                        n[(d = t[y = --e]).uuid] = c, t[c] = d, t.pop();
                        for (f = 0, m = s; f !== m; ++f) {
                            var b;
                            (b = r[f])[c] = b[y], b.pop()
                        }
                    }
                }
                this.nCachedObjects_ = i
            }, subscribe_: function (t, e) {
                var i = this._bindingsIndicesByPath, n = i[t], r = this._bindings;
                if (void 0 !== n) return r[n];
                var s = this._paths, a = this._parsedPaths, o = this._objects, h = o.length, l = this.nCachedObjects_,
                    c = new Array(h);
                n = r.length, i[t] = n, s.push(t), a.push(e), r.push(c);
                for (var u = l, p = o.length; u !== p; ++u) {
                    var d = o[u];
                    c[u] = new J_(d, t, e)
                }
                return c
            }, unsubscribe_: function (t) {
                var e = this._bindingsIndicesByPath, i = e[t];
                if (void 0 !== i) {
                    var n = this._paths, r = this._parsedPaths, s = this._bindings, a = s.length - 1, o = s[a];
                    e[t[a]] = i, s[i] = o, s.pop(), r[i] = r[a], r.pop(), n[i] = n[a], n.pop()
                }
            }
        }), Object.assign(Q_.prototype, {
            play: function () {
                return this._mixer._activateAction(this), this
            }, stop: function () {
                return this._mixer._deactivateAction(this), this.reset()
            }, reset: function () {
                return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
            }, isRunning: function () {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            }, isScheduled: function () {
                return this._mixer._isActiveAction(this)
            }, startAt: function (t) {
                return this._startTime = t, this
            }, setLoop: function (t, e) {
                return this.loop = t, this.repetitions = e, this
            }, setEffectiveWeight: function (t) {
                return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
            }, getEffectiveWeight: function () {
                return this._effectiveWeight
            }, fadeIn: function (t) {
                return this._scheduleFading(t, 0, 1)
            }, fadeOut: function (t) {
                return this._scheduleFading(t, 1, 0)
            }, crossFadeFrom: function (t, e, i) {
                if (t.fadeOut(e), this.fadeIn(e), i) {
                    var n = this._clip.duration, r = t._clip.duration, s = r / n, a = n / r;
                    t.warp(1, s, e), this.warp(a, 1, e)
                }
                return this
            }, crossFadeTo: function (t, e, i) {
                return t.crossFadeFrom(this, e, i)
            }, stopFading: function () {
                var t = this._weightInterpolant;
                return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            }, setEffectiveTimeScale: function (t) {
                return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
            }, getEffectiveTimeScale: function () {
                return this._effectiveTimeScale
            }, setDuration: function (t) {
                return this.timeScale = this._clip.duration / t, this.stopWarping()
            }, syncWith: function (t) {
                return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
            }, halt: function (t) {
                return this.warp(this._effectiveTimeScale, 0, t)
            }, warp: function (t, e, i) {
                var n = this._mixer, r = n.time, s = this._timeScaleInterpolant, a = this.timeScale;
                null === s && (s = n._lendControlInterpolant(), this._timeScaleInterpolant = s);
                var o = s.parameterPositions, h = s.sampleValues;
                return o[0] = r, o[1] = r + i, h[0] = t / a, h[1] = e / a, this
            }, stopWarping: function () {
                var t = this._timeScaleInterpolant;
                return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            }, getMixer: function () {
                return this._mixer
            }, getClip: function () {
                return this._clip
            }, getRoot: function () {
                return this._localRoot || this._mixer._root
            }, _update: function (t, e, i, n) {
                if (this.enabled) {
                    var r = this._startTime;
                    if (null !== r) {
                        var s = (t - r) * i;
                        if (s < 0 || 0 === i) return;
                        this._startTime = null, e = i * s
                    }
                    e *= this._updateTimeScale(t);
                    var a = this._updateTime(e), o = this._updateWeight(t);
                    if (o > 0) for (var h = this._interpolants, l = this._propertyBindings, c = 0, u = h.length; c !== u; ++c) h[c].evaluate(a), l[c].accumulate(n, o)
                } else this._updateWeight(t)
            }, _updateWeight: function (t) {
                var e = 0;
                if (this.enabled) {
                    e = this.weight;
                    var i = this._weightInterpolant;
                    if (null !== i) {
                        var n = i.evaluate(t)[0];
                        e *= n, t > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = e, e
            }, _updateTimeScale: function (t) {
                var e = 0;
                if (!this.paused) {
                    e = this.timeScale;
                    var i = this._timeScaleInterpolant;
                    if (null !== i) e *= i.evaluate(t)[0], t > i.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
                }
                return this._effectiveTimeScale = e, e
            }, _updateTime: function (t) {
                var e = this.time + t, i = this._clip.duration, n = this.loop, r = this._loopCount, s = 2202 === n;
                if (0 === t) return -1 === r ? e : s && 1 == (1 & r) ? i - e : e;
                if (2200 === n) {
                    -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                    t:{
                        if (e >= i) e = i; else {
                            if (!(e < 0)) {
                                this.time = e;
                                break t
                            }
                            e = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = e, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t < 0 ? -1 : 1
                        })
                    }
                } else {
                    if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), e >= i || e < 0) {
                        var a = Math.floor(e / i);
                        e -= i * a, r += Math.abs(a);
                        var o = this.repetitions - r;
                        if (o <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, e = t > 0 ? i : 0, this.time = e, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t > 0 ? 1 : -1
                        }); else {
                            if (1 === o) {
                                var h = t < 0;
                                this._setEndings(h, !h, s)
                            } else this._setEndings(!1, !1, s);
                            this._loopCount = r, this.time = e, this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: a
                            })
                        }
                    } else this.time = e;
                    if (s && 1 == (1 & r)) return i - e
                }
                return e
            }, _setEndings: function (t, e, i) {
                var n = this._interpolantSettings;
                i ? (n.endingStart = gm, n.endingEnd = gm) : (n.endingStart = t ? this.zeroSlopeAtStart ? gm : mm : vm, n.endingEnd = e ? this.zeroSlopeAtEnd ? gm : mm : vm)
            }, _scheduleFading: function (t, e, i) {
                var n = this._mixer, r = n.time, s = this._weightInterpolant;
                null === s && (s = n._lendControlInterpolant(), this._weightInterpolant = s);
                var a = s.parameterPositions, o = s.sampleValues;
                return a[0] = r, o[0] = e, a[1] = r + t, o[1] = i, this
            }
        }), K_.prototype = Object.assign(Object.create(Vf.prototype), {
            constructor: K_, _bindAction: function (t, e) {
                var i = t._localRoot || this._root, n = t._clip.tracks, r = n.length, s = t._propertyBindings,
                    a = t._interpolants, o = i.uuid, h = this._bindingsByRootAndName, l = h[o];
                void 0 === l && (l = {}, h[o] = l);
                for (var c = 0; c !== r; ++c) {
                    var u = n[c], p = u.name, d = l[p];
                    if (void 0 !== d) s[c] = d; else {
                        if (void 0 !== (d = s[c])) {
                            null === d._cacheIndex && (++d.referenceCount, this._addInactiveBinding(d, o, p));
                            continue
                        }
                        var f = e && e._propertyBindings[c].binding.parsedPath;
                        ++(d = new L_(J_.create(i, p, f), u.ValueTypeName, u.getValueSize())).referenceCount, this._addInactiveBinding(d, o, p), s[c] = d
                    }
                    a[c].resultBuffer = d.buffer
                }
            }, _activateAction: function (t) {
                if (!this._isActiveAction(t)) {
                    if (null === t._cacheIndex) {
                        var e = (t._localRoot || this._root).uuid, i = t._clip.uuid, n = this._actionsByClip[i];
                        this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e)
                    }
                    for (var r = t._propertyBindings, s = 0, a = r.length; s !== a; ++s) {
                        var o = r[s];
                        0 == o.useCount++ && (this._lendBinding(o), o.saveOriginalState())
                    }
                    this._lendAction(t)
                }
            }, _deactivateAction: function (t) {
                if (this._isActiveAction(t)) {
                    for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
                        var r = e[i];
                        0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                    }
                    this._takeBackAction(t)
                }
            }, _initMemoryManager: function () {
                this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                var t = this;
                this.stats = {
                    actions: {
                        get total() {
                            return t._actions.length
                        }, get inUse() {
                            return t._nActiveActions
                        }
                    }, bindings: {
                        get total() {
                            return t._bindings.length
                        }, get inUse() {
                            return t._nActiveBindings
                        }
                    }, controlInterpolants: {
                        get total() {
                            return t._controlInterpolants.length
                        }, get inUse() {
                            return t._nActiveControlInterpolants
                        }
                    }
                }
            }, _isActiveAction: function (t) {
                var e = t._cacheIndex;
                return null !== e && e < this._nActiveActions
            }, _addInactiveAction: function (t, e, i) {
                var n = this._actions, r = this._actionsByClip, s = r[e];
                if (void 0 === s) s = {knownActions: [t], actionByRoot: {}}, t._byClipCacheIndex = 0, r[e] = s; else {
                    var a = s.knownActions;
                    t._byClipCacheIndex = a.length, a.push(t)
                }
                t._cacheIndex = n.length, n.push(t), s.actionByRoot[i] = t
            }, _removeInactiveAction: function (t) {
                var e = this._actions, i = e[e.length - 1], n = t._cacheIndex;
                i._cacheIndex = n, e[n] = i, e.pop(), t._cacheIndex = null;
                var r = t._clip.uuid, s = this._actionsByClip, a = s[r], o = a.knownActions, h = o[o.length - 1],
                    l = t._byClipCacheIndex;
                h._byClipCacheIndex = l, o[l] = h, o.pop(), t._byClipCacheIndex = null, delete a.actionByRoot[(t._localRoot || this._root).uuid], 0 === o.length && delete s[r], this._removeInactiveBindingsForAction(t)
            }, _removeInactiveBindingsForAction: function (t) {
                for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
                    var r = e[i];
                    0 == --r.referenceCount && this._removeInactiveBinding(r)
                }
            }, _lendAction: function (t) {
                var e = this._actions, i = t._cacheIndex, n = this._nActiveActions++, r = e[n];
                t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
            }, _takeBackAction: function (t) {
                var e = this._actions, i = t._cacheIndex, n = --this._nActiveActions, r = e[n];
                t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
            }, _addInactiveBinding: function (t, e, i) {
                var n = this._bindingsByRootAndName, r = n[e], s = this._bindings;
                void 0 === r && (r = {}, n[e] = r), r[i] = t, t._cacheIndex = s.length, s.push(t)
            }, _removeInactiveBinding: function (t) {
                var e = this._bindings, i = t.binding, n = i.rootNode.uuid, r = i.path, s = this._bindingsByRootAndName,
                    a = s[n], o = e[e.length - 1], h = t._cacheIndex;
                o._cacheIndex = h, e[h] = o, e.pop(), delete a[r];
                t:{
                    for (var l in a) break t;
                    delete s[n]
                }
            }, _lendBinding: function (t) {
                var e = this._bindings, i = t._cacheIndex, n = this._nActiveBindings++, r = e[n];
                t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
            }, _takeBackBinding: function (t) {
                var e = this._bindings, i = t._cacheIndex, n = --this._nActiveBindings, r = e[n];
                t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
            }, _lendControlInterpolant: function () {
                var t = this._controlInterpolants, e = this._nActiveControlInterpolants++, i = t[e];
                return void 0 === i && ((i = new Qx(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e, t[e] = i), i
            }, _takeBackControlInterpolant: function (t) {
                var e = this._controlInterpolants, i = t.__cacheIndex, n = --this._nActiveControlInterpolants, r = e[n];
                t.__cacheIndex = n, e[n] = t, r.__cacheIndex = i, e[i] = r
            }, _controlInterpolantsResultBuffer: new Float32Array(1), clipAction: function (t, e) {
                var i = e || this._root, n = i.uuid, r = "string" == typeof t ? ow.findByName(i, t) : t,
                    s = null !== r ? r.uuid : t, a = this._actionsByClip[s], o = null;
                if (void 0 !== a) {
                    var h = a.actionByRoot[n];
                    if (void 0 !== h) return h;
                    o = a.knownActions[0], null === r && (r = o._clip)
                }
                if (null === r) return null;
                var l = new Q_(this, r, e);
                return this._bindAction(l, o), this._addInactiveAction(l, s, n), l
            }, existingAction: function (t, e) {
                var i = e || this._root, n = i.uuid, r = "string" == typeof t ? ow.findByName(i, t) : t,
                    s = r ? r.uuid : t, a = this._actionsByClip[s];
                return void 0 !== a && a.actionByRoot[n] || null
            }, stopAllAction: function () {
                var t = this._actions, e = this._nActiveActions, i = this._bindings, n = this._nActiveBindings;
                this._nActiveActions = 0, this._nActiveBindings = 0;
                for (var r = 0; r !== e; ++r) t[r].reset();
                for (r = 0; r !== n; ++r) i[r].useCount = 0;
                return this
            }, update: function (t) {
                t *= this.timeScale;
                for (var e = this._actions, i = this._nActiveActions, n = this.time += t, r = Math.sign(t), s = this._accuIndex ^= 1, a = 0; a !== i; ++a) {
                    e[a]._update(n, t, r, s)
                }
                var o = this._bindings, h = this._nActiveBindings;
                for (a = 0; a !== h; ++a) o[a].apply(s);
                return this
            }, getRoot: function () {
                return this._root
            }, uncacheClip: function (t) {
                var e = this._actions, i = t.uuid, n = this._actionsByClip, r = n[i];
                if (void 0 !== r) {
                    for (var s = r.knownActions, a = 0, o = s.length; a !== o; ++a) {
                        var h = s[a];
                        this._deactivateAction(h);
                        var l = h._cacheIndex, c = e[e.length - 1];
                        h._cacheIndex = null, h._byClipCacheIndex = null, c._cacheIndex = l, e[l] = c, e.pop(), this._removeInactiveBindingsForAction(h)
                    }
                    delete n[i]
                }
            }, uncacheRoot: function (t) {
                var e = t.uuid, i = this._actionsByClip;
                for (var n in i) {
                    var r = i[n].actionByRoot[e];
                    void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r))
                }
                var s = this._bindingsByRootAndName[e];
                if (void 0 !== s) for (var a in s) {
                    var o = s[a];
                    o.restoreOriginalState(), this._removeInactiveBinding(o)
                }
            }, uncacheAction: function (t, e) {
                var i = this.existingAction(t, e);
                null !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
            }
        }), $_.prototype.clone = function () {
            return new $_(void 0 === this.value.clone ? this.value : this.value.clone())
        }, tE.prototype = Object.assign(Object.create(ab.prototype), {
            constructor: tE,
            isInstancedInterleavedBuffer: !0,
            copy: function (t) {
                return ab.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
            }
        }), Object.assign(eE.prototype, {
            linePrecision: 1, set: function (t, e) {
                this.ray.set(t, e)
            }, setFromCamera: function (t, e) {
                e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
            }, intersectObject: function (t, e, i) {
                var n = i || [];
                return nE(t, this, n, e), n.sort(iE), n
            }, intersectObjects: function (t, e, i) {
                var n = i || [];
                if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), n;
                for (var r = 0, s = t.length; r < s; r++) nE(t[r], this, n, e);
                return n.sort(iE), n
            }
        }), Object.assign(function (t, e, i) {
            return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== i ? i : 0, this
        }.prototype, {
            set: function (t, e, i) {
                return this.radius = t, this.phi = e, this.theta = i, this
            }, clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
            }, makeSafe: function () {
                var t = 1e-6;
                return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)), this
            }, setFromVector3: function (t) {
                return this.setFromCartesianCoords(t.x, t.y, t.z)
            }, setFromCartesianCoords: function (t, e, i) {
                return this.radius = Math.sqrt(t * t + e * e + i * i), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, i), this.phi = Math.acos(bm.clamp(e / this.radius, -1, 1))), this
            }
        }), Object.assign(function (t, e, i) {
            return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== i ? i : 0, this
        }.prototype, {
            set: function (t, e, i) {
                return this.radius = t, this.theta = e, this.y = i, this
            }, clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
            }, setFromVector3: function (t) {
                return this.setFromCartesianCoords(t.x, t.y, t.z)
            }, setFromCartesianCoords: function (t, e, i) {
                return this.radius = Math.sqrt(t * t + i * i), this.theta = Math.atan2(t, i), this.y = e, this
            }
        }), Object.assign(rE.prototype, {
            set: function (t, e) {
                return this.min.copy(t), this.max.copy(e), this
            }, setFromPoints: function (t) {
                this.makeEmpty();
                for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                return this
            }, setFromCenterAndSize: function () {
                var t = new xm;
                return function (e, i) {
                    var n = t.copy(i).multiplyScalar(.5);
                    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                }
            }(), clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            }, makeEmpty: function () {
                return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
            }, isEmpty: function () {
                return this.max.x < this.min.x || this.max.y < this.min.y
            }, getCenter: function (t) {
                return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new xm), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }, getSize: function (t) {
                return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new xm), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
            }, expandByPoint: function (t) {
                return this.min.min(t), this.max.max(t), this
            }, expandByVector: function (t) {
                return this.min.sub(t), this.max.add(t), this
            }, expandByScalar: function (t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            }, containsPoint: function (t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
            }, containsBox: function (t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
            }, getParameter: function (t, e) {
                return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new xm), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
            }, intersectsBox: function (t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
            }, clampPoint: function (t, e) {
                return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new xm), e.copy(t).clamp(this.min, this.max)
            }, distanceToPoint: function () {
                var t = new xm;
                return function (e) {
                    return t.copy(e).clamp(this.min, this.max).sub(e).length()
                }
            }(), intersect: function (t) {
                return this.min.max(t.min), this.max.min(t.max), this
            }, union: function (t) {
                return this.min.min(t.min), this.max.max(t.max), this
            }, translate: function (t) {
                return this.min.add(t), this.max.add(t), this
            }, equals: function (t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }), Object.assign(sE.prototype, {
            set: function (t, e) {
                return this.start.copy(t), this.end.copy(e), this
            }, clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                return this.start.copy(t.start), this.end.copy(t.end), this
            }, getCenter: function (t) {
                return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new _m), t.addVectors(this.start, this.end).multiplyScalar(.5)
            }, delta: function (t) {
                return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new _m), t.subVectors(this.end, this.start)
            }, distanceSq: function () {
                return this.start.distanceToSquared(this.end)
            }, distance: function () {
                return this.start.distanceTo(this.end)
            }, at: function (t, e) {
                return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new _m), this.delta(e).multiplyScalar(t).add(this.start)
            }, closestPointToPointParameter: (G_ = new _m, U_ = new _m, function (t, e) {
                G_.subVectors(t, this.start), U_.subVectors(this.end, this.start);
                var i = U_.dot(U_), n = U_.dot(G_) / i;
                return e && (n = bm.clamp(n, 0, 1)), n
            }), closestPointToPoint: function (t, e, i) {
                var n = this.closestPointToPointParameter(t, e);
                return void 0 === i && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), i = new _m), this.delta(i).multiplyScalar(n).add(this.start)
            }, applyMatrix4: function (t) {
                return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
            }, equals: function (t) {
                return t.start.equals(this.start) && t.end.equals(this.end)
            }
        }), aE.prototype = Object.create(vg.prototype), aE.prototype.constructor = aE, aE.prototype.isImmediateRenderObject = !0, oE.prototype = Object.create(gb.prototype), oE.prototype.constructor = oE, oE.prototype.update = function () {
            var t = new _m, e = new _m, i = new Em;
            return function () {
                var n = ["a", "b", "c"];
                this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
                var r = this.object.matrixWorld, s = this.geometry.attributes.position, a = this.object.geometry;
                if (a && a.isGeometry) for (var o = a.vertices, h = a.faces, l = 0, c = 0, u = h.length; c < u; c++) for (var p = h[c], d = 0, f = p.vertexNormals.length; d < f; d++) {
                    var m = o[p[n[d]]], g = p.vertexNormals[d];
                    t.copy(m).applyMatrix4(r), e.copy(g).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), s.setXYZ(l, t.x, t.y, t.z), l += 1, s.setXYZ(l, e.x, e.y, e.z), l += 1
                } else if (a && a.isBufferGeometry) {
                    var v = a.attributes.position, y = a.attributes.normal;
                    for (l = 0, d = 0, f = v.count; d < f; d++) t.set(v.getX(d), v.getY(d), v.getZ(d)).applyMatrix4(r), e.set(y.getX(d), y.getY(d), y.getZ(d)), e.applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), s.setXYZ(l, t.x, t.y, t.z), l += 1, s.setXYZ(l, e.x, e.y, e.z), l += 1
                }
                s.needsUpdate = !0
            }
        }(), hE.prototype = Object.create(vg.prototype), hE.prototype.constructor = hE, hE.prototype.dispose = function () {
            this.cone.geometry.dispose(), this.cone.material.dispose()
        }, hE.prototype.update = function () {
            var t = new _m;
            return function () {
                this.light.updateMatrixWorld();
                var e = this.light.distance ? this.light.distance : 1e3, i = e * Math.tan(this.light.angle);
                this.cone.scale.set(i, i, e), t.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(t), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
            }
        }(), cE.prototype = Object.create(gb.prototype), cE.prototype.constructor = cE, cE.prototype.updateMatrixWorld = function () {
            var t = new _m, e = new Jm, i = new Jm;
            return function (n) {
                var r = this.bones, s = this.geometry, a = s.getAttribute("position");
                i.getInverse(this.root.matrixWorld);
                for (var o = 0, h = 0; o < r.length; o++) {
                    var l = r[o];
                    l.parent && l.parent.isBone && (e.multiplyMatrices(i, l.matrixWorld), t.setFromMatrixPosition(e), a.setXYZ(h, t.x, t.y, t.z), e.multiplyMatrices(i, l.parent.matrixWorld), t.setFromMatrixPosition(e), a.setXYZ(h + 1, t.x, t.y, t.z), h += 2)
                }
                s.getAttribute("position").needsUpdate = !0, vg.prototype.updateMatrixWorld.call(this, n)
            }
        }(), uE.prototype = Object.create(rv.prototype), uE.prototype.constructor = uE, uE.prototype.dispose = function () {
            this.geometry.dispose(), this.material.dispose()
        }, uE.prototype.update = function () {
            void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
        }, pE.prototype = Object.create(mb.prototype), pE.prototype.constructor = pE, pE.prototype.update = function () {
            if (this.scale.set(.5 * this.light.width, .5 * this.light.height, 1), void 0 !== this.color) this.material.color.set(this.color), this.children[0].material.color.set(this.color); else {
                this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
                var t = this.material.color, e = Math.max(t.r, t.g, t.b);
                e > 1 && t.multiplyScalar(1 / e), this.children[0].material.color.copy(this.material.color)
            }
        }, pE.prototype.dispose = function () {
            this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose()
        }, dE.prototype = Object.create(vg.prototype), dE.prototype.constructor = dE, dE.prototype.dispose = function () {
            this.children[0].geometry.dispose(), this.children[0].material.dispose()
        }, dE.prototype.update = function () {
            var t = new _m, e = new rg, i = new rg;
            return function () {
                var n = this.children[0];
                if (void 0 !== this.color) this.material.color.set(this.color); else {
                    var r = n.geometry.getAttribute("color");
                    e.copy(this.light.color), i.copy(this.light.groundColor);
                    for (var s = 0, a = r.count; s < a; s++) {
                        var o = s < a / 2 ? e : i;
                        r.setXYZ(s, o.r, o.g, o.b)
                    }
                    r.needsUpdate = !0
                }
                n.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate())
            }
        }(), fE.prototype = Object.create(rv.prototype), fE.prototype.constructor = fE, fE.prototype.dispose = function () {
            this.geometry.dispose(), this.material.dispose()
        }, fE.prototype.onBeforeRender = function () {
            this.position.copy(this.lightProbe.position), this.scale.set(1, 1, 1).multiplyScalar(this.size), this.material.uniforms.intensity.value = this.lightProbe.intensity
        }, mE.prototype = Object.assign(Object.create(gb.prototype), {
            constructor: mE, copy: function (t) {
                return gb.prototype.copy.call(this, t), this.geometry.copy(t.geometry), this.material.copy(t.material), this
            }, clone: function () {
                return (new this.constructor).copy(this)
            }
        }), gE.prototype = Object.create(gb.prototype), gE.prototype.constructor = gE, vE.prototype = Object.create(mb.prototype), vE.prototype.constructor = vE, vE.prototype.update = function () {
            var t, e, i = this.audio, n = this.range, r = this.divisionsInnerAngle, s = this.divisionsOuterAngle,
                a = bm.degToRad(i.panner.coneInnerAngle), o = bm.degToRad(i.panner.coneOuterAngle), h = a / 2,
                l = o / 2, c = 0, u = 0, p = this.geometry, d = p.attributes.position;

            function f(i, r, s, a) {
                var o = (r - i) / s;
                for (d.setXYZ(c, 0, 0, 0), u++, t = i; t < r; t += o) e = c + u, d.setXYZ(e, Math.sin(t) * n, 0, Math.cos(t) * n), d.setXYZ(e + 1, Math.sin(Math.min(t + o, r)) * n, 0, Math.cos(Math.min(t + o, r)) * n), d.setXYZ(e + 2, 0, 0, 0), u += 3;
                p.addGroup(c, u, a), c += u, u = 0
            }

            p.clearGroups(), f(-l, -h, s, 0), f(-h, h, r, 1), f(h, l, s, 0), d.needsUpdate = !0, a === o && (this.material[0].visible = !1)
        }, vE.prototype.dispose = function () {
            this.geometry.dispose(), this.material[0].dispose(), this.material[1].dispose()
        }, yE.prototype = Object.create(gb.prototype), yE.prototype.constructor = yE, yE.prototype.update = function () {
            var t = new _m, e = new _m, i = new Em;
            return function () {
                this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
                for (var n = this.object.matrixWorld, r = this.geometry.attributes.position, s = this.object.geometry, a = s.vertices, o = s.faces, h = 0, l = 0, c = o.length; l < c; l++) {
                    var u = o[l], p = u.normal;
                    t.copy(a[u.a]).add(a[u.b]).add(a[u.c]).divideScalar(3).applyMatrix4(n), e.copy(p).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), r.setXYZ(h, t.x, t.y, t.z), h += 1, r.setXYZ(h, e.x, e.y, e.z), h += 1
                }
                r.needsUpdate = !0
            }
        }(), bE.prototype = Object.create(vg.prototype), bE.prototype.constructor = bE, bE.prototype.dispose = function () {
            this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
        }, bE.prototype.update = function () {
            var t = new _m, e = new _m, i = new _m;
            return function () {
                t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), i.subVectors(e, t), this.lightPlane.lookAt(e), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(e), this.targetLine.scale.z = i.length()
            }
        }(), xE.prototype = Object.create(gb.prototype), xE.prototype.constructor = xE, xE.prototype.update = function () {
            var t, e, i = new _m, n = new Gy;

            function r(r, s, a, o) {
                i.set(s, a, o).unproject(n);
                var h = e[r];
                if (void 0 !== h) for (var l = t.getAttribute("position"), c = 0, u = h.length; c < u; c++) l.setXYZ(h[c], i.x, i.y, i.z)
            }

            return function () {
                t = this.geometry, e = this.pointMap;
                n.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), r("c", 0, 0, -1), r("t", 0, 0, 1), r("n1", -1, -1, -1), r("n2", 1, -1, -1), r("n3", -1, 1, -1), r("n4", 1, 1, -1), r("f1", -1, -1, 1), r("f2", 1, -1, 1), r("f3", -1, 1, 1), r("f4", 1, 1, 1), r("u1", .7, 1.1, -1), r("u2", -.7, 1.1, -1), r("u3", 0, 2, -1), r("cf1", -1, 0, 1), r("cf2", 1, 0, 1), r("cf3", 0, -1, 1), r("cf4", 0, 1, 1), r("cn1", -1, 0, -1), r("cn2", 1, 0, -1), r("cn3", 0, -1, -1), r("cn4", 0, 1, -1), t.getAttribute("position").needsUpdate = !0
            }
        }(), wE.prototype = Object.create(gb.prototype), wE.prototype.constructor = wE, wE.prototype.update = function () {
            var t = new qm;
            return function (e) {
                if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && t.setFromObject(this.object), !t.isEmpty()) {
                    var i = t.min, n = t.max, r = this.geometry.attributes.position, s = r.array;
                    s[0] = n.x, s[1] = n.y, s[2] = n.z, s[3] = i.x, s[4] = n.y, s[5] = n.z, s[6] = i.x, s[7] = i.y, s[8] = n.z, s[9] = n.x, s[10] = i.y, s[11] = n.z, s[12] = n.x, s[13] = n.y, s[14] = i.z, s[15] = i.x, s[16] = n.y, s[17] = i.z, s[18] = i.x, s[19] = i.y, s[20] = i.z, s[21] = n.x, s[22] = i.y, s[23] = i.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
                }
            }
        }(), wE.prototype.setFromObject = function (t) {
            return this.object = t, this.update(), this
        }, wE.prototype.copy = function (t) {
            return gb.prototype.copy.call(this, t), this.object = t.object, this
        }, wE.prototype.clone = function () {
            return (new this.constructor).copy(this)
        }, _E.prototype = Object.create(gb.prototype), _E.prototype.constructor = _E, _E.prototype.updateMatrixWorld = function (t) {
            var e = this.box;
            e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), vg.prototype.updateMatrixWorld.call(this, t))
        }, EE.prototype = Object.create(mb.prototype), EE.prototype.constructor = EE, EE.prototype.updateMatrixWorld = function (t) {
            var e = -this.plane.constant;
            Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? 1 : 0, this.lookAt(this.plane.normal), vg.prototype.updateMatrixWorld.call(this, t)
        }, ME.prototype = Object.create(vg.prototype), ME.prototype.constructor = ME, ME.prototype.setDirection = (X_ = new _m, function (t) {
            t.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : t.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (X_.set(t.z, 0, -t.x).normalize(), q_ = Math.acos(t.y), this.quaternion.setFromAxisAngle(X_, q_))
        }), ME.prototype.setLength = function (t, e, i) {
            void 0 === e && (e = .2 * t), void 0 === i && (i = .2 * e), this.line.scale.set(1, Math.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(i, e, i), this.cone.position.y = t, this.cone.updateMatrix()
        }, ME.prototype.setColor = function (t) {
            this.line.material.color.copy(t), this.cone.material.color.copy(t)
        }, ME.prototype.copy = function (t) {
            return vg.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this
        }, ME.prototype.clone = function () {
            return (new this.constructor).copy(this)
        }, AE.prototype = Object.create(gb.prototype), AE.prototype.constructor = AE;

        function SE(t) {
            console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Sw.call(this, t), this.type = "catmullrom"
        }

        yw.create = function (t, e) {
            return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(yw.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
        }, Object.assign(Bw.prototype, {
            createPointsGeometry: function (t) {
                console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                var e = this.getPoints(t);
                return this.createGeometry(e)
            }, createSpacedPointsGeometry: function (t) {
                console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                var e = this.getSpacedPoints(t);
                return this.createGeometry(e)
            }, createGeometry: function (t) {
                console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                for (var e = new wg, i = 0, n = t.length; i < n; i++) {
                    var r = t[i];
                    e.vertices.push(new _m(r.x, r.y, r.z || 0))
                }
                return e
            }
        }), Object.assign(Nw.prototype, {
            fromPoints: function (t) {
                console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
            }
        }), Object.create(Sw.prototype), Object.create(Sw.prototype), SE.prototype = Object.create(Sw.prototype), Object.assign(SE.prototype, {
            initFromArray: function () {
                console.error("THREE.Spline: .initFromArray() has been removed.")
            }, getControlPointsArray: function () {
                console.error("THREE.Spline: .getControlPointsArray() has been removed.")
            }, reparametrizeByArcLength: function () {
                console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
            }
        }), mE.prototype.setColors = function () {
            console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
        }, cE.prototype.update = function () {
            console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
        }, Object.assign(v_.prototype, {
            extractUrlBase: function (t) {
                return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), $w(t)
            }
        }), Object.assign(r_.prototype, {
            setTexturePath: function (t) {
                return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t)
            }
        }), Object.assign(rE.prototype, {
            center: function (t) {
                return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
            }, empty: function () {
                return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            }, isIntersectionBox: function (t) {
                return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            }, size: function (t) {
                return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
            }
        }), Object.assign(qm.prototype, {
            center: function (t) {
                return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
            }, empty: function () {
                return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            }, isIntersectionBox: function (t) {
                return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            }, isIntersectionSphere: function (t) {
                return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
            }, size: function (t) {
                return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
            }
        }), sE.prototype.center = function (t) {
            return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
        }, Object.assign(bm, {
            random16: function () {
                return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
            }, nearestPowerOfTwo: function (t) {
                return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), bm.floorPowerOfTwo(t)
            }, nextPowerOfTwo: function (t) {
                return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), bm.ceilPowerOfTwo(t)
            }
        }), Object.assign(Em.prototype, {
            flattenToArrayOffset: function (t, e) {
                return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
            }, multiplyVector3: function (t) {
                return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
            }, multiplyVector3Array: function () {
                console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
            }, applyToBuffer: function (t) {
                return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
            }, applyToVector3Array: function () {
                console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
            }
        }), Object.assign(Jm.prototype, {
            extractPosition: function (t) {
                return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
            }, flattenToArrayOffset: function (t, e) {
                return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
            }, getPosition: function () {
                var t;
                return function () {
                    return void 0 === t && (t = new _m), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), t.setFromMatrixColumn(this, 3)
                }
            }(), setRotationFromQuaternion: function (t) {
                return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
            }, multiplyToArray: function () {
                console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
            }, multiplyVector3: function (t) {
                return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            }, multiplyVector4: function (t) {
                return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            }, multiplyVector3Array: function () {
                console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
            }, rotateAxis: function (t) {
                console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
            }, crossVector: function (t) {
                return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            }, translate: function () {
                console.error("THREE.Matrix4: .translate() has been removed.")
            }, rotateX: function () {
                console.error("THREE.Matrix4: .rotateX() has been removed.")
            }, rotateY: function () {
                console.error("THREE.Matrix4: .rotateY() has been removed.")
            }, rotateZ: function () {
                console.error("THREE.Matrix4: .rotateZ() has been removed.")
            }, rotateByAxis: function () {
                console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
            }, applyToBuffer: function (t) {
                return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
            }, applyToVector3Array: function () {
                console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
            }, makeFrustum: function (t, e, i, n, r, s) {
                return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, n, i, r, s)
            }
        }), Ym.prototype.isIntersectionLine = function (t) {
            return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
        }, wm.prototype.multiplyVector3 = function (t) {
            return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
        }, Object.assign(ev.prototype, {
            isIntersectionBox: function (t) {
                return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            }, isIntersectionPlane: function (t) {
                return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
            }, isIntersectionSphere: function (t) {
                return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
            }
        }), Object.assign(iv.prototype, {
            area: function () {
                return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
            }, barycoordFromPoint: function (t, e) {
                return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
            }, midpoint: function (t) {
                return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
            }, normal: function (t) {
                return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
            }, plane: function (t) {
                return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
            }
        }), Object.assign(iv, {
            barycoordFromPoint: function (t, e, i, n, r) {
                return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), iv.getBarycoord(t, e, i, n, r)
            }, normal: function (t, e, i, n) {
                return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), iv.getNormal(t, e, i, n)
            }
        }), Object.assign(jw.prototype, {
            extractAllPoints: function (t) {
                return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
            }, extrude: function (t) {
                return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new fx(this, t)
            }, makeGeometry: function (t) {
                return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Sx(this, t)
            }
        }), Object.assign(xm.prototype, {
            fromAttribute: function (t, e, i) {
                return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
            }, distanceToManhattan: function (t) {
                return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
            }, lengthManhattan: function () {
                return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }
        }), Object.assign(_m.prototype, {
            setEulerFromRotationMatrix: function () {
                console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
            }, setEulerFromQuaternion: function () {
                console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
            }, getPositionFromMatrix: function (t) {
                return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
            }, getScaleFromMatrix: function (t) {
                return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
            }, getColumnFromMatrix: function (t, e) {
                return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
            }, applyProjection: function (t) {
                return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
            }, fromAttribute: function (t, e, i) {
                return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
            }, distanceToManhattan: function (t) {
                return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
            }, lengthManhattan: function () {
                return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }
        }), Object.assign(Vm.prototype, {
            fromAttribute: function (t, e, i) {
                return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
            }, lengthManhattan: function () {
                return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }
        }), Object.assign(wg.prototype, {
            computeTangents: function () {
                console.error("THREE.Geometry: .computeTangents() has been removed.")
            }, computeLineDistances: function () {
                console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
            }
        }), Object.assign(vg.prototype, {
            getChildByName: function (t) {
                return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
            }, renderDepth: function () {
                console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
            }, translate: function (t, e) {
                return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
            }, getWorldRotation: function () {
                console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
            }
        }), Object.defineProperties(vg.prototype, {
            eulerOrder: {
                get: function () {
                    return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                }, set: function (t) {
                    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                }
            }, useQuaternion: {
                get: function () {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                }, set: function () {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                }
            }
        }), Object.defineProperties(cb.prototype, {
            objects: {
                get: function () {
                    return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                }
            }
        }), Object.defineProperty(pb.prototype, "useVertexTexture", {
            get: function () {
                console.warn("THREE.Skeleton: useVertexTexture has been removed.")
            }, set: function () {
                console.warn("THREE.Skeleton: useVertexTexture has been removed.")
            }
        }), ub.prototype.initBones = function () {
            console.error("THREE.SkinnedMesh: initBones() has been removed.")
        }, Object.defineProperty(yw.prototype, "__arcLengthDivisions", {
            get: function () {
                return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
            }, set: function (t) {
                console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t
            }
        }), Uy.prototype.setLens = function (t, e) {
            console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
        }, Object.defineProperties(Vw.prototype, {
            onlyShadow: {
                set: function () {
                    console.warn("THREE.Light: .onlyShadow has been removed.")
                }
            }, shadowCameraFov: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
                }
            }, shadowCameraLeft: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
                }
            }, shadowCameraRight: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
                }
            }, shadowCameraTop: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
                }
            }, shadowCameraBottom: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
                }
            }, shadowCameraNear: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
                }
            }, shadowCameraFar: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
                }
            }, shadowCameraVisible: {
                set: function () {
                    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                }
            }, shadowBias: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
                }
            }, shadowDarkness: {
                set: function () {
                    console.warn("THREE.Light: .shadowDarkness has been removed.")
                }
            }, shadowMapWidth: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
                }
            }, shadowMapHeight: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                }
            }
        }), Object.defineProperties(_g.prototype, {
            length: {
                get: function () {
                    return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                }
            }, copyIndicesArray: function () {
                console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
            }
        }), Object.assign(kg.prototype, {
            addIndex: function (t) {
                console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
            }, addDrawCall: function (t, e, i) {
                void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
            }, clearDrawCalls: function () {
                console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
            }, computeTangents: function () {
                console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
            }, computeOffsets: function () {
                console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
            }
        }), Object.defineProperties(kg.prototype, {
            drawcalls: {
                get: function () {
                    return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                }
            }, offsets: {
                get: function () {
                    return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                }
            }
        }), Object.assign(mx.prototype, {
            getArrays: function () {
                console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
            }, addShapeList: function () {
                console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
            }, addShape: function () {
                console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
            }
        }), Object.defineProperties($_.prototype, {
            dynamic: {
                set: function () {
                    console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                }
            }, onUpdate: {
                value: function () {
                    return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
                }
            }
        }), Object.defineProperties(Vg.prototype, {
            wrapAround: {
                get: function () {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                }, set: function () {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                }
            }, overdraw: {
                get: function () {
                    console.warn("THREE.Material: .overdraw has been removed.")
                }, set: function () {
                    console.warn("THREE.Material: .overdraw has been removed.")
                }
            }, wrapRGB: {
                get: function () {
                    return console.warn("THREE.Material: .wrapRGB has been removed."), new rg
                }
            }, shading: {
                get: function () {
                    console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                }, set: function (t) {
                    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t
                }
            }
        }), Object.defineProperties(Vx.prototype, {
            metal: {
                get: function () {
                    return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
                }, set: function () {
                    console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                }
            }
        }), Object.defineProperties(tv.prototype, {
            derivatives: {
                get: function () {
                    return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                }, set: function (t) {
                    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                }
            }
        }), Object.assign(ib.prototype, {
            clearTarget: function (t, e, i, n) {
                console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, i, n)
            }, animate: function (t) {
                console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
            }, getCurrentRenderTarget: function () {
                return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
            }, getMaxAnisotropy: function () {
                return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
            }, getPrecision: function () {
                return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
            }, resetGLState: function () {
                return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
            }, supportsFloatTextures: function () {
                return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
            }, supportsHalfFloatTextures: function () {
                return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
            }, supportsStandardDerivatives: function () {
                return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
            }, supportsCompressedTextureS3TC: function () {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
            }, supportsCompressedTexturePVRTC: function () {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
            }, supportsBlendMinMax: function () {
                return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
            }, supportsVertexTextures: function () {
                return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
            }, supportsInstancedArrays: function () {
                return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
            }, enableScissorTest: function (t) {
                console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
            }, initMaterial: function () {
                console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
            }, addPrePlugin: function () {
                console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
            }, addPostPlugin: function () {
                console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
            }, updateShadowMap: function () {
                console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
            }, setFaceCulling: function () {
                console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
            }, allocTextureUnit: function () {
                console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
            }, setTexture: function () {
                console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
            }, setTexture2D: function () {
                console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
            }, setTextureCube: function () {
                console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
            }
        }), Object.defineProperties(ib.prototype, {
            shadowMapEnabled: {
                get: function () {
                    return this.shadowMap.enabled
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                }
            }, shadowMapType: {
                get: function () {
                    return this.shadowMap.type
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
                }
            }, shadowMapCullFace: {
                get: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                }, set: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                }
            }
        }), Object.defineProperties(zy.prototype, {
            cullFace: {
                get: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                }, set: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                }
            }, renderReverseSided: {
                get: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                }, set: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                }
            }, renderSingleSided: {
                get: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                }, set: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                }
            }
        }), Object.defineProperties(Hm.prototype, {
            activeCubeFace: {
                set: function () {
                    console.warn("THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().")
                }
            }, activeMipMapLevel: {
                set: function () {
                    console.warn("THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().")
                }
            }
        }), Object.defineProperties(Gm.prototype, {
            wrapS: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                }
            }, wrapT: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
                }
            }, magFilter: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
                }
            }, minFilter: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
                }
            }, anisotropy: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
                }
            }, offset: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
                }
            }, repeat: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
                }
            }, format: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
                }
            }, type: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
                }
            }, generateMipmaps: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                }
            }
        }), Object.defineProperties(tb.prototype, {
            standing: {
                set: function () {
                    console.warn("THREE.WebVRManager: .standing has been removed.")
                }
            }, userHeight: {
                set: function () {
                    console.warn("THREE.WebVRManager: .userHeight has been removed.")
                }
            }
        }), C_.prototype.load = function (t) {
            console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
            var e = this;
            return (new b_).load(t, (function (t) {
                e.setBuffer(t)
            })), this
        }, I_.prototype.getData = function () {
            return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
        }, S_.prototype.updateCubeMap = function (t, e) {
            return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
        };
        Bm.crossOrigin = void 0, Bm.loadTexture = function (t, e, i, n) {
            console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
            var r = new vw;
            r.setCrossOrigin(this.crossOrigin);
            var s = r.load(t, i, void 0, n);
            return e && (s.mapping = e), s
        }, Bm.loadTextureCube = function (t, e, i, n) {
            console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
            var r = new gw;
            r.setCrossOrigin(this.crossOrigin);
            var s = r.load(t, i, void 0, n);
            return e && (s.mapping = e), s
        }, Bm.loadCompressedTexture = function () {
            console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
        }, Bm.loadCompressedTextureCube = function () {
            console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
        };
        const TE = "0.12.1", DE = {three: "^0.105.2"}, CE = (TE.split(".")[1], DE.three.split(".")[1]),
            PE = (DE.three.replace(/[^0-9.]/g, ""), 0), IE = 1, LE = 1, RE = 2, FE = 3, kE = {
                Info: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABAAAAAQADq8/hgAAADBklEQVR42u2bP08UQRiHnzFaSYCI/xoksdBIqGwIiYWRUBISExpCQ0ej38FWOmlIKKhoMPEbaCxsrrHiYrQgOSlQEaICrT+LHSPZzNzt3s3c3Hn7lHvLzvv82L2dm30XKioqKgYY062BJF0HpoA7wARwBbhsPz4DjoEG8AnYNcZ8Sx1Op8IXJM1KWpdUV3nq9m9nJV1I7VNGfEzSM0mNNqR9NOwxx1L7NRMflbQm6SSgeJ4TO8Zoat+8/LKkg4jieQ4kLaf2RtKwpJ0uiufZkTScSn5S0l5C+b/sSZrstvyMpKPU5uc4kjTTjkvpeYCkaeA1/+7hvcIZMGuMqUULQNIU8Aa4ltrWwyHwyBizGzwASSPAe+B2assW7AH3jTE/i+xcZoa12Qfy2Bo3i+5cKABl99zF1GYlWFTBeULLS0DZrOsDcDNggTXgc27bLWA64BhfgHvGmB8dHUXZ1DM0S45xliKMs9bKr+klIOkqsBrwv9JtVq1DewEAT4Ch1BYdMGQdygeg7Df4SmqDAKyoyXpCszPgITCeuvoAjFuX0gE8jljUdv7bCtiOOJ7XpdUZ8L/gdXHOA5QtYH5NXXVgbrgWWn1nwFTqaiPgdPIFcDd1tRFwOl307DwRuZgXwLvctgfA04hjOp18AcReZ6sZY16e3yDpUuQxnU6+S2AkcjEpcDr1zxOXSPgCKLSa0mc4nXwB/EpdbQScTr4AGqmrjYDTyRfAx9TVRsDp5Aug8LJyH+F0cgZg58z11BUHpO5ruGh2G3ybuuqAeF2aBfAqddUB8bq0OgP2U1cegH3aOQOMMb+BrdTVB2DLupQLwLIOnKY26IBT6+ClaQDGmO/ARmqLDtiwDn7HVkcY+EdjNoTlCI+tYhO2iUppm6HKslPUq2qQKHpUe8AFsjaUXuUQWCgqXyoAG8IuME/WkNRrnAHzZfqDSgdgQ6gBc2Td3b3CMTBXtkOsIzTIjZLnQhjcVtlcEIPZLJ0LoVvt8s/Va+3yuSAG84UJRxB98cpM9dJURUVFxSDzBxKde4Lk3/h2AAAAAElFTkSuQmCC",
                Arrow: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABAAAAAQADq8/hgAAADPklEQVR42u2bMUscQRiG30/SRaJEI1ZKUiRErNIELRUbQYSAnX8hpVUgkDYp0wgWVjYW+QcJaQzYpLojJIXhtDDEKBpj65ti58ixmdmb2ZvZ7+T2AUHudmfmeXf2bnb3O6CmpqZmgJGqOiI5AWAWwEMA0wDuArht3r4CcAagBeAbgIaI/NQOp1fhIZKLJN+SbDKcptl3keSQtk+I+BjJVyRbJaRdtEybY9p+ReKjJN+QvIwonufS9DGq7ZuXXyd5nFA8zzHJdW1vkLxDcrdC8Ty7JO9oyc+QPFCUb3NAcqZq+TmSp9rmHZySnCvjErwOIPkUwHv8+w7vF64ALIrIfrIASM4C+ADgnratgxMACyLSiB4AyREAnwE80LbswgGAJyJy4bNxyApr6wbIw4xxy3djrwCYfeeuaZsFsEbPdULXU4DZqusLgMkEA21P05EEbf8A8FhEzos28pkBLxLKL5s/r/M1kEkz9vKQHGeatf05yfmOfubNa7G5JDle5NhtBjwHMBz5yFwAWBaRT+0XzP8pZsKwcQiH2fX8Ycojb+kzxUw4ZJn7CSQXqpRPHMKCq7+iZJ71Mvdy/DftXSQ6HcJdSDaqPPKW/mPOBO+lcbvzCU35RCFM2PpwnQKzZQfdgfe0dxH5dLA6uQJ4pC2fIASrkyuA6X6QjxyC1ckVQNn7bNHlI4ZgdXIFUObiJJl8pBCsTjGfuIwA2Cv4FN7xbYjkjqsRAHuIePXoCiDF1Zk2VidXAL+1R5sAq5MrgJb2aBNgdXIF8FV7tAmwOrkCCFs73wysTtYATHFCU3vEEWm6Ci6KvgY/ao86Ik6XogDeaY86Ik6XbjPgSHvkEThCwQy45XpDRK5JbgN4GWkgUyR9H65MRQxgW0SunZ5FezK7pfwd8e8MV8UfAPdF5Jdrg8JrAbPjprZFD2wWyQP6j8ZSEufRmGlgQ9umBBvd5IOgbjFUKLu+XnWBhG+rpsFVZGUo/coJgFVf+aAATAgNACvICpL6jSsAKyH1QcEBmBD2ASwhq+7uF84ALIVWiPUEB7lQsiOEwS2VzQUxmMXSuRCqKpd/zX4rl88FMZg/mLAEcSN+MlP/aKqmpqZmkPkL0hSjwOpNKxwAAAAASUVORK5CYII=",
                FullscreenEnter: "data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjRkZGRkZGIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxwYXRoIGQ9Ik0wIDBoMjR2MjRIMHoiIGZpbGw9Im5vbmUiLz4KICAgIDxwYXRoIGQ9Ik03IDE0SDV2NWg1di0ySDd2LTN6bS0yLTRoMlY3aDNWNUg1djV6bTEyIDdoLTN2Mmg1di01aC0ydjN6TTE0IDV2MmgzdjNoMlY1aC01eiIvPgo8L3N2Zz4=",
                FullscreenLeave: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggc3R5bGU9ImZpbGw6I2ZmZiIgZD0iTTE0LDE0SDE5VjE2SDE2VjE5SDE0VjE0TTUsMTRIMTBWMTlIOFYxNkg1VjE0TTgsNUgxMFYxMEg1VjhIOFY1TTE5LDhWMTBIMTRWNUgxNlY4SDE5WiIgLz48L3N2Zz4=",
                VideoPlay: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggc3R5bGU9ImZpbGw6I2ZmZiIgZD0iTTgsNS4xNFYxOS4xNEwxOSwxMi4xNEw4LDUuMTRaIiAvPjwvc3ZnPg==",
                VideoPause: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggc3R5bGU9ImZpbGw6I2ZmZiIgZD0iTTE0LDE5LjE0SDE4VjUuMTRIMTRNNiwxOS4xNEgxMFY1LjE0SDZWMTkuMTRaIiAvPjwvc3ZnPg==",
                WhiteTile: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIABAMAAAAGVsnJAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAB1WlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+CiAgICAgICAgIDx0aWZmOkNvbXByZXNzaW9uPjE8L3RpZmY6Q29tcHJlc3Npb24+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24+MjwvdGlmZjpQaG90b21ldHJpY0ludGVycHJldGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KAtiABQAAACRQTFRFAAAAAAAABgYGBwcHHh4eKysrx8fHy8vLzMzM7OzsAAAABgYG+q7SZgAAAAp0Uk5TAP7+/v7+/v7+/iJx/a8AAAOwSURBVHja7d0hbsNAEAVQo6SFI6XEcALDcgNLvUBvEBQVhpkWVYWlhSsVFS7t5QIshRt695lEASZP+8c7a1kzDL1fz+/zyuvzp6FbvoddrL6uDd1yGZ5eXldeb18N3fIx7A+58prmhm65DfvDcd0952lu6JabFbD/zVprZj1lzcys+fj9z8xTZtbT8rv8yWlu6BYAIgAAAAAAAAAAAABAM6QXEAEAAAAAAAAAgJ2gnaAIiIA3Q2qAGgAAAAAAAAAAAAAAAAAAAAAAAAAAQJsADkVFAAAAAAA8Bj0GRUAEREAEREAEREAEREAEAAAAAAAAAAB2gnaCIiACPplRA9QANUAERAAAAEVQERQBERCBVlfAcZ3aeZobusUKMGBhV6KUElHGKBERJR6/fxExRkQZl9/lT8S1oVsuhqyYMmPKjCkzvfcCpsxohrwY0Q06EAEAAAAAAAAAAACgGdILiAAAAAAAAAAAwE7QTlAERMCbITVADQAAAAAAAAAAAAAAAAAAAAAAAAAAwKmwQ1ERAAAAAACPQY9BERABERABERABERABERABAAAAAAAAAICdoJ2gCIiAT2bUADVADRABEQAAQBFUBEVABERgEyvAlJm+V4ApM6bMmDJjyowpM6bMdN0LmDKjGfJiRDfoQAQAAAAAAAAAAACAZkgvIAIAAAAAAAAAADtBO0EREAFvhtQANQAAAAAAAAAAAAAAAAAAAAAAAAAAAKfCDkVFAAAAAAA8Bj0GRUAEREAEREAEREAEREAEAAAAAAAAAAB2gnaCIiACPplRA9QANUAERAAAAEVQERQBERCBTawAU2b6XgGmzJgyY8qMKTOmzJgy03UvYMqMZsiLEd2gAxEAAAAAAAAAAAAAmiG9gAgAAAAAAAAAAOwE7QRFQAS8GVID1AAAAAAAAAAAAAAAAAAAAAAAAAAAAJwKOxQVAQAAAADwGPQYFAEREAEREAEREAEREAERAAAAAAAAAADYCdoJioAI+GRGDVAD1AAREAEAABRBRVAEREAENrECTJnpewWYMmPKjCkzpsyYMmPKTNe9gCkzmiEvRnSDDkQAAAAAAAAAAAAAaIb0AiIAAAAAAAAAALATtBMUARHwZkgNUAMAAAAAAAAAAAAAAAAAAAAAAAAAAHAq7FBUBAAAAADAY9BjUAREQAREQAREQAREQAREAAAAAAAAAABgJ2gnKAIi4JMZNUANUANEQAQAAFAEFUEREAER2MQKMGWm7xVgyowpM50PWen9ugNGXz1XaocAFgAAAABJRU5ErkJggg==",
                Setting: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABAAAAAQADq8/hgAAADn0lEQVR42u2bzUsVURjGnyO6CPzAMnTjppAo3LTwH1CqTfaxbeOiRS37A0wXtROFVi1aRBs3LWohSIGbQAQXViBGRhG0UIRKUCpK7q/FnOB2uc6cOXNmRnGe3eW+H8/7zLln3vNxpQoVKlQ4wjBFJAFOSRqX1O7osivpvjHmU1nChBZglvSYLYJbS0EanCvIJzWK+gnsyH34/8OuMaYjb265jwCgz6N4SWq3vodbAEmnS/KtBDgoAgyU5BteAOAkMAPcBroc7PskDWfgN+wyDwBdltMMcDI3tYBnde/pHeARMNTErgd4APzweP834oeN1dMkz5DlsFNn/yyv4kdiSK4At4AO4CqwGaDwRmza2B0210qM7YhrXU59ANAq6bWkwQTTn5KO5fIE0uVYlXTeGLOXFMx1DrjlULwKKN41x6DlnIjEEQCckPRe0okCiguJr5LOGGO+xhm5jICJQ1i8LOeJJKPYEQAMKvrtt5ZdjSf2FM0Fq/sZJI2A6UNcvCz36TiDfUcAcE1SPu/U6Mm8k/TFfu6XdFb5iX3dGPM8lQfwNod3+TowBnQ3yddtv1vPIe+b1JIBiwEJ1IAJ208k5W21trWA+V/5CHAcmAtU/A2P/DcCiTAHHE8tgCVhgLvAXgYCk17Jo/yTGfLuWe7Zd72AC8CWB4n3OAz7mLytNkZabAEXMhfeQKYfWEpJZCxA3rGUOZeA/qDF15FpAz47EvlNk9neI2e3jeWCz0BbmvipNkSMMX8kuSZYM8Z8zyqAjbHmaN5mOeYjgIXrU93MWrxHrNQjrqiDkQMLHwG+OdqF3NN3jeXKzU8AoF1SzdH8XKhJUO7HZDXLMbwAwICkJUULFxe0SbqSVQAbw3Xi7Ze0ZLmGAzAKbHs0JGU1QtvAaIjCW4B7ZOvJy2qFa5a730RPtBiaz0CgnkiZi6F5fBZDVMvho7EhcuS3xJJ2hV9IupgTqaLw0hhzab8vq23xOG/r+LDsKjLgYVzxUnU0ltwK2wDezUyJmEwqXgp/PL4rvxthaeCSI+zxuA10J8ZkWdJNSb2SLkvayKHwDRu71+ZajrG941J8agALDQ3GU/a/IvMkYCPzmCbtLNEVmacNtgs5iP9fYVNEV1Q6Hez7yNZSL+J2SarTcpqiyV2iUkG0IvPFvbz5FbEn+KEk3wMjwMeSfCsBXFBdly9CAPk9ydyffpECuB5tZfVJjaKWueOSfinln6YK4lahQoUKRxd/AcRPGTcQCAUQAAAAAElFTkSuQmCC",
                ChevronRight: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTguNTksMTYuNThMMTMuMTcsMTJMOC41OSw3LjQxTDEwLDZMMTYsMTJMMTAsMThMOC41OSwxNi41OFoiIC8+PC9zdmc+",
                Check: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTIxLDdMOSwxOUwzLjUsMTMuNUw0LjkxLDEyLjA5TDksMTYuMTdMMTkuNTksNS41OUwyMSw3WiIgLz48L3N2Zz4=",
                ViewIndicator: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBpZD0idmlldy1pbmRpY2F0b3IiIGhlaWdodD0iMzAiIHdpZHRoPSIzMCIgdmlld0JveD0iLTIuNSAtMSAzMCAzMCI+Cgk8c3R5bGUgdHlwZT0idGV4dC9jc3MiPi5zdDB7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLW1pdGVybGltaXQ6MTA7ZmlsbDpub25lO30uc3Qxe3N0cm9rZS13aWR0aDo2O3N0cm9rZS1taXRlcmxpbWl0OjEwO30KCTwvc3R5bGU+Cgk8Zz4KCQk8cGF0aCBjbGFzcz0ic3QwIiBkPSJNIDEyLjUgMCBBIDEyLjUgMTIuNSAwIDAgMCAtMTIuNSAwIEEgMTIuNSAxMi41IDAgMCAwIDEyLjUgMCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMywxNS41KSI+PC9wYXRoPgoJCTxwYXRoIGNsYXNzPSJzdDIiIGQ9Ik0gMTMgMCBMIDEwIDIgTCAxNiAyIFoiPjwvcGF0aD4KCQk8cGF0aCBjbGFzcz0ic3QyIiBkPSJNIDIgMCBBIDIgMiAwIDAgMCAtMiAwIEEgMiAyIDAgMCAwIDIgMCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMywxNS41KSI+PC9wYXRoPgoJCTxwYXRoIGNsYXNzPSJzdDEiIGlkPSJpbmRpY2F0b3IiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTMsMTUuNSkiPjwvcGF0aD4KCTwvZz4KPC9zdmc+"
            }, OE = {
                load: function (t, e = (() => {
                }), i = (() => {
                }), n = (() => {
                })) {
                    let r, s, a, o, h, l, c;
                    lw.enabled = !0;
                    for (let e in kE) kE.hasOwnProperty(e) && t === kE[e] && (c = e);
                    if (r = lw.get(c || t), void 0 !== r) return e && setTimeout((function () {
                        i({loaded: 1, total: 1}), e(r)
                    }), 0), r;
                    h = window.URL || window.webkitURL, l = document.createElementNS("http://www.w3.org/1999/xhtml", "img"), lw.add(c || t, l);
                    const u = () => {
                        h.revokeObjectURL(l.src), e(l)
                    };
                    if (0 === t.indexOf("data:")) return l.addEventListener("load", u, !1), l.src = t, l;
                    l.crossOrigin = void 0 !== this.crossOrigin ? this.crossOrigin : "", s = new window.XMLHttpRequest, s.open("GET", t, !0), "test" !== process.env.npm_lifecycle_event && (s.onreadystatechange = function () {
                        4 === this.readyState && this.status >= 400 && n()
                    }), s.responseType = "arraybuffer", s.addEventListener("error", n), s.addEventListener("progress", (t => {
                        if (!t) return;
                        const {loaded: e, total: n, lengthComputable: r} = t;
                        r && i({loaded: e, total: n})
                    })), s.addEventListener("loadend", (t => {
                        if (!t) return;
                        const {currentTarget: {response: e}} = t;
                        a = new Uint8Array(e), o = new window.Blob([a]), l.addEventListener("load", u, !1), l.src = h.createObjectURL(o)
                    })), s.send(null)
                }
            }, zE = function (t, e = (() => {
            }), i, n) {
                var r = new jm;
                return OE.load(t, (function (i) {
                    r.image = i;
                    const n = t.search(/\.(jpg|jpeg)$/) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                    r.format = n ? hm : lm, r.needsUpdate = !0, e(r)
                }), i, n), r
            }, BE = function (t, e = (() => {
            }), i = (() => {
            }), n) {
                var r, s, a, o, h;
                return r = new gv([]), s = 0, a = {}, o = {}, t.map((function (t, l) {
                    OE.load(t, (function (t) {
                        r.images[l] = t, 6 === ++s && (r.needsUpdate = !0, e(r))
                    }), (function (t) {
                        for (var e in a[l] = {
                            loaded: t.loaded,
                            total: t.total
                        }, o.loaded = 0, o.total = 0, h = 0, a) h++, o.loaded += a[e].loaded, o.total += a[e].total;
                        h < 6 && (o.total = o.total / h * 6), i(o)
                    }), n)
                })), r
            };

        function NE(t) {
            this.constraints = Object.assign({
                video: {
                    width: {ideal: 1920},
                    height: {ideal: 1080},
                    facingMode: {exact: "environment"}
                }, audio: !1
            }, t), this.container = null, this.scene = null, this.element = null, this.devices = [], this.stream = null, this.ratioScalar = 1, this.videoDeviceIndex = 0
        }

        function jE(t = 16777215, e = !0, i = 1500) {
            this.dpr = window.devicePixelRatio;
            const {canvas: n, context: r} = this.createCanvas(),
                s = new hb({color: t, map: this.createCanvasTexture(n)});
            lb.call(this, s), this.canvasWidth = n.width, this.canvasHeight = n.height, this.context = r, this.color = t instanceof rg ? t : new rg(t), this.autoSelect = e, this.dwellTime = i, this.rippleDuration = 500, this.position.z = -10, this.center.set(.5, .5), this.scale.set(.5, .5, 1), this.startTimestamp = null, this.timerId = null, this.callback = null, this.frustumCulled = !1, this.updateCanvasArcByProgress(0)
        }

        NE.prototype = Object.assign(Object.create(Vf.prototype), {
            setContainer: function (t) {
                this.container = t
            }, setScene: function (t) {
                this.scene = t
            }, enumerateDevices: function () {
                const t = this.devices, e = new Promise((e => {
                    e(t)
                }));
                return t.length > 0 ? e : window.navigator.mediaDevices.enumerateDevices()
            }, switchNextVideoDevice: function () {
                const t = this.stop.bind(this), e = this.start.bind(this), i = this.setVideDeviceIndex.bind(this);
                let n = this.videoDeviceIndex;
                this.getDevices("video").then((r => {
                    t(), n++, n >= r.length ? (i(0), n--) : i(n), e(r[n])
                }))
            }, getDevices: function (t = "video") {
                const e = this.devices;
                return this.enumerateDevices().then((t => t.map((t => (e.includes(t) || e.push(t), t))))).then((e => {
                    const i = new RegExp(t, "i");
                    return e.filter((t => i.test(t.kind)))
                }))
            }, getUserMedia: function (t) {
                const e = this.setMediaStream.bind(this), i = this.playVideo.bind(this);
                return window.navigator.mediaDevices.getUserMedia(t).then(e).then(i).catch((t => {
                    console.warn(`PANOLENS.Media: ${t}`)
                }))
            }, setVideDeviceIndex: function (t) {
                this.videoDeviceIndex = t
            }, start: function (t) {
                const e = this.constraints, i = this.getUserMedia.bind(this);
                return this.element = this.createVideoElement(), this.getDevices().then((n => {
                    if (!n || 0 === n.length) throw Error("no video device found");
                    const r = t || n[0];
                    return e.video.deviceId = r.deviceId, i(e)
                }))
            }, stop: function () {
                const t = this.stream;
                if (t && t.active) {
                    t.getTracks()[0].stop(), window.removeEventListener("resize", this.onWindowResize.bind(this)), this.element = null, this.stream = null
                }
            }, setMediaStream: function (t) {
                this.stream = t, this.element.srcObject = t, this.scene && (this.scene.background = this.createVideoTexture()), window.addEventListener("resize", this.onWindowResize.bind(this))
            }, playVideo: function () {
                const {element: t} = this;
                t && (t.play(), this.dispatchEvent({type: "play"}))
            }, pauseVideo: function () {
                const {element: t} = this;
                t && (t.pause(), this.dispatchEvent({type: "pause"}))
            }, createVideoTexture: function () {
                const t = this.element, e = new xb(t);
                return e.generateMipmaps = !1, e.minFilter = em, e.magFilter = em, e.format = hm, e.center.set(.5, .5), t.addEventListener("canplay", this.onWindowResize.bind(this)), e
            }, createVideoElement: function () {
                const t = this.dispatchEvent.bind(this), e = document.createElement("video");
                return e.setAttribute("autoplay", ""), e.setAttribute("muted", ""), e.setAttribute("playsinline", ""), e.style.position = "absolute", e.style.top = "0", e.style.left = "0", e.style.width = "100%", e.style.height = "100%", e.style.objectPosition = "center", e.style.objectFit = "cover", e.style.display = this.scene ? "none" : "", e.addEventListener("canplay", (() => t({type: "canplay"}))), e
            }, onWindowResize: function () {
                if (this.element && this.element.videoWidth && this.element.videoHeight && this.scene) {
                    const {clientWidth: t, clientHeight: e} = this.container, i = this.scene.background, {
                        videoWidth: n,
                        videoHeight: r
                    } = this.element, s = r / n * (this.container ? t / e : 1) * this.ratioScalar;
                    t > e ? i.repeat.set(s, 1) : i.repeat.set(1, 1 / s)
                }
            }
        }), jE.prototype = Object.assign(Object.create(lb.prototype), {
            constructor: jE, setColor: function (t) {
                this.material.color.copy(t instanceof rg ? t : new rg(t))
            }, createCanvasTexture: function (t) {
                const e = new _b(t);
                return e.minFilter = em, e.magFilter = em, e.generateMipmaps = !1, e
            }, createCanvas: function () {
                const t = document.createElement("canvas"), e = t.getContext("2d"), i = this.dpr;
                return t.width = 32 * i, t.height = 32 * i, e.scale(i, i), e.shadowBlur = 5, e.shadowColor = "rgba(200,200,200,0.9)", {
                    canvas: t,
                    context: e
                }
            }, updateCanvasArcByProgress: function (t) {
                const e = this.context, {canvasWidth: i, canvasHeight: n, material: r} = this, s = this.dpr,
                    a = t * Math.PI * 2, o = this.color.getStyle(), h = .5 * i / s, l = .5 * n / s;
                e.clearRect(0, 0, i, n), e.beginPath(), 0 === t ? (e.arc(h, l, i / 16, 0, 2 * Math.PI), e.fillStyle = o, e.fill()) : (e.arc(h, l, i / 4 - 3, -Math.PI / 2, -Math.PI / 2 + a), e.strokeStyle = o, e.lineWidth = 3, e.stroke()), e.closePath(), r.map.needsUpdate = !0
            }, ripple: function () {
                const t = this.context, {canvasWidth: e, canvasHeight: i, material: n} = this, r = this.rippleDuration,
                    s = performance.now(), a = this.color, o = this.dpr, h = .5 * e / o, l = .5 * i / o, c = () => {
                        const u = window.requestAnimationFrame(c), p = (performance.now() - s) / r,
                            d = 1 - p > 0 ? 1 - p : 0, f = p * e * .5 / o;
                        t.clearRect(0, 0, e, i), t.beginPath(), t.arc(h, l, f, 0, 2 * Math.PI), t.fillStyle = `rgba(${255 * a.r}, ${255 * a.g}, ${255 * a.b}, ${d})`, t.fill(), t.closePath(), p >= 1 && (window.cancelAnimationFrame(u), this.updateCanvasArcByProgress(0), this.dispatchEvent({type: "reticle-ripple-end"})), n.map.needsUpdate = !0
                    };
                this.dispatchEvent({type: "reticle-ripple-start"}), c()
            }, show: function () {
                this.visible = !0
            }, hide: function () {
                this.visible = !1
            }, start: function (t) {
                this.autoSelect && (this.dispatchEvent({type: "reticle-start"}), this.startTimestamp = performance.now(), this.callback = t, this.update())
            }, end: function () {
                this.startTimestamp && (window.cancelAnimationFrame(this.timerId), this.updateCanvasArcByProgress(0), this.callback = null, this.timerId = null, this.startTimestamp = null, this.dispatchEvent({type: "reticle-end"}))
            }, update: function () {
                this.timerId = window.requestAnimationFrame(this.update.bind(this));
                const t = (performance.now() - this.startTimestamp) / this.dwellTime;
                this.updateCanvasArcByProgress(t), this.dispatchEvent({
                    type: "reticle-update",
                    progress: t
                }), t >= 1 && (window.cancelAnimationFrame(this.timerId), this.callback && this.callback(), this.end(), this.ripple())
            }
        });
        var VE = function (t, e) {
            return t(e = {exports: {}}, e.exports), e.exports
        }((function (t, e) {
            var i = function () {
                this._tweens = {}, this._tweensAddedDuringUpdate = {}
            };
            i.prototype = {
                getAll: function () {
                    return Object.keys(this._tweens).map(function (t) {
                        return this._tweens[t]
                    }.bind(this))
                }, removeAll: function () {
                    this._tweens = {}
                }, add: function (t) {
                    this._tweens[t.getId()] = t, this._tweensAddedDuringUpdate[t.getId()] = t
                }, remove: function (t) {
                    delete this._tweens[t.getId()], delete this._tweensAddedDuringUpdate[t.getId()]
                }, update: function (t, e) {
                    var i = Object.keys(this._tweens);
                    if (0 === i.length) return !1;
                    for (t = void 0 !== t ? t : r.now(); i.length > 0;) {
                        this._tweensAddedDuringUpdate = {};
                        for (var n = 0; n < i.length; n++) {
                            var s = this._tweens[i[n]];
                            s && !1 === s.update(t) && (s._isPlaying = !1, e || delete this._tweens[i[n]])
                        }
                        i = Object.keys(this._tweensAddedDuringUpdate)
                    }
                    return !0
                }
            };
            var n, r = new i;
            r.Group = i, r._nextId = 0, r.nextId = function () {
                return r._nextId++
            }, "undefined" == typeof self && "undefined" != typeof process && process.hrtime ? r.now = function () {
                var t = process.hrtime();
                return 1e3 * t[0] + t[1] / 1e6
            } : "undefined" != typeof self && void 0 !== self.performance && void 0 !== self.performance.now ? r.now = self.performance.now.bind(self.performance) : void 0 !== Date.now ? r.now = Date.now : r.now = function () {
                return (new Date).getTime()
            }, r.Tween = function (t, e) {
                this._object = t, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._repeat = 0, this._repeatDelayTime = void 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = null, this._easingFunction = r.Easing.Linear.None, this._interpolationFunction = r.Interpolation.Linear, this._chainedTweens = [], this._onStartCallback = null, this._onStartCallbackFired = !1, this._onUpdateCallback = null, this._onRepeatCallback = null, this._onCompleteCallback = null, this._onStopCallback = null, this._group = e || r, this._id = r.nextId()
            }, r.Tween.prototype = {
                getId: function () {
                    return this._id
                }, isPlaying: function () {
                    return this._isPlaying
                }, to: function (t, e) {
                    return this._valuesEnd = Object.create(t), void 0 !== e && (this._duration = e), this
                }, duration: function (t) {
                    return this._duration = t, this
                }, start: function (t) {
                    for (var e in this._group.add(this), this._isPlaying = !0, this._onStartCallbackFired = !1, this._startTime = void 0 !== t ? "string" == typeof t ? r.now() + parseFloat(t) : t : r.now(), this._startTime += this._delayTime, this._valuesEnd) {
                        if (this._valuesEnd[e] instanceof Array) {
                            if (0 === this._valuesEnd[e].length) continue;
                            this._valuesEnd[e] = [this._object[e]].concat(this._valuesEnd[e])
                        }
                        void 0 !== this._object[e] && (this._valuesStart[e] = this._object[e], this._valuesStart[e] instanceof Array == !1 && (this._valuesStart[e] *= 1), this._valuesStartRepeat[e] = this._valuesStart[e] || 0)
                    }
                    return this
                }, stop: function () {
                    return this._isPlaying ? (this._group.remove(this), this._isPlaying = !1, null !== this._onStopCallback && this._onStopCallback(this._object), this.stopChainedTweens(), this) : this
                }, end: function () {
                    return this.update(1 / 0), this
                }, stopChainedTweens: function () {
                    for (var t = 0, e = this._chainedTweens.length; t < e; t++) this._chainedTweens[t].stop()
                }, group: function (t) {
                    return this._group = t, this
                }, delay: function (t) {
                    return this._delayTime = t, this
                }, repeat: function (t) {
                    return this._repeat = t, this
                }, repeatDelay: function (t) {
                    return this._repeatDelayTime = t, this
                }, yoyo: function (t) {
                    return this._yoyo = t, this
                }, easing: function (t) {
                    return this._easingFunction = t, this
                }, interpolation: function (t) {
                    return this._interpolationFunction = t, this
                }, chain: function () {
                    return this._chainedTweens = arguments, this
                }, onStart: function (t) {
                    return this._onStartCallback = t, this
                }, onUpdate: function (t) {
                    return this._onUpdateCallback = t, this
                }, onRepeat: function (t) {
                    return this._onRepeatCallback = t, this
                }, onComplete: function (t) {
                    return this._onCompleteCallback = t, this
                }, onStop: function (t) {
                    return this._onStopCallback = t, this
                }, update: function (t) {
                    var e, i, n;
                    if (t < this._startTime) return !0;
                    for (e in !1 === this._onStartCallbackFired && (null !== this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), i = (t - this._startTime) / this._duration, i = 0 === this._duration || i > 1 ? 1 : i, n = this._easingFunction(i), this._valuesEnd) if (void 0 !== this._valuesStart[e]) {
                        var r = this._valuesStart[e] || 0, s = this._valuesEnd[e];
                        s instanceof Array ? this._object[e] = this._interpolationFunction(s, n) : ("string" == typeof s && (s = "+" === s.charAt(0) || "-" === s.charAt(0) ? r + parseFloat(s) : parseFloat(s)), "number" == typeof s && (this._object[e] = r + (s - r) * n))
                    }
                    if (null !== this._onUpdateCallback && this._onUpdateCallback(this._object, i), 1 === i) {
                        if (this._repeat > 0) {
                            for (e in isFinite(this._repeat) && this._repeat--, this._valuesStartRepeat) {
                                if ("string" == typeof this._valuesEnd[e] && (this._valuesStartRepeat[e] = this._valuesStartRepeat[e] + parseFloat(this._valuesEnd[e])), this._yoyo) {
                                    var a = this._valuesStartRepeat[e];
                                    this._valuesStartRepeat[e] = this._valuesEnd[e], this._valuesEnd[e] = a
                                }
                                this._valuesStart[e] = this._valuesStartRepeat[e]
                            }
                            return this._yoyo && (this._reversed = !this._reversed), void 0 !== this._repeatDelayTime ? this._startTime = t + this._repeatDelayTime : this._startTime = t + this._delayTime, null !== this._onRepeatCallback && this._onRepeatCallback(this._object), !0
                        }
                        null !== this._onCompleteCallback && this._onCompleteCallback(this._object);
                        for (var o = 0, h = this._chainedTweens.length; o < h; o++) this._chainedTweens[o].start(this._startTime + this._duration);
                        return !1
                    }
                    return !0
                }
            }, r.Easing = {
                Linear: {
                    None: function (t) {
                        return t
                    }
                }, Quadratic: {
                    In: function (t) {
                        return t * t
                    }, Out: function (t) {
                        return t * (2 - t)
                    }, InOut: function (t) {
                        return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
                    }
                }, Cubic: {
                    In: function (t) {
                        return t * t * t
                    }, Out: function (t) {
                        return --t * t * t + 1
                    }, InOut: function (t) {
                        return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
                    }
                }, Quartic: {
                    In: function (t) {
                        return t * t * t * t
                    }, Out: function (t) {
                        return 1 - --t * t * t * t
                    }, InOut: function (t) {
                        return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
                    }
                }, Quintic: {
                    In: function (t) {
                        return t * t * t * t * t
                    }, Out: function (t) {
                        return --t * t * t * t * t + 1
                    }, InOut: function (t) {
                        return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
                    }
                }, Sinusoidal: {
                    In: function (t) {
                        return 1 - Math.cos(t * Math.PI / 2)
                    }, Out: function (t) {
                        return Math.sin(t * Math.PI / 2)
                    }, InOut: function (t) {
                        return .5 * (1 - Math.cos(Math.PI * t))
                    }
                }, Exponential: {
                    In: function (t) {
                        return 0 === t ? 0 : Math.pow(1024, t - 1)
                    }, Out: function (t) {
                        return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
                    }, InOut: function (t) {
                        return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
                    }
                }, Circular: {
                    In: function (t) {
                        return 1 - Math.sqrt(1 - t * t)
                    }, Out: function (t) {
                        return Math.sqrt(1 - --t * t)
                    }, InOut: function (t) {
                        return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
                    }
                }, Elastic: {
                    In: function (t) {
                        return 0 === t ? 0 : 1 === t ? 1 : -Math.pow(2, 10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI)
                    }, Out: function (t) {
                        return 0 === t ? 0 : 1 === t ? 1 : Math.pow(2, -10 * t) * Math.sin(5 * (t - .1) * Math.PI) + 1
                    }, InOut: function (t) {
                        return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? -.5 * Math.pow(2, 10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI) : .5 * Math.pow(2, -10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI) + 1
                    }
                }, Back: {
                    In: function (t) {
                        var e = 1.70158;
                        return t * t * ((e + 1) * t - e)
                    }, Out: function (t) {
                        var e = 1.70158;
                        return --t * t * ((e + 1) * t + e) + 1
                    }, InOut: function (t) {
                        var e = 2.5949095;
                        return (t *= 2) < 1 ? t * t * ((e + 1) * t - e) * .5 : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
                    }
                }, Bounce: {
                    In: function (t) {
                        return 1 - r.Easing.Bounce.Out(1 - t)
                    }, Out: function (t) {
                        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                    }, InOut: function (t) {
                        return t < .5 ? .5 * r.Easing.Bounce.In(2 * t) : .5 * r.Easing.Bounce.Out(2 * t - 1) + .5
                    }
                }
            }, r.Interpolation = {
                Linear: function (t, e) {
                    var i = t.length - 1, n = i * e, s = Math.floor(n), a = r.Interpolation.Utils.Linear;
                    return e < 0 ? a(t[0], t[1], n) : e > 1 ? a(t[i], t[i - 1], i - n) : a(t[s], t[s + 1 > i ? i : s + 1], n - s)
                }, Bezier: function (t, e) {
                    for (var i = 0, n = t.length - 1, s = Math.pow, a = r.Interpolation.Utils.Bernstein, o = 0; o <= n; o++) i += s(1 - e, n - o) * s(e, o) * t[o] * a(n, o);
                    return i
                }, CatmullRom: function (t, e) {
                    var i = t.length - 1, n = i * e, s = Math.floor(n), a = r.Interpolation.Utils.CatmullRom;
                    return t[0] === t[i] ? (e < 0 && (s = Math.floor(n = i * (1 + e))), a(t[(s - 1 + i) % i], t[s], t[(s + 1) % i], t[(s + 2) % i], n - s)) : e < 0 ? t[0] - (a(t[0], t[0], t[1], t[1], -n) - t[0]) : e > 1 ? t[i] - (a(t[i], t[i], t[i - 1], t[i - 1], n - i) - t[i]) : a(t[s ? s - 1 : 0], t[s], t[i < s + 1 ? i : s + 1], t[i < s + 2 ? i : s + 2], n - s)
                }, Utils: {
                    Linear: function (t, e, i) {
                        return (e - t) * i + t
                    }, Bernstein: function (t, e) {
                        var i = r.Interpolation.Utils.Factorial;
                        return i(t) / i(e) / i(t - e)
                    }, Factorial: (n = [1], function (t) {
                        var e = 1;
                        if (n[t]) return n[t];
                        for (var i = t; i > 1; i--) e *= i;
                        return n[t] = e, e
                    }), CatmullRom: function (t, e, i, n, r) {
                        var s = .5 * (i - t), a = .5 * (n - e), o = r * r;
                        return (2 * e - 2 * i + s + a) * (r * o) + (-3 * e + 3 * i - 2 * s - a) * o + s * r + e
                    }
                }
            }, t.exports = r
        }));

        function GE(t = 300, e, i) {
            const n = 500;
            e = e || kE.Info, lb.call(this), this.type = "infospot", this.animated = void 0 === i || i, this.isHovering = !1, this.frustumCulled = !1, this.element = null, this.toPanorama = null, this.cursorStyle = null, this.mode = LE, this.scale.set(t, t, 1), this.rotation.y = Math.PI, this.container = null, this.originalRaycast = this.raycast, this.HANDLER_FOCUS = null, this.material.side = 2, this.material.depthTest = !1, this.material.transparent = !0, this.material.opacity = 0, this.scaleUpAnimation = new VE.Tween, this.scaleDownAnimation = new VE.Tween;
            const r = function (e) {
                if (!this.material) return;
                const i = e.image.width / e.image.height, r = new _m;
                e.image.width = e.image.naturalWidth || 64, e.image.height = e.image.naturalHeight || 64, this.scale.set(i * t, t, 1), r.copy(this.scale), this.scaleUpAnimation = new VE.Tween(this.scale).to({
                    x: 1.3 * r.x,
                    y: 1.3 * r.y
                }, n).easing(VE.Easing.Elastic.Out), this.scaleDownAnimation = new VE.Tween(this.scale).to({
                    x: r.x,
                    y: r.y
                }, n).easing(VE.Easing.Elastic.Out), this.material.map = e, this.material.needsUpdate = !0
            }.bind(this);
            this.showAnimation = new VE.Tween(this.material).to({opacity: 1}, n).onStart(this.enableRaycast.bind(this, !0)).easing(VE.Easing.Quartic.Out), this.hideAnimation = new VE.Tween(this.material).to({opacity: 0}, n).onStart(this.enableRaycast.bind(this, !1)).easing(VE.Easing.Quartic.Out), this.addEventListener("click", this.onClick), this.addEventListener("hover", this.onHover), this.addEventListener("hoverenter", this.onHoverStart), this.addEventListener("hoverleave", this.onHoverEnd), this.addEventListener("panolens-dual-eye-effect", this.onDualEyeEffect), this.addEventListener("panolens-container", this.setContainer.bind(this)), this.addEventListener("dismiss", this.onDismiss), this.addEventListener("panolens-infospot-focus", this.setFocusMethod), zE(e, r)
        }

        function UE(t) {
            t || console.warn("PANOLENS.Widget: No container specified"), Vf.call(this), this.DEFAULT_TRANSITION = "all 0.27s ease", this.TOUCH_ENABLED = !!("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch), this.PREVENT_EVENT_HANDLER = function (t) {
                t.preventDefault(), t.stopPropagation()
            }, this.container = t, this.barElement = null, this.fullscreenElement = null, this.videoElement = null, this.settingElement = null, this.mainMenu = null, this.activeMainItem = null, this.activeSubMenu = null, this.mask = null
        }

        function HE(t, e) {
            rv.call(this, t, e), this.type = "panorama", this.ImageQualityLow = 1, this.ImageQualityFair = 2, this.ImageQualityMedium = 3, this.ImageQualityHigh = 4, this.ImageQualitySuperHigh = 5, this.animationDuration = 1e3, this.defaultInfospotSize = 350, this.container = void 0, this.loaded = !1, this.linkedSpots = [], this.isInfospotVisible = !1, this.linkingImageURL = void 0, this.linkingImageScale = void 0, this.material.side = 1, this.material.opacity = 0, this.scale.x *= -1, this.renderOrder = -1, this.active = !1, this.infospotAnimation = new VE.Tween(this).to({}, this.animationDuration / 2), this.addEventListener("load", this.fadeIn.bind(this)), this.addEventListener("panolens-container", this.setContainer.bind(this)), this.addEventListener("click", this.onClick.bind(this)), this.setupTransitions()
        }

        function WE(t, e, i) {
            const n = e || new wx(5e3, 60, 40), r = i || new nv({opacity: 0, transparent: !0});
            HE.call(this, n, r), this.src = t, this.radius = 5e3
        }

        function qE() {
            const t = new kg, e = new nv({color: 0, opacity: 0, transparent: !0});
            t.addAttribute("position", new _g(new Float32Array, 1)), HE.call(this, t, e)
        }

        function XE(t = []) {
            const e = 1e4, i = Object.assign({}, og.cube), n = new zg(e, e, e), r = new tv({
                fragmentShader: i.fragmentShader,
                vertexShader: i.vertexShader,
                uniforms: i.uniforms,
                side: 1,
                transparent: !0
            });
            HE.call(this, n, r), this.images = t, this.edgeLength = e, this.material.uniforms.opacity.value = 0
        }

        function YE() {
            const t = [];
            for (let e = 0; e < 6; e++) t.push(kE.WhiteTile);
            XE.call(this, t)
        }

        function ZE(t, e = {}) {
            const i = new wx(5e3, 60, 40), n = new nv({opacity: 0, transparent: !0});
            HE.call(this, i, n), this.src = t, this.options = {
                videoElement: document.createElement("video"),
                loop: !0,
                muted: !0,
                autoplay: !1,
                playsinline: !0,
                crossOrigin: "anonymous"
            }, Object.assign(this.options, e), this.videoElement = this.options.videoElement, this.videoProgress = 0, this.radius = 5e3, this.addEventListener("leave", this.pauseVideo.bind(this)), this.addEventListener("enter-fade-start", this.resumeVideoProgress.bind(this)), this.addEventListener("video-toggle", this.toggleVideo.bind(this)), this.addEventListener("video-time", this.setVideoCurrentTime.bind(this))
        }

        function JE(t = {}) {
            let e;
            this._parameters = t, this._zoom = null, this._panoId = null, this._panoClient = new google.maps.StreetViewService, this._count = 0, this._total = 0, this._canvas = [], this._ctx = [], this._wc = 0, this._hc = 0, this.result = null, this.rotation = 0, this.copyright = "", this.onSizeChange = null, this.onPanoramaLoad = null, this.levelsW = [1, 2, 4, 7, 13, 26], this.levelsH = [1, 1, 2, 4, 7, 13], this.widths = [416, 832, 1664, 3328, 6656, 13312], this.heights = [416, 416, 832, 1664, 3328, 6656], this.maxW = 6656, this.maxH = 6656;
            try {
                const t = document.createElement("canvas");
                e = t.getContext("experimental-webgl"), e || (e = t.getContext("webgl"))
            } catch (t) {
            }
            this.maxW = Math.max(e.getParameter(e.MAX_TEXTURE_SIZE), this.maxW), this.maxH = Math.max(e.getParameter(e.MAX_TEXTURE_SIZE), this.maxH)
        }

        function QE(t, e) {
            WE.call(this), this.panoId = t, this.gsvLoader = null, this.loadRequested = !1, this.setupGoogleMapAPI(e)
        }

        GE.prototype = Object.assign(Object.create(lb.prototype), {
            constructor: GE, setContainer: function (t) {
                let e;
                t instanceof HTMLElement ? e = t : t && t.container && (e = t.container), e && this.element && e.appendChild(this.element), this.container = e
            }, getContainer: function () {
                return this.container
            }, onClick: function (t) {
                this.element && this.getContainer() && (this.onHoverStart(t), this.lockHoverElement())
            }, onDismiss: function () {
                this.element && (this.unlockHoverElement(), this.onHoverEnd())
            }, onHover: function () {
            }, onHoverStart: function (t) {
                if (!this.getContainer()) return;
                const e = this.cursorStyle || (this.mode === LE ? "pointer" : "default"), {
                    scaleDownAnimation: i,
                    scaleUpAnimation: n,
                    element: r
                } = this;
                if (this.isHovering = !0, this.container.style.cursor = e, this.animated && (i.stop(), n.start()), r && t.mouseEvent.clientX >= 0 && t.mouseEvent.clientY >= 0) {
                    const {left: t, right: e, style: i} = r;
                    this.mode === RE || this.mode === FE ? (i.display = "none", t.style.display = "block", e.style.display = "block", r._width = t.clientWidth, r._height = t.clientHeight) : (i.display = "block", t && (t.style.display = "none"), e && (e.style.display = "none"), r._width = r.clientWidth, r._height = r.clientHeight)
                }
            }, onHoverEnd: function () {
                if (!this.getContainer()) return;
                const {scaleDownAnimation: t, scaleUpAnimation: e, element: i} = this;
                if (this.isHovering = !1, this.container.style.cursor = "default", this.animated && (e.stop(), t.start()), i && !this.element.locked) {
                    const {left: t, right: e, style: n} = i;
                    n.display = "none", t && (t.style.display = "none"), e && (e.style.display = "none"), this.unlockHoverElement()
                }
            }, onDualEyeEffect: function (t) {
                if (!this.getContainer()) return;
                let e, i, n;
                this.mode = t.mode, e = this.element, i = this.container.clientWidth / 2, n = this.container.clientHeight / 2, e && (e.left || e.right || (e.left = e.cloneNode(!0), e.right = e.cloneNode(!0)), this.mode === RE || this.mode === FE ? (e.left.style.display = e.style.display, e.right.style.display = e.style.display, e.style.display = "none") : (e.style.display = e.left.style.display, e.left.style.display = "none", e.right.style.display = "none"), this.translateElement(i, n), this.container.appendChild(e.left), this.container.appendChild(e.right))
            }, translateElement: function (t, e) {
                if (!this.element._width || !this.element._height || !this.getContainer()) return;
                let i, n, r, s, a, o, h;
                h = this.container, r = this.element, s = r._width / 2, a = r._height / 2, o = void 0 !== r.verticalDelta ? r.verticalDelta : 40, i = t - s, n = e - a - o, this.mode !== RE && this.mode !== FE || !r.left || !r.right || t === h.clientWidth / 2 && e === h.clientHeight / 2 ? this.setElementStyle("transform", r, "translate(" + i + "px, " + n + "px)") : (i = h.clientWidth / 4 - s + (t - h.clientWidth / 2), n = h.clientHeight / 2 - a - o + (e - h.clientHeight / 2), this.setElementStyle("transform", r.left, "translate(" + i + "px, " + n + "px)"), i += h.clientWidth / 2, this.setElementStyle("transform", r.right, "translate(" + i + "px, " + n + "px)"))
            }, setElementStyle: function (t, e, i) {
                const n = e.style;
                "transform" === t && (n.webkitTransform = n.msTransform = n.transform = i)
            }, setText: function (t) {
                this.element && (this.element.textContent = t)
            }, setCursorHoverStyle: function (t) {
                this.cursorStyle = t
            }, addHoverText: function (t, e = 40) {
                this.element || (this.element = document.createElement("div"), this.element.style.display = "none", this.element.style.color = "#fff", this.element.style.top = 0, this.element.style.maxWidth = "50%", this.element.style.maxHeight = "50%", this.element.style.textShadow = "0 0 3px #000000", this.element.style.fontFamily = '"Trebuchet MS", Helvetica, sans-serif', this.element.style.position = "absolute", this.element.classList.add("panolens-infospot"), this.element.verticalDelta = e), this.setText(t)
            }, addHoverElement: function (t, e = 40) {
                this.element || (this.element = t.cloneNode(!0), this.element.style.display = "none", this.element.style.top = 0, this.element.style.position = "absolute", this.element.classList.add("panolens-infospot"), this.element.verticalDelta = e)
            }, removeHoverElement: function () {
                this.element && (this.element.left && (this.container.removeChild(this.element.left), this.element.left = null), this.element.right && (this.container.removeChild(this.element.right), this.element.right = null), this.container.removeChild(this.element), this.element = null)
            }, lockHoverElement: function () {
                this.element && (this.element.locked = !0)
            }, unlockHoverElement: function () {
                this.element && (this.element.locked = !1)
            }, enableRaycast: function (t = !0) {
                this.raycast = t ? this.originalRaycast : () => {
                }
            }, show: function (t = 0) {
                const {animated: e, hideAnimation: i, showAnimation: n, material: r} = this;
                e ? (i.stop(), n.delay(t).start()) : (this.enableRaycast(!0), r.opacity = 1)
            }, hide: function (t = 0) {
                const {animated: e, hideAnimation: i, showAnimation: n, material: r, element: s} = this;
                if (s) {
                    const {style: t} = s;
                    t.display = "none"
                }
                e ? (n.stop(), i.delay(t).start()) : (this.enableRaycast(!1), r.opacity = 0)
            }, setFocusMethod: function (t) {
                t && (this.HANDLER_FOCUS = t.method)
            }, focus: function (t, e) {
                this.HANDLER_FOCUS && (this.HANDLER_FOCUS(this.position, t, e), this.onDismiss())
            }, dispose: function () {
                const {geometry: t, material: e} = this, {map: i} = e;
                this.removeHoverElement(), this.parent && this.parent.remove(this), i && (i.dispose(), e.map = null), t && (t.dispose(), this.geometry = null), e && (e.dispose(), this.material = null)
            }
        }), UE.prototype = Object.assign(Object.create(Vf.prototype), {
            constructor: UE, addControlBar: function () {
                if (this.container) {
                    var t, e, i, n, r = this;
                    n = "linear-gradient(bottom, rgba(0,0,0,0.2), rgba(0,0,0,0))", (t = document.createElement("div")).style.width = "100%", t.style.height = "44px", t.style.float = "left", t.style.transform = t.style.webkitTransform = t.style.msTransform = "translateY(-100%)", t.style.background = "-webkit-" + n, t.style.background = "-moz-" + n, t.style.background = "-o-" + n, t.style.background = "-ms-" + n, t.style.background = n, t.style.transition = this.DEFAULT_TRANSITION, t.style.pointerEvents = "none", t.isHidden = !1, t.toggle = function () {
                        t.isHidden = !t.isHidden, e = t.isHidden ? "translateY(0)" : "translateY(-100%)", i = t.isHidden ? 0 : 1, t.style.transform = t.style.webkitTransform = t.style.msTransform = e, t.style.opacity = i
                    };
                    var s = this.createDefaultMenu();
                    this.mainMenu = this.createMainMenu(s), t.appendChild(this.mainMenu);
                    var a = this.createMask();
                    this.mask = a, this.container.appendChild(a), t.dispose = function () {
                        r.fullscreenElement && (t.removeChild(r.fullscreenElement), r.fullscreenElement.dispose(), r.fullscreenElement = null), r.settingElement && (t.removeChild(r.settingElement), r.settingElement.dispose(), r.settingElement = null), r.videoElement && (t.removeChild(r.videoElement), r.videoElement.dispose(), r.videoElement = null)
                    }, this.container.appendChild(t), this.mask.addEventListener("mousemove", this.PREVENT_EVENT_HANDLER, !0), this.mask.addEventListener("mouseup", this.PREVENT_EVENT_HANDLER, !0), this.mask.addEventListener("mousedown", this.PREVENT_EVENT_HANDLER, !0), this.mask.addEventListener(r.TOUCH_ENABLED ? "touchend" : "click", (function (t) {
                        t.preventDefault(), t.stopPropagation(), r.mask.hide(), r.settingElement.deactivate()
                    }), !1), this.addEventListener("control-bar-toggle", t.toggle), this.barElement = t
                } else console.warn("Widget container not set")
            }, createDefaultMenu: function () {
                var t, e = this;
                return t = function (t, i) {
                    return function () {
                        e.dispatchEvent({type: "panolens-viewer-handler", method: t, data: i})
                    }
                }, [{
                    title: "Control",
                    subMenu: [{
                        title: this.TOUCH_ENABLED ? "Touch" : "Mouse",
                        handler: t("enableControl", PE)
                    }, {title: "Sensor", handler: t("enableControl", IE)}]
                }, {
                    title: "Mode",
                    subMenu: [{title: "Normal", handler: t("disableEffect")}, {
                        title: "Cardboard",
                        handler: t("enableEffect", RE)
                    }, {title: "Stereoscopic", handler: t("enableEffect", FE)}]
                }]
            }, addControlButton: function (t) {
                let e;
                switch (t) {
                    case"fullscreen":
                        e = this.createFullscreenButton(), this.fullscreenElement = e;
                        break;
                    case"setting":
                        e = this.createSettingButton(), this.settingElement = e;
                        break;
                    case"video":
                        e = this.createVideoControl(), this.videoElement = e;
                        break;
                    default:
                        return
                }
                e && this.barElement.appendChild(e)
            }, createMask: function () {
                const t = document.createElement("div");
                return t.style.position = "absolute", t.style.top = 0, t.style.left = 0, t.style.width = "100%", t.style.height = "100%", t.style.background = "transparent", t.style.display = "none", t.show = function () {
                    this.style.display = "block"
                }, t.hide = function () {
                    this.style.display = "none"
                }, t
            }, createSettingButton: function () {
                let t, e = this;
                return t = this.createCustomItem({
                    style: {
                        backgroundImage: 'url("' + kE.Setting + '")',
                        webkitTransition: this.DEFAULT_TRANSITION,
                        transition: this.DEFAULT_TRANSITION
                    }, onTap: function (t) {
                        t.preventDefault(), t.stopPropagation(), e.mainMenu.toggle(), this.activated ? this.deactivate() : this.activate()
                    }
                }), t.activate = function () {
                    this.style.transform = "rotate3d(0,0,1,90deg)", this.activated = !0, e.mask.show()
                }, t.deactivate = function () {
                    this.style.transform = "rotate3d(0,0,0,0)", this.activated = !1, e.mask.hide(), e.mainMenu && e.mainMenu.visible && e.mainMenu.hide(), e.activeSubMenu && e.activeSubMenu.visible && e.activeSubMenu.hide(), e.mainMenu && e.mainMenu._width && (e.mainMenu.changeSize(e.mainMenu._width), e.mainMenu.unslideAll())
                }, t.activated = !1, t
            }, createFullscreenButton: function () {
                let t, e, i = this, n = !1, r = !0;
                const {container: s} = this;
                if (e = "panolens-style-addon", document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled) {
                    if (document.addEventListener("fullscreenchange", a, !1), document.addEventListener("webkitfullscreenchange", a, !1), document.addEventListener("mozfullscreenchange", a, !1), document.addEventListener("MSFullscreenChange", a, !1), t = this.createCustomItem({
                        style: {backgroundImage: 'url("' + kE.FullscreenEnter + '")'},
                        onTap: function (t) {
                            t.preventDefault(), t.stopPropagation(), r = !1, n ? (document.exitFullscreen && document.exitFullscreen(), document.msExitFullscreen && document.msExitFullscreen(), document.mozCancelFullScreen && document.mozCancelFullScreen(), document.webkitExitFullscreen && document.webkitExitFullscreen(), n = !1) : (s.requestFullscreen && s.requestFullscreen(), s.msRequestFullscreen && s.msRequestFullscreen(), s.mozRequestFullScreen && s.mozRequestFullScreen(), s.webkitRequestFullscreen && s.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT), n = !0), this.style.backgroundImage = n ? 'url("' + kE.FullscreenLeave + '")' : 'url("' + kE.FullscreenEnter + '")'
                        }
                    }), !document.querySelector(e)) {
                        const t = document.createElement("style");
                        t.id = e, t.innerHTML = ":-webkit-full-screen { width: 100% !important; height: 100% !important }", document.body.appendChild(t)
                    }
                    return t
                }

                function a() {
                    r && (n = !n, t.style.backgroundImage = n ? 'url("' + kE.FullscreenLeave + '")' : 'url("' + kE.FullscreenEnter + '")'), i.dispatchEvent({
                        type: "panolens-viewer-handler",
                        method: "onWindowResize"
                    }), r = !0
                }
            }, createVideoControl: function () {
                const t = document.createElement("span");
                return t.style.display = "none", t.show = function () {
                    t.style.display = ""
                }, t.hide = function () {
                    t.style.display = "none", t.controlButton.paused = !0, t.controlButton.update()
                }, t.controlButton = this.createVideoControlButton(), t.seekBar = this.createVideoControlSeekbar(), t.appendChild(t.controlButton), t.appendChild(t.seekBar), t.dispose = function () {
                    t.removeChild(t.controlButton), t.removeChild(t.seekBar), t.controlButton.dispose(), t.controlButton = null, t.seekBar.dispose(), t.seekBar = null
                }, this.addEventListener("video-control-show", t.show), this.addEventListener("video-control-hide", t.hide), t
            }, createVideoControlButton: function () {
                const t = this;
                const e = this.createCustomItem({
                    style: {float: "left", backgroundImage: 'url("' + kE.VideoPlay + '")'},
                    onTap: function (i) {
                        i.preventDefault(), i.stopPropagation(), t.dispatchEvent({
                            type: "panolens-viewer-handler",
                            method: "toggleVideoPlay",
                            data: !this.paused
                        }), this.paused = !this.paused, e.update()
                    }
                });
                return e.paused = !0, e.update = function (t) {
                    this.paused = void 0 !== t ? t : this.paused, this.style.backgroundImage = 'url("' + (this.paused ? kE.VideoPlay : kE.VideoPause) + '")'
                }, e
            }, createVideoControlSeekbar: function () {
                let t, e, i, n, r, s, a = this, o = !1;

                function h(t) {
                    t.stopPropagation(), o = !0, n = t.clientX || t.changedTouches && t.changedTouches[0].clientX, r = parseInt(e.style.width) / 100, a.container.addEventListener("mousemove", l, {passive: !0}), a.container.addEventListener("mouseup", c, {passive: !0}), a.container.addEventListener("touchmove", l, {passive: !0}), a.container.addEventListener("touchend", c, {passive: !0})
                }

                function l(e) {
                    if (o) {
                        const i = e.clientX || e.changedTouches && e.changedTouches[0].clientX;
                        s = (i - n) / t.clientWidth, s = r + s, s = s > 1 ? 1 : s < 0 ? 0 : s, t.setProgress(s), a.dispatchEvent({
                            type: "panolens-viewer-handler",
                            method: "setVideoCurrentTime",
                            data: s
                        })
                    }
                }

                function c(t) {
                    t.stopPropagation(), o = !1, u()
                }

                function u() {
                    a.container.removeEventListener("mousemove", l, !1), a.container.removeEventListener("mouseup", c, !1), a.container.removeEventListener("touchmove", l, !1), a.container.removeEventListener("touchend", c, !1)
                }

                return e = document.createElement("div"), e.style.width = "0%", e.style.height = "100%", e.style.backgroundColor = "#fff", i = document.createElement("div"), i.style.float = "right", i.style.width = "14px", i.style.height = "14px", i.style.transform = "translate(7px, -5px)", i.style.borderRadius = "50%", i.style.backgroundColor = "#ddd", i.addEventListener("mousedown", h, {passive: !0}), i.addEventListener("touchstart", h, {passive: !0}), e.appendChild(i), t = this.createCustomItem({
                    style: {
                        float: "left",
                        width: "30%",
                        height: "4px",
                        marginTop: "20px",
                        backgroundColor: "rgba(188,188,188,0.8)"
                    }, onTap: function (e) {
                        if (e.preventDefault(), e.stopPropagation(), e.target === i) return;
                        const n = e.changedTouches && e.changedTouches.length > 0 ? (e.changedTouches[0].pageX - e.target.getBoundingClientRect().left) / this.clientWidth : e.offsetX / this.clientWidth;
                        a.dispatchEvent({
                            type: "panolens-viewer-handler",
                            method: "setVideoCurrentTime",
                            data: n
                        }), t.setProgress(e.offsetX / this.clientWidth)
                    }, onDispose: function () {
                        u(), e = null, i = null
                    }
                }), t.appendChild(e), t.setProgress = function (t) {
                    e.style.width = 100 * t + "%"
                }, this.addEventListener("video-update", (function (e) {
                    t.setProgress(e.percentage)
                })), t.progressElement = e, t.progressElementControl = i, t
            }, createMenuItem: function (t) {
                const e = this, i = document.createElement("a");
                return i.textContent = t, i.style.display = "block", i.style.padding = "10px", i.style.textDecoration = "none", i.style.cursor = "pointer", i.style.pointerEvents = "auto", i.style.transition = this.DEFAULT_TRANSITION, i.slide = function (t) {
                    this.style.transform = "translateX(" + (t ? "" : "-") + "100%)"
                }, i.unslide = function () {
                    this.style.transform = "translateX(0)"
                }, i.setIcon = function (t) {
                    this.icon && (this.icon.style.backgroundImage = "url(" + t + ")")
                }, i.setSelectionTitle = function (t) {
                    this.selection && (this.selection.textContent = t)
                }, i.addSelection = function (t) {
                    const e = document.createElement("span");
                    return e.style.fontSize = "13px", e.style.fontWeight = "300", e.style.float = "right", this.selection = e, this.setSelectionTitle(t), this.appendChild(e), this
                }, i.addIcon = function (t = kE.ChevronRight, e = !1, i = !1) {
                    const n = document.createElement("span");
                    return n.style.float = e ? "left" : "right", n.style.width = "17px", n.style.height = "17px", n.style["margin" + (e ? "Right" : "Left")] = "12px", n.style.backgroundSize = "cover", i && (n.style.transform = "rotateZ(180deg)"), this.icon = n, this.setIcon(t), this.appendChild(n), this
                }, i.addSubMenu = function (t, i) {
                    return this.subMenu = e.createSubMenu(t, i), this
                }, i.addEventListener("mouseenter", (function () {
                    this.style.backgroundColor = "#e0e0e0"
                }), !1), i.addEventListener("mouseleave", (function () {
                    this.style.backgroundColor = "#fafafa"
                }), !1), i
            }, createMenuItemHeader: function (t) {
                const e = this.createMenuItem(t);
                return e.style.borderBottom = "1px solid #333", e.style.paddingBottom = "15px", e
            }, createMainMenu: function (t) {
                let e = this, i = this.createMenu();

                function n(t) {
                    t.preventDefault(), t.stopPropagation();
                    let i = e.mainMenu, n = this.subMenu;
                    i.hide(), i.slideAll(), i.parentElement.appendChild(n), e.activeMainItem = this, e.activeSubMenu = n, window.requestAnimationFrame((function () {
                        i.changeSize(n.clientWidth), n.show(), n.unslideAll()
                    }))
                }

                i._width = 200, i.changeSize(i._width);
                for (var r = 0; r < t.length; r++) {
                    var s = i.addItem(t[r].title);
                    if (s.style.paddingLeft = "20px", s.addIcon().addEventListener(e.TOUCH_ENABLED ? "touchend" : "click", n, !1), t[r].subMenu && t[r].subMenu.length > 0) {
                        var a = t[r].subMenu[0].title;
                        s.addSelection(a).addSubMenu(t[r].title, t[r].subMenu)
                    }
                }
                return i
            }, createSubMenu: function (t, e) {
                let i, n = this, r = this.createMenu();

                function s(t) {
                    t.preventDefault(), t.stopPropagation(), i = n.mainMenu, i.changeSize(i._width), i.unslideAll(), i.show(), r.slideAll(!0), r.hide(), "header" !== this.type && (r.setActiveItem(this), n.activeMainItem.setSelectionTitle(this.textContent), this.handler && this.handler())
                }

                r.items = e, r.activeItem = null, r.addHeader(t).addIcon(void 0, !0, !0).addEventListener(n.TOUCH_ENABLED ? "touchend" : "click", s, !1);
                for (let t = 0; t < e.length; t++) {
                    const i = r.addItem(e[t].title);
                    i.style.fontWeight = 300, i.handler = e[t].handler, i.addIcon(" ", !0), i.addEventListener(n.TOUCH_ENABLED ? "touchend" : "click", s, !1), r.activeItem || r.setActiveItem(i)
                }
                return r.slideAll(!0), r
            }, createMenu: function () {
                const t = this, e = document.createElement("span"), i = e.style;
                return i.padding = "5px 0", i.position = "fixed", i.bottom = "100%", i.right = "14px", i.backgroundColor = "#fafafa", i.fontFamily = "Helvetica Neue", i.fontSize = "14px", i.visibility = "hidden", i.opacity = 0, i.boxShadow = "0 0 12pt rgba(0,0,0,0.25)", i.borderRadius = "2px", i.overflow = "hidden", i.willChange = "width, height, opacity", i.pointerEvents = "auto", i.transition = this.DEFAULT_TRANSITION, e.visible = !1, e.changeSize = function (t, e) {
                    t && (this.style.width = t + "px"), e && (this.style.height = e + "px")
                }, e.show = function () {
                    this.style.opacity = 1, this.style.visibility = "visible", this.visible = !0
                }, e.hide = function () {
                    this.style.opacity = 0, this.style.visibility = "hidden", this.visible = !1
                }, e.toggle = function () {
                    this.visible ? this.hide() : this.show()
                }, e.slideAll = function (t) {
                    for (let i = 0; i < e.children.length; i++) e.children[i].slide && e.children[i].slide(t)
                }, e.unslideAll = function () {
                    for (let t = 0; t < e.children.length; t++) e.children[t].unslide && e.children[t].unslide()
                }, e.addHeader = function (e) {
                    const i = t.createMenuItemHeader(e);
                    return i.type = "header", this.appendChild(i), i
                }, e.addItem = function (e) {
                    const i = t.createMenuItem(e);
                    return i.type = "item", this.appendChild(i), i
                }, e.setActiveItem = function (t) {
                    this.activeItem && this.activeItem.setIcon(" "), t.setIcon(kE.Check), this.activeItem = t
                }, e.addEventListener("mousemove", this.PREVENT_EVENT_HANDLER, !0), e.addEventListener("mouseup", this.PREVENT_EVENT_HANDLER, !0), e.addEventListener("mousedown", this.PREVENT_EVENT_HANDLER, !0), e
            }, createCustomItem: function (t = {}) {
                const e = this, i = t.element || document.createElement("span"), {onDispose: n} = t;
                return i.style.cursor = "pointer", i.style.float = "right", i.style.width = "44px", i.style.height = "100%", i.style.backgroundSize = "60%", i.style.backgroundRepeat = "no-repeat", i.style.backgroundPosition = "center", i.style.webkitUserSelect = i.style.MozUserSelect = i.style.userSelect = "none", i.style.position = "relative", i.style.pointerEvents = "auto", i.addEventListener(e.TOUCH_ENABLED ? "touchstart" : "mouseenter", (function () {
                    i.style.filter = i.style.webkitFilter = "drop-shadow(0 0 5px rgba(255,255,255,1))"
                }), {passive: !0}), i.addEventListener(e.TOUCH_ENABLED ? "touchend" : "mouseleave", (function () {
                    i.style.filter = i.style.webkitFilter = ""
                }), {passive: !0}), this.mergeStyleOptions(i, t.style), t.onTap && i.addEventListener(e.TOUCH_ENABLED ? "touchend" : "click", t.onTap, !1), i.dispose = function () {
                    i.removeEventListener(e.TOUCH_ENABLED ? "touchend" : "click", t.onTap, !1), n && t.onDispose()
                }, i
            }, mergeStyleOptions: function (t, e = {}) {
                for (let i in e) e.hasOwnProperty(i) && (t.style[i] = e[i]);
                return t
            }, dispose: function () {
                this.barElement && (this.container.removeChild(this.barElement), this.barElement.dispose(), this.barElement = null)
            }
        }), HE.prototype = Object.assign(Object.create(rv.prototype), {
            constructor: HE, add: function (t) {
                let e;
                if (arguments.length > 1) {
                    for (var i = 0; i < arguments.length; i++) this.add(arguments[i]);
                    return this
                }
                if (t instanceof GE) {
                    if (e = t, t.dispatchEvent) {
                        const {container: e} = this;
                        e && t.dispatchEvent({
                            type: "panolens-container",
                            container: e
                        }), t.dispatchEvent({
                            type: "panolens-infospot-focus", method: function (t, e, i) {
                                this.dispatchEvent({
                                    type: "panolens-viewer-handler",
                                    method: "tweenControlCenter",
                                    data: [t, e, i]
                                })
                            }.bind(this)
                        })
                    }
                } else e = new vg, e.scale.x = -1, e.scalePlaceHolder = !0, e.add(t);
                vg.prototype.add.call(this, e)
            }, load: function () {
                this.onLoad()
            }, onClick: function (t) {
                t.intersects && 0 === t.intersects.length && this.traverse((function (t) {
                    t.dispatchEvent({type: "dismiss"})
                }))
            }, setContainer: function (t) {
                let e;
                t instanceof HTMLElement ? e = t : t && t.container && (e = t.container), e && (this.children.forEach((function (t) {
                    t instanceof GE && t.dispatchEvent && t.dispatchEvent({type: "panolens-container", container: e})
                })), this.container = e)
            }, onLoad: function () {
                this.loaded = !0, this.dispatchEvent({type: "load"})
            }, onProgress: function (t) {
                this.dispatchEvent({type: "progress", progress: t})
            }, onError: function () {
                this.dispatchEvent({type: "error"})
            }, getZoomLevel: function () {
                let t;
                return t = window.innerWidth <= 800 ? this.ImageQualityFair : window.innerWidth > 800 && window.innerWidth <= 1280 ? this.ImageQualityMedium : window.innerWidth > 1280 && window.innerWidth <= 1920 ? this.ImageQualityHigh : window.innerWidth > 1920 ? this.ImageQualitySuperHigh : this.ImageQualityLow, t
            }, updateTexture: function (t) {
                this.material.map = t, this.material.needsUpdate = !0
            }, toggleInfospotVisibility: function (t, e) {
                e = void 0 !== e ? e : 0;
                const i = void 0 !== t ? t : !this.isInfospotVisible;
                this.traverse((function (t) {
                    t instanceof GE && (i ? t.show(e) : t.hide(e))
                })), this.isInfospotVisible = i, this.infospotAnimation.onComplete(function () {
                    this.dispatchEvent({type: "infospot-animation-complete", visible: i})
                }.bind(this)).delay(e).start()
            }, setLinkingImage: function (t, e) {
                this.linkingImageURL = t, this.linkingImageScale = e
            }, link: function (t, e, i, n) {
                let r, s;
                if (this.visible = !0, !e) return void console.warn("Please specify infospot position for linking");
                r = void 0 !== i ? i : void 0 !== t.linkingImageScale ? t.linkingImageScale : 300, s = n || (t.linkingImageURL ? t.linkingImageURL : kE.Arrow);
                const a = new GE(r, s);
                a.position.copy(e), a.toPanorama = t, a.addEventListener("click", function () {
                    this.dispatchEvent({type: "panolens-viewer-handler", method: "setPanorama", data: t})
                }.bind(this)), this.linkedSpots.push(a), this.add(a), this.visible = !1
            }, reset: function () {
                this.children.length = 0
            }, setupTransitions: function () {
                this.fadeInAnimation = new VE.Tween(this.material).easing(VE.Easing.Quartic.Out).onStart(function () {
                    this.visible = !0, this.dispatchEvent({type: "enter-fade-start"})
                }.bind(this)), this.fadeOutAnimation = new VE.Tween(this.material).easing(VE.Easing.Quartic.Out).onComplete(function () {
                    this.visible = !1, this.dispatchEvent({type: "leave-complete"})
                }.bind(this)), this.enterTransition = new VE.Tween(this).easing(VE.Easing.Quartic.Out).onComplete(function () {
                    this.dispatchEvent({type: "enter-complete"})
                }.bind(this)).start(), this.leaveTransition = new VE.Tween(this).easing(VE.Easing.Quartic.Out)
            }, onFadeAnimationUpdate: function () {
                const t = this.material.opacity, {uniforms: e} = this.material;
                e && e.opacity && (e.opacity.value = t)
            }, fadeIn: function (t) {
                t = t >= 0 ? t : this.animationDuration, this.fadeOutAnimation.stop(), this.fadeInAnimation.to({opacity: 1}, t).onUpdate(this.onFadeAnimationUpdate.bind(this)).onComplete(function () {
                    this.toggleInfospotVisibility(!0, t / 2), this.dispatchEvent({type: "enter-fade-complete"})
                }.bind(this)).start()
            }, fadeOut: function (t) {
                t = t >= 0 ? t : this.animationDuration, this.fadeInAnimation.stop(), this.fadeOutAnimation.to({opacity: 0}, t).onUpdate(this.onFadeAnimationUpdate.bind(this)).start()
            }, onEnter: function () {
                const t = this.animationDuration;
                this.leaveTransition.stop(), this.enterTransition.to({}, t).onStart(function () {
                    this.dispatchEvent({type: "enter-start"}), this.loaded ? this.fadeIn(t) : this.load()
                }.bind(this)).start(), this.dispatchEvent({type: "enter"}), this.children.forEach((t => {
                    t.dispatchEvent({type: "panorama-enter"})
                })), this.active = !0
            }, onLeave: function () {
                const t = this.animationDuration;
                this.enterTransition.stop(), this.leaveTransition.to({}, t).onStart(function () {
                    this.dispatchEvent({type: "leave-start"}), this.fadeOut(t), this.toggleInfospotVisibility(!1)
                }.bind(this)).start(), this.dispatchEvent({type: "leave"}), this.children.forEach((t => {
                    t.dispatchEvent({type: "panorama-leave"})
                })), this.active = !1
            }, dispose: function () {
                this.infospotAnimation.stop(), this.fadeInAnimation.stop(), this.fadeOutAnimation.stop(), this.enterTransition.stop(), this.leaveTransition.stop(), this.dispatchEvent({
                    type: "panolens-viewer-handler",
                    method: "onPanoramaDispose",
                    data: this
                }), function t(e) {
                    const {geometry: i, material: n} = e;
                    for (var r = e.children.length - 1; r >= 0; r--) t(e.children[r]), e.remove(e.children[r]);
                    e instanceof GE && e.dispose(), i && (i.dispose(), e.geometry = null), n && (n.dispose(), e.material = null)
                }(this), this.parent && this.parent.remove(this)
            }
        }), WE.prototype = Object.assign(Object.create(HE.prototype), {
            constructor: WE, load: function (t) {
                (t = t || this.src) ? "string" == typeof t ? zE(t, this.onLoad.bind(this), this.onProgress.bind(this), this.onError.bind(this)) : t instanceof HTMLImageElement && this.onLoad(new jm(t)) : console.warn("Image source undefined")
            }, onLoad: function (t) {
                t.minFilter = t.magFilter = em, t.needsUpdate = !0, this.updateTexture(t), window.requestAnimationFrame(HE.prototype.onLoad.bind(this))
            }, reset: function () {
                HE.prototype.reset.call(this)
            }, dispose: function () {
                const {material: {map: t}} = this;
                lw.remove(this.src), t && t.dispose(), HE.prototype.dispose.call(this)
            }
        }), qE.prototype = Object.assign(Object.create(HE.prototype), {constructor: qE}), XE.prototype = Object.assign(Object.create(HE.prototype), {
            constructor: XE,
            load: function () {
                BE(this.images, this.onLoad.bind(this), this.onProgress.bind(this), this.onError.bind(this))
            },
            onLoad: function (t) {
                this.material.uniforms.tCube.value = t, HE.prototype.onLoad.call(this)
            },
            dispose: function () {
                const {value: t} = this.material.uniforms.tCube;
                this.images.forEach((t => {
                    lw.remove(t)
                })), t instanceof gv && t.dispose(), HE.prototype.dispose.call(this)
            }
        }), YE.prototype = Object.assign(Object.create(XE.prototype), {constructor: YE}), ZE.prototype = Object.assign(Object.create(HE.prototype), {
            constructor: ZE, isMobile: function () {
                let t = !1;
                var e;
                return e = window.navigator.userAgent || window.navigator.vendor || window.opera, (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0, 4))) && (t = !0), t
            }, load: function () {
                const {muted: t, loop: e, autoplay: i, playsinline: n, crossOrigin: r} = this.options,
                    s = this.videoElement, a = this.material, o = this.onProgress.bind(this),
                    h = this.onLoad.bind(this);
                s.loop = e, s.autoplay = i, s.playsinline = n, s.crossOrigin = r, s.muted = t, n && (s.setAttribute("playsinline", ""), s.setAttribute("webkit-playsinline", ""));
                const l = function () {
                    this.setVideoTexture(s), i && this.dispatchEvent({
                        type: "panolens-viewer-handler",
                        method: "updateVideoPlayButton",
                        data: !1
                    }), this.isMobile() && (s.pause(), i && t ? this.dispatchEvent({
                        type: "panolens-viewer-handler",
                        method: "updateVideoPlayButton",
                        data: !1
                    }) : this.dispatchEvent({
                        type: "panolens-viewer-handler",
                        method: "updateVideoPlayButton",
                        data: !0
                    }));
                    window.requestAnimationFrame((() => {
                        a.map.needsUpdate = !0, o({loaded: 1, total: 1}), h()
                    }))
                };
                if (s.readyState > 2) l.call(this); else {
                    if (0 === s.querySelectorAll("source").length) {
                        const t = document.createElement("source");
                        t.src = this.src, s.appendChild(t)
                    }
                    s.load()
                }
                s.addEventListener("loadeddata", l.bind(this)), s.addEventListener("timeupdate", function () {
                    this.videoProgress = s.duration >= 0 ? s.currentTime / s.duration : 0, this.dispatchEvent({
                        type: "panolens-viewer-handler",
                        method: "onVideoUpdate",
                        data: this.videoProgress
                    })
                }.bind(this)), s.addEventListener("ended", function () {
                    e || (this.resetVideo(), this.dispatchEvent({
                        type: "panolens-viewer-handler",
                        method: "updateVideoPlayButton",
                        data: !0
                    }))
                }.bind(this), !1)
            }, setVideoTexture: function (t) {
                if (!t) return;
                const e = new xb(t);
                e.minFilter = em, e.magFilter = em, e.format = hm, this.updateTexture(e)
            }, reset: function () {
                this.videoElement = void 0, HE.prototype.reset.call(this)
            }, isVideoPaused: function () {
                return this.videoElement.paused
            }, toggleVideo: function () {
                const t = this.videoElement;
                t && t[t.paused ? "play" : "pause"]()
            }, setVideoCurrentTime: function ({percentage: t}) {
                const e = this.videoElement;
                e && !Number.isNaN(t) && 1 !== t && (e.currentTime = e.duration * t, this.dispatchEvent({
                    type: "panolens-viewer-handler",
                    method: "onVideoUpdate",
                    data: t
                }))
            }, playVideo: function () {
                const t = this.videoElement, e = this.playVideo.bind(this), i = this.dispatchEvent.bind(this),
                    n = () => {
                        i({type: "play"})
                    }, r = t => {
                        window.requestAnimationFrame(e), i({type: "play-error", error: t})
                    };
                t && t.paused && t.play().then(n).catch(r)
            }, pauseVideo: function () {
                const t = this.videoElement;
                t && !t.paused && t.pause(), this.dispatchEvent({type: "pause"})
            }, resumeVideoProgress: function () {
                const t = this.videoElement;
                t.readyState >= 4 && t.autoplay && !this.isMobile() ? (this.playVideo(), this.dispatchEvent({
                    type: "panolens-viewer-handler",
                    method: "updateVideoPlayButton",
                    data: !1
                })) : (this.pauseVideo(), this.dispatchEvent({
                    type: "panolens-viewer-handler",
                    method: "updateVideoPlayButton",
                    data: !0
                })), this.setVideoCurrentTime({percentage: this.videoProgress})
            }, resetVideo: function () {
                this.videoElement && this.setVideoCurrentTime({percentage: 0})
            }, isVideoMuted: function () {
                return this.videoElement.muted
            }, muteVideo: function () {
                const t = this.videoElement;
                t && !t.muted && (t.muted = !0), this.dispatchEvent({type: "volumechange"})
            }, unmuteVideo: function () {
                const t = this.videoElement;
                t && this.isVideoMuted() && (t.muted = !1), this.dispatchEvent({type: "volumechange"})
            }, getVideoElement: function () {
                return this.videoElement
            }, dispose: function () {
                const {material: {map: t}} = this;
                this.pauseVideo(), this.removeEventListener("leave", this.pauseVideo.bind(this)), this.removeEventListener("enter-fade-start", this.resumeVideoProgress.bind(this)), this.removeEventListener("video-toggle", this.toggleVideo.bind(this)), this.removeEventListener("video-time", this.setVideoCurrentTime.bind(this)), t && t.dispose(), HE.prototype.dispose.call(this)
            }
        }), Object.assign(JE.prototype, {
            constructor: JE, setProgress: function (t, e) {
                this.onProgress && this.onProgress({loaded: t, total: e})
            }, adaptTextureToZoom: function () {
                const t = this.widths[this._zoom], e = this.heights[this._zoom], i = this.maxW, n = this.maxH;
                this._wc = Math.ceil(t / i), this._hc = Math.ceil(e / n);
                for (let r = 0; r < this._hc; r++) for (let s = 0; s < this._wc; s++) {
                    const a = document.createElement("canvas");
                    s < this._wc - 1 ? a.width = i : a.width = t - i * s, r < this._hc - 1 ? a.height = n : a.height = e - n * r, this._canvas.push(a), this._ctx.push(a.getContext("2d"))
                }
            }, composeFromTile: function (t, e, i) {
                const n = this.maxW, r = this.maxH;
                t *= 512, e *= 512;
                const s = Math.floor(t / n), a = Math.floor(e / r);
                t -= s * n, e -= a * r, this._ctx[a * this._wc + s].drawImage(i, 0, 0, i.width, i.height, t, e, 512, 512), this.progress()
            }, progress: function () {
                this._count++, this.setProgress(this._count, this._total), this._count === this._total && (this.canvas = this._canvas, this.panoId = this._panoId, this.zoom = this._zoom, this.onPanoramaLoad && this.onPanoramaLoad(this._canvas[0]))
            }, composePanorama: function () {
                this.setProgress(0, 1);
                const t = this.levelsW[this._zoom], e = this.levelsH[this._zoom], i = this;
                this._count = 0, this._total = t * e;
                const {useWebGL: n} = this._parameters;
                for (let r = 0; r < e; r++) for (let e = 0; e < t; e++) {
                    const t = "https://geo0.ggpht.com/cbk?cb_client=maps_sv.tactile&authuser=0&hl=en&output=tile&zoom=" + this._zoom + "&x=" + e + "&y=" + r + "&panoid=" + this._panoId + "&nbt&fover=2";
                    !function (e, r) {
                        if (n) {
                            const n = zE(t, null, (function () {
                                i.composeFromTile(e, r, n)
                            }))
                        } else {
                            const n = new Image;
                            n.addEventListener("load", (function () {
                                i.composeFromTile(e, r, this)
                            })), n.crossOrigin = "", n.src = t
                        }
                    }(e, r)
                }
            }, load: function (t) {
                this.loadPano(t)
            }, loadPano: function (t) {
                const e = this;
                this._panoClient.getPanoramaById(t, (function (t, i) {
                    i === google.maps.StreetViewStatus.OK && (e.result = t, e.copyright = t.copyright, e._panoId = t.location.pano, e.composePanorama())
                }))
            }, setZoom: function (t) {
                this._zoom = t, this.adaptTextureToZoom()
            }
        }), QE.prototype = Object.assign(Object.create(WE.prototype), {
            constructor: QE, load: function (t) {
                this.loadRequested = !0, (t = t || this.panoId || {}) && this.gsvLoader && this.loadGSVLoader(t)
            }, setupGoogleMapAPI: function (t) {
                const e = document.createElement("script");
                e.src = "https://maps.googleapis.com/maps/api/js?", e.src += t ? "key=" + t : "", e.onreadystatechange = this.setGSVLoader.bind(this), e.onload = this.setGSVLoader.bind(this), document.querySelector("head").appendChild(e)
            }, setGSVLoader: function () {
                this.gsvLoader = new JE, this.loadRequested && this.load()
            }, getGSVLoader: function () {
                return this.gsvLoader
            }, loadGSVLoader: function (t) {
                this.loadRequested = !1, this.gsvLoader.onProgress = this.onProgress.bind(this), this.gsvLoader.onPanoramaLoad = this.onLoad.bind(this), this.gsvLoader.setZoom(this.getZoomLevel()), this.gsvLoader.load(t), this.gsvLoader.loaded = !0
            }, onLoad: function (t) {
                WE.prototype.onLoad.call(this, new jm(t))
            }, reset: function () {
                this.gsvLoader = void 0, WE.prototype.reset.call(this)
            }
        });
        const KE = {
            uniforms: {
                tDiffuse: {value: new jm},
                resolution: {value: 1},
                transform: {value: new Jm},
                zoom: {value: 1},
                opacity: {value: 1}
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float resolution;", "uniform mat4 transform;", "uniform float zoom;", "uniform float opacity;", "varying vec2 vUv;", "const float PI = 3.141592653589793;", "void main(){", "vec2 position = -1.0 +  2.0 * vUv;", "position *= vec2( zoom * resolution, zoom * 0.5 );", "float x2y2 = position.x * position.x + position.y * position.y;", "vec3 sphere_pnt = vec3( 2. * position, x2y2 - 1. ) / ( x2y2 + 1. );", "sphere_pnt = vec3( transform * vec4( sphere_pnt, 1.0 ) );", "vec2 sampleUV = vec2(", "(atan(sphere_pnt.y, sphere_pnt.x) / PI + 1.0) * 0.5,", "(asin(sphere_pnt.z) / PI + 0.5)", ");", "gl_FragColor = texture2D( tDiffuse, sampleUV );", "gl_FragColor.a *= opacity;", "}"].join("\n")
        };

        function $E(t = "image", e, i = 1e4, n = .5) {
            "image" === t && WE.call(this, e, this.createGeometry(i, n), this.createMaterial(i)), this.size = i, this.ratio = n, this.EPS = 1e-6, this.frameId = null, this.dragging = !1, this.userMouse = new xm, this.quatA = new wm, this.quatB = new wm, this.quatCur = new wm, this.quatSlerp = new wm, this.vectorX = new _m(1, 0, 0), this.vectorY = new _m(0, 1, 0), this.addEventListener("window-resize", this.onWindowResize)
        }

        function tM(t, e, i) {
            $E.call(this, "image", t, e, i)
        }

        function eM(t) {
            const e = new wx(5e3, 60, 40), i = new nv({visible: !1});
            HE.call(this, e, i), this.media = new NE(t), this.radius = 5e3, this.addEventListener("enter", this.start.bind(this)), this.addEventListener("leave", this.stop.bind(this)), this.addEventListener("panolens-container", this.onPanolensContainer.bind(this)), this.addEventListener("panolens-scene", this.onPanolensScene.bind(this))
        }

        function iM(t, e) {
            this.object = t, this.domElement = void 0 !== e ? e : document, this.frameId = null, this.enabled = !0, this.target = new _m, this.center = this.target, this.noZoom = !1, this.zoomSpeed = 1, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.noRotate = !1, this.rotateSpeed = -.15, this.noPan = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.momentumDampingFactor = .9, this.momentumScalingFactor = -.005, this.momentumKeydownFactor = 20, this.minFov = 30, this.maxFov = 120, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.noKeys = !1, this.keys = {
                LEFT: 37,
                UP: 38,
                RIGHT: 39,
                BOTTOM: 40
            }, this.mouseButtons = {ORBIT: Wf, ZOOM: qf, PAN: Xf};
            var i, n, r, s, a, o = this, h = 1e-7, l = 1e-4, c = new xm, u = new xm, p = new xm, d = new xm, f = new xm,
                m = new xm, g = new _m, v = new _m, y = new xm, b = new xm, x = new xm, w = 0, _ = 0, E = 0, M = 0,
                A = 1, S = new _m, T = new _m, D = new wm, C = 0, P = 0, I = !1, L = -1, R = 0, F = 1, k = 2, O = 3,
                z = 4, B = 5, N = L;
            this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom;
            var j = (new wm).setFromUnitVectors(t.up, new _m(0, 1, 0)), V = j.clone().inverse(), G = {type: "change"},
                U = {type: "start"}, H = {type: "end"};

            function W() {
                return 2 * Math.PI / 60 / 60 * o.autoRotateSpeed
            }

            function q() {
                return Math.pow(.95, o.zoomSpeed)
            }

            function X(t) {
                if (I = !1, C = P = 0, !1 !== o.enabled) {
                    if (t.preventDefault(), t.button === o.mouseButtons.ORBIT) {
                        if (!0 === o.noRotate) return;
                        N = R, c.set(t.clientX, t.clientY)
                    } else if (t.button === o.mouseButtons.ZOOM) {
                        if (!0 === o.noZoom) return;
                        N = F, y.set(t.clientX, t.clientY)
                    } else if (t.button === o.mouseButtons.PAN) {
                        if (!0 === o.noPan) return;
                        N = k, d.set(t.clientX, t.clientY)
                    }
                    N !== L && (document.addEventListener("mousemove", Y, !1), document.addEventListener("mouseup", Z, !1), o.dispatchEvent(U)), o.update()
                }
            }

            function Y(t) {
                if (!1 !== o.enabled) {
                    t.preventDefault();
                    var e = o.domElement === document ? o.domElement.body : o.domElement;
                    if (N === R) {
                        if (!0 === o.noRotate) return;
                        u.set(t.clientX, t.clientY), p.subVectors(u, c), o.rotateLeft(2 * Math.PI * p.x / e.clientWidth * o.rotateSpeed), o.rotateUp(2 * Math.PI * p.y / e.clientHeight * o.rotateSpeed), c.copy(u), i && (C = t.clientX - i.clientX, P = t.clientY - i.clientY), i = t
                    } else if (N === F) {
                        if (!0 === o.noZoom) return;
                        b.set(t.clientX, t.clientY), x.subVectors(b, y), x.y > 0 ? o.dollyIn() : x.y < 0 && o.dollyOut(), y.copy(b)
                    } else if (N === k) {
                        if (!0 === o.noPan) return;
                        f.set(t.clientX, t.clientY), m.subVectors(f, d), o.pan(m.x, m.y), d.copy(f)
                    }
                    N !== L && o.update()
                }
            }

            function Z() {
                I = !0, i = void 0, !1 !== o.enabled && (document.removeEventListener("mousemove", Y, !1), document.removeEventListener("mouseup", Z, !1), o.dispatchEvent(H), N = L)
            }

            function J(t) {
                if (!1 !== o.enabled && !0 !== o.noZoom && N === L) {
                    t.preventDefault(), t.stopPropagation();
                    var e = 0;
                    void 0 !== t.wheelDelta ? e = t.wheelDelta : void 0 !== t.detail && (e = -t.detail), e > 0 ? (o.object.fov = o.object.fov < o.maxFov ? o.object.fov + 1 : o.maxFov, o.object.updateProjectionMatrix()) : e < 0 && (o.object.fov = o.object.fov > o.minFov ? o.object.fov - 1 : o.minFov, o.object.updateProjectionMatrix()), o.update(), o.dispatchEvent(G), o.dispatchEvent(U), o.dispatchEvent(H)
                }
            }

            function Q(t) {
                switch (t.keyCode) {
                    case o.keys.UP:
                        n = !1;
                        break;
                    case o.keys.BOTTOM:
                        r = !1;
                        break;
                    case o.keys.LEFT:
                        s = !1;
                        break;
                    case o.keys.RIGHT:
                        a = !1
                }
            }

            function K(t) {
                if (!1 !== o.enabled && !0 !== o.noKeys && !0 !== o.noRotate) {
                    switch (t.keyCode) {
                        case o.keys.UP:
                            n = !0;
                            break;
                        case o.keys.BOTTOM:
                            r = !0;
                            break;
                        case o.keys.LEFT:
                            s = !0;
                            break;
                        case o.keys.RIGHT:
                            a = !0
                    }
                    (n || r || s || a) && (I = !0, n && (P = -o.rotateSpeed * o.momentumKeydownFactor), r && (P = o.rotateSpeed * o.momentumKeydownFactor), s && (C = -o.rotateSpeed * o.momentumKeydownFactor), a && (C = o.rotateSpeed * o.momentumKeydownFactor))
                }
            }

            function $(t) {
                if (I = !1, C = P = 0, !1 !== o.enabled) {
                    switch (t.touches.length) {
                        case 1:
                            if (!0 === o.noRotate) return;
                            N = O, c.set(t.touches[0].pageX, t.touches[0].pageY);
                            break;
                        case 2:
                            if (!0 === o.noZoom) return;
                            N = z;
                            var e = t.touches[0].pageX - t.touches[1].pageX,
                                i = t.touches[0].pageY - t.touches[1].pageY, n = Math.sqrt(e * e + i * i);
                            y.set(0, n);
                            break;
                        case 3:
                            if (!0 === o.noPan) return;
                            N = B, d.set(t.touches[0].pageX, t.touches[0].pageY);
                            break;
                        default:
                            N = L
                    }
                    N !== L && o.dispatchEvent(U)
                }
            }

            function tt(t) {
                if (!1 !== o.enabled) {
                    t.preventDefault(), t.stopPropagation();
                    var e = o.domElement === document ? o.domElement.body : o.domElement;
                    switch (t.touches.length) {
                        case 1:
                            if (!0 === o.noRotate) return;
                            if (N !== O) return;
                            u.set(t.touches[0].pageX, t.touches[0].pageY), p.subVectors(u, c), o.rotateLeft(2 * Math.PI * p.x / e.clientWidth * o.rotateSpeed), o.rotateUp(2 * Math.PI * p.y / e.clientHeight * o.rotateSpeed), c.copy(u), i && (C = t.touches[0].pageX - i.pageX, P = t.touches[0].pageY - i.pageY), i = {
                                pageX: t.touches[0].pageX,
                                pageY: t.touches[0].pageY
                            }, o.update();
                            break;
                        case 2:
                            if (!0 === o.noZoom) return;
                            if (N !== z) return;
                            var n = t.touches[0].pageX - t.touches[1].pageX,
                                r = t.touches[0].pageY - t.touches[1].pageY, s = Math.sqrt(n * n + r * r);
                            b.set(0, s), x.subVectors(b, y), x.y < 0 ? (o.object.fov = o.object.fov < o.maxFov ? o.object.fov + 1 : o.maxFov, o.object.updateProjectionMatrix()) : x.y > 0 && (o.object.fov = o.object.fov > o.minFov ? o.object.fov - 1 : o.minFov, o.object.updateProjectionMatrix()), y.copy(b), o.update(), o.dispatchEvent(G);
                            break;
                        case 3:
                            if (!0 === o.noPan) return;
                            if (N !== B) return;
                            f.set(t.touches[0].pageX, t.touches[0].pageY), m.subVectors(f, d), o.pan(m.x, m.y), d.copy(f), o.update();
                            break;
                        default:
                            N = L
                    }
                }
            }

            function et() {
                I = !0, i = void 0, !1 !== o.enabled && (o.dispatchEvent(H), N = L)
            }

            this.setLastQuaternion = function (t) {
                D.copy(t), o.object.quaternion.copy(t)
            }, this.getLastPosition = function () {
                return T
            }, this.rotateLeft = function (t) {
                void 0 === t && (t = W()), M -= t
            }, this.rotateUp = function (t) {
                void 0 === t && (t = W()), E -= t
            }, this.panLeft = function (t) {
                var e = this.object.matrix.elements;
                g.set(e[0], e[1], e[2]), g.multiplyScalar(-t), S.add(g)
            }, this.panUp = function (t) {
                var e = this.object.matrix.elements;
                g.set(e[4], e[5], e[6]), g.multiplyScalar(t), S.add(g)
            }, this.pan = function (t, e) {
                var i = o.domElement === document ? o.domElement.body : o.domElement;
                if (o.object instanceof Uy) {
                    var n = o.object.position.clone().sub(o.target).length();
                    n *= Math.tan(o.object.fov / 2 * Math.PI / 180), o.panLeft(2 * t * n / i.clientHeight), o.panUp(2 * e * n / i.clientHeight)
                } else o.object instanceof Xw ? (o.panLeft(t * (o.object.right - o.object.left) / i.clientWidth), o.panUp(e * (o.object.top - o.object.bottom) / i.clientHeight)) : console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.")
            }, this.momentum = function () {
                I && (Math.abs(C) < l && Math.abs(P) < l ? I = !1 : (P *= this.momentumDampingFactor, C *= this.momentumDampingFactor, M -= this.momentumScalingFactor * C, E -= this.momentumScalingFactor * P))
            }, this.dollyIn = function (t) {
                void 0 === t && (t = q()), o.object instanceof Uy ? A /= t : o.object instanceof Xw ? (o.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom * t)), o.object.updateProjectionMatrix(), o.dispatchEvent(G)) : console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.")
            }, this.dollyOut = function (t) {
                void 0 === t && (t = q()), o.object instanceof Uy ? A *= t : o.object instanceof Xw ? (o.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / t)), o.object.updateProjectionMatrix(), o.dispatchEvent(G)) : console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.")
            }, this.update = function (t) {
                var e = this.object.position;
                v.copy(e).sub(this.target), v.applyQuaternion(j), w = Math.atan2(v.x, v.z), _ = Math.atan2(Math.sqrt(v.x * v.x + v.z * v.z), v.y), this.autoRotate && N === L && this.rotateLeft(W()), this.momentum(), w += M, _ += E, w = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, w)), _ = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, _)), _ = Math.max(h, Math.min(Math.PI - h, _));
                var i = v.length() * A;
                i = Math.max(this.minDistance, Math.min(this.maxDistance, i)), this.target.add(S), v.x = i * Math.sin(_) * Math.sin(w), v.y = i * Math.cos(_), v.z = i * Math.sin(_) * Math.cos(w), v.applyQuaternion(V), e.copy(this.target).add(v), this.object.lookAt(this.target), M = 0, E = 0, A = 1, S.set(0, 0, 0), (T.distanceToSquared(this.object.position) > h || 8 * (1 - D.dot(this.object.quaternion)) > h) && (!0 !== t && this.dispatchEvent(G), T.copy(this.object.position), D.copy(this.object.quaternion))
            }, this.reset = function () {
                N = L, this.target.copy(this.target0), this.object.position.copy(this.position0), this.object.zoom = this.zoom0, this.object.updateProjectionMatrix(), this.dispatchEvent(G), this.update()
            }, this.getPolarAngle = function () {
                return _
            }, this.getAzimuthalAngle = function () {
                return w
            }, this.dispose = function () {
                this.domElement.removeEventListener("mousedown", X), this.domElement.removeEventListener("mousewheel", J), this.domElement.removeEventListener("DOMMouseScroll", J), this.domElement.removeEventListener("touchstart", $), this.domElement.removeEventListener("touchend", et), this.domElement.removeEventListener("touchmove", tt), window.removeEventListener("keyup", Q), window.removeEventListener("keydown", K)
            }, this.domElement.addEventListener("mousedown", X, {passive: !1}), this.domElement.addEventListener("mousewheel", J, {passive: !1}), this.domElement.addEventListener("DOMMouseScroll", J, {passive: !1}), this.domElement.addEventListener("touchstart", $, {passive: !1}), this.domElement.addEventListener("touchend", et, {passive: !1}), this.domElement.addEventListener("touchmove", tt, {passive: !1}), window.addEventListener("keyup", Q, {passive: !1}), window.addEventListener("keydown", K, {passive: !1}), this.update()
        }

        function nM(t, e) {
            var i = this, n = {type: "change"}, r = 0, s = 0, a = 0, o = 0;
            this.camera = t, this.camera.rotation.reorder("YXZ"), this.domElement = void 0 !== e ? e : document, this.enabled = !0, this.deviceOrientation = {}, this.screenOrientation = 0, this.alpha = 0, this.alphaOffsetAngle = 0;
            var h = function (t) {
                i.deviceOrientation = t
            }, l = function () {
                i.screenOrientation = window.orientation || 0
            }, c = function (t) {
                t.preventDefault(), t.stopPropagation(), a = t.touches[0].pageX, o = t.touches[0].pageY
            }, u = function (t) {
                t.preventDefault(), t.stopPropagation(), r += bm.degToRad((t.touches[0].pageX - a) / 4), s += bm.degToRad((o - t.touches[0].pageY) / 4), i.updateAlphaOffsetAngle(r), a = t.touches[0].pageX, o = t.touches[0].pageY
            };
            this.connect = function () {
                l(), window.addEventListener("orientationchange", l, {passive: !0}), window.addEventListener("deviceorientation", h, {passive: !0}), window.addEventListener("deviceorientation", this.update.bind(this), {passive: !0}), i.domElement.addEventListener("touchstart", c, {passive: !1}), i.domElement.addEventListener("touchmove", u, {passive: !1}), i.enabled = !0
            }, this.disconnect = function () {
                window.removeEventListener("orientationchange", l, !1), window.removeEventListener("deviceorientation", h, !1), window.removeEventListener("deviceorientation", this.update.bind(this), !1), i.domElement.removeEventListener("touchstart", c, !1), i.domElement.removeEventListener("touchmove", u, !1), i.enabled = !1
            }, this.update = function (t) {
                if (!1 !== i.enabled) {
                    var e = i.deviceOrientation.alpha ? bm.degToRad(i.deviceOrientation.alpha) + i.alphaOffsetAngle : 0,
                        r = i.deviceOrientation.beta ? bm.degToRad(i.deviceOrientation.beta) : 0,
                        a = i.deviceOrientation.gamma ? bm.degToRad(i.deviceOrientation.gamma) : 0,
                        o = i.screenOrientation ? bm.degToRad(i.screenOrientation) : 0;
                    !function (t, e, n, r, a) {
                        var o, h = new _m(0, 0, 1), l = new ug, c = new wm,
                            u = new wm(-Math.sqrt(.5), 0, 0, Math.sqrt(.5)), p = new wm, d = new wm;
                        0 == i.screenOrientation ? (o = new _m(1, 0, 0), p.setFromAxisAngle(o, -s)) : 180 == i.screenOrientation ? (o = new _m(1, 0, 0), p.setFromAxisAngle(o, s)) : 90 == i.screenOrientation ? (o = new _m(0, 1, 0), p.setFromAxisAngle(o, s)) : -90 == i.screenOrientation && (o = new _m(0, 1, 0), p.setFromAxisAngle(o, -s)), u.multiply(p), u.multiply(d), l.set(n, e, -r, "YXZ"), t.setFromEuler(l), t.multiply(u), t.multiply(c.setFromAxisAngle(h, -a))
                    }(i.camera.quaternion, e, r, a, o), i.alpha = e, !0 !== t && i.dispatchEvent(n)
                }
            }, this.updateAlphaOffsetAngle = function (t) {
                this.alphaOffsetAngle = t, this.update()
            }, this.dispose = function () {
                this.disconnect()
            }, this.connect()
        }

        function rM(t) {
            var e = new Xw(-1, 1, 1, -1, 0, 1), i = new sb, n = new M_;
            n.aspect = .5;
            var r = new Gm(512, 512, {minFilter: em, magFilter: Kf, format: lm});
            r.scissorTest = !0, r.texture.generateMipmaps = !1;
            var s = new xm(.441, .156), a = new Ng(1, 1, 10, 20).removeAttribute("normal").toNonIndexed(),
                o = a.attributes.position.array, h = a.attributes.uv.array;
            a.attributes.position.count *= 2, a.attributes.uv.count *= 2;
            var l = new Float32Array(2 * o.length);
            l.set(o), l.set(o, o.length);
            var c = new Float32Array(2 * h.length);
            c.set(h), c.set(h, h.length);
            for (var u = new xm, p = o.length / 3, d = 0, f = l.length / 3; d < f; d++) {
                u.x = l[3 * d + 0], u.y = l[3 * d + 1];
                var m = u.dot(u), g = 1.5 + (s.x + s.y * m) * m, v = d < p ? 0 : 1;
                l[3 * d + 0] = u.x / g * 1.5 - .5 + v, l[3 * d + 1] = u.y / g * 3, c[2 * d] = .5 * (c[2 * d] + v)
            }
            a.attributes.position.array = l, a.attributes.uv.array = c;
            var y = new rv(a, new nv({map: r.texture}));
            i.add(y), this.setSize = function (e, i) {
                t.setSize(e, i);
                var n = t.getPixelRatio();
                r.setSize(e * n, i * n)
            }, this.render = function (s, a) {
                s.updateMatrixWorld(), null === a.parent && a.updateMatrixWorld(), n.update(a);
                var o = r.width / 2, h = r.height;
                t.autoClear && t.clear(), r.scissor.set(0, 0, o, h), r.viewport.set(0, 0, o, h), t.setRenderTarget(r), t.render(s, n.cameraL), t.clearDepth(), r.scissor.set(o, 0, o, h), r.viewport.set(o, 0, o, h), t.setRenderTarget(r), t.render(s, n.cameraR), t.clearDepth(), t.setRenderTarget(null), t.render(i, e)
            }
        }

        $E.prototype = Object.assign(Object.create(WE.prototype), {
            constructor: $E, add: function (t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                    return this
                }
                t instanceof GE && (t.material.depthTest = !1), WE.prototype.add.call(this, t)
            }, createGeometry: function (t, e) {
                return new Ng(t, t * e)
            }, createMaterial: function (t) {
                const e = Object.assign({}, KE), i = e.uniforms;
                return i.zoom.value = t, i.opacity.value = 0, new tv({
                    uniforms: i,
                    vertexShader: e.vertexShader,
                    fragmentShader: e.fragmentShader,
                    side: 1,
                    transparent: !0
                })
            }, registerMouseEvents: function () {
                this.container.addEventListener("mousedown", this.onMouseDown.bind(this), {passive: !0}), this.container.addEventListener("mousemove", this.onMouseMove.bind(this), {passive: !0}), this.container.addEventListener("mouseup", this.onMouseUp.bind(this), {passive: !0}), this.container.addEventListener("touchstart", this.onMouseDown.bind(this), {passive: !0}), this.container.addEventListener("touchmove", this.onMouseMove.bind(this), {passive: !0}), this.container.addEventListener("touchend", this.onMouseUp.bind(this), {passive: !0}), this.container.addEventListener("mousewheel", this.onMouseWheel.bind(this), {passive: !1}), this.container.addEventListener("DOMMouseScroll", this.onMouseWheel.bind(this), {passive: !1}), this.container.addEventListener("contextmenu", this.onContextMenu.bind(this), {passive: !0})
            }, unregisterMouseEvents: function () {
                this.container.removeEventListener("mousedown", this.onMouseDown.bind(this), !1), this.container.removeEventListener("mousemove", this.onMouseMove.bind(this), !1), this.container.removeEventListener("mouseup", this.onMouseUp.bind(this), !1), this.container.removeEventListener("touchstart", this.onMouseDown.bind(this), !1), this.container.removeEventListener("touchmove", this.onMouseMove.bind(this), !1), this.container.removeEventListener("touchend", this.onMouseUp.bind(this), !1), this.container.removeEventListener("mousewheel", this.onMouseWheel.bind(this), !1), this.container.removeEventListener("DOMMouseScroll", this.onMouseWheel.bind(this), !1), this.container.removeEventListener("contextmenu", this.onContextMenu.bind(this), !1)
            }, onMouseDown: function (t) {
                switch (t.touches && t.touches.length || 1) {
                    case 1:
                        const e = t.clientX >= 0 ? t.clientX : t.touches[0].clientX,
                            i = t.clientY >= 0 ? t.clientY : t.touches[0].clientY;
                        this.dragging = !0, this.userMouse.set(e, i);
                        break;
                    case 2:
                        const n = t.touches[0].pageX - t.touches[1].pageX, r = t.touches[0].pageY - t.touches[1].pageY,
                            s = Math.sqrt(n * n + r * r);
                        this.userMouse.pinchDistance = s
                }
                this.onUpdateCallback()
            }, onMouseMove: function (t) {
                switch (t.touches && t.touches.length || 1) {
                    case 1:
                        const e = t.clientX >= 0 ? t.clientX : t.touches[0].clientX,
                            i = t.clientY >= 0 ? t.clientY : t.touches[0].clientY,
                            n = .4 * bm.degToRad(e - this.userMouse.x), r = .4 * bm.degToRad(i - this.userMouse.y);
                        this.dragging && (this.quatA.setFromAxisAngle(this.vectorY, n), this.quatB.setFromAxisAngle(this.vectorX, r), this.quatCur.multiply(this.quatA).multiply(this.quatB), this.userMouse.set(e, i));
                        break;
                    case 2:
                        const s = t.touches[0].pageX - t.touches[1].pageX, a = t.touches[0].pageY - t.touches[1].pageY,
                            o = Math.sqrt(s * s + a * a);
                        this.addZoomDelta(this.userMouse.pinchDistance - o)
                }
            }, onMouseUp: function () {
                this.dragging = !1
            }, onMouseWheel: function (t) {
                t.preventDefault(), t.stopPropagation();
                let e = 0;
                void 0 !== t.wheelDelta ? e = t.wheelDelta : void 0 !== t.detail && (e = -t.detail), this.addZoomDelta(e), this.onUpdateCallback()
            }, addZoomDelta: function (t) {
                const e = this.material.uniforms, i = .1 * this.size, n = 10 * this.size;
                e.zoom.value += t, e.zoom.value <= i ? e.zoom.value = i : e.zoom.value >= n && (e.zoom.value = n)
            }, onUpdateCallback: function () {
                this.frameId = window.requestAnimationFrame(this.onUpdateCallback.bind(this)), this.quatSlerp.slerp(this.quatCur, .1), this.material && this.material.uniforms.transform.value.makeRotationFromQuaternion(this.quatSlerp), !this.dragging && 1 - this.quatSlerp.clone().dot(this.quatCur) < this.EPS && window.cancelAnimationFrame(this.frameId)
            }, reset: function () {
                this.quatCur.set(0, 0, 0, 1), this.quatSlerp.set(0, 0, 0, 1), this.onUpdateCallback()
            }, onLoad: function (t) {
                this.material.uniforms.resolution.value = this.container.clientWidth / this.container.clientHeight, this.registerMouseEvents(), this.onUpdateCallback(), this.dispatchEvent({
                    type: "panolens-viewer-handler",
                    method: "disableControl"
                }), WE.prototype.onLoad.call(this, t)
            }, onLeave: function () {
                this.unregisterMouseEvents(), this.dispatchEvent({
                    type: "panolens-viewer-handler",
                    method: "enableControl",
                    data: PE
                }), window.cancelAnimationFrame(this.frameId), WE.prototype.onLeave.call(this)
            }, onWindowResize: function () {
                this.material.uniforms.resolution.value = this.container.clientWidth / this.container.clientHeight
            }, onContextMenu: function () {
                this.dragging = !1
            }, dispose: function () {
                this.unregisterMouseEvents(), WE.prototype.dispose.call(this)
            }
        }), tM.prototype = Object.assign(Object.create($E.prototype), {
            constructor: tM, onLoad: function (t) {
                this.updateTexture(t), $E.prototype.onLoad.call(this, t)
            }, updateTexture: function (t) {
                t.minFilter = t.magFilter = em, this.material.uniforms.tDiffuse.value = t
            }, dispose: function () {
                const t = this.material.uniforms.tDiffuse;
                t && t.value && t.value.dispose(), $E.prototype.dispose.call(this)
            }
        }), eM.prototype = Object.assign(Object.create(HE.prototype), {
            constructor: eM,
            onPanolensContainer: function ({container: t}) {
                this.media.setContainer(t)
            },
            onPanolensScene: function ({scene: t}) {
                this.media.setScene(t)
            },
            start: function () {
                return this.media.start()
            },
            stop: function () {
                this.media.stop()
            }
        }), iM.prototype = Object.assign(Object.create(Vf.prototype), {constructor: iM}), nM.prototype = Object.assign(Object.create(Vf.prototype), {constructor: nM});
        const sM = function (t) {
            var e = new M_;
            e.aspect = .5;
            var i = new xm;
            this.setEyeSeparation = function (t) {
                e.eyeSep = t
            }, this.setSize = function (e, i) {
                t.setSize(e, i)
            }, this.render = function (n, r) {
                n.updateMatrixWorld(), null === r.parent && r.updateMatrixWorld(), e.update(r), t.getSize(i), t.autoClear && t.clear(), t.setScissorTest(!0), t.setScissor(0, 0, i.width / 2, i.height), t.setViewport(0, 0, i.width / 2, i.height), t.render(n, e.cameraL), t.setScissor(i.width / 2, 0, i.width / 2, i.height), t.setViewport(i.width / 2, 0, i.width / 2, i.height), t.render(n, e.cameraR), t.setScissorTest(!1)
            }
        };

        function aM(t) {
            let e;
            (t = t || {}).controlBar = void 0 === t.controlBar || t.controlBar, t.controlButtons = t.controlButtons || ["fullscreen", "setting", "video"], t.autoHideControlBar = void 0 !== t.autoHideControlBar && t.autoHideControlBar, t.autoHideInfospot = void 0 === t.autoHideInfospot || t.autoHideInfospot, t.horizontalView = void 0 !== t.horizontalView && t.horizontalView, t.clickTolerance = t.clickTolerance || 10, t.cameraFov = t.cameraFov || 60, t.reverseDragging = t.reverseDragging || !1, t.enableReticle = t.enableReticle || !1, t.dwellTime = t.dwellTime || 1500, t.autoReticleSelect = void 0 === t.autoReticleSelect || t.autoReticleSelect, t.viewIndicator = void 0 !== t.viewIndicator && t.viewIndicator, t.indicatorSize = t.indicatorSize || 30, t.output = t.output ? t.output : "none", t.autoRotate = t.autoRotate || !1, t.autoRotateSpeed = t.autoRotateSpeed || 2, t.autoRotateActivationDuration = t.autoRotateActivationDuration || 5e3, this.options = t, t.container ? (e = t.container, e._width = e.clientWidth, e._height = e.clientHeight) : (e = document.createElement("div"), e.classList.add("panolens-container"), e.style.width = "100%", e.style.height = "100%", e._width = window.innerWidth, e._height = window.innerHeight, document.body.appendChild(e)), this.container = e, this.camera = t.camera || new Uy(this.options.cameraFov, this.container.clientWidth / this.container.clientHeight, 1, 1e4), this.scene = t.scene || new sb, this.renderer = t.renderer || new ib({
                alpha: !0,
                antialias: !1
            }), this.sceneReticle = new sb, this.viewIndicatorSize = this.options.indicatorSize, this.reticle = {}, this.tempEnableReticle = this.options.enableReticle, this.mode = LE, this.panorama = null, this.widget = null, this.hoverObject = null, this.infospot = null, this.pressEntityObject = null, this.pressObject = null, this.raycaster = new eE, this.raycasterPoint = new xm, this.userMouse = new xm, this.updateCallbacks = [], this.requestAnimationId = null, this.cameraFrustum = new Zm, this.cameraViewProjectionMatrix = new Jm, this.autoRotateRequestId = null, this.outputDivElement = null, this.touchSupported = "ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch, this.HANDLER_MOUSE_DOWN = this.onMouseDown.bind(this), this.HANDLER_MOUSE_UP = this.onMouseUp.bind(this), this.HANDLER_MOUSE_MOVE = this.onMouseMove.bind(this), this.HANDLER_WINDOW_RESIZE = this.onWindowResize.bind(this), this.HANDLER_KEY_DOWN = this.onKeyDown.bind(this), this.HANDLER_KEY_UP = this.onKeyUp.bind(this), this.HANDLER_TAP = this.onTap.bind(this, {
                clientX: this.container.clientWidth / 2,
                clientY: this.container.clientHeight / 2
            }), this.OUTPUT_INFOSPOT = !1, this.tweenLeftAnimation = new VE.Tween, this.tweenUpAnimation = new VE.Tween, this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.setSize(this.container.clientWidth, this.container.clientHeight), this.renderer.setClearColor(0, 0), this.renderer.autoClear = !1, this.renderer.domElement.classList.add("panolens-canvas"), this.renderer.domElement.style.display = "block", this.container.style.backgroundColor = "#000", this.container.appendChild(this.renderer.domElement), this.OrbitControls = new iM(this.camera, this.container), this.OrbitControls.id = "orbit", this.OrbitControls.minDistance = 1, this.OrbitControls.noPan = !0, this.OrbitControls.autoRotate = this.options.autoRotate, this.OrbitControls.autoRotateSpeed = this.options.autoRotateSpeed, this.DeviceOrientationControls = new nM(this.camera, this.container), this.DeviceOrientationControls.id = "device-orientation", this.DeviceOrientationControls.enabled = !1, this.camera.position.z = 1, this.options.passiveRendering && console.warn("passiveRendering is now deprecated"), this.controls = [this.OrbitControls, this.DeviceOrientationControls], this.control = this.OrbitControls, this.CardboardEffect = new rM(this.renderer), this.CardboardEffect.setSize(this.container.clientWidth, this.container.clientHeight), this.StereoEffect = new sM(this.renderer), this.StereoEffect.setSize(this.container.clientWidth, this.container.clientHeight), this.effect = this.CardboardEffect, this.addReticle(), this.options.horizontalView && (this.OrbitControls.minPolarAngle = Math.PI / 2, this.OrbitControls.maxPolarAngle = Math.PI / 2), !1 !== this.options.controlBar && this.addDefaultControlBar(this.options.controlButtons), this.options.viewIndicator && this.addViewIndicator(), this.options.reverseDragging && this.reverseDraggingDirection(), this.options.enableReticle ? this.enableReticleControl() : this.registerMouseAndTouchEvents(), "overlay" === this.options.output && this.addOutputElement(), this.registerEventListeners(), this.animate.call(this)
        }

        aM.prototype = Object.assign(Object.create(Vf.prototype), {
            constructor: aM, add: function (t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                    return this
                }
                this.scene.add(t), t.addEventListener && t.addEventListener("panolens-viewer-handler", this.eventHandler.bind(this)), t instanceof HE && t.dispatchEvent && t.dispatchEvent({
                    type: "panolens-container",
                    container: this.container
                }), t instanceof eM && t.dispatchEvent({
                    type: "panolens-scene",
                    scene: this.scene
                }), "panorama" === t.type && (this.addPanoramaEventListener(t), this.panorama || this.setPanorama(t))
            }, remove: function (t) {
                t.removeEventListener && t.removeEventListener("panolens-viewer-handler", this.eventHandler.bind(this)), this.scene.remove(t)
            }, addDefaultControlBar: function (t) {
                if (this.widget) return void console.warn("Default control bar exists");
                const e = new UE(this.container);
                e.addEventListener("panolens-viewer-handler", this.eventHandler.bind(this)), e.addControlBar(), t.forEach((t => {
                    e.addControlButton(t)
                })), this.widget = e
            }, setPanorama: function (t) {
                const e = this.panorama;
                if ("panorama" === t.type && e !== t) {
                    this.hideInfospot();
                    const i = function () {
                        e && e.onLeave(), t.removeEventListener("enter-fade-start", i)
                    };
                    t.addEventListener("enter-fade-start", i), (this.panorama = t).onEnter()
                }
            }, eventHandler: function (t) {
                t.method && this[t.method] && this[t.method](t.data)
            }, dispatchEventToChildren: function (t) {
                this.scene.traverse((function (e) {
                    e.dispatchEvent && e.dispatchEvent(t)
                }))
            }, activateWidgetItem: function (t, e) {
                const i = this.widget.mainMenu, n = i.children[0], r = i.children[1];
                let s;
                if (void 0 !== t) {
                    switch (t) {
                        case 0:
                        default:
                            s = n.subMenu.children[1];
                            break;
                        case 1:
                            s = n.subMenu.children[2]
                    }
                    n.subMenu.setActiveItem(s), n.setSelectionTitle(s.textContent)
                }
                if (void 0 !== e) {
                    switch (e) {
                        case RE:
                            s = r.subMenu.children[2];
                            break;
                        case FE:
                            s = r.subMenu.children[3];
                            break;
                        default:
                            s = r.subMenu.children[1]
                    }
                    r.subMenu.setActiveItem(s), r.setSelectionTitle(s.textContent)
                }
            }, enableEffect: function (t) {
                if (this.mode === t) return;
                if (t === LE) return void this.disableEffect();
                this.mode = t;
                const e = this.camera.fov;
                switch (t) {
                    case RE:
                        this.effect = this.CardboardEffect, this.enableReticleControl();
                        break;
                    case FE:
                        this.effect = this.StereoEffect, this.enableReticleControl();
                        break;
                    default:
                        this.effect = null, this.disableReticleControl()
                }
                this.activateWidgetItem(void 0, this.mode), this.dispatchEventToChildren({
                    type: "panolens-dual-eye-effect",
                    mode: this.mode
                }), this.camera.fov = e + .01, this.effect.setSize(this.container.clientWidth, this.container.clientHeight), this.render(), this.camera.fov = e, this.dispatchEvent({
                    type: "mode-change",
                    mode: this.mode
                })
            }, disableEffect: function () {
                this.mode !== LE && (this.mode = LE, this.disableReticleControl(), this.activateWidgetItem(void 0, this.mode), this.dispatchEventToChildren({
                    type: "panolens-dual-eye-effect",
                    mode: this.mode
                }), this.renderer.setSize(this.container.clientWidth, this.container.clientHeight), this.render(), this.dispatchEvent({
                    type: "mode-change",
                    mode: this.mode
                }))
            }, enableReticleControl: function () {
                this.reticle.visible || (this.tempEnableReticle = !0, this.unregisterMouseAndTouchEvents(), this.reticle.show(), this.registerReticleEvent(), this.updateReticleEvent())
            }, disableReticleControl: function () {
                this.tempEnableReticle = !1, this.options.enableReticle ? this.updateReticleEvent() : (this.reticle.hide(), this.unregisterReticleEvent(), this.registerMouseAndTouchEvents())
            }, enableAutoRate: function () {
                this.options.autoRotate = !0, this.OrbitControls.autoRotate = !0
            }, disableAutoRate: function () {
                clearTimeout(this.autoRotateRequestId), this.options.autoRotate = !1, this.OrbitControls.autoRotate = !1
            }, toggleVideoPlay: function (t) {
                this.panorama instanceof ZE && this.panorama.dispatchEvent({type: "video-toggle", pause: t})
            }, setVideoCurrentTime: function (t) {
                this.panorama instanceof ZE && this.panorama.dispatchEvent({type: "video-time", percentage: t})
            }, onVideoUpdate: function (t) {
                const {widget: e} = this;
                e && e.dispatchEvent({type: "video-update", percentage: t})
            }, addUpdateCallback: function (t) {
                t && this.updateCallbacks.push(t)
            }, removeUpdateCallback: function (t) {
                const e = this.updateCallbacks.indexOf(t);
                t && e >= 0 && this.updateCallbacks.splice(e, 1)
            }, showVideoWidget: function () {
                const {widget: t} = this;
                t && t.dispatchEvent({type: "video-control-show"})
            }, hideVideoWidget: function () {
                const {widget: t} = this;
                t && t.dispatchEvent({type: "video-control-hide"})
            }, updateVideoPlayButton: function (t) {
                const {widget: e} = this;
                e && e.videoElement && e.videoElement.controlButton && e.videoElement.controlButton.update(t)
            }, addPanoramaEventListener: function (t) {
                t.addEventListener("enter-fade-start", this.setCameraControl.bind(this)), t instanceof ZE && (t.addEventListener("enter-fade-start", this.showVideoWidget.bind(this)), t.addEventListener("leave", function () {
                    this.panorama instanceof ZE || this.hideVideoWidget.call(this)
                }.bind(this)))
            }, setCameraControl: function () {
                this.OrbitControls.target.copy(this.panorama.position)
            }, getControl: function () {
                return this.control
            }, getScene: function () {
                return this.scene
            }, getCamera: function () {
                return this.camera
            }, getRenderer: function () {
                return this.renderer
            }, getContainer: function () {
                return this.container
            }, getControlId: function () {
                return this.control.id
            }, getNextControlId: function () {
                return this.controls[this.getNextControlIndex()].id
            }, getNextControlIndex: function () {
                const t = this.controls, e = this.control, i = t.indexOf(e) + 1;
                return i >= t.length ? 0 : i
            }, setCameraFov: function (t) {
                this.camera.fov = t, this.camera.updateProjectionMatrix()
            }, enableControl: function (t) {
                switch (t = t >= 0 && t < this.controls.length ? t : 0, this.control.enabled = !1, this.control = this.controls[t], this.control.enabled = !0, t) {
                    case PE:
                        this.camera.position.copy(this.panorama.position), this.camera.position.z += 1;
                        break;
                    case IE:
                        this.camera.position.copy(this.panorama.position)
                }
                this.control.update(), this.activateWidgetItem(t, void 0)
            }, disableControl: function () {
                this.control.enabled = !1
            }, toggleNextControl: function () {
                this.enableControl(this.getNextControlIndex())
            }, getScreenVector: function (t) {
                const e = t.clone(), i = this.container.clientWidth / 2, n = this.container.clientHeight / 2;
                return e.project(this.camera), e.x = e.x * i + i, e.y = -e.y * n + n, e.z = 0, e
            }, checkSpriteInViewport: function (t) {
                return this.camera.matrixWorldInverse.getInverse(this.camera.matrixWorld), this.cameraViewProjectionMatrix.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse), this.cameraFrustum.setFromMatrix(this.cameraViewProjectionMatrix), t.visible && this.cameraFrustum.intersectsSprite(t)
            }, reverseDraggingDirection: function () {
                this.OrbitControls.rotateSpeed *= -1, this.OrbitControls.momentumScalingFactor *= -1
            }, addReticle: function () {
                this.reticle = new jE(16777215, !0, this.options.dwellTime), this.reticle.hide(), this.camera.add(this.reticle), this.sceneReticle.add(this.camera)
            }, tweenControlCenter: function (t, e, i) {
                if (this.control !== this.OrbitControls) return;
                let n, r, s, a, o, h, l, c, u, p;
                t instanceof Array && (e = t[1], i = t[2], t = t[0]), e = void 0 !== e ? e : 1e3, i = i || VE.Easing.Exponential.Out, n = this, a = this.camera.getWorldDirection(new _m), o = a.clone(), c = this.panorama.getWorldPosition(new _m).sub(this.camera.getWorldPosition(new _m)), h = t.clone(), h.x *= -1, h.add(c).normalize(), l = h.clone(), a.y = 0, h.y = 0, r = Math.atan2(h.z, h.x) - Math.atan2(a.z, a.x), r = r > Math.PI ? r - 2 * Math.PI : r, r = r < -Math.PI ? r + 2 * Math.PI : r, s = Math.abs(o.angleTo(a) + (o.y * l.y <= 0 ? l.angleTo(h) : -l.angleTo(h))), s *= l.y < o.y ? 1 : -1, u = {
                    left: 0,
                    up: 0
                }, p = {
                    left: 0,
                    up: 0
                }, this.tweenLeftAnimation.stop(), this.tweenUpAnimation.stop(), this.tweenLeftAnimation = new VE.Tween(u).to({left: r}, e).easing(i).onUpdate((function (t) {
                    n.control.rotateLeft(t.left - p.left), p.left = t.left
                })).start(), this.tweenUpAnimation = new VE.Tween(u).to({up: s}, e).easing(i).onUpdate((function (t) {
                    n.control.rotateUp(t.up - p.up), p.up = t.up
                })).start()
            }, tweenControlCenterByObject: function (t, e, i) {
                let n = !1;
                if (t.traverseAncestors((function (t) {
                    t.scalePlaceHolder && (n = !0)
                })), n) {
                    const n = new _m(-1, 1, 1);
                    this.tweenControlCenter(t.getWorldPosition(new _m).multiply(n), e, i)
                } else this.tweenControlCenter(t.getWorldPosition(new _m), e, i)
            }, onWindowResize: function (t, e) {
                let i, n;
                const r = this.container.classList.contains("panolens-container") || this.container.isFullscreen;
                if (void 0 !== t && void 0 !== e) i = t, n = e, this.container._width = t, this.container._height = e; else {
                    const t = /(android)/i.test(window.navigator.userAgent),
                        e = t ? Math.min(document.documentElement.clientWidth, window.innerWidth || 0) : Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
                        s = t ? Math.min(document.documentElement.clientHeight, window.innerHeight || 0) : Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
                    i = r ? e : this.container.clientWidth, n = r ? s : this.container.clientHeight, this.container._width = i, this.container._height = n
                }
                this.camera.aspect = i / n, this.camera.updateProjectionMatrix(), this.renderer.setSize(i, n), (this.options.enableReticle || this.tempEnableReticle) && this.updateReticleEvent(), this.dispatchEvent({
                    type: "window-resize",
                    width: i,
                    height: n
                }), this.scene.traverse((function (t) {
                    t.dispatchEvent && t.dispatchEvent({type: "window-resize", width: i, height: n})
                }))
            }, addOutputElement: function () {
                const t = document.createElement("div");
                t.style.position = "absolute", t.style.right = "10px", t.style.top = "10px", t.style.color = "#fff", this.container.appendChild(t), this.outputDivElement = t
            }, outputPosition: function () {
                const t = this.raycaster.intersectObject(this.panorama, !0);
                if (t.length > 0) {
                    const e = t[0].point.clone(), i = new _m(-1, 1, 1), n = this.panorama.getWorldPosition(new _m);
                    e.sub(n).multiply(i);
                    const r = {x: e.x.toFixed(2), y: e.y.toFixed(2), z: e.z.toFixed(2)}, s = `${r.x}, ${r.y}, ${r.z}`;
                    if (0 === e.length()) return;
                    switch (this.options.output) {
                        case"event":
                            this.dispatchEvent({type: "position-output", position: r});
                            break;
                        case"console":
                            console.info(s);
                            break;
                        case"overlay":
                            this.outputDivElement.textContent = s
                    }
                }
            }, onMouseDown: function (t) {
                t.preventDefault(), this.userMouse.x = t.clientX >= 0 ? t.clientX : t.touches[0].clientX, this.userMouse.y = t.clientY >= 0 ? t.clientY : t.touches[0].clientY, this.userMouse.type = "mousedown", this.onTap(t)
            }, onMouseMove: function (t) {
                t.preventDefault(), this.userMouse.type = "mousemove", this.onTap(t)
            }, onMouseUp: function (t) {
                let e = !1;
                this.userMouse.type = "mouseup";
                const i = this.userMouse.x >= t.clientX - this.options.clickTolerance && this.userMouse.x <= t.clientX + this.options.clickTolerance && this.userMouse.y >= t.clientY - this.options.clickTolerance && this.userMouse.y <= t.clientY + this.options.clickTolerance || t.changedTouches && this.userMouse.x >= t.changedTouches[0].clientX - this.options.clickTolerance && this.userMouse.x <= t.changedTouches[0].clientX + this.options.clickTolerance && this.userMouse.y >= t.changedTouches[0].clientY - this.options.clickTolerance && this.userMouse.y <= t.changedTouches[0].clientY + this.options.clickTolerance ? "click" : void 0;
                if ((!t || !t.target || t.target.classList.contains("panolens-canvas")) && (t.preventDefault(), e = t.changedTouches && 1 === t.changedTouches.length ? this.onTap({
                    clientX: t.changedTouches[0].clientX,
                    clientY: t.changedTouches[0].clientY
                }, i) : this.onTap(t, i), this.userMouse.type = "none", !e && "click" === i)) {
                    const {
                        options: {autoHideInfospot: t, autoHideControlBar: e},
                        panorama: i,
                        toggleControlBar: n
                    } = this;
                    t && i && i.toggleInfospotVisibility(), e && n()
                }
            }, onTap: function (t, e) {
                const {left: i, top: n} = this.container.getBoundingClientRect(), {
                    clientWidth: r,
                    clientHeight: s
                } = this.container;
                if (this.raycasterPoint.x = (t.clientX - i) / r * 2 - 1, this.raycasterPoint.y = -(t.clientY - n) / s * 2 + 1, this.raycaster.setFromCamera(this.raycasterPoint, this.camera), !this.panorama) return;
                ("mousedown" !== t.type && this.touchSupported || this.OUTPUT_INFOSPOT) && this.outputPosition();
                const a = this.raycaster.intersectObjects(this.panorama.children, !0),
                    o = this.getConvertedIntersect(a), h = a.length > 0 ? a[0].object : void 0;
                if ("mouseup" === this.userMouse.type && (o && this.pressEntityObject === o && this.pressEntityObject.dispatchEvent && this.pressEntityObject.dispatchEvent({
                    type: "pressstop-entity",
                    mouseEvent: t
                }), this.pressEntityObject = void 0), "mouseup" === this.userMouse.type && (h && this.pressObject === h && this.pressObject.dispatchEvent && this.pressObject.dispatchEvent({
                    type: "pressstop",
                    mouseEvent: t
                }), this.pressObject = void 0), "click" === e ? (this.panorama.dispatchEvent({
                    type: "click",
                    intersects: a,
                    mouseEvent: t
                }), o && o.dispatchEvent && o.dispatchEvent({
                    type: "click-entity",
                    mouseEvent: t
                }), h && h.dispatchEvent && h.dispatchEvent({
                    type: "click",
                    mouseEvent: t
                })) : (this.panorama.dispatchEvent({
                    type: "hover",
                    intersects: a,
                    mouseEvent: t
                }), (this.hoverObject && a.length > 0 && this.hoverObject !== o || this.hoverObject && 0 === a.length) && (this.hoverObject.dispatchEvent && (this.hoverObject.dispatchEvent({
                    type: "hoverleave",
                    mouseEvent: t
                }), this.reticle.end()), this.hoverObject = void 0), o && a.length > 0 && (this.hoverObject !== o && (this.hoverObject = o, this.hoverObject.dispatchEvent && (this.hoverObject.dispatchEvent({
                    type: "hoverenter",
                    mouseEvent: t
                }), (this.options.autoReticleSelect && this.options.enableReticle || this.tempEnableReticle) && this.reticle.start(this.onTap.bind(this, t, "click")))), "mousedown" === this.userMouse.type && this.pressEntityObject != o && (this.pressEntityObject = o, this.pressEntityObject.dispatchEvent && this.pressEntityObject.dispatchEvent({
                    type: "pressstart-entity",
                    mouseEvent: t
                })), "mousedown" === this.userMouse.type && this.pressObject != h && (this.pressObject = h, this.pressObject.dispatchEvent && this.pressObject.dispatchEvent({
                    type: "pressstart",
                    mouseEvent: t
                })), ("mousemove" === this.userMouse.type || this.options.enableReticle) && (h && h.dispatchEvent && h.dispatchEvent({
                    type: "hover",
                    mouseEvent: t
                }), this.pressEntityObject && this.pressEntityObject.dispatchEvent && this.pressEntityObject.dispatchEvent({
                    type: "pressmove-entity",
                    mouseEvent: t
                }), this.pressObject && this.pressObject.dispatchEvent && this.pressObject.dispatchEvent({
                    type: "pressmove",
                    mouseEvent: t
                }))), !o && this.pressEntityObject && this.pressEntityObject.dispatchEvent && (this.pressEntityObject.dispatchEvent({
                    type: "pressstop-entity",
                    mouseEvent: t
                }), this.pressEntityObject = void 0), !h && this.pressObject && this.pressObject.dispatchEvent && (this.pressObject.dispatchEvent({
                    type: "pressstop",
                    mouseEvent: t
                }), this.pressObject = void 0)), h && h instanceof GE) {
                    if (this.infospot = h, "click" === e) return !0
                } else this.infospot && this.hideInfospot();
                this.options.autoRotate && "mousemove" !== this.userMouse.type && (clearTimeout(this.autoRotateRequestId), this.control === this.OrbitControls && (this.OrbitControls.autoRotate = !1, this.autoRotateRequestId = window.setTimeout(this.enableAutoRate.bind(this), this.options.autoRotateActivationDuration)))
            }, getConvertedIntersect: function (t) {
                let e;
                for (let i = 0; i < t.length; i++) if (t[i].distance >= 0 && t[i].object && !t[i].object.passThrough) {
                    if (t[i].object.entity && t[i].object.entity.passThrough) continue;
                    if (t[i].object.entity && !t[i].object.entity.passThrough) {
                        e = t[i].object.entity;
                        break
                    }
                    e = t[i].object;
                    break
                }
                return e
            }, hideInfospot: function () {
                this.infospot && (this.infospot.onHoverEnd(), this.infospot = void 0)
            }, toggleControlBar: function () {
                const {widget: t} = this;
                t && t.dispatchEvent({type: "control-bar-toggle"})
            }, onKeyDown: function (t) {
                this.options.output && "none" !== this.options.output && "Control" === t.key && (this.OUTPUT_INFOSPOT = !0)
            }, onKeyUp: function () {
                this.OUTPUT_INFOSPOT = !1
            }, update: function () {
                VE.update(), this.updateCallbacks.forEach((function (t) {
                    t()
                })), this.control.update(), this.scene.traverse(function (t) {
                    if (t instanceof GE && t.element && (this.hoverObject === t || "none" !== t.element.style.display || t.element.left && "none" !== t.element.left.style.display || t.element.right && "none" !== t.element.right.style.display)) if (this.checkSpriteInViewport(t)) {
                        const {x: e, y: i} = this.getScreenVector(t.getWorldPosition(new _m));
                        t.translateElement(e, i)
                    } else t.onDismiss()
                }.bind(this))
            }, render: function () {
                this.mode === RE || this.mode === FE ? (this.renderer.clear(), this.effect.render(this.scene, this.camera), this.effect.render(this.sceneReticle, this.camera)) : (this.renderer.clear(), this.renderer.render(this.scene, this.camera), this.renderer.clearDepth(), this.renderer.render(this.sceneReticle, this.camera))
            }, animate: function () {
                this.requestAnimationId = window.requestAnimationFrame(this.animate.bind(this)), this.onChange()
            }, onChange: function () {
                this.update(), this.render()
            }, registerMouseAndTouchEvents: function () {
                const t = {passive: !1};
                this.container.addEventListener("mousedown", this.HANDLER_MOUSE_DOWN, t), this.container.addEventListener("mousemove", this.HANDLER_MOUSE_MOVE, t), this.container.addEventListener("mouseup", this.HANDLER_MOUSE_UP, t), this.container.addEventListener("touchstart", this.HANDLER_MOUSE_DOWN, t), this.container.addEventListener("touchend", this.HANDLER_MOUSE_UP, t)
            }, unregisterMouseAndTouchEvents: function () {
                this.container.removeEventListener("mousedown", this.HANDLER_MOUSE_DOWN, !1), this.container.removeEventListener("mousemove", this.HANDLER_MOUSE_MOVE, !1), this.container.removeEventListener("mouseup", this.HANDLER_MOUSE_UP, !1), this.container.removeEventListener("touchstart", this.HANDLER_MOUSE_DOWN, !1), this.container.removeEventListener("touchend", this.HANDLER_MOUSE_UP, !1)
            }, registerReticleEvent: function () {
                this.addUpdateCallback(this.HANDLER_TAP)
            }, unregisterReticleEvent: function () {
                this.removeUpdateCallback(this.HANDLER_TAP)
            }, updateReticleEvent: function () {
                const t = this.container.clientWidth / 2 + this.container.offsetLeft,
                    e = this.container.clientHeight / 2;
                this.removeUpdateCallback(this.HANDLER_TAP), this.HANDLER_TAP = this.onTap.bind(this, {
                    clientX: t,
                    clientY: e
                }), this.addUpdateCallback(this.HANDLER_TAP)
            }, registerEventListeners: function () {
                window.addEventListener("resize", this.HANDLER_WINDOW_RESIZE, !0), window.addEventListener("keydown", this.HANDLER_KEY_DOWN, !0), window.addEventListener("keyup", this.HANDLER_KEY_UP, !0)
            }, unregisterEventListeners: function () {
                window.removeEventListener("resize", this.HANDLER_WINDOW_RESIZE, !0), window.removeEventListener("keydown", this.HANDLER_KEY_DOWN, !0), window.removeEventListener("keyup", this.HANDLER_KEY_UP, !0)
            }, dispose: function () {
                this.tweenLeftAnimation.stop(), this.tweenUpAnimation.stop(), this.unregisterEventListeners(), function t(e) {
                    for (let i = e.children.length - 1; i >= 0; i--) t(e.children[i]), e.remove(e.children[i]);
                    e instanceof HE || e instanceof GE ? (e.dispose(), e = null) : e.dispatchEvent && e.dispatchEvent("dispose")
                }(this.scene), this.widget && (this.widget.dispose(), this.widget = null), lw && lw.enabled && lw.clear()
            }, destroy: function () {
                this.dispose(), this.render(), window.cancelAnimationFrame(this.requestAnimationId)
            }, onPanoramaDispose: function (t) {
                t instanceof ZE && this.hideVideoWidget(), t === this.panorama && (this.panorama = null)
            }, loadAsyncRequest: function (t, e = (() => {
            })) {
                const i = new window.XMLHttpRequest;
                i.onloadend = function (t) {
                    e(t)
                }, i.open("GET", t, !0), i.send(null)
            }, addViewIndicator: function () {
                const t = this;
                this.loadAsyncRequest(kE.ViewIndicator, (function (e) {
                    if (0 === e.loaded) return;
                    const i = e.target.responseXML.documentElement;
                    i.style.width = t.viewIndicatorSize + "px", i.style.height = t.viewIndicatorSize + "px", i.style.position = "absolute", i.style.top = "10px", i.style.left = "10px", i.style.opacity = "0.5", i.style.cursor = "pointer", i.id = "panolens-view-indicator-container", t.container.appendChild(i);
                    const n = i.querySelector("#indicator");
                    t.addUpdateCallback((function () {
                        t.radius = .225 * t.viewIndicatorSize, t.currentPanoAngle = t.camera.rotation.y - bm.degToRad(90), t.fovAngle = bm.degToRad(t.camera.fov), t.leftAngle = -t.currentPanoAngle - t.fovAngle / 2, t.rightAngle = -t.currentPanoAngle + t.fovAngle / 2, t.leftX = t.radius * Math.cos(t.leftAngle), t.leftY = t.radius * Math.sin(t.leftAngle), t.rightX = t.radius * Math.cos(t.rightAngle), t.rightY = t.radius * Math.sin(t.rightAngle), t.indicatorD = "M " + t.leftX + " " + t.leftY + " A " + t.radius + " " + t.radius + " 0 0 1 " + t.rightX + " " + t.rightY, t.leftX && t.leftY && t.rightX && t.rightY && t.radius && n.setAttribute("d", t.indicatorD)
                    })), i.addEventListener("mouseenter", (function () {
                        this.style.opacity = "1"
                    })), i.addEventListener("mouseleave", (function () {
                        this.style.opacity = "0.5"
                    }))
                }))
            }, appendControlItem: function (t) {
                const e = this.widget.createCustomItem(t);
                return "video" === t.group ? this.widget.videoElement.appendChild(e) : this.widget.barElement.appendChild(e), e
            }, clearAllCache: function () {
                lw.clear()
            }
        }), "105" != CE && console.warn(`three.js version is not matched. Please consider use the target revision ${CE}`), window.TWEEN = VE;
        const oM = class {
            constructor(t) {
                this.el = t, this.viewer = null, this.el && this.init()
            }

            run() {
                var t = this.el.dataset.panoramaurl;
                t && (this.url = new WE(t), this.viewer = new aM({container: this.el}), this.viewer.add(this.url))
            }

            destroy() {
                this.viewer.dispose()
            }

            init() {
                this.run()
            }
        };
        const hM = class extends Rf {
            onEnter() {
                super.onEnter()
            }

            onLeave() {
                super.onLeave()
            }

            onEnterCompleted() {
                super.onEnterCompleted(), this.related = new Ao({
                    el: document.querySelector(".js-related"),
                    navigation: !0,
                    bullets: !0,
                    isClick: !0
                });
                var t = document.querySelector(".js-panorama");
                t && (this.panorama = new oM(t)), this.initLb(), this.initTabs()
            }

            onLeaveCompleted() {
                super.onLeaveCompleted(), this.panorama && this.panorama.destroy(), this.related && this.related.destroy(), this.tabs && this.tabs.destroy()
            }

            initLb() {
                document.querySelector(".js-lb") && (this.lb = new class {
                    constructor() {
                        uh(this, "open", (t => {
                            var {currentTarget: e} = t, i = [...this.ui.triggers].indexOf(e);
                            this.draggable && this.draggable.onSet(i), n.isLightbox = !0, xn.to(this.el, {
                                duration: .5,
                                autoAlpha: 1,
                                ease: "power1"
                            }), this.initial || (this.initial = !0, this.loadImages(i)), Pa.state.isUp && Pa.close()
                        })), uh(this, "close", (() => {
                            xn.to(this.el, {
                                duration: .5, autoAlpha: 0, ease: "power1", onComplete: () => {
                                    n.isLightbox = !1
                                }
                            })
                        })), this.el = document.querySelector(".js-lb"), this.ui = {
                            triggers: document.querySelectorAll(".js-lb-open"),
                            close: this.el.querySelector(".js-lb__close"),
                            wrapper: this.el.querySelector(".js-lb__wrapper")
                        }, this.addEvents()
                    }

                    addEvents() {
                        var {triggers: t, close: e} = this.ui;
                        t.forEach((t => Eo(t, "a", "click", this.open))), Eo(e, "a", "click", this.close)
                    }

                    loadImage(t, e) {
                        return new Promise((e => {
                            var i = document.createElement("img");
                            Eo(i, "a", "load", (i => e(t))), i.src = t, this.slides.push(i)
                        }))
                    }

                    loadImages(t) {
                        var e = this;
                        return ch((function* () {
                            e.el.classList.add("is-loading"), e.slides = null, e.slides = [];
                            var i = JSON.parse(e.el.dataset.images), n = i.map(function () {
                                var t = ch((function* (t) {
                                    var n = i.indexOf(t, 0);
                                    yield e.loadImage(t, n)
                                }));
                                return function (e) {
                                    return t.apply(this, arguments)
                                }
                            }());
                            return yield Promise.all(n), e.createSlider(t)
                        }))()
                    }

                    createSlider(t) {
                        var e = this.slides.length - 1;
                        this.el.classList.remove("is-loading"), this.slides.forEach(((i, n) => {
                            this.ui.wrapper.appendChild(i), i.style.left = "".concat(100 * n, "%"), i.draggable = !1, i.classList.add("js-drag-item"), n === e && (this.draggable = new Ao({
                                el: this.el,
                                bullets: !0,
                                navigation: !0
                            }), this.draggable.onSet(t))
                        }))
                    }

                    removeEvents() {
                        var {triggers: t, close: e} = this.ui;
                        t.forEach((t => Eo(t, "r", "click", this.open))), Eo(e, "r", "click", this.close)
                    }

                    destroy() {
                        this.removeEvents(), this.draggable && this.draggable.destroy()
                    }
                })
            }

            initTabs() {
                document.querySelector(".js-interior") && (this.tabs = new class {
                    constructor() {
                        !function (t, e, i) {
                            e in t ? Object.defineProperty(t, e, {
                                value: i,
                                enumerable: !0,
                                configurable: !0,
                                writable: !0
                            }) : t[e] = i
                        }(this, "toggle", (t => {
                            var {currentTarget: e} = t, i = [...this.btns].indexOf(e);
                            this.current !== i && (this.tabs[this.current].classList.remove("is-active"), this.btns[this.current].classList.remove("is-active"), this.current = i, this.tabs[this.current].classList.add("is-active"), e.classList.add("is-active"), Vn.emit("GlobalResize.events.RESIZE"))
                        })), this.tabs = document.querySelectorAll(".js-gllry-tab"), this.btns = document.querySelectorAll(".js-gllry-nav button"), this.current = 0, this.init()
                    }

                    init() {
                        this.addEvents()
                    }

                    addEvents() {
                        this.btns.forEach((t => t.addEventListener("click", this.toggle)))
                    }

                    removeEvents() {
                        this.btns.forEach((t => t.removeEventListener("click", this.toggle)))
                    }

                    destroy() {
                        this.removeEvents(), this.tabs = null, this.btns = null
                    }
                })
            }
        };
        const lM = class extends Rf {
            onEnter() {
                super.onEnter()
            }

            onLeave() {
                super.onLeave()
            }

            onEnterCompleted() {
                super.onEnterCompleted()
            }

            onLeaveCompleted() {
                super.onLeaveCompleted()
            }
        };
        var cM;

        class uM extends Ua.Transition {
            in(t) {
                var {from: e, to: i, done: r} = t, s = i.querySelector(".js-hero img"),
                    a = i.querySelector(".js-t-scale"),
                    o = n.body.classList.remove("dark") || n.body.classList.remove("light");
                n.body.classList.remove(o), cM && cM.kill(), cM = xn.timeline({
                    paused: !0,
                    immediateRender: !0,
                    delay: .1,
                    force3D: !0
                });
                var h = i.querySelectorAll(".js-transition-line");
                cM.to(".js-mask", {
                    duration: .85,
                    yPercent: -100,
                    ease: "expo.inOut"
                }).set(".js-mask", {autoAlpha: 0}).from(".js-intro-item", {
                    duration: 1.5,
                    alpha: 0,
                    y: 30,
                    stagger: "0.1",
                    ease: "expo"
                }, 0), a && cM.from(a, {duration: 3, scale: 1.25, ease: "power3"}, 0), h && h.forEach(((t, e) => {
                    var i = new (La())(t, {type: "lines, words, chars"});
                    cM.set(i.lines, {overflow: "hidden"}).from(i.chars, {
                        duration: 1.5,
                        yPercent: 105,
                        ease: "expo",
                        stagger: .05
                    }, .25).set(i.lines, {clearProps: "overflow"})
                })), s ? Pf(s.src).then((() => {
                    cM.play(), n.body.style.cursor = "default", n.isTransition = !1, r()
                })) : (cM.play(), n.body.style.cursor = "default", n.isTransition = !1, r()), e.remove()
            }

            out(t) {
                var {from: e, trigger: i, done: r} = t;
                n.body.style.cursor = "progress", n.isTransition = !0, cM && cM.kill(), (cM = xn.timeline({onComplete: r})).set(".js-mask", {autoAlpha: 1}).fromTo(".js-mask", {yPercent: 100}, {
                    duration: .85,
                    yPercent: 0,
                    ease: "expo.inOut"
                })
            }
        }

        const pM = uM;
        const dM = new class {
            constructor() {
                !function (t, e, i) {
                    e in t ? Object.defineProperty(t, e, {
                        value: i,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : t[e] = i
                }(this, "toggle", (t => {
                    this.state.headActive = t, n.isMenuOpen ? this.close() : this.open()
                })), this.el = document.querySelector(".js-mobile-nav"), this.ui = {
                    headers: document.querySelectorAll(".js-site-head"),
                    toggle: document.querySelectorAll(".js-menu-toggle"),
                    inner: this.el.querySelector(".js-mobile-nav__inner"),
                    links: this.el.querySelectorAll(".js-mobile-nav__link")
                }, this.state = {headActive: 0, light: "#fff", dark: "#102723"}, this.tl = null
            }

            setInitial() {
                var {toggle: t, links: e, inner: i} = this.ui;
                xn.set([this.el, ".js-mobile-nav__link"], {yPercent: -100}), xn.set(i, {yPercent: 100}), xn.set(".js-burger-close__line--1", {scaleX: 0}), xn.set(".js-burger-close__line--2", {scaleY: 0})
            }

            getCache() {
                var {headers: t} = this.ui;
                this.headCache = [], t.forEach((t => {
                    this.headCache.push({
                        openLines: t.querySelectorAll(".js-burger__line"),
                        closeLineOne: t.querySelector(".js-burger-close__line--1"),
                        closeLineTwo: t.querySelector(".js-burger-close__line--2"),
                        logo: t.querySelectorAll(".js-site-head__logo path")
                    })
                }))
            }

            open() {
                var {inner: t} = this.ui, {headActive: e, light: i} = this.state, {
                    openLines: r,
                    closeLineOne: s,
                    closeLineTwo: a,
                    logo: o
                } = this.headCache[e];
                document.body.classList.add("menu-is-open"), n.isMenuOpen = !0, this.tl && this.tl.kill(), this.tl = xn.timeline(), this.tl.set(this.el, {autoAlpha: 1}).to(r, {
                    duration: .35,
                    scaleX: 0,
                    ease: "power1.in",
                    stagger: -.05
                }, 0).to(s, {duration: .75, scaleX: 1, ease: "expo"}, .55).to(a, {
                    duration: .75,
                    scaleY: 1,
                    ease: "expo"
                }, .56).to([this.el, t], {
                    duration: 1.1,
                    yPercent: 0,
                    ease: "expo.inOut"
                }, 0).to(".js-mobile-nav__link", {
                    duration: 1.1,
                    yPercent: 0,
                    stagger: -.1,
                    ease: "expo"
                }, .5), 0 === e && this.tl.set(this.el, {zIndex: 999}, 0), 1 === e && this.tl.set(this.el, {zIndex: 1002}, 0).set([s, a], {backgroundColor: i}, 0).to(r, {
                    duration: .5,
                    backgroundColor: i,
                    ease: "power1"
                }, 0).to(o, {duration: .5, fill: i, ease: "power1"}, 0)
            }

            close() {
                var {inner: t} = this.ui, {headActive: e, dark: i} = this.state, {
                    openLines: r,
                    closeLineOne: s,
                    closeLineTwo: a,
                    logo: o
                } = this.headCache[e];
                document.body.classList.remove("menu-is-open"), n.isMenuOpen = !1, this.tl && this.tl.kill(), this.tl = xn.timeline(), this.tl.to(s, {
                    duration: .35,
                    scaleX: 0,
                    ease: "power1.in"
                }, 0).to(a, {duration: .35, scaleY: 0, ease: "power1.in"}, .05).to(this.el, {
                    duration: 1.1,
                    yPercent: -100,
                    ease: "expo.inOut"
                }, 0).to(t, {
                    duration: 1.1,
                    yPercent: 100,
                    ease: "expo.inOut"
                }, 0).to(".js-mobile-nav__link", {
                    duration: .65,
                    yPercent: -100,
                    ease: "power2.inOut"
                }, 0).set(this.el, {autoAlpha: 0}), 0 === e && this.tl.to(r, {
                    duration: .5,
                    scaleX: 1,
                    ease: "expo",
                    stagger: -.05
                }, .5), 1 === e && this.tl.set([s, a, r], {backgroundColor: i}).to(r, {
                    duration: .5,
                    scaleX: 1,
                    ease: "expo",
                    stagger: -.05
                }, .75).to(o, {duration: .5, fill: i, ease: "power1"}, .75)
            }

            on() {
                var {toggle: t} = this.ui;
                t.forEach(((t, e) => {
                    Eo(t, "a", "click", (t => this.toggle(e)))
                }))
            }

            init() {
                this.on(), this.getCache(), this.setInitial()
            }
        };
        var fM;

        class mM extends Ua.Transition {
            in(t) {
                var {from: e, to: i, done: r} = t,
                    s = n.body.classList.remove("dark") || n.body.classList.remove("light");
                n.body.classList.remove(s);
                var a = i.querySelector(".js-hero img");
                fM && fM.kill(), dM.close(), fM = xn.timeline({
                    paused: !0, onComplete: () => {
                        n.isTransition = !1
                    }
                });
                var o = i.querySelectorAll(".js-transition-line");
                o && o.forEach(((t, e) => {
                    var i = new (La())(t, {type: "lines, words, chars"});
                    fM.set(i.lines, {overflow: "hidden"}, 0).from(i.chars, 1.5, {
                        yPercent: 105,
                        stagger: .05,
                        ease: "expo"
                    }, .25).set(i.lines, {clearProps: "overflow"})
                })), e.remove(), a ? Pf(a.src).then((() => {
                    fM.play(), n.body.style.cursor = "default", n.isTransition = !1, r()
                })) : (fM.play(), n.body.style.cursor = "default", n.isTransition = !1, r())
            }

            out(t) {
                var {done: e} = t;
                n.body.style.cursor = "progress", n.isTransition = !0, e()
            }
        }

        const gM = mM, vM = new Ua.Core({
            renderers: {home: Ff, listing: jf, residence: hM, press: lM, default: Rf},
            transitions: {default: pM, contextual: {menu: gM}}
        });

        function yM(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }

        new class {
            constructor() {
                yM(this, "setup", (() => {
                    e().addClasses(n.body), this.checkCookie(), new ka
                })), yM(this, "onLoad", (() => {
                    this.tl.play()
                })), this.setup(), this.init()
            }

            init() {
                Pa.init(), n.isDevice && dM.init(), this.initH(), this.logoLinks()
            }

            initH() {
                vM.on("NAVIGATE_OUT", (t => {
                    var {from: e, to: i, location: n} = t;
                    Pa.close(), document.querySelectorAll(".js-site-link").forEach((t => {
                        t.classList.remove("is-active"), t.href === n.href && t.classList.add("is-active")
                    }))
                })), vM.on("NAVIGATE_IN", (t => {
                    var {location: e} = t;
                    window.scrollTo(0, 0)
                })), vM.on("NAVIGATE_END", (t => {
                    var {to: e, location: i} = t;
                    "undefined" != typeof gtag && gtag("config", "UA-20252272-23", {
                        page_path: i.pathname,
                        page_title: e.page.title,
                        page_location: i.href
                    })
                }))
            }

            logoLinks() {
                document.querySelectorAll(".js-logo-link").forEach((t => {
                    Eo(t, "a", "click", (() => {
                        n.isMenuOpen ? vM.redirect(location.origin, "menu") : vM.redirect(location.origin)
                    }))
                }))
            }

            setCookie(t, e, i) {
                var n = new Date;
                n.setTime(n.getTime() + 24 * i * 60 * 60 * 1e3);
                var r = "expires=" + n.toUTCString();
                document.cookie = t + "=" + e + ";" + r + ";path=/"
            }

            getCookie(t) {
                for (var e = t + "=", i = decodeURIComponent(document.cookie).split(";"), n = 0; n < i.length; n++) {
                    for (var r = i[n]; " " == r.charAt(0);) r = r.substring(1);
                    if (0 == r.indexOf(e)) return r.substring(e.length, r.length)
                }
                return ""
            }

            checkCookie() {
                var t = document.querySelector(".js-consent");
                if ("" == this.getCookie("consent")) {
                    var e = t.querySelector(".js-consent__ok");
                    xn.set(t, {display: "block"}), e.addEventListener("click", (() => {
                        this.setCookie("consent", "agreed", 365), xn.to(t, {
                            duration: .5,
                            yPercent: 100,
                            ease: "power2.inOut",
                            onComplete: () => {
                                t.remove()
                            }
                        })
                    }))
                } else t.remove()
            }

            introAnimation() {
                var t = document.querySelector(".js-hero__box"), e = document.querySelector(".js-transition-line");
                if (this.tl = xn.timeline({paused: !0, immediateRender: !0, delay: .5}).to(".js-mask", {
                    duration: .65,
                    autoAlpha: 0,
                    ease: "linear"
                }, 0).from(".js-intro-item", {duration: 1.5, alpha: 0, y: 30, stagger: .1, ease: "expo"}, .35), t) {
                    var i = t.querySelector(".js-hero__box-inner");
                    this.tl.set(t, {alpha: 0}, 0).to(t, {
                        duration: .5,
                        alpha: 1,
                        ease: "linear"
                    }, .5).from([t, i], {
                        cycle: {xPercent: [-100, 100]},
                        duration: 1.5,
                        stagger: 0,
                        ease: "power3.inOut"
                    }, .5).from(".js-hero__box-item", {
                        duration: 1.5,
                        x: -60,
                        alpha: 0,
                        stagger: .1,
                        ease: "expo"
                    }, 1.25)
                }
                if (e) {
                    var n = new SplitText(e, {type: "lines, words"});
                    this.tl.set(n.lines, {overflow: "hidden"}).from(n.words, {
                        duration: 1.5,
                        yPercent: 105,
                        ease: "expo",
                        stagger: .1
                    }, .75).set(n.lines, {clearProps: "overflow"})
                }
            }
        }
    })()
})();